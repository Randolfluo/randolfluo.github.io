<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>csapp第八章——异常控制流 | Randolfluo's blog</title><meta name="author" content="Randolf luo"><meta name="copyright" content="Randolf luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="csapp">
<meta property="og:type" content="article">
<meta property="og:title" content="csapp第八章——异常控制流">
<meta property="og:url" content="http://randolfluo.github.io/2024/02/13/csapp/%E7%AC%AC8%E7%AB%A0%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/index.html">
<meta property="og:site_name" content="Randolfluo&#39;s blog">
<meta property="og:description" content="csapp">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://randolfluo.github.io/img/cover3.jpg">
<meta property="article:published_time" content="2024-02-13T14:42:00.000Z">
<meta property="article:modified_time" content="2024-07-11T16:00:00.000Z">
<meta property="article:author" content="Randolf luo">
<meta property="article:tag" content="csapp">
<meta property="article:tag" content="book">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://randolfluo.github.io/img/cover3.jpg"><link rel="shortcut icon" href="/img/avater.jpg"><link rel="canonical" href="http://randolfluo.github.io/2024/02/13/csapp/%E7%AC%AC8%E7%AB%A0%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Randolf luo","link":"链接: ","source":"来源: Randolfluo's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'csapp第八章——异常控制流',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avater.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">111</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover3.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Randolfluo's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">csapp第八章——异常控制流</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">csapp第八章——异常控制流</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-13T14:42:00.000Z" title="发表于 2024-02-13 22:42:00">2024-02-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-11T16:00:00.000Z" title="更新于 2024-07-12 00:00:00">2024-07-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/csapp/">csapp</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/csapp/book/">book</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>[TOC]</p>
<h1 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h1><p>现代系统通过使控制流发生突变来对系统状态的变化做出反应 。一般而言 ，我们把这些突变称为<code>异常控制流 (Exceptional Control Flow, ECF) 。</code></p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常是异常控制流的一种形式，它一部分由<code>硬件</code>实现，一部分由<code>操作系统</code>实现。</p>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240210180910491.png" alt="image-20240210180910491"></p>
<p>异常 (exception) 就是控制流中的突变，用来响应处理器状态中的某些变化。</p>
<p>当处理器检测到有事件发生时，它就会通过一张叫做<code>异常表 (exception table)</code>的跳转表，进行一个<code>间接过程调用（异常）</code>，到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序 (exception handler)) 。</p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240212222613370.png" alt="image-20240212222613370"></p>
<p>异常处理程序运行在<code>内核模式</code>下，这意味它们对所有的系统资源都有完全的访问权限。</p>
<h4 id="异常的类别"><a href="#异常的类别" class="headerlink" title="异常的类别"></a>异常的类别</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240210192934372.png" alt="image-20240210192934372"></p>
<blockquote>
<p>同步异步表示的结果的获取方式是主动获取还是被动接收；阻塞非阻塞表示的是获取这个动作是否可以立即返回不用等待。</p>
</blockquote>
<h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><p>中断是<code>异步</code>发生的， 是来自处理器外部的 I/0 设备的信号的结果。例如定时器计时结束后会向处理器发送一个中断。</p>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215162205029.png" alt="image-20240215162205029"></p>
<h5 id="陷阱和系统调用"><a href="#陷阱和系统调用" class="headerlink" title="陷阱和系统调用"></a>陷阱和系统调用</h5><p>陷阱是有意的异常，是执行一条指令的结果 。如读文件（read），创建一个新的进程（fork）。</p>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215163333455.png" alt="image-20240215163333455"></p>
<h5 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h5><p>故障由错误情况引起，它可能能够被故障处理程序修正。</p>
<p>一个经典的故障示例是<code>缺页异常</code>，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障。</p>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215163341288.png" alt="image-20240215163341288"></p>
<h5 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h5><p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 DRAM 或者SRAM 位被损坏时发生的奇偶错误。</p>
<h4 id="Linux-86-64-系统调用"><a href="#Linux-86-64-系统调用" class="headerlink" title="Linux/86-64 系统调用"></a>Linux/86-64 系统调用</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215164416422.png" alt="image-20240215164416422"></p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li><p>异常是允许操作系统内核提供进程 (process) 概念的基本构造块。</p>
</li>
<li><p>进程的经典定义就是一个执行中程序的实例。</p>
</li>
<li><p>系统中的每个程序都运行在某个进程的<code>上下文 (context)</code> 中。</p>
</li>
<li><p>上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的<code>程序的代码和数据</code>，它的<code>栈</code>、<code>通用目的寄存器的内容</code>、<code>程序计数器</code>、<code>环境变量</code>以及<code>打开文件描述符</code>的集合.</p>
</li>
<li>每次用户通过向 shell 输入 个可执行目标文件的名字，运行程序时， <code>shell 就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。</code></li>
</ul>
<p>进程提供给应用程序的关键抽象：</p>
<ul>
<li>一个<code>独立的逻辑控制流</code>，它提供一个假象，好像我们的程序独占地使用处理器。</li>
<li>一个<code>私有的地址空间</code>，它提供一个假象，好像我们的程序独占地使用内存系统。</li>
</ul>
<h4 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h4><p>进程是轮流使用处理器的。每个进程执行它的流的一部分，然后被抢占 (preempted) (暂时挂起），然后轮到其他进程。</p>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215165111954.png" alt="image-20240215165111954"></p>
<h4 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h4><p>一个逻辑流的执行在时间上与另一个流重叠，称为<code>并发流 (concurrent flow)</code>, 这两个流被称为并发地运行。</p>
<p>多个流并发地执行的一般现象被称为<code>并发 (concurrency)</code>。</p>
<p>一 个进程和其他进程轮流运行的概念称为<code>多任务(multitasking)</code> 。</p>
<p>一个进程执行它的控制流的一部分的每一时间段叫做<code>时间片 (time slice)</code>。</p>
<p>因此，多任务也叫做<code>时间分片 (time slicing)</code> 。</p>
<h4 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h4><p>x86-64：</p>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215170927300.png" alt="image-20240215170927300"></p>
<h4 id="用户模式和内核模式"><a href="#用户模式和内核模式" class="headerlink" title="用户模式和内核模式"></a>用户模式和内核模式</h4><p>处理器将某个控制寄存器中的一个模式为（mode bit）来区别进程运行在用户模式还是内核模式（超级用户模式）。</p>
<p><code>/proc</code>文件系统它允许用户模式进程访问内核数据结构的内容。</p>
<p><code>/sys</code>文件系统，它输出关于系统总线和设备的额外的低层信息。</p>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>操作系统内核使用一种称为<code>上下文切换 (context switch)</code> 的较高层形式的异常控制流来实现多任务。</p>
<p>在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做<code>调度 (scheduling)</code>, 是由内核中称为调度器 (scheduler) 的代码处理的。</p>
<ol>
<li>保存当前进程的上下文</li>
<li>恢复某个先前被抢占的进程被保存的上下文</li>
<li>将控制传递给这个新恢复的进程</li>
</ol>
<p>由于从磁盘中读取文件需要几十毫秒，当进程A阻塞（需要的文件未读取完成），cpu会去执行其他进程，当读取完成时，磁盘发送中断异常到cpu，继续执行指令。</p>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215172337812.png" alt="image-20240215172337812"></p>
<h3 id="系统调用错误处理"><a href="#系统调用错误处理" class="headerlink" title="系统调用错误处理"></a>系统调用错误处理</h3><p>Unix 系统级函数遇到错误时，它们通常会返回-1, 并设詈全局整数变量<code>errno</code>示什么出错了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span> *msg)</span> <span class="comment">/* 错误处理包装函数 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如<code>Fork</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">Fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><h4 id="获取进程ID"><a href="#获取进程ID" class="headerlink" title="获取进程ID"></a>获取进程ID</h4><p>每个进程都有一个唯一的正数<code>进程 ID(PID)</code>。<code>getpid()</code>通过函数返回调用进程的 PID。<code>getppid()</code>函数返回它的父进程的 PID( 创建调用进程的进程）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>; </span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>; </span><br></pre></td></tr></table></figure>
<p><code>getppid ()</code>函数返回一个类型为 <code>pid_t</code> 的整数值，在 Linux 系统上它在<code>types.h</code>中被定义为<code>int</code>。</p>
<h4 id="创建和终止进程"><a href="#创建和终止进程" class="headerlink" title="创建和终止进程"></a>创建和终止进程</h4><ul>
<li>进程总是处于运行、停止和终止三种状态。</li>
</ul>
<p><strong>fork函数</strong>：</p>
<p>子进程返回0，父进程返回子进程的<code>PID</code>,如果出错则返回-1。</p>
<ul>
<li><code>调用一次，返回两次</code></li>
<li>并发执行</li>
<li><code>相同但是独立的地址空间</code></li>
<li>共享文件</li>
</ul>
<p>可以通过进程图来理解带有嵌套的fork函数</p>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215183725431.png" alt="image-20240215183725431"></p>
<h4 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h4><ul>
<li><p>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收 (reaped) 。当父进程回收己终止的子进程时，<code>内核将子进程的退出状态传递给父进程</code>，然后抛弃己终止的进程，从此时开始，该进程就不存在了。</p>
</li>
<li><p>一个终止了但还未被回收的进程称为<code>僵死进程 (zombie）</code>。</p>
</li>
<li>如果一个父进程终止了，内核会安排 <code>init</code>进程成为它的孤儿进程的养父。</li>
<li><code>init</code>进程PID=1, 是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。</li>
</ul>
<p>​    </p>
<p><strong>waitpid</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span> </span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *statusp, <span class="type">int</span> options)</span>; </span><br></pre></td></tr></table></figure>
<p>当等待集合中的进程终止后返回终止进程pid。</p>
<ol>
<li><p>判定等待集合的成员</p>
<p>如果pid&gt;0, 那么等待集合就是一个单独的子进程，它的进程 ID 等于 pid。<br>如果pid= -1, 那么等待集合就是由父进程所有的子进程组成的。</p>
</li>
<li><p>修改默认行为</p>
</li>
</ol>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215201704669.png" alt="image-20240215201704669"></p>
<ol>
<li>检查已回收子进程的退出状态</li>
</ol>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215201738218.png" alt="image-20240215201738218"></p>
<ol>
<li>错误条件</li>
</ol>
<p>如果调用进程<code>没有子进程</code>，那么 waitpid 返回<code>-1</code>, 并且设置<code>errno</code>为<code>ECHILD</code>。如果waitpid 函数<code>被一个信号中断</code>，那么它返回-1, 并设置 <code>errno</code>为<code>EINTR</code>。</p>
<ol>
<li>wait函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span> </span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *statusp)</span>; </span><br></pre></td></tr></table></figure>
<p>waitpid的简化版。等价于<code>waitpid(-1,&amp;status,0)</code>。</p>
<ol>
<li>使用waitpid的示例</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* $begin waitpid2 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status, i;</span><br><span class="line">    <span class="type">pid_t</span> pid[N], retpid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parent creates N children */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">if</span> ((pid[i] = Fork()) == <span class="number">0</span>)  <span class="comment">/* Child */</span>          <span class="comment">//fork进程并存储对应pid</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">100</span>+i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parent reaps N children in order */</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((retpid = waitpid(pid[i++], &amp;status, <span class="number">0</span>)) &gt; <span class="number">0</span>) &#123; <span class="comment">//按照顺序回收子进程</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated normally with exit status=%d\n&quot;</span>,</span><br><span class="line">                   retpid, WEXITSTATUS(status));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated abnormally\n&quot;</span>, retpid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确认没有子进程 */</span></span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">        unix_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end waitpid2 */</span></span><br></pre></td></tr></table></figure>
<h4 id="让进程休眠"><a href="#让进程休眠" class="headerlink" title="让进程休眠"></a>让进程休眠</h4><p><code>sleep</code>函数将一个进程挂起一个指定时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>时间到了，返回0；时间未到，返回剩余时间。</p>
<p><code>pause函数</code>使调用函数休眠，直到该进程收到一个信号。</p>
<h4 id="加载并运行程序"><a href="#加载并运行程序" class="headerlink" title="加载并运行程序"></a>加载并运行程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *argv[], <span class="type">const</span> <span class="type">char</span> *envp[])</span>; </span><br></pre></td></tr></table></figure>
<p><code>execve</code>调用一次<code>从不返回</code>，execve 函数在当前进程的上下文中加载并运行一个新的程序 它会覆盖当前进程的地址空间，但并没有创建一个新进程 。</p>
<p><code>argv 变量</code>指向一个以 <code>null 结尾的指针数组</code>，其中每个指针都指向一个参数字符串。按照惯例， argv [0] 是可执行目标文件的名字。</p>
<p> <code>envp 变量</code>指向一个以<code>null 结尾的指针数组</code>，其中每个指针指向一个环境变量字符串，每个串都是形如”name=value” 的名字-值对。</p>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215204034862.png" alt="image-20240215204034862"></p>
<p>main 函数有3个参数： </p>
<ol>
<li><code>argc</code>, 它给出 <code>argv[ ]</code>数组中非空指针的数量</li>
<li><code>argv</code>, <code>指向argv[ ]</code>数组中的第一个条目。</li>
<li><code>envp</code>, <code>指向 envp[]</code>数组中的第一个条目。</li>
</ol>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215204911421.png" alt="image-20240215204911421"></p>
<p>linux可以通过<code>getenv</code>和<code>setenv</code>来修改环境变量。</p>
<blockquote>
<p>程序与进程</p>
<p>进程是执行中程序的一个具体的实例；程序总是运行在某个进程的上下文中。</p>
</blockquote>
<h4 id="利用fork和execve运行程序"><a href="#利用fork和execve运行程序" class="headerlink" title="利用fork和execve运行程序"></a>利用fork和execve运行程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* $begin shellmain */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS   128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function prototypes */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">char</span> *buf, <span class="type">char</span> **argv)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_command</span><span class="params">(<span class="type">char</span> **argv)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE]; <span class="comment">/* Command line */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;			</span><br><span class="line">        <span class="comment">/* Read */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">        Fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>);			<span class="comment">//反复读取参数</span></span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>))<span class="comment">//C 库函数 int feof(FILE *stream) 测试给定流 stream 的文件结束标识符。</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);	<span class="comment">//当设置了与流关联的文件结束标识符时，该函数返回一个非零值，否则返回零。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Evaluate */</span></span><br><span class="line">        eval(cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end shellmain */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin eval */</span></span><br><span class="line"><span class="comment">/* eval - Evaluate a command line */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span>		<span class="comment">//解析</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *argv[MAXARGS]; <span class="comment">/* Argument list execve() */</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];   <span class="comment">/* Holds modified command line */</span></span><br><span class="line">    <span class="type">int</span> bg;              <span class="comment">/* Should the job run in bg or fg? */</span></span><br><span class="line">    <span class="type">pid_t</span> pid;           <span class="comment">/* Process id */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(buf, argv);</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;   <span class="comment">/* Ignore empty lines */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!builtin_command(argv)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) &#123;   <span class="comment">/* Child runs user job */</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Parent waits for foreground job to terminate */</span></span><br><span class="line">        <span class="keyword">if</span> (!bg) &#123;</span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                unix_error(<span class="string">&quot;waitfg: waitpid error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %s&quot;</span>, pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If first arg is a builtin command, run it and return true */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_command</span><span class="params">(<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>)) <span class="comment">/* quit command */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;&amp;&quot;</span>))    <span class="comment">/* Ignore singleton &amp; */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                     <span class="comment">/* Not a builtin command */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end eval */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin parseline */</span></span><br><span class="line"><span class="comment">/* parseline - Parse the command line and build the argv array */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">char</span> *buf, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *delim;         <span class="comment">/* Points to first space delimiter */</span></span><br><span class="line">    <span class="type">int</span> argc;            <span class="comment">/* Number of args */</span></span><br><span class="line">    <span class="type">int</span> bg;              <span class="comment">/* Background job? */</span></span><br><span class="line"></span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="string">&#x27; &#x27;</span>;  <span class="comment">/* Replace trailing &#x27;\n&#x27; with space */</span></span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* Ignore leading spaces */</span></span><br><span class="line">        buf++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build the argv list */</span></span><br><span class="line">    argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>))) &#123;</span><br><span class="line">        argv[argc++] = buf;</span><br><span class="line">        *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        buf = delim + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* Ignore spaces */</span></span><br><span class="line">            buf++;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span>)  <span class="comment">/* Ignore blank line */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Should the job run in the background? */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc<span class="number">-1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>)</span><br><span class="line">        argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end parseline */</span></span><br></pre></td></tr></table></figure>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。</p>
<p><code>软件形式的异常</code>，称为 Linux 信号，它允许进程和内核中断其他进程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man signal   //信号手册</span><br></pre></td></tr></table></figure>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240216134615426.png" alt="image-20240216134615426"></p>
<h4 id="信号术语"><a href="#信号术语" class="headerlink" title="信号术语"></a>信号术语</h4><ul>
<li>发送信号</li>
<li>接受信号</li>
<li>待处理信号，在任何时刻，<code>一种类型至多只会有一个待处理信号</code>，多余的会被丢弃。</li>
<li><code>一个待处理信号最多只能被接收一次</code>。内核为每个进程在<code>pending 位向量</code>中维护着待处理信号的集合，而在 <code>blocked 位向量（也称为信号掩码signal mask）中维护被阻塞的信号集合</code>。</li>
</ul>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240216135351733.png" alt="image-20240216135351733"></p>
<h4 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h4><ol>
<li><p>进程组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//返回：调用进程的进程组 ID</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>; <span class="comment">//返回：若成功则为 0, 若错误则为-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setpgid(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">//会创建一个新的进程组，若进程名为15213，那么其进程组 ID 15213, 并且把进程 15213 加入到这个新的进程组中。</span></span><br></pre></td></tr></table></figure>
<p>如果 pid是0， 那么就使用当前进程PID 如果 pgid是0, 那么就用pid指定的进程的 PID 作为进程组 ID 。</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef //常用</span><br><span class="line">ps -ajx //查看父进程ID，进程ID，进程组ID，会话ID</span><br></pre></td></tr></table></figure>
<ol>
<li>使用 <code>/bin/kill 程序</code>发送信号</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">/bin/kill -9 15213</span>  </span><br><span class="line">//发送信号 9(SIGKILL) 给进程 15213 。</span><br><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">/bin/kill -9 -15213</span></span><br><span class="line">//发送 SIGKILL 信号给进程组 15213 中的每个进程。</span><br></pre></td></tr></table></figure>
<ol>
<li>从键盘发送信号</li>
</ol>
<p>Unix shell 使用作业 (job) 这个抽象概念来表示为对一条命令行求值而创建的进程,任何时刻，<code>至多只有一个前台作业和 0个或多个后台作业</code>。</p>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240216142444242.png" alt="image-20240216142444242"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl+C</td>
<td>内核发送一个 SIGINT 信号到前台进程组中的每个进程。默认情况下，结果是终止前台作业。</td>
</tr>
<tr>
<td>Ctrl+Z</td>
<td>发送一个 SIGTSTP信号到前台进程组中的每个进程。默认情况下，结果是停止（挂起）前台作业。</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>用kill函数发送信号</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>; 	<span class="comment">//返回：若成功则为0, 若错误则为- 1,</span></span><br></pre></td></tr></table></figure>
<ul>
<li>pid&gt;0，发送给进程pid。</li>
<li>pid=0，发送给<code>调用进程所在进程组</code>的每个进程。</li>
<li>pid&lt;0，发送给<code>进程组|pid|中的每个进程</code>。</li>
</ul>
<p>父进程用kill函数发送 SIGKILL 信号给它的子进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Child sleeps until SIGKILL signal received, then dies */</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        Pause();  <span class="comment">/* Wait for a signal to arrive */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;control should never reach here!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parent sends a SIGKILL signal to a child */</span></span><br><span class="line">    Kill(pid, SIGKILL);</span><br><span class="line">    wait(pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGKILL!@!&quot;</span>);	<span class="comment">//确认子进程终止</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>用alarm函数发送信号</li>
</ol>
<p>进程可以通过调用 <code>alarm 函数向它自己发送 SIGALRM 信号</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>; </span><br><span class="line"><span class="comment">//返回：前一次闹钟剩余的秒数，若以前没有设定闹钟，则为0</span></span><br></pre></td></tr></table></figure>
<h4 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h4><p>当内核把进程 从<code>内核模式</code>切换到<code>用户模式</code>时，它会检查进程的<code>未被阻塞的待处理信号的 (pending &amp; ~blocked)</code></p>
<ul>
<li>如果这个集合为空（通常情况下），那么内核将控制传递到 的逻辑控制流中的下一条指令</li>
<li>如果集合是非空的，那么内核选择集合中的某个信号,并且且强制进程接收信号，收到这个信号会触发进程采取某种行为， 一旦进程完成了这个行为，那么控制就传递回进程的逻辑控制流中的下一条指令。</li>
</ul>
<p>每个信号类型都有一个预定义的默认行为。</p>
<ul>
<li>进程终止</li>
<li>进程终止并转储内存。</li>
<li>进程停止（挂起）直到被 SIGCONT 信号重启。</li>
<li>进程忽略该信号。</li>
</ul>
<p>可以通过使用 <code>signal 函数</code>修改和信号相 联的默认行为,唯一的例外是 <code>SIGSTOP</code> 和<code>SIGKILL</code>,它们的默认行为是不能修改的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>; </span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>; </span><br><span class="line"><span class="comment">//返回：若成功则为指向前次处理程序的指针，若出错则为 SIG_ERR(不设置 errno)</span></span><br></pre></td></tr></table></figure>
<p>signal 函数可以通过设置handeler来改变和信号 signum 相关联的行为：</p>
<ul>
<li>如果<code>handler SIG_IGN</code>, 那么忽略类型为 signum 的信号。</li>
<li>如果 <code>handler SIG_DFL</code>, 那么类型为 signum 的信号行为恢复为默认行为</li>
<li>否则， handler 就是用户定义的函数的地址，这个函数被称为<code>信号处理程序</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span> <span class="comment">/* SIGINT handler */</span>   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught SIGINT!\n&quot;</span>);   </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);                     </span><br><span class="line">&#125;                                              </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Install the SIGINT handler */</span></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, sigint_handler) == SIG_ERR) </span><br><span class="line">        unix_error(<span class="string">&quot;signal error&quot;</span>);                 </span><br><span class="line">    pause(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240216154617280.png" alt="image-20240216154617280"></p>
<blockquote>
<p>练习题8.7</p>
<p>编写一个叫做 snooze 的程序，它有一个命令行参数，用这个参数调用<br>练习题 8. 中的 snooze 函数，然后终止。编写程序，使得用户可以通过在键盘上输入Ctrl+C 中断 snooze 函数。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">snooze</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> rc = sleep(secs);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Slept for %d of %d secs.\n&quot;</span>, secs-rc, secs);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;secs&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, handler) == SIG_ERR) </span><br><span class="line">        unix_error(<span class="string">&quot;signal error\n&quot;</span>);</span><br><span class="line">    (<span class="type">void</span>)snooze(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="阻塞和解除阻塞信号"><a href="#阻塞和解除阻塞信号" class="headerlink" title="阻塞和解除阻塞信号"></a>阻塞和解除阻塞信号</h4><p><code>隐式阻塞机制</code>。内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。</p>
<p><code>显式阻塞机制</code>。应用程序可以使用 <code>sigprocmask 函数</code>和它的辅助函数，明确地阻塞和解除阻塞选定的信号。</p>
<p>sigprocmask 函数改变当前阻塞的信号集合 (blocked 位向量）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>; 	<span class="comment">//检查或修改进程的信号掩码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>; <span class="comment">//初始化 set 为空集合。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>; <span class="comment">//把每个信号都添加到set中。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;<span class="comment">//把 signum 添加到 set</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;<span class="comment">//从set中删除signum</span></span><br><span class="line"><span class="comment">//返回：如果成功则为0, 若出错则为-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>; </span><br><span class="line"><span class="comment">//返回：若 signum set 的成员则为 1, 如果不是则为0若出错则为—1</span></span><br></pre></td></tr></table></figure>
<p>具体行为以来how的值</p>
<ul>
<li><code>SIG_BLOCK</code>: set 中的信号添加到 blocked (blocked=blocked I set)</li>
<li><code>SIG_ UNBLOCK</code>: blocked 中删除 set 中的信号 (blocked=blocked &amp;~set)</li>
<li><code>SIG_SETMASK</code>: block=set</li>
</ul>
<h4 id="编写信号处理程序"><a href="#编写信号处理程序" class="headerlink" title="编写信号处理程序"></a>编写信号处理程序</h4><ol>
<li>安全的信号处理</li>
</ol>
<ul>
<li><p>处理程序要尽可能简单。</p>
</li>
<li><p>在处理程序中只调用<code>异步信号安全的函数</code>。(可重入的且不能被信号处理程序中断)。</p>
</li>
</ul>
<p>异步信号安全的函数</p>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240216222621366.png" alt="image-20240216222621366"></p>
<p>信号处理程序中产生输出唯一安全的方法是使用<code>write</code>函数。</p>
<ul>
<li><code>保存和恢复errno</code>。</li>
</ul>
<p>在进入处理程序时把 errno 保存在某个局部变最中，在处理程序返回前恢复它。</p>
<ul>
<li><p><code>阻塞所有的信号，保护对共享全局数据结构的访问</code>。</p>
</li>
<li><p>用volatile 声明全局变量</p>
</li>
</ul>
<p><code>volatile限定符</code>强迫编译器每次在代码中引用时，都要从内存中读取值。</p>
<ul>
<li>sig_atomic_t 声明标志。</li>
</ul>
<p>对sig_atomic_t声明的变量的读和写会是原子的（不可中断的）。</p>
<ol>
<li>正确的信号处理</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler1</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;	<span class="comment">// 保存和恢复 errno</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>)<span class="comment">//-1表示由父进程创建的所有子进程</span></span><br><span class="line">        sio_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    Sio_puts(<span class="string">&quot;Handler reaped child\n&quot;</span>);</span><br><span class="line">    Sleep(<span class="number">1</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line">    <span class="type">char</span> buf[MAXBUF];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGCHLD, handler1) == SIG_ERR)<span class="comment">//=设置SIGCHLD的信号处理程序</span></span><br><span class="line">        unix_error(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parent creates children */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello from child %d\n&quot;</span>, (<span class="type">int</span>)getpid());</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parent waits for terminal input and then processes it */</span></span><br><span class="line">    <span class="keyword">if</span> ((n = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf))) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent processing input\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于信号处理函数没有解决信号不会排队等待这样的情况。当接受并捕获第一个信号进入处理程序，第二个信号就传送并添加到了待处理信号集合里。然而，因为 SIGCHLD 信号被 SIGCHLD理程序阻塞了，所以第二个信号就不会被接收。第三个信号到达。有了一个待处理的 SIGCHLD, 第三个信号会被丢弃。</p>
<p>通过修改handler函数来修正这一问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler2</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使得每次 SIGCHLD 处理程序被调用时，回收尽可能多的僵死子进程。</span></span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Sio_puts(<span class="string">&quot;Handler reaped child\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">        Sio_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    Sleep(<span class="number">1</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>可移植的信号处理</li>
</ol>
<p>Posix 标准定义了 <code>sigaction</code> 函数，它允许用户在设置信号处理时，明确指定他们想要的信号处理语义。</p>
<h4 id="同步流以避免讨厌的并发错误"><a href="#同步流以避免讨厌的并发错误" class="headerlink" title="同步流以避免讨厌的并发错误"></a>同步流以避免讨厌的并发错误</h4><ul>
<li>通过设置和解除阻塞的<code>SIGCHLD</code>信号来避免进程在添加进<code>job组</code>前终止导致把不存在的子进程添加到作业列表中。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sigfillset</span>(&amp;mask_all);</span><br><span class="line">    <span class="keyword">while</span> ((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>) &#123; <span class="comment">/* Reap a zombie child */</span></span><br><span class="line">        <span class="built_in">Sigprocmask</span>(SIG_BLOCK, &amp;mask_all, &amp;prev_all);		<span class="comment">//防止重入</span></span><br><span class="line">        <span class="built_in">deletejob</span>(pid); <span class="comment">/* Delete the child from the job list */</span></span><br><span class="line">        <span class="built_in">Sigprocmask</span>(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">        <span class="built_in">Sio_error</span>(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sigfillset</span>(&amp;mask_all);				<span class="comment">//把每个信号添加到mask_all</span></span><br><span class="line">    <span class="built_in">Sigemptyset</span>(&amp;mask_one);				<span class="comment">//初始化mask_one为空集合</span></span><br><span class="line">    <span class="built_in">Sigaddset</span>(&amp;mask_one, SIGCHLD);		<span class="comment">// 把SIGCHLD添加到mask_one</span></span><br><span class="line">    <span class="built_in">Signal</span>(SIGCHLD, handler);			<span class="comment">//设置SIGCHLD异常处理函数</span></span><br><span class="line">    <span class="built_in">initjobs</span>(); <span class="comment">/* Initialize the job list */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">Sigprocmask</span>(SIG_BLOCK, &amp;mask_one, &amp;prev_one); <span class="comment">/* Block SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = <span class="built_in">Fork</span>()) == <span class="number">0</span>) &#123; <span class="comment">/* Child process */</span></span><br><span class="line">            <span class="built_in">Sigprocmask</span>(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">/* Unblock SIGCHLD */</span></span><br><span class="line">            <span class="built_in">Execve</span>(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Sigprocmask</span>(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>); <span class="comment">/* Parent process */</span></span><br><span class="line">        <span class="built_in">addjob</span>(pid);  <span class="comment">/* Add the child to the job list */</span></span><br><span class="line">        <span class="built_in">Sigprocmask</span>(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>);  <span class="comment">/* Unblock SIGCHLD */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="显示地等待信号"><a href="#显示地等待信号" class="headerlink" title="显示地等待信号"></a>显示地等待信号</h4><ul>
<li>当<code>linux shell</code>创建一个前台作业时，在接收下一条用户命令之前，它必须等待作业终止，被<code>SIGCHLD</code>处理程序回收。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *mask)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sigsuspend 函数暂时用mask替换当前的阻塞集合，然后挂起该进程，直到收到一个信号，其行为要么是运行一个处理程序，要么是终止该进程。如果它的行为是终止，那么该进程不从sigsuspend 返回就直接终止。如果它的行为是运行一个处理程序，那么sigsuspend 从处理程序返回，恢复调用sigsuspend 时原有的阻塞集合。sigsuspend 函数等价于下述代码的原子的（不可中断的）版本：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于下面三条语句的原子版本</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;mask, &amp;prev);</span><br><span class="line"><span class="built_in">pause</span>();</span><br><span class="line"><span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    pid = <span class="built_in">Waitpid</span>(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Signal</span>(SIGCHLD, sigchld_handler);</span><br><span class="line">    <span class="built_in">Signal</span>(SIGINT, sigint_handler);</span><br><span class="line">    <span class="built_in">Sigemptyset</span>(&amp;mask);</span><br><span class="line">    <span class="built_in">Sigaddset</span>(&amp;mask, SIGCHLD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">Sigprocmask</span>(SIG_BLOCK, &amp;mask, &amp;prev); <span class="comment">/* Block SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Fork</span>() == <span class="number">0</span>) <span class="comment">/* Child */</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Wait for SIGCHLD to be received */</span></span><br><span class="line">        pid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pid)</span><br><span class="line">            <span class="built_in">Sigsuspend</span>(&amp;prev);			<span class="comment">//设置掩码，然后挂起进程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Optionally unblock SIGCHLD */</span></span><br><span class="line">        <span class="built_in">Sigprocmask</span>(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Do some work after receiving SIGCHLD */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h3><ul>
<li>通过<code>longjmp</code>和<code>setjmp</code>实现。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;			<span class="comment">//返回0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> savesigs)</span></span>;			<span class="comment">//返回非0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> retval)</span></span>;			<span class="comment">//从不返回。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> retval)</span></span>;		<span class="comment">//从不返回。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>类似于 C 语言中的 try-catch 块，在函数调用链中实现了异常的传递。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sigjmp_buf buf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">siglongjmp</span>(buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">sigsetjmp</span>(buf, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">Signal</span>(SIGINT, handler);</span><br><span class="line">        <span class="built_in">Sio_puts</span>(<span class="string">&quot;starting\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">Sio_puts</span>(<span class="string">&quot;restarting\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Sio_puts</span>(<span class="string">&quot;processing...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* Control never reaches here */</span></span><br><span class="line">&#125;</span><br><span class="line">linux&gt; ./restart</span><br><span class="line">starting</span><br><span class="line">processing </span><br><span class="line">processing </span><br><span class="line">Ctrl+C</span><br><span class="line">restarting</span><br><span class="line">processing </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="操作进程的工具"><a href="#操作进程的工具" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h3><ul>
<li>STRACE: 打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。对于好奇的学生而言，这是一个令人着迷的工具。用 -static 编译你的程序，能得到一个更干净的、不带有大量与共享库相关的输出的轨迹。</li>
<li>PS: 列出当前系统中的进程（包括僵死进程）。</li>
<li>TOP: 打印出关千当前进程资源使用的信息，HTOP更加详细。</li>
<li>PMAP: 显示进程的内存映射</li>
<li>/proc: 一个虚拟文件系统，以 ASCII 文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容 比如，输入 “cat /proc/loadavg”, 可以看到你的 Linux 系统上当前的平均负载。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​    异常控制流 (ECF) 发生在计算机系统的各个层次，是计算机系统中<code>提供并发的基本机制</code>。</p>
<ul>
<li><p>在硬件层 ，异常是由处理器中的事件触发的控制流中的 突变。控制流 传递给一个软件处理程序，该处理程序进行一些处理，然后返回控制给被中断的控制流。<br>有四种不同类型的异常：中断、故障、终 止和陷阱。</p>
</li>
<li><p>在操作系统层，内核用 ECF 提供进程的基本概念 进程提供给应用两个重要的抽象： 1) 逻辑控制流，它提供给每个程序一个假象，好像它是在独占地使用处理器， 2) 私有地址空间，它提供给每个程序一个假象，好像它是在独占地使用主存</p>
</li>
<li><p>在操作系统和应用程序之间的接口处，应用程序可以创建子进程，等待它们的子进程停止或者终止，运行新的程序，以及捕获来自其他进程的信号。信号处理的语义是微妙的，并且随系统不同而不同。然而， 在与 Posix 兼容的系统上存在 一些机制，允许程序 清楚 地指定期望的信号处理语义。</p>
</li>
<li><p>最后 ，在应用层， 程序可以使用非本地跳转来规避正常的调用 返回栈规则，并且直接从一个函数分支到另一个函数。</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://randolfluo.github.io">Randolf luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://randolfluo.github.io/2024/02/13/csapp/%E7%AC%AC8%E7%AB%A0%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/">http://randolfluo.github.io/2024/02/13/csapp/%E7%AC%AC8%E7%AB%A0%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://randolfluo.github.io" target="_blank">Randolfluo's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/csapp/">csapp</a><a class="post-meta__tags" href="/tags/book/">book</a></div><div class="post-share"><div class="social-share" data-image="/img/cover3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/02/05/51%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA0x1/" title="51单片机学习0x1"><img class="cover" src="/img/cover3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">51单片机学习0x1</div></div><div class="info-2"><div class="info-item-1">江科大51单片机学习笔记 单片机​    单片机不是完成某一个逻辑功能的芯片，而是把一个计算机系统集成到一个芯片上。相当于一个微型的计算机。  命名规则：  51单片机　51单片机是对所有兼容Intel8031指令系统的单片机的统称，这一系列的单片机的始祖是Intel的8031单片机，后来随着flash...</div></div></div></a><a class="pagination-related" href="/2024/02/15/stm32/stm32%E5%8D%95%E7%89%87%E6%9C%BA0x1/" title="stm32单片机0x1"><img class="cover" src="/img/cover1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">stm32单片机0x1</div></div><div class="info-2"><div class="info-item-1">stm32STM32是ST公司基于ARM Cortex-M内核开发的32位微控制器  ARM内核 stm32F103C8T6采用Cortex-M3内核，发布于2004年10月。  片上资源/外设     英文缩写 名称 英文缩写 名称     NVIC 嵌套向量中断控制器 CAN CAN通信   SysTick 系统滴答定时器 USB USB通信   RCC 复位和时钟控制 RTC 实时时钟   GPIO 通用IO口 CRC CRC校验   AFIO 复用IO口 PWR 电源控制   EXTI 外部中断 BKP 备份寄存器   TIM 定时器 IWDG 独立看门狗   ADC 模数转换器 WWDG 窗口看门狗   DMA 直接内存访问 DAC 数模转换器   USART 同步/异步串口通信 SDIO SD卡接口   I2C I2C通信 FSMC 可变静态存储控制器   SPI SPI通信 USB...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/02/26/csapp/%E7%AC%AC10%E7%AB%A0%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/" title="csapp第十章——系统级IO"><img class="cover" src="/img/cover1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-26</div><div class="info-item-2">csapp第十章——系统级IO</div></div><div class="info-2"><div class="info-item-1">系统级I/O输入与输出 (I/O) 是在主存和外部设备（例如磁盘驱动器、终端和网络）之间复制数据的过程。 UNIX I/O 所有的设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。   打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。 Linux shell 创建的每个进程开始时都有三个打开的文件：  12345/*								 /usr/include/unisted.h 						 */#define STDIN_FILENO    0       /* Standard input.  */#define STDOUT_FILENO   1       /* Standard output.  */#define STDERR_FILENO   2       /* Standard error output. ...</div></div></div></a><a class="pagination-related" href="/2024/01/28/csapp/%E7%AC%AC5%E7%AB%A0%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/" title="csapp第五章——优化程序性能"><img class="cover" src="/img/cover3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-28</div><div class="info-item-2">csapp第五章——优化程序性能</div></div><div class="info-2"><div class="info-item-1">优化程序性能 第一，我们必须选择一组适当的算法和数据结构。 第二，我们必须编写出编译器能够有效优化以转换成高效可执行代码的源代码。   为什么我们需要优化程序，现代编译器不是具有很强的优化能力吗？ ans:因为编译器只进行安全的优化，消除可能出现的异常的运行时行为。意味着我们需要写出适合编译器优化的代码，优化程序性能。  内存别名使用 两个指针可能指向同一个内存位置的情况称为内存别名使用 (memory aliasing)  12345678910void twiddlel(long *Xp, long *yp) &#123; *XP += *yp; *XP += *yp; &#125; void twiddle2(long *XP, long *yp) &#123; *XP += 2* *yp; &#125;  乍一看两个函数好像没有区别，但是当*XP与*YP指向同一内存时。twiddle1变为原来的四倍，twiddle2变为原来的三倍。改变了程序的行为。 ...</div></div></div></a><a class="pagination-related" href="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/" title="csapp第六章——存储器层次结构"><img class="cover" src="/img/cover2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-01</div><div class="info-item-2">csapp第六章——存储器层次结构</div></div><div class="info-2"><div class="info-item-1">存储器层次结构计算机技术的成功很大程度上源自于存储技术的巨大进步 。 随机访问存储器静态RAM 由于 SRAM 存储器单元的双稳态特性，只要有电，它就会永远地保持它的值。 动态RAMDRAM 将每个位存储为对每个电容的充电。与 SRAM 不同， DRAM 存储器单元对干扰非常敏感 。  传统的DRAMDRAM 芯片中的单元（位）被分成d 个超单元 (supercell) , 每个超单元都个DRAM单元组成。 d*w 的DRAM 总共存储了d w位信息。  图示为168 DRAM 芯片的组织，有 d=l6 个超单元，每个超单元有 w=8 位， r=4 行，c=4 。   将 DRAM 组织成二维阵列而不是线性数组的一个原因是降低芯片上地址引脚的数量。  二维阵列组织的缺点是必须分两步发送地址，这增加了访问时间。   内存模块DRAM 芯片封装在内存模块 (memory module) 中，它插到主板的扩展槽上 。 内存控制器将超单元地址 发送到内存模块，然后内存模块再广播到每个 DRAM 。作为响应，每个DRAM...</div></div></div></a><a class="pagination-related" href="/2024/01/30/csapp/%E7%AC%AC7%E7%AB%A0%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/" title="csapp第七章——链接"><img class="cover" src="/img/cover1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-30</div><div class="info-item-2">csapp第七章——链接</div></div><div class="info-2"><div class="info-item-1">链接链接 (linking) 是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行 。  链接可以执行于编译时 (compile time), 也就是在源代码被翻译成机器代码时；  也可以执行与加载时 (load time), 也就是在程序被加载器 (loader) 加载到内存并执行时；  甚至执行于运行时 (run time), 也就是由应用程序来执行。   编译器驱动程序12345678910111213141516171819202122232425/* main.c *//* $begin main */int sum(int *a, int n);int array[2] = &#123;1, 2&#125;;int main()&#123;    int val = sum(array, 2);    return val;&#125;/* $end main *//* sum.c *//* $begin sum */int sum(int *a, int n)&#123;    int i, s = 0;    for (i...</div></div></div></a><a class="pagination-related" href="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" title="csapp第九章——虚拟内存"><img class="cover" src="/img/cover2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-18</div><div class="info-item-2">csapp第九章——虚拟内存</div></div><div class="info-2"><div class="info-item-1">虚拟内存虚拟内存提供了三个重要的能力：   它将主存看成是 个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存  它为每个进程提供了一致的地址空间，从而简化了内存管理。  它保护了每个进程的地址空间不被其他进程破坏  物理和虚拟内存将虚拟地址转换为物理地址的任务叫做地址翻译 (address translation)。 地址翻译需要 CPU 硬件和操作系统之间的紧密合作 CPU 芯片上叫做内存管理单元(Memory Management Unit, MMU) 的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。  地址空间地址空间 (address space) 个非负整数地址的有序集合： 一个地址空间的大小是由表示最大地址所需要的位数来描述的。  虚拟地址空间： 一个包含 N=2**n个地址的虚拟地址空间就叫做一个n位地址空间，现代系统通常支持 32 位或者 64 位虚拟地址空间。  物理地址空间：对应于系统中物理内存的M个字节。   虚拟内存作为缓存的工具VM...</div></div></div></a><a class="pagination-related" href="/2023/12/07/csapp/attacklab/" title="attacklab"><img class="cover" src="/img/cover3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-07</div><div class="info-item-2">attacklab</div></div><div class="info-2"><div class="info-item-1">Part I: Code Injection Attacks开冲！！ level1 sub rsp,0x28说明缓冲区有0x28即40字节，我们只需在这之后加入touch1()函数的权限地址来提权。 gets()函数不会对输入大小进行检查，遇到\n0x0a结束字符串读取  touch1地址为0x4017c0  payload(注意不能填充0a)，同时小端序要倒序存储(低地址存放数据低位，高地址存放数据高位)  12345600 00 00 00 00 00 00 00 #低地址00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00c0 17 40 00 00 00 00 00...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avater.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Randolf luo</div><div class="author-info-description">今日事，今日毕</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">111</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Randolfluo" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:lrj3216610@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">1.</span> <span class="toc-text">异常控制流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.0.1.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">异常的类别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">1.0.1.2.1.</span> <span class="toc-text">中断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%B7%E9%98%B1%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.0.1.2.2.</span> <span class="toc-text">陷阱和系统调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%85%E9%9A%9C"><span class="toc-number">1.0.1.2.3.</span> <span class="toc-text">故障</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2"><span class="toc-number">1.0.1.2.4.</span> <span class="toc-text">终止</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-86-64-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">Linux&#x2F;86-64 系统调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.0.2.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">逻辑控制流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%B5%81"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">并发流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">私有地址空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%86%85%E6%A0%B8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.0.2.4.</span> <span class="toc-text">用户模式和内核模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.0.2.5.</span> <span class="toc-text">上下文切换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.0.3.</span> <span class="toc-text">系统调用错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.0.4.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8BID"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">获取进程ID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.0.4.2.</span> <span class="toc-text">创建和终止进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.0.4.3.</span> <span class="toc-text">回收子进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A9%E8%BF%9B%E7%A8%8B%E4%BC%91%E7%9C%A0"><span class="toc-number">1.0.4.4.</span> <span class="toc-text">让进程休眠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%B9%B6%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.0.4.5.</span> <span class="toc-text">加载并运行程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8fork%E5%92%8Cexecve%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.0.4.6.</span> <span class="toc-text">利用fork和execve运行程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.0.5.</span> <span class="toc-text">信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">信号术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">发送信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.0.5.3.</span> <span class="toc-text">接收信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E8%A7%A3%E9%99%A4%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.0.5.4.</span> <span class="toc-text">阻塞和解除阻塞信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.0.5.5.</span> <span class="toc-text">编写信号处理程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%B5%81%E4%BB%A5%E9%81%BF%E5%85%8D%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%B9%B6%E5%8F%91%E9%94%99%E8%AF%AF"><span class="toc-number">1.0.5.6.</span> <span class="toc-text">同步流以避免讨厌的并发错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%9C%B0%E7%AD%89%E5%BE%85%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.0.5.7.</span> <span class="toc-text">显示地等待信号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%9C%AC%E5%9C%B0%E8%B7%B3%E8%BD%AC"><span class="toc-number">1.0.6.</span> <span class="toc-text">非本地跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">1.0.7.</span> <span class="toc-text">操作进程的工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.0.8.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/11/daily%20record/20241111/" title="记一次2024ICPC杭州站"><img src="/img/cover3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="记一次2024ICPC杭州站"/></a><div class="content"><a class="title" href="/2024/11/11/daily%20record/20241111/" title="记一次2024ICPC杭州站">记一次2024ICPC杭州站</a><time datetime="2024-11-11T09:42:00.000Z" title="发表于 2024-11-11 17:42:00">2024-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/15/math/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" title="无标题"><img src="/img/cover3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2024/10/15/math/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" title="无标题">无标题</a><time datetime="2024-10-15T06:44:44.734Z" title="发表于 2024-10-15 14:44:44">2024-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/29/potato_clock/v0.01/" title="无标题"><img src="/img/cover3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2024/09/29/potato_clock/v0.01/" title="无标题">无标题</a><time datetime="2024-09-29T06:08:49.443Z" title="发表于 2024-09-29 14:08:49">2024-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/26/%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%840x2/" title="无标题"><img src="/img/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2024/09/26/%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%840x2/" title="无标题">无标题</a><time datetime="2024-09-26T12:40:48.042Z" title="发表于 2024-09-26 20:40:48">2024-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/26/pr/pr%E5%85%A5%E9%97%A8/" title="无标题"><img src="/img/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2024/09/26/pr/pr%E5%85%A5%E9%97%A8/" title="无标题">无标题</a><time datetime="2024-09-26T12:40:47.924Z" title="发表于 2024-09-26 20:40:47">2024-09-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover3.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By Randolf luo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>