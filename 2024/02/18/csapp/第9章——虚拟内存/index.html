<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>csapp第九章——虚拟内存 | Randolfluo's blog</title><meta name="author" content="Randolf luo"><meta name="copyright" content="Randolf luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="csapp">
<meta property="og:type" content="article">
<meta property="og:title" content="csapp第九章——虚拟内存">
<meta property="og:url" content="http://randolfluo.github.io/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/index.html">
<meta property="og:site_name" content="Randolfluo&#39;s blog">
<meta property="og:description" content="csapp">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://api.yujn.cn/api/ACG.php">
<meta property="article:published_time" content="2024-02-18T14:42:00.000Z">
<meta property="article:modified_time" content="2024-02-17T16:00:00.000Z">
<meta property="article:author" content="Randolf luo">
<meta property="article:tag" content="csapp">
<meta property="article:tag" content="book">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://api.yujn.cn/api/ACG.php"><link rel="shortcut icon" href="/img/avater.jpg"><link rel="canonical" href="http://randolfluo.github.io/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Randolf luo","link":"链接: ","source":"来源: Randolfluo's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'csapp第九章——虚拟内存',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avater.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(http://api.yujn.cn/api/ACG.php);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Randolfluo's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">csapp第九章——虚拟内存</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">csapp第九章——虚拟内存</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-18T14:42:00.000Z" title="发表于 2024-02-18 22:42:00">2024-02-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-17T16:00:00.000Z" title="更新于 2024-02-18 00:00:00">2024-02-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/csapp/">csapp</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/csapp/book/">book</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>虚拟内存提供了三个重要的能力： </p>
<ol>
<li>它将主存看成是 个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存 </li>
<li>它为每个进程提供了一致的地址空间，从而简化了内存管理。 </li>
<li>它保护了每个进程的地址空间不被其他进程破坏</li>
</ol>
<h3 id="物理和虚拟内存"><a href="#物理和虚拟内存" class="headerlink" title="物理和虚拟内存"></a>物理和虚拟内存</h3><p>将虚拟地址转换为物理地址的任务叫做<code>地址翻译 (address translation)</code>。</p>
<p>地址翻译需要 CPU 硬件和操作系统之间的紧密合作 CPU 芯片上叫做<code>内存管理单元</code>(Memory Management Unit, MMU) 的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。</p>
<img src="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/8a2fbf25aab1e67aa3a8d126b095543e.png" class="" title="image-20240218022153223">
<h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>地址空间 (address space) 个非负整数地址的有序集合：</p>
<p>一个地址空间的大小是由表示最大地址所需要的位数来描述的。</p>
<ul>
<li><p>虚拟地址空间：</p>
<p>一个包含 N=2**n个地址的虚拟地址空间就叫做一个n位地址空间，现代系统通常支持 32 位或者 64 位虚拟地址空间。</p>
</li>
<li><p>物理地址空间：对应于系统中物理内存的M个字节。</p>
</li>
</ul>
<h3 id="虚拟内存作为缓存的工具"><a href="#虚拟内存作为缓存的工具" class="headerlink" title="虚拟内存作为缓存的工具"></a>虚拟内存作为缓存的工具</h3><p>VM 系统通过将虚拟内存分割为称为<code>虚拟页 (Virtual Page, VP)</code> 的大小固定的块。物理内存被分割为物理页 (Physical Page, PP) （物理页也被称为页帧 (page frame ))</p>
<p>在任意时刻，虚拟页面的集合都分为三个不相交的子集：</p>
<ul>
<li>未分配的： VM 系统还未分配（或者创建）的页，未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。</li>
<li>已缓存的：当前已缓存在物理内存中的已分配页</li>
<li>未缓存的：未缓存在物理内存中的已分配页</li>
</ul>
<img src="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/b032172616347533fc3139b3e11f1971.png" class="" title="image-20240218023457320">
<h4 id="DRAM-缓存的组织结构"><a href="#DRAM-缓存的组织结构" class="headerlink" title="DRAM 缓存的组织结构"></a>DRAM 缓存的组织结构</h4><p>使用术语 SRAM 缓存来表示位于 CPU 和主存之间的 L1、L2、L3 高速缓存，并且用术语 DRAM 缓存来表示虚拟内存系统的缓存，它在主存中缓存虚拟页</p>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>和一个存放在物理内存中叫做<code>页表 (page table)</code>的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。</p>
<p>操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。因DRAM 缓存是全相联的，所以任意物理页都可以包含任意虚拟页。</p>
<p>页表就是一个页表条目 (Page Table Entry, PTE) 的数组。虚拟地址空间中的每个页在页表中一个固定偏移处都有一个 PTE。</p>
<p>每个PTE 是由一个有效位(valid bit) 和一个n 位地址字段组成的。有效位表明了该虚拟页当前是否被物理内存缓存在DRAM 中。</p>
<img src="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/3aff753fc23d99993151e351bd0f117c.png" class="" title="image-20240218025013379">
<h4 id="页命中"><a href="#页命中" class="headerlink" title="页命中"></a>页命中</h4><p>因为设置了有效位，那么地址翻译硬件就知道VP 2 是缓存在内存中的了。所以它使用PTE 中的物理内存地址（该地址指向pp 1 中缓存页的起始位置），构造出这个字的物理地址。</p>
<img src="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/cd96b1225f4b6184ecf71d3f31028435.png" class="" title="image-20240218025429701">
<h4 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h4><p>即DRAM缓存不命中，触个缺页异常。缺页异常调用内核中的缺页异常处理程序。选择一个牺牲页，然后将需要的页替换掉牺牲页</p>
<img src="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2c3d99da998e95bc5e9a110dcb0b8a57.png" class="" title="image-20240218184355131">
<img src="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/b1db3db79337fa1fb34d61b8ad4b93f4.png" class="" title="image-20240218184401314">
<ul>
<li><p>在磁盘和内存之间传送页的活动叫做<code>交换 (swapping)</code>或者<code>页面调度 (paging)</code> 。</p>
</li>
<li><p>当有不命中发生时，才换入页面的这种策略称为<code>按需页面调度 (demand paging)</code>。</p>
</li>
</ul>
<h4 id="又是局部性救了我们"><a href="#又是局部性救了我们" class="headerlink" title="又是局部性救了我们"></a>又是局部性救了我们</h4><ul>
<li><p>局部性性原则保证了在任意时刻，程序将趋向于在一个较小的活动页面 (active page) 集合上工作，这个集合叫做工作集 (working set) 或者常驻集合(resident set) 。</p>
</li>
<li><p>如果工作集的大小超出了物理内存的大小，那么程序将产生一种不幸的状态，叫做抖动 (thrashing), 这时页面将不断地换进换出 。</p>
</li>
<li><p>可以利用 Linux getrusage 函数监测缺页的数量（以及许多其他的信息）</p>
</li>
</ul>
<h3 id="虚拟内存作为内存管理的工具"><a href="#虚拟内存作为内存管理的工具" class="headerlink" title="虚拟内存作为内存管理的工具"></a>虚拟内存作为内存管理的工具</h3><p>操作系统为<code>每个进程</code>提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。</p>
<img src="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/e93d46b1742bd466d71670aed9646771.png" class="" title="image-20240628164234401">
<ul>
<li><p>简化链接</p>
<p>不同段在虚拟位置的位置是固定的。这样的一致性极大地简化了链接器的设计和实现，允许链接器生成<code>完全链接</code>的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的。</p>
</li>
<li><p>简化加载</p>
<p>虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。</p>
</li>
</ul>
<p>Linux 加载器为代码和数据段分配虚拟页，把它们标记为<code>无效的（即未被缓存的）</code>，将页表条目指向目标文件中适当的位置 。加载器从不从磁盘到内存实际复制任何数据 。在每个页初次被引用时，虚拟内存系统会按照需要自动地调入数据页。</p>
<p>将一组连续的虚拟页映射到任意一个文件中的任意位  示法称作内存映射 (memory mapping) Linux 提供一个称为 mmap 的系统调用，允许应用程序自己做内存映射。</p>
<ul>
<li>简化共享</li>
</ul>
<p>独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。</p>
<ul>
<li>简化内存分配 </li>
</ul>
<p>由于页表工作的方式，操作系统没有必要分配连续的物理内存页面。页面可以随机地分散在物理内存中。</p>
<h3 id="虚拟内存作为内存保护的工具"><a href="#虚拟内存作为内存保护的工具" class="headerlink" title="虚拟内存作为内存保护的工具"></a>虚拟内存作为内存保护的工具</h3><p>SUP 位表示进程是否必须运行在内核（超级用户）模式下才能访问该页。</p>
<p>如果一条指令违反了这些许可条件，那么 CPU 就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。 Linux shell 一般将这种异常报告为<code>＂段错误 (segmentation fault)&quot;</code></p>
<img src="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/219d1600c962c245f30ead786d833a60.png" class="" title="image-20240218194515336">
<h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><p>//TODO</p>
<h4 id="结合高速缓存和虚拟内存"><a href="#结合高速缓存和虚拟内存" class="headerlink" title="结合高速缓存和虚拟内存"></a>结合高速缓存和虚拟内存</h4><p>大多数系统是选择物理寻址的。使用物理寻址，多个进程同时在高速缓存中有存储块和共享来自相同虚拟页面的块成为很简单的事情。而且，高速缓存无需处理保护问题，因为访问权限的检查是地址翻译过程的一部分。</p>
<img src="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9b0124c0e1f879b44d277384a8e2ee57.png" class="" title="image-20240628164608051">
<h4 id="利用TLB加速地址翻译"><a href="#利用TLB加速地址翻译" class="headerlink" title="利用TLB加速地址翻译"></a>利用TLB加速地址翻译</h4><p>翻译后备缓冲器（Translation Lookaside Buffer，简称TLB）是一个用于改进虚拟内存系统性能的硬件缓存。在操作系统中，TLB用来减少处理器处理内存时地址转换的延迟。</p>
<p>当CPU接收到一个虚拟地址时，它首先在TLB中查找。如果找到了对应的物理地址，那么就可以直接使用，这被称为TLB命中（TLB Hit）。如果没有找到，即TLB未命中（TLB Miss），系统就必须查询内存中的页表，并将结果存入TLB中以便后续使用。</p>
<img src="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/1465533f76a2da0d0e7a51ff6633a212.png" class="" title="image-20240628165020124">
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>采用多层次的页表，虚拟内存地址被分成多个部分，每一部分用于索引不同级别的页表。</p>
<img src="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/4b43d5bcab04dbf4513c47d94475ec6b.png" class="" title="image-20240628170122691">
<h4 id="综合：端到端的地址翻译"><a href="#综合：端到端的地址翻译" class="headerlink" title="综合：端到端的地址翻译"></a>综合：端到端的地址翻译</h4><p>//TODO</p>
<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p><code>内存映射(memory mapping)</code>：将一个虚拟内存区域与一个磁盘上的对象(object) 关联起来</p>
<ul>
<li>一个区域可以映射到一个普通磁盘文件的连续部分。</li>
<li>一个区域也可以映射到一个<code>匿名文件</code>，<code>匿名文件</code>是由内核创建的，包含的全是二进制零。<code>匿名文件</code>可用于内存分配、进程间通信（IPC）、性能优化、用户空间分配器、操作系统内核、沙箱环境、虚拟化技术。</li>
</ul>
<h4 id="再看共享对象"><a href="#再看共享对象" class="headerlink" title="再看共享对象"></a>再看共享对象</h4><ul>
<li>对象可被映射为<code>共享对象</code>和<code>私有对象</code>。</li>
<li>即使<code>共享对象</code>被映射到了多个共享区域，物理内存中也只需要存放共享对象的一个副本。</li>
</ul>
<img src="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/c8112455812019c2f9524c1f171db78a.png" class="" title="image-20240411171229982">
<p><strong>写时复制（copy-on-write）</strong></p>
<ul>
<li><p>当多个进程将一个私有对象映射到内存时，如<code>图a</code>所示，该页表条目被标记为<code>只读</code>，区域结构被标记为<code>写时复制</code>，只要没有进程执行写操作，就保持图a的状态。  </p>
</li>
<li><p>当进程试图写该私有对象时，触发<code>保护</code>故障，进入<code>故障处理程序</code>,返回后进入<code>图b</code>状态。  </p>
</li>
<li>通过延迟私有对象中的副本直到最后可能的时刻，写时复制最充分地使用了稀有的物理内存。</li>
</ul>
<img src="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/819e6aa006d7890872347bc6044515f1.png" class="" title="image-20240411172044441">
<h4 id="再看fork函数"><a href="#再看fork函数" class="headerlink" title="再看fork函数"></a>再看fork函数</h4><ul>
<li>当fork 函数被当前进程调用时，内核为新进程创建各种<code>数据结构</code>，并分配给它一个唯一的<code>PID</code> 。为了给这个新进程创建虚拟内存，它创建了当前进程的<code>mm_struct 、区域结构和页表的原样副本</code>。它将两个进程中的<code>每个页面都标记为只读</code>，并将两个进程中的每个区域结构都标记为私有的写时复制。</li>
<li>当fork 在新进程中返回时，新进程现在的虚拟内存刚好和调用fork 时存在的虚拟内存<code>相同</code>。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。</li>
</ul>
<h4 id="再看execve函数"><a href="#再看execve函数" class="headerlink" title="再看execve函数"></a>再看execve函数</h4><ul>
<li><strong>删除已存在的用户区域</strong>。删除当前进程虚拟地址的用户部分中的已存在的区域结构。</li>
<li><strong>映射私有区域</strong>。为新程序的代码、数据、bss 和栈区域创建新的区域结构。所有这些新的区域都是<code>私有的、写时复制</code>的。<code>代码</code>和<code>数据区域</code>被映射为a.out 文件中的<code>.text</code>和<code>.data 区</code>。<code>bss 区域</code>是<code>请求二进制零</code>的，<code>映射到匿名文件</code>，其大小包含在a.out 中。<code>栈</code>和<code>堆</code>区域也是<code>请求二进制零</code>的，初始长度为零。但是栈内存不是通过匿名文件映射来实现的，而是直接由内核管理的。当使用<code>brk()</code>和<code>sbrk()</code>时，堆内存的扩展是通过改变进程的<code>program break</code>来实现的，这并<code>不涉及匿名文件映射</code>。当使用<code>mmap()</code>来分配内存时，可以映射到<code>匿名文件（anonymous file）</code>，这种方式称为匿名内存映射。这种映射不与磁盘上的实际文件关联，而是直接映射到虚拟内存中的区域。</li>
<li><strong>映射共享区域</strong>。如果a.out 程序与共享对象（或目标）链接，比如标准C 库<code>libc.so</code>, 那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。</li>
<li><strong>设置程序计数器(PC)</strong> 。<code>execve</code> 做的最后一件事情就是设置当前进程上下文中的<code>程序计数器</code>，使之指向代码区域的入口点。下一次调度这个进程时，它将从这个入口点开始执行。Linux 将根据需要换入代码和数据页面。</li>
</ul>
<h4 id="使用mmap函数的用户级内存映射"><a href="#使用mmap函数的用户级内存映射" class="headerlink" title="使用mmap函数的用户级内存映射"></a>使用mmap函数的用户级内存映射</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include &lt;unistd.h&gt; </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,<span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>
<p>mmap 函数要求内核创建一个新的虚拟内存区域， 最好是从地址 start 开始的一个区 域， 并将文件描述符 fd 指定的对象的一个连续的片(chunk)映射到这个新的区域。 连续的 对象片大小为 length 字节， 从距文件开始处偏移量为 offset 字节的地方开始。 </p>
<ul>
<li>PROT_EXEC: 这个区域内的页面由可以被CPU执行的指令组成。</li>
<li>PROT_READ: 这个区域内的页面可读。</li>
<li>PROT _WRITE: 这个区域内的页面可写。</li>
<li>PROT _NONE: 这个区域内的页面不能被访问。</li>
</ul>
<img src="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/93f1236b73a5eefb60bed2f00e48bd6a.png" class="" title="image-20240627232715280">
<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><img src="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/1e75805b54ff310b1ed4b62160fe44f9.png" class="" title="image-20240411173846341">
<ul>
<li>动态内存分配器维护着一个进程的虚拟内存区域，称为<code>堆(heap)</code>。</li>
<li><p>对于<code>每个进程</code>内核维护着一个<code>brk</code>变量指向堆顶</p>
</li>
<li><p>显式内存分配器：<code>C</code>的<code>malloc</code>和<code>free</code>，<code>C++</code>的<code>new</code>和<code>delete</code>。</p>
</li>
<li>隐式内存分配器：通过<code>垃圾回收器</code>回收，如java。</li>
</ul>
<h4 id="malloc和free函数"><a href="#malloc和free函数" class="headerlink" title="malloc和free函数"></a>malloc和free函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配指定大小的内存块，并返回指向该内存块起始地址的指针。分配的内存块中的内容是未初始化的。 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配指定数量的指定大小的内存块，并将其内容初始化为零。 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重新分配之前分配的内存块的大小，并返回指向新内存块的指针。如果新分配的大小比旧分配的大小大，那么新分配的内存块可能与旧内存块相同，否则，它可能是一个新的内存块。 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放 分配的内存块。注意：在释放内存块后，指向该内存块的指针将不再有效，任何对该指针的后续访问都可能导致未定义的行为。 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 增加程序的数据段的大小，即在堆上分配一定大小的内存空间。通常在内部由 malloc() 等函数调用。 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">sbrk</span><span class="params">(<span class="type">intptr_t</span> incr)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="为什么要使用动态内存分配"><a href="#为什么要使用动态内存分配" class="headerlink" title="为什么要使用动态内存分配"></a>为什么要使用动态内存分配</h4><ul>
<li>因为只有直到程序实际实际运行时才知道某些数据结构的大小</li>
</ul>
<h4 id="分配器的要求和目标"><a href="#分配器的要求和目标" class="headerlink" title="分配器的要求和目标"></a>分配器的要求和目标</h4><p>要求：</p>
<ul>
<li>处理任意请求序列。</li>
<li>立即响应请求。 分配器必须立即响应分配请求。 </li>
<li>不允许分配器为了提高性能 重新排列或者缓冲请求。只使用堆。</li>
<li>对齐块（对齐要求）。 分配器必须对齐块， 使得它们可以保存任何类型的数据对象。</li>
</ul>
<p>目标: </p>
<ul>
<li>最大化吞吐率。</li>
<li>最大化内存利用率。</li>
</ul>
<h4 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h4><ul>
<li><strong>内部碎片：</strong>分配块大小和它们的有效载荷大小之差的和。在任意时刻，内部碎片的数量只取决于以前请求的模式和分配器的实现方式。</li>
<li>外部碎片：外部碎片是当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生的。不仅取决于以前请求的模式和分配器的实现方式， 还取决千将来请求的模式。 </li>
</ul>
<h4 id="放置已分配的块"><a href="#放置已分配的块" class="headerlink" title="放置已分配的块"></a>放置已分配的块</h4><ul>
<li>首次适配：这种策略会搜索内存的第一个足够大的空闲块来满足请求。首次适配简单且执行速度快，但可能会导致内存碎片。</li>
<li>下一次适配：下一次适配不会每次都从内存列表的开始处查找，而是从上次分配的位置继续查找。这可以减少内存碎片，但性能上可能不如首次适配。</li>
<li>最佳适配：最佳适配策略寻找最接近所需大小的空闲内存块。这种方法可以最小化内存碎片。但是，最佳适配可能需要更多的时间来搜索合适的空闲块，因为它必须检查所有的空闲块以找到最佳匹配。</li>
</ul>
<h4 id="获取额外内存"><a href="#获取额外内存" class="headerlink" title="获取额外内存"></a>获取额外内存</h4><p>通过sbrk函数</p>
<h4 id="合并空闲块"><a href="#合并空闲块" class="headerlink" title="合并空闲块"></a>合并空闲块</h4><ul>
<li>立即合并</li>
<li>推迟合并</li>
</ul>
<h4 id="带边界标记的合并"><a href="#带边界标记的合并" class="headerlink" title="带边界标记的合并"></a>带边界标记的合并</h4><p>通过在每一个块尾部添加一个脚部来实现块的合并（会增大内存开销），可分为以下四种情况：</p>
<img src="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/4f8be14ffd5905df79d5c43b3a42ac67.png" class="" title="image-20240627223704750">
<h4 id="综合：实现一个简单的分配器"><a href="#综合：实现一个简单的分配器" class="headerlink" title="综合：实现一个简单的分配器"></a>综合：实现一个简单的分配器</h4><p>malloc lab</p>
<h4 id="显式空闲列表"><a href="#显式空闲列表" class="headerlink" title="显式空闲列表"></a>显式空闲列表</h4><p>通过添加祖先和后继节点加快分配时空闲块的访问速度。</p>
<img src="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/08d2bf31cdb86dc6f4fe511e8aca147a.png" class="" title="image-20240627223736177">
<h4 id="分离的空闲列表"><a href="#分离的空闲列表" class="headerlink" title="分离的空闲列表"></a>分离的空闲列表</h4><p>将{1}，{2}，{4}…..{2^10}等不同大小的空闲块按照2的幂分类，每个类组成一个空闲链表</p>
<ol>
<li><p>简单分离存储：不对空闲块进行分割合并。因此只需要succ指针，最小块为一个字。但是会造成很多内部碎片和外部碎片。</p>
</li>
<li><p>分离适配：GNU malloc包采用此方法，即找到合适块后，（可选地）分割它，将剩余部分插入其他适当空闲链表。释放一个块，执行合并，将结果放置到对应地空闲链表中。</p>
</li>
<li><p>伙伴系统：</p>
<ul>
<li>每个块都有一个伙伴，伙伴的大小相同，位置相邻。如果一个块位于地址A，那么它的伙伴就位于地址A±块大小。这样，内存就被组织成了一个伙伴对的双向链表。</li>
<li><p>当需要分配内存时，系统会查找大小最接近所需大小的块。如果找到的块太大，就会被分裂成两个较小的块，每个块都是原块大小的一半。这个过程会一直重复，直到找到大小合适的块为止。</p>
</li>
<li><p>当释放内存时，系统会检查释放的块的伙伴是否也是空闲的。如果是，那么这两个伙伴块会被合并成一个更大的块，并放回到块链表中。这个过程可能会递归进行，如果更大的伙伴块也是空闲的，它们也会被合并。</p>
</li>
<li>优点是能快速搜索和快速合并，缺点是可能导致显著的内存碎片。</li>
</ul>
</li>
</ol>
<h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><h4 id="垃圾收集的基本知识"><a href="#垃圾收集的基本知识" class="headerlink" title="垃圾收集的基本知识"></a>垃圾收集的基本知识</h4><p>垃圾收集器(garbage collector)是一种动态内存分配器，它自动释放程序不再需要的已分配块。</p>
<p>垃圾收集器将内存视为一张有向可达图(reachability graph)：</p>
<img src="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/709196241f6f6738811c459933b49ff6.png" class="" title="image-20240627230439248">
<p>无论何时需要堆空间时，应用都会用通常的方式调用malloc。 如果malloc找不到一个合适的空闲块， 那么它就调用垃圾收集器， 希望能够回收一些垃圾到空闲链表 。收集器识别出垃圾块，并通过调用free函数将它们返回给堆 。关键的思想是收集器代替应用去调用free。 </p>
<img src="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/877447035a71a78b0a85e3869cd7f29d.png" class="" title="image-20240627230646589">
<h4 id="Mark-amp-Sweep垃圾收集器"><a href="#Mark-amp-Sweep垃圾收集器" class="headerlink" title="Mark&amp;Sweep垃圾收集器"></a>Mark&amp;Sweep垃圾收集器</h4><p>Mark&amp;Sweep垃圾收集器由标记(mark)阶段和清除(sweep)阶段组成，标记阶段标记出根节点的所有可达的和已分配的后继， 而后面的清除阶段释放每个未被标记的已分配块。 块头部中空闲的低位中的一位通常用来表示这个块是否被标记了 。</p>
<img src="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/05b397e041c17ee6bebd276336c86124.png" class="" title="image-20240627230811901">
<h4 id="C程序的保守Mark-amp-Sweep"><a href="#C程序的保守Mark-amp-Sweep" class="headerlink" title="C程序的保守Mark&amp;Sweep"></a>C程序的保守Mark&amp;Sweep</h4><p>C程序的Mark &amp; Sweep收集器必须是保守的， 其根本原因是C语言不会用类型信息来标记内存位置。 </p>
<h3 id="C程序常见的与内存有关的错误"><a href="#C程序常见的与内存有关的错误" class="headerlink" title="C程序常见的与内存有关的错误"></a>C程序常见的与内存有关的错误</h3><h4 id="间接引用坏指针"><a href="#间接引用坏指针" class="headerlink" title="间接引用坏指针"></a>间接引用坏指针</h4><p>注意需要的是<code>指针指向的地址</code>还是<code>指针指向的地址的值</code></p>
<h4 id="读未初始化的内存"><a href="#读未初始化的内存" class="headerlink" title="读未初始化的内存"></a>读未初始化的内存</h4><p>注意malloc等部分函数得到的地址是未初始化的，我们不能假设其全为0，可以使用calloc代替或显示初始化为0。</p>
<h4 id="允许栈缓冲区溢出"><a href="#允许栈缓冲区溢出" class="headerlink" title="允许栈缓冲区溢出"></a>允许栈缓冲区溢出</h4><p>避免使用gets等危险函数，否则输入可能会大于容纳数组的大小。</p>
<h4 id="假设指针和它们所指向的对象时相同大小的"><a href="#假设指针和它们所指向的对象时相同大小的" class="headerlink" title="假设指针和它们所指向的对象时相同大小的"></a>假设指针和它们所指向的对象时相同大小的</h4><p><code>sizeof(int)</code>和<code>sizeof(int *)</code>在64位机器上大小是不同的。</p>
<h4 id="造成错位错误"><a href="#造成错位错误" class="headerlink" title="造成错位错误"></a>造成错位错误</h4><p>注意对内存的操作不要越界</p>
<h4 id="引用指针，而不是它所指向的对象"><a href="#引用指针，而不是它所指向的对象" class="headerlink" title="引用指针，而不是它所指向的对象"></a>引用指针，而不是它所指向的对象</h4><p>采用括号来避免可能发生的优先级错误</p>
<h4 id="误解指针运算"><a href="#误解指针运算" class="headerlink" title="误解指针运算"></a>误解指针运算</h4><p>不同类型的指针步长不同，但我们访问指针的下一元素只需要将指针+1即可。</p>
<h4 id="引用不存在的变量"><a href="#引用不存在的变量" class="headerlink" title="引用不存在的变量"></a>引用不存在的变量</h4><p>禁止返回临时变量。</p>
<h4 id="引用空闲堆块中的数据"><a href="#引用空闲堆块中的数据" class="headerlink" title="引用空闲堆块中的数据"></a>引用空闲堆块中的数据</h4><p>在malloc后free掉的数据不能够再次使用。</p>
<h4 id="引起内存泄露"><a href="#引起内存泄露" class="headerlink" title="引起内存泄露"></a>引起内存泄露</h4><p>别忘了free！！！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://randolfluo.github.io">Randolf luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://randolfluo.github.io/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">http://randolfluo.github.io/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://randolfluo.github.io" target="_blank">Randolfluo's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/csapp/">csapp</a><a class="post-meta__tags" href="/tags/book/">book</a></div><div class="post-share"><div class="social-share" data-image="http://api.yujn.cn/api/ACG.php" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/02/15/stm32/stm32%E5%8D%95%E7%89%87%E6%9C%BA0x1/" title="stm32单片机0x1"><img class="cover" src="https://www.dmoe.cc/random.php" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">stm32单片机0x1</div></div><div class="info-2"><div class="info-item-1">stm32STM32是ST公司基于ARM Cortex-M内核开发的32位微控制器  ARM内核 stm32F103C8T6采用Cortex-M3内核，发布于2004年10月。  片上资源/外设     英文缩写 名称 英文缩写 名称     NVIC 嵌套向量中断控制器 CAN CAN通信   SysTick 系统滴答定时器 USB USB通信   RCC 复位和时钟控制 RTC 实时时钟   GPIO 通用IO口 CRC CRC校验   AFIO 复用IO口 PWR 电源控制   EXTI 外部中断 BKP 备份寄存器   TIM 定时器 IWDG 独立看门狗   ADC 模数转换器 WWDG 窗口看门狗   DMA 直接内存访问 DAC 数模转换器   USART 同步/异步串口通信 SDIO SD卡接口   I2C I2C通信 FSMC 可变静态存储控制器   SPI SPI通信 USB...</div></div></div></a><a class="pagination-related" href="/2024/02/26/csapp/%E7%AC%AC10%E7%AB%A0%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/" title="csapp第十章——系统级IO"><img class="cover" src="http://api.yujn.cn/api/ACG.php" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">csapp第十章——系统级IO</div></div><div class="info-2"><div class="info-item-1">系统级I/O输入与输出 (I/O) 是在主存和外部设备（例如磁盘驱动器、终端和网络）之间复制数据的过程。 UNIX I/O 所有的设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。   打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。 Linux shell 创建的每个进程开始时都有三个打开的文件：  12345/*								 /usr/include/unisted.h 						 */#define STDIN_FILENO    0       /* Standard input.  */#define STDOUT_FILENO   1       /* Standard output.  */#define STDERR_FILENO   2       /* Standard error output. ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/01/28/csapp/%E7%AC%AC5%E7%AB%A0%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/" title="csapp第五章——优化程序性能"><img class="cover" src="https://api.gumengya.com/Api/DmImg?format=image" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-28</div><div class="info-item-2">csapp第五章——优化程序性能</div></div><div class="info-2"><div class="info-item-1">优化程序性能 第一，我们必须选择一组适当的算法和数据结构。 第二，我们必须编写出编译器能够有效优化以转换成高效可执行代码的源代码。   为什么我们需要优化程序，现代编译器不是具有很强的优化能力吗？ ans:因为编译器只进行安全的优化，消除可能出现的异常的运行时行为。意味着我们需要写出适合编译器优化的代码，优化程序性能。  内存别名使用 两个指针可能指向同一个内存位置的情况称为内存别名使用 (memory aliasing)  12345678910void twiddlel(long *Xp, long *yp) &#123; *XP += *yp; *XP += *yp; &#125; void twiddle2(long *XP, long *yp) &#123; *XP += 2* *yp; &#125;  乍一看两个函数好像没有区别，但是当*XP与*YP指向同一内存时。twiddle1变为原来的四倍，twiddle2变为原来的三倍。改变了程序的行为。 ...</div></div></div></a><a class="pagination-related" href="/2024/02/26/csapp/%E7%AC%AC10%E7%AB%A0%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/" title="csapp第十章——系统级IO"><img class="cover" src="http://api.yujn.cn/api/ACG.php" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-26</div><div class="info-item-2">csapp第十章——系统级IO</div></div><div class="info-2"><div class="info-item-1">系统级I/O输入与输出 (I/O) 是在主存和外部设备（例如磁盘驱动器、终端和网络）之间复制数据的过程。 UNIX I/O 所有的设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。   打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。 Linux shell 创建的每个进程开始时都有三个打开的文件：  12345/*								 /usr/include/unisted.h 						 */#define STDIN_FILENO    0       /* Standard input.  */#define STDOUT_FILENO   1       /* Standard output.  */#define STDERR_FILENO   2       /* Standard error output. ...</div></div></div></a><a class="pagination-related" href="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/" title="csapp第六章——存储器层次结构"><img class="cover" src="https://api.mtyqx.cn/tapi/random.php" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-01</div><div class="info-item-2">csapp第六章——存储器层次结构</div></div><div class="info-2"><div class="info-item-1">存储器层次结构计算机技术的成功很大程度上源自于存储技术的巨大进步 。 随机访问存储器静态RAM 由于 SRAM 存储器单元的双稳态特性，只要有电，它就会永远地保持它的值。 动态RAMDRAM 将每个位存储为对每个电容的充电。与 SRAM 不同， DRAM 存储器单元对干扰非常敏感 。  传统的DRAMDRAM 芯片中的单元（位）被分成d 个超单元 (supercell) , 每个超单元都个DRAM单元组成。 d*w 的DRAM 总共存储了d w位信息。  图示为168 DRAM 芯片的组织，有 d=l6 个超单元，每个超单元有 w=8 位， r=4 行，c=4 。   将 DRAM 组织成二维阵列而不是线性数组的一个原因是降低芯片上地址引脚的数量。  二维阵列组织的缺点是必须分两步发送地址，这增加了访问时间。   内存模块DRAM 芯片封装在内存模块 (memory module) 中，它插到主板的扩展槽上 。 内存控制器将超单元地址 发送到内存模块，然后内存模块再广播到每个 DRAM 。作为响应，每个DRAM...</div></div></div></a><a class="pagination-related" href="/2024/01/30/csapp/%E7%AC%AC7%E7%AB%A0%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/" title="csapp第七章——链接"><img class="cover" src="https://img.paulzzh.com/touhou/random" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-30</div><div class="info-item-2">csapp第七章——链接</div></div><div class="info-2"><div class="info-item-1">链接链接 (linking) 是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行 。  链接可以执行于编译时 (compile time), 也就是在源代码被翻译成机器代码时；  也可以执行与加载时 (load time), 也就是在程序被加载器 (loader) 加载到内存并执行时；  甚至执行于运行时 (run time), 也就是由应用程序来执行。   编译器驱动程序12345678910111213141516171819202122232425/* main.c *//* $begin main */int sum(int *a, int n);int array[2] = &#123;1, 2&#125;;int main()&#123;    int val = sum(array, 2);    return val;&#125;/* $end main *//* sum.c *//* $begin sum */int sum(int *a, int n)&#123;    int i, s = 0;    for (i...</div></div></div></a><a class="pagination-related" href="/2024/02/13/csapp/%E7%AC%AC8%E7%AB%A0%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" title="csapp第八章——异常控制流"><img class="cover" src="https://api.paugram.com/wallpaper/" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-13</div><div class="info-item-2">csapp第八章——异常控制流</div></div><div class="info-2"><div class="info-item-1">[TOC] 异常控制流现代系统通过使控制流发生突变来对系统状态的变化做出反应 。一般而言 ，我们把这些突变称为异常控制流 (Exceptional Control Flow, ECF) 。 异常异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。  异常 (exception) 就是控制流中的突变，用来响应处理器状态中的某些变化。 当处理器检测到有事件发生时，它就会通过一张叫做异常表 (exception table)的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序 (exception handler)) 。 异常处理 异常处理程序运行在内核模式下，这意味它们对所有的系统资源都有完全的访问权限。 异常的类别  同步异步表示的结果的获取方式是主动获取还是被动接收；阻塞非阻塞表示的是获取这个动作是否可以立即返回不用等待。  中断中断是异步发生的， 是来自处理器外部的 I/0 设备的信号的结果。例如定时器计时结束后会向处理器发送一个中断。  陷阱和系统调用陷阱是有意的异常，是执行一条指令的结果...</div></div></div></a><a class="pagination-related" href="/2023/12/07/csapp/attacklab/" title="attacklab"><img class="cover" src="https://www.dmoe.cc/random.php" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-07</div><div class="info-item-2">attacklab</div></div><div class="info-2"><div class="info-item-1">Part I: Code Injection Attacks开冲！！ level1 sub rsp,0x28说明缓冲区有0x28即40字节，我们只需在这之后加入touch1()函数的权限地址来提权。 gets()函数不会对输入大小进行检查，遇到\n0x0a结束字符串读取  touch1地址为0x4017c0  payload(注意不能填充0a)，同时小端序要倒序存储(低地址存放数据低位，高地址存放数据高位)  12345600 00 00 00 00 00 00 00 #低地址00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00c0 17 40 00 00 00 00 00...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avater.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Randolf luo</div><div class="author-info-description">今日事，今日毕</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Randolfluo" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:lrj3216610@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">1.</span> <span class="toc-text">虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">1.0.1.</span> <span class="toc-text">物理和虚拟内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.0.2.</span> <span class="toc-text">地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">1.0.3.</span> <span class="toc-text">虚拟内存作为缓存的工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DRAM-%E7%BC%93%E5%AD%98%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">DRAM 缓存的组织结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E5%91%BD%E4%B8%AD"><span class="toc-number">1.0.3.3.</span> <span class="toc-text">页命中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5"><span class="toc-number">1.0.3.4.</span> <span class="toc-text">缺页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%88%E6%98%AF%E5%B1%80%E9%83%A8%E6%80%A7%E6%95%91%E4%BA%86%E6%88%91%E4%BB%AC"><span class="toc-number">1.0.3.5.</span> <span class="toc-text">又是局部性救了我们</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">1.0.4.</span> <span class="toc-text">虚拟内存作为内存管理的工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">1.0.5.</span> <span class="toc-text">虚拟内存作为内存保护的工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="toc-number">1.0.6.</span> <span class="toc-text">地址翻译</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">结合高速缓存和虚拟内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8TLB%E5%8A%A0%E9%80%9F%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="toc-number">1.0.6.2.</span> <span class="toc-text">利用TLB加速地址翻译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.0.6.3.</span> <span class="toc-text">多级页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%EF%BC%9A%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%9A%84%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="toc-number">1.0.6.4.</span> <span class="toc-text">综合：端到端的地址翻译</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">1.0.7.</span> <span class="toc-text">内存映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%8D%E7%9C%8B%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.0.7.1.</span> <span class="toc-text">再看共享对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%8D%E7%9C%8Bfork%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.7.2.</span> <span class="toc-text">再看fork函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%8D%E7%9C%8Bexecve%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.7.3.</span> <span class="toc-text">再看execve函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8mmap%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%88%B7%E7%BA%A7%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">1.0.7.4.</span> <span class="toc-text">使用mmap函数的用户级内存映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.0.8.</span> <span class="toc-text">动态内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc%E5%92%8Cfree%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">malloc和free函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.0.8.2.</span> <span class="toc-text">为什么要使用动态内存分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E8%A6%81%E6%B1%82%E5%92%8C%E7%9B%AE%E6%A0%87"><span class="toc-number">1.0.8.3.</span> <span class="toc-text">分配器的要求和目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A2%8E%E7%89%87"><span class="toc-number">1.0.8.4.</span> <span class="toc-text">碎片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BE%E7%BD%AE%E5%B7%B2%E5%88%86%E9%85%8D%E7%9A%84%E5%9D%97"><span class="toc-number">1.0.8.5.</span> <span class="toc-text">放置已分配的块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%A2%9D%E5%A4%96%E5%86%85%E5%AD%98"><span class="toc-number">1.0.8.6.</span> <span class="toc-text">获取额外内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E7%A9%BA%E9%97%B2%E5%9D%97"><span class="toc-number">1.0.8.7.</span> <span class="toc-text">合并空闲块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E8%BE%B9%E7%95%8C%E6%A0%87%E8%AE%B0%E7%9A%84%E5%90%88%E5%B9%B6"><span class="toc-number">1.0.8.8.</span> <span class="toc-text">带边界标记的合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">1.0.8.9.</span> <span class="toc-text">综合：实现一个简单的分配器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8"><span class="toc-number">1.0.8.10.</span> <span class="toc-text">显式空闲列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E7%9A%84%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8"><span class="toc-number">1.0.8.11.</span> <span class="toc-text">分离的空闲列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="toc-number">1.0.9.</span> <span class="toc-text">垃圾收集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">1.0.9.1.</span> <span class="toc-text">垃圾收集的基本知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mark-amp-Sweep%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.0.9.2.</span> <span class="toc-text">Mark&amp;Sweep垃圾收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BF%9D%E5%AE%88Mark-amp-Sweep"><span class="toc-number">1.0.9.3.</span> <span class="toc-text">C程序的保守Mark&amp;Sweep</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%8E%E5%86%85%E5%AD%98%E6%9C%89%E5%85%B3%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">1.0.10.</span> <span class="toc-text">C程序常见的与内存有关的错误</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%9D%8F%E6%8C%87%E9%92%88"><span class="toc-number">1.0.10.1.</span> <span class="toc-text">间接引用坏指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-number">1.0.10.2.</span> <span class="toc-text">读未初始化的内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%81%E8%AE%B8%E6%A0%88%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="toc-number">1.0.10.3.</span> <span class="toc-text">允许栈缓冲区溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%87%E8%AE%BE%E6%8C%87%E9%92%88%E5%92%8C%E5%AE%83%E4%BB%AC%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%97%B6%E7%9B%B8%E5%90%8C%E5%A4%A7%E5%B0%8F%E7%9A%84"><span class="toc-number">1.0.10.4.</span> <span class="toc-text">假设指针和它们所指向的对象时相同大小的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%A0%E6%88%90%E9%94%99%E4%BD%8D%E9%94%99%E8%AF%AF"><span class="toc-number">1.0.10.5.</span> <span class="toc-text">造成错位错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%8C%87%E9%92%88%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%AE%83%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.0.10.6.</span> <span class="toc-text">引用指针，而不是它所指向的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AF%E8%A7%A3%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="toc-number">1.0.10.7.</span> <span class="toc-text">误解指针运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">1.0.10.8.</span> <span class="toc-text">引用不存在的变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%A9%BA%E9%97%B2%E5%A0%86%E5%9D%97%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">1.0.10.9.</span> <span class="toc-text">引用空闲堆块中的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E8%B5%B7%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">1.0.10.10.</span> <span class="toc-text">引起内存泄露</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/18/%E9%A2%98%E8%A7%A3/The%2018th%20Zhejiang%20Provincial%20Collegiate%20Programming%20Contest/" title="The 18th Zhejiang Provincial Collegiate Programming Contest"><img src="https://www.dmoe.cc/random.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="The 18th Zhejiang Provincial Collegiate Programming Contest"/></a><div class="content"><a class="title" href="/2025/04/18/%E9%A2%98%E8%A7%A3/The%2018th%20Zhejiang%20Provincial%20Collegiate%20Programming%20Contest/" title="The 18th Zhejiang Provincial Collegiate Programming Contest">The 18th Zhejiang Provincial Collegiate Programming Contest</a><time datetime="2025-04-17T16:00:00.000Z" title="发表于 2025-04-18 00:00:00">2025-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/14/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC7%E7%AB%A0-%E6%9F%A5%E6%89%BE/" title="无标题"><img src="http://api.yujn.cn/api/ACG.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2025/04/14/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC7%E7%AB%A0-%E6%9F%A5%E6%89%BE/" title="无标题">无标题</a><time datetime="2025-04-14T02:09:58.968Z" title="发表于 2025-04-14 10:09:58">2025-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/14/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC5%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构-第5章—树与二叉树"><img src="https://api.mtyqx.cn/tapi/random.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构-第5章—树与二叉树"/></a><div class="content"><a class="title" href="/2025/04/14/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC5%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构-第5章—树与二叉树">数据结构-第5章—树与二叉树</a><time datetime="2025-04-13T16:00:00.000Z" title="发表于 2025-04-14 00:00:00">2025-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/13/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" title="线段树与树状数组"><img src="https://img.paulzzh.com/touhou/random" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线段树与树状数组"/></a><div class="content"><a class="title" href="/2025/04/13/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" title="线段树与树状数组">线段树与树状数组</a><time datetime="2025-04-13T09:42:00.000Z" title="发表于 2025-04-13 17:42:00">2025-04-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/13/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC6%E7%AB%A0-%E5%9B%BE/" title="数据结构-第6章—图"><img src="https://img.paulzzh.com/touhou/random" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构-第6章—图"/></a><div class="content"><a class="title" href="/2025/04/13/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC6%E7%AB%A0-%E5%9B%BE/" title="数据结构-第6章—图">数据结构-第6章—图</a><time datetime="2025-04-12T16:00:00.000Z" title="发表于 2025-04-13 00:00:00">2025-04-13</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(http://api.yujn.cn/api/ACG.php);"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By Randolf luo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>