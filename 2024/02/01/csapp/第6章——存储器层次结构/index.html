<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>csapp第六章——存储器层次结构 | Randolfluo's blog</title><meta name="author" content="Randolf luo"><meta name="copyright" content="Randolf luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="csapp">
<meta property="og:type" content="article">
<meta property="og:title" content="csapp第六章——存储器层次结构">
<meta property="og:url" content="http://randolfluo.github.io/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Randolfluo&#39;s blog">
<meta property="og:description" content="csapp">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.paulzzh.com/touhou/random">
<meta property="article:published_time" content="2024-02-01T14:42:00.000Z">
<meta property="article:modified_time" content="2024-01-31T16:00:00.000Z">
<meta property="article:author" content="Randolf luo">
<meta property="article:tag" content="csapp">
<meta property="article:tag" content="book">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.paulzzh.com/touhou/random"><link rel="shortcut icon" href="/img/avater.jpg"><link rel="canonical" href="http://randolfluo.github.io/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Randolf luo","link":"链接: ","source":"来源: Randolfluo's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'csapp第六章——存储器层次结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avater.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/album/"><i class="fa-fw fas fa_images"></i><span> 图片</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://img.paulzzh.com/touhou/random);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Randolfluo's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">csapp第六章——存储器层次结构</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/album/"><i class="fa-fw fas fa_images"></i><span> 图片</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">csapp第六章——存储器层次结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-01T14:42:00.000Z" title="发表于 2024-02-01 22:42:00">2024-02-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-31T16:00:00.000Z" title="更新于 2024-02-01 00:00:00">2024-02-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/csapp/">csapp</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/csapp/book/">book</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>22分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h1><p>计算机技术的成功很大程度上源自于存储技术的巨大进步 。</p>
<h3 id="随机访问存储器"><a href="#随机访问存储器" class="headerlink" title="随机访问存储器"></a>随机访问存储器</h3><h4 id="静态RAM"><a href="#静态RAM" class="headerlink" title="静态RAM"></a>静态RAM</h4><img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/c8e6b1388f0289e6c7c6e9001eb781d8.png" class="" title="image-20240201205902876">
<p>由于 <code>SRAM</code> 存储器单元的双稳态特性，只要有电，它就会永远地保持它的值。</p>
<h4 id="动态RAM"><a href="#动态RAM" class="headerlink" title="动态RAM"></a>动态RAM</h4><p>DRAM 将每个位存储为对每个电容的充电。与 SRAM 不同， DRAM 存储器单元对干扰非常敏感 。</p>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/e92e32acc7686e11eafca6698414cd15.png" class="" title="image-20240201210226240">
<h4 id="传统的DRAM"><a href="#传统的DRAM" class="headerlink" title="传统的DRAM"></a>传统的DRAM</h4><p>DRAM 芯片中的单元（位）被分成d 个超单元 (supercell) , 每个超单元都个DRAM单元组成。 d*w 的DRAM 总共存储了d w位信息。</p>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/a8eba9591cc15c1793d73a3d470799d4.png" class="" title="image-20240201210456088">
<p>图示为168 DRAM 芯片的组织，有 d=l6 个超单元，每个超单元有 w=8 位， r=4 行，c=4 。</p>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/eea9fe903004a4dcc124d84157688f8f.png" class="" title="image-20240201220810834">
<ul>
<li><p>将 DRAM 组织成二维阵列而不是线性数组的一个原因是降低芯片上地址引脚的数量。</p>
</li>
<li><p>二维阵列组织的缺点是必须分两步发送地址，这增加了访问时间。</p>
</li>
</ul>
<h4 id="内存模块"><a href="#内存模块" class="headerlink" title="内存模块"></a>内存模块</h4><p>DRAM 芯片封装在内存模块 (memory module) 中，它插到主板的扩展槽上 。</p>
<p>内存控制器将超单元地址 发送到内存模块，然后内存模块再广播到每个 DRAM 。作为响应，每个DRAM 输出它的超单元的8位内容。模块中的电路收集这些输出，并把它们合并成64 位字，再返回给内存控制器。</p>
<p>将多个内存模块连接到内存控制器，能够聚合成主存。<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/8fafd8ffe8841b166621e295ceb2e293.png" class="" title="image-20240201221228731"></p>
<p>这也是为什么16GB板载内存被分为8*2GB小内存的原因</p>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/0beb20407a2584c8a74538e5c63027d4.png" class="" title="image-20240201221933534">
<h4 id="增强的DRAM"><a href="#增强的DRAM" class="headerlink" title="增强的DRAM"></a>增强的DRAM</h4><ul>
<li>快页模式 DRAM(Fast Page Mode DRAM, FPM DRAM) </li>
</ul>
<p>若第四个超单元来自同一行，那么的第一个发送RAS/CAS请求，后面三个超单元发送CAS请求，直接从行缓冲区获得。</p>
<ul>
<li>扩展数据输出 DRAM(Extended Data Out DRAM, EDO DRAM)</li>
</ul>
<p>FPM DRAM一个增强的形式，它允许各个 CAS 信号在时间上靠得更紧密一点。</p>
<ul>
<li><p>同步 DRAM(Synchronous DRAM, SDRAM) 。</p>
<p>SDRAM 能够比那些异步的存储器更快地输出它的超单元的内容。</p>
</li>
<li><p>双倍数据速率同步 DRAM (Double Data-Rate Synchronous DRAM, DDR SDRAM)</p>
</li>
</ul>
<p>它通过使用两个时钟沿作为控制信号，从而使 DRAM 的速度翻倍,不同类型的 DDR SDRAM 是用提高有效带宽的很小的预取缓冲区的大小来划分的： DDR(2 位）、 DDR2(4 位）和 DDR(8 位）</p>
<ul>
<li>视频 RAM(Video RAM, VRAM) </li>
</ul>
<p>它用在图形系统的帧缓冲区中。</p>
<h4 id="非易失性存储器"><a href="#非易失性存储器" class="headerlink" title="非易失性存储器"></a>非易失性存储器</h4><p>非易失性存储器 (nonvolatile memory) 即使是在关电后，仍然保存着它们的信息 。</p>
<h4 id="访问主存"><a href="#访问主存" class="headerlink" title="访问主存"></a>访问主存</h4><p>数据流通过称为总线 (bus) 的共享电子电路在处理器和 DRAM 存之间来来回回。</p>
<p>其中一条总线是<code>系统总线 (system bus)</code>, 它连接 CPU和I/0 桥接器，另一条总线是内<code>存总线 (memory bus)</code>, 它连接 I/0 桥接器和主存，I/O桥接器将系统总线的电子信号翻译成内存总线的电子信号。</p>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/36744c3285317946143aaac3122a1535.png" class="" title="image-20240205205403294">
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/b67c6584c551bf475772a8ee8dca3a03.png" class="" title="image-20240205210231874">
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/270991b85f0abff5e836f2ac6b15cdc6.png" class="" title="image-20240205210125807">
<h3 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h3><h4 id="磁盘构造"><a href="#磁盘构造" class="headerlink" title="磁盘构造"></a>磁盘构造</h4><img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/b144646f425e3ec3b7963dd915243ad8.png" class="" title="image-20240205210332028">
<ul>
<li>磁盘是由<code>盘片 (platter)</code> 构成的。每个盘片(表面)有两面, 表面覆盖着磁性记录材料。</li>
<li>盘面中央有个可以旋转的<code>主轴 (spindle)</code>。</li>
<li>每个表面是由一组称为<code>磁道 (track)</code> 的同心圆组成的。</li>
<li>每个磁道被划分为一组<code>扇区 (sector)</code>。每个扇区包含相等数量的数据位（通常512 字节），这些数据编码在扇区上的磁性材料中。</li>
<li>扇区之间由一些间隙 (gap) 分隔开，这些间隙中不存储数据。间隙存储用来标识扇区的格式化位。</li>
<li>磁盘是 一个或多个叠放在一起 的盘片组成的，它们被封装在 一个密封的包装里，整个装置通常被称为<code>磁盘驱动器 (disk drive)</code>, 我们通常简称为<code>磁盘 (disk)</code>。</li>
<li><code>柱面(cylinder)</code>是所有盘片表面上到主轴中心的距离相等的磁道的集合。</li>
</ul>
<h4 id="磁盘容量"><a href="#磁盘容量" class="headerlink" title="磁盘容量"></a>磁盘容量</h4><ul>
<li><p>记录密度 (recording density) (位/英寸）：磁道一英寸的段中可以放入的位数。 </p>
</li>
<li><p>磁道密度 (track density)( 道/英寸）：从盘片中心出发半径上一英寸的段内可以放入的磁道数。</p>
</li>
<li>面密度 (areal density) (位/平方英寸）：记录密度与磁道密度的乘积。</li>
</ul>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/061f40697f4097e9431ac2c283ffa425.png" class="" title="image-20240205211057271">
<h4 id="磁盘操作"><a href="#磁盘操作" class="headerlink" title="磁盘操作"></a>磁盘操作</h4><img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/a473a7c294fa00c531470c10d9703aed.png" class="" title="image-20240205211939780">
<ul>
<li>通过沿着半径轴前后移动这个传动臂，驱动器可以将读/写头定位在盘面上的任何磁道上。这样的机械运动称为寻道 (seek) 。</li>
<li>在任何时刻，所有的读/写头都位于同一个柱面上。</li>
</ul>
<p>访问时间 (access time) 有三个主要的部分：</p>
<ol>
<li><code>寻道时间</code>：为了读取某个目标扇区的内容，传动臂首先将读/写头定位到包含目标扇区的磁道上。移动传动臂所需的时间称为寻道时间。寻道时间依赖于读/写头以前的位置和传动臂在盘面上移动的速度。</li>
<li><code>旋转时间</code>：一旦读/写头定位到了期望的磁道，驱动器等待目标扇区的第一个位旋转到读/写头下。这个步骤的性能依赖于当读/写头到达目标扇区时盘面的位置以及磁盘的旋转速度。在最坏的情况下，读/写头刚刚错过了目标扇区，必须等待磁盘转一整圈。</li>
<li><code>传送时间</code>：当目标扇区的第一个位位于读/写头下时，驱动器就可以开始读或者写该扇区的内容了。 一个扇区的传送时间依赖于旋转速度和每条磁道的扇区数目。</li>
</ol>
<h4 id="逻辑磁盘块"><a href="#逻辑磁盘块" class="headerlink" title="逻辑磁盘块"></a>逻辑磁盘块</h4><p>磁盘封装中有一个小的硬件/固件设备，称为磁盘控制器，维护着逻辑块号和实际（物理）磁盘扇区之间的映射关系。</p>
<h4 id="连接I-O设备"><a href="#连接I-O设备" class="headerlink" title="连接I/O设备"></a>连接I/O设备</h4><img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/3a08d1532e694965897c8ac137b41ffa.png" class="" title="image-20240205213744503">
<ul>
<li><p><code>通用串行总线 (Universal Serial Bus, USB) 控制器</code>是一个连接到 USB 总线的设备的中转机构， </p>
</li>
<li><p><code>图形卡（或适配器）</code>包含硬件和软件逻辑，它们负责代表 CPU 在显示器上画像素。</p>
</li>
<li><p><code>主机总线适配器</code>将一个或多个磁盘连接到总线，使用的是一个特别的主线总线接口定义的通信协议。</p>
<p>两个最常用的这样的磁盘接口是SATA和SCSI</p>
</li>
</ul>
<h4 id="访问磁盘"><a href="#访问磁盘" class="headerlink" title="访问磁盘"></a>访问磁盘</h4><p>CPU使用一种称为<code>内存映射</code> (memory-mapped I/0) 的技术来向 I/0 设备发射命令</p>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/1942aa3498f559d1446a39c95fe38450.png" class="" title="image-20240205215250941">
<ol>
<li>CPU 发出了请求之后，在磁盘执行读的时候，它通常会做些其他的工作。</li>
<li>在磁盘控制器收到来自 CPU 的读命令之后，它将逻辑块号翻译成一个扇区地址，读该扇区的内容，然后将这些内容直接传送到主存，不需要 CPU 的干涉。设备可以自己执行读或者写总线事务而不需要 CPU 干涉的过程，称为<code>直接内存访问 (Direct Memory Access, DMA)</code> 。这种数据传送称为<code>DMA 传送 (DMA transfer)</code>。</li>
<li>DMA 传送完成，磁盘扇区的内容被安全地存储在主存中以后，磁盘控制器通过给CPU 发送一个中断信号来通知 CPU。</li>
</ol>
<h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><ul>
<li><p>固态硬盘 (Solid State Disk , SSD) 种基于闪存的存储技术。</p>
</li>
<li><p>一个 SSD 封装由一个或多个<code>闪存芯片</code>和<code>闪存翻译层 (flash translation layer)</code>组成。</p>
</li>
</ul>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/af1fce144708cf73a426eb80efefc85c.png" class="" title="image-20240205220637797">
<ul>
<li><p><code>读 SSD 比写要快</code>。随机读和写的性能别是由底层闪存基本属性决定的。</p>
</li>
<li><p>一个闪存由B个块的序列组成，每个块由P页组成。</p>
</li>
<li><p>数据是以页为单位读写的。只有在一页所属的块整个被擦除之后，才能写这一页（通常是指该块中的所有位都被设置为 1) 。</p>
</li>
<li>随机写很慢有两个原因：（1）擦除块需要相对较长的时间。（2）如果试图修改一个巳经有数据（也就是不是全为 1) 的页p, 那么这个块中所有带有用数据的页都必须被复制到一个新（擦除过的）块，然后才能进行对页写。</li>
<li>闪存翻译层中的平均磨损 (wear leveling) 逻辑试图通过将擦除平均分布在所有的块上来最大化每个块的寿命。</li>
</ul>
<h4 id="存储技术趋势"><a href="#存储技术趋势" class="headerlink" title="存储技术趋势"></a>存储技术趋势</h4><img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/c4a26f4266a9d1bf33391405953bcb5c.png" class="" title="image-20240205222326800">
<ul>
<li><p>增加密度（从而降低成本）比降低访问时间容易得多。</p>
</li>
<li><p>DRAM 和磁盘的性能滞后于 CPU 的性能。</p>
</li>
</ul>
<h3 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h3><p>一个编写良好的计 程序常常具有良好的局部性 (locality) 。也就是，它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。</p>
<p>时间局部性 (temporal locality) 和空间局部性 (spatial locality): </p>
<ul>
<li><p>时间局部性：被引用过一次的内存位置很可能在不远的将来再被多次引用 </p>
</li>
<li><p>空间局部性：如果一个内存位被引用了一次，那么程序很可能在不远的将来引用附近的 一个内存位置。</p>
</li>
</ul>
<h4 id="对程序数据引用的局部性"><a href="#对程序数据引用的局部性" class="headerlink" title="对程序数据引用的局部性"></a>对程序数据引用的局部性</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumvec</span><span class="params">(<span class="type">int</span> v[N])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        sum += v[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>变量sum 在每次循环迭代中被引用一次，因此，对于 sum 来说，有好的时间局部性。另一方面，因为 sum是标量 ，对于 sum 来说，没有空间局部性。</li>
<li>对于变量v，函数有很好的空间局部性，但是时间局部性很差，因为每个向量元素只被访问一次。</li>
</ul>
<p>我们说像 <code>sumvec</code>这样顺序访问一个向最每个元素的函数，具有步长为1 的<code>引用模式(stride-I reference pattern) (相对于元素的大小）</code>。有时我们称步长为1的引用模式为<code>顺序引用模式 (sequential reference pattern)</code> 。一个连续向量中，每隔 k个元素进行访问，就称为步长为k的引用模式 (stride-k reference pattern) 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumarrayrows</span><span class="params">(<span class="type">int</span> a[M][N])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sumarraycols</code>按照数组被存储的行优先顺序来访问这个数组。其结果是得到一个很好的步长为1 的引用模式，具有良好的空间局部性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumarraycols</span><span class="params">(<span class="type">int</span> a[M][N])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sumarraycols</code>步长为 N的引用模式,空间局部性很差。</p>
<h4 id="取指令的局部性"><a href="#取指令的局部性" class="headerlink" title="取指令的局部性"></a>取指令的局部性</h4><p>for 循环体里的指令是按照连续的内存顺序执行的，因此循环有良好的空间局部性。因为循环体会被执行多次，所以它也有很好的时间局部性。</p>
<h4 id="局部性小结"><a href="#局部性小结" class="headerlink" title="局部性小结"></a>局部性小结</h4><ul>
<li>重复引用相同变量的程序有良好的时间局部性。</li>
<li>对于具有步长为k的引用模式的程序，步长越小，空间局部性越好。具有步长为l的引用模式的程序有很好的空间局部性。在内存中以大步长跳来跳去的程序空间局部性会很差。</li>
<li>对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。</li>
</ul>
<h3 id="存储器层次结构-1"><a href="#存储器层次结构-1" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h3><img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/c9905ba4b8fc1ce718dfa4cb52a0c4ad.png" class="" title="image-20240205222847968">
<h4 id="存储器层次结构中的缓存"><a href="#存储器层次结构中的缓存" class="headerlink" title="存储器层次结构中的缓存"></a>存储器层次结构中的缓存</h4><ul>
<li><p>高速缓存 (cache, 读作 “cash”) 是一个小而快速的存储设备，它作为存储在更大、也更慢的设备中的数据对象的缓冲区域。</p>
</li>
<li><p>层次结构中的每一层都缓存来自较低一层的数据对象。</p>
</li>
</ul>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/446fe3a0d2d5f9f2bc365088aaa43d92.png" class="" title="image-20240209213352133">
<ul>
<li><p>数据总是以块大小为<code>传送单元 (transfer unit)</code> 在第 k层和第 k+l 层之间来回复制的。</p>
</li>
<li><p>较低层的传送使用的块一般比较高层传送用的块更大。</p>
</li>
</ul>
<ul>
<li><p><code>缓存命中</code>：直接从第 k层读取对象d, 根据存储器层次结构的性质，这要比从第 k+l 层读取 更快。</p>
</li>
<li><p><code>缓存不命中</code>第k 层中没有缓存数据对象 d。第k 层的缓存从第k+1层缓存中取出包含d的那个块，如果第k层的缓存已经满了，可能就会覆盖现存的一个块（称为牺牲块）。</p>
</li>
<li><p>一个空的缓存有时被称为<code>冷缓存 (cold cache)</code> , 此类不命中称为强制性不命中 (compulsory miss) 或冷不命中 (cold miss) 。</p>
</li>
<li><p>冲突不命中 (conflict miss), ，多个对象映射到同 一个缓存块，缓存会一直不命中。</p>
</li>
</ul>
<ul>
<li>一个嵌套的循环可能会反复地访问同一个数组的元素。这个块的集合称为这个阶段的工作集 (working set) 。当工作集的大小超过缓存的小时，缓存会经历<code>容量不命中 (capacity miss)</code> 。</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/3820506130f7f6b443399f1c85ca071e.png" class="" title="image-20240209215623716">
<p>概括来说，基于缓存的存储器层次结构行之有效，是因为较慢的存储设备比较快的存储设备更便宜，还因为程序倾向于展示局部性：</p>
<ul>
<li>利用时间局部性：由于时间局部性，同一数据对象可能会被多次使用。 一旦一个数据对象在第一次不命中时被复制到缓存中，我们就会期望后面对该目标有一系列的访问命中。因为缓存比低一层的存储设备更快，对后面的命中的服务会比最开始的不命中快很多。</li>
<li>利用空间局部性：块通常包含有多个数据对象。由于空间局部性，我们会望后面对该块中其他对象的访问能够补偿不命中后复制该块的花费。</li>
</ul>
<h3 id="高速缓存存储器"><a href="#高速缓存存储器" class="headerlink" title="高速缓存存储器"></a>高速缓存存储器</h3><img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/7cb396c3f2fd6d7521dca02eb3acd02e.png" class="" title="image-20240209215810816">
<h4 id="通用的高速缓存存储器组织结构"><a href="#通用的高速缓存存储器组织结构" class="headerlink" title="通用的高速缓存存储器组织结构"></a>通用的高速缓存存储器组织结构</h4><h4 id="直接映射高速缓存"><a href="#直接映射高速缓存" class="headerlink" title="直接映射高速缓存"></a>直接映射高速缓存</h4><p>每个组只有一行的高速缓存称为直接映射高速缓存 (direct-mapped cache) 。</p>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/468d5d01995f4b54f83f5ced68b7564e.png" class="" title="image-20240209223156267">
<ol>
<li>直接映射高速缓存中的组选择</li>
</ol>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/ddb86d3690c884ffba102ad810fabed4.png" class="" title="image-20240209223459723">
<p>高速缓存从w的地址中间抽取出s个组索引位。这些位被解释成一个对应于一个组号的无符号整数。</p>
<ol>
<li>直接映射高速缓存中的行匹配</li>
</ol>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/8f9a902fb2c3b9d4091164776eee3222.png" class="" title="image-20240209223621395">
<p>当且仅当设置了<code>有效位</code>，而且高速缓存行中的标记与的地址中的标记相匹配时，这 行中包含的一个副本。则缓存命中。</p>
<ol>
<li>直接映射高速缓存中的字选择</li>
</ol>
<p>一旦命中，我们知道 就在这个块中的某个地方。块偏移位提供了所需要的字的第一个字节的偏移。</p>
<ol>
<li>直接映射高速缓存中不命中时的行替换</li>
</ol>
<p>如果缓存不命中，那么它需要从存储器层次结构中的下一层取出被请求的块 ，然 后将新的块存储在组索引位指示的组中的一个高速缓存行中。</p>
<ol>
<li>综合：运行中的直接映射高速缓存</li>
</ol>
<ul>
<li><p>标记位和索引位连起来唯 地标识了内存中的每个块。</p>
</li>
<li><p>多个块会映射到同一个高速缓存组（即它们有相同的组索引）。</p>
</li>
<li>映射到同一个高速缓存组的块由标记位唯一地标识。</li>
</ul>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/cbb2f81466379654b1514a5c9a9d8557.png" class="" title="image-20240209230912140">
<p>1) 读地址0的字，缓存不命中。高速缓存从内存（或低一层的高速缓存）取出块 0, 并把这个块存储在组0中。然后，高速缓存返回新取出的高速缓存行的块 [0J 的m[0]。</p>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/87187e59eeacd45e1f521abf210d7e2f.png" class="" title="image-20240209231206019">
<p>2) 读地址1的字,高速缓存命中。高速缓存立即从高速缓存行的块 [1] 中返m[1] 。</p>
<ol>
<li>读地址 13 的字。缓存不命中。高速缓存把块6加载到组2中，然后从新的高速缓存行的块[1] 中返回 m[13].</li>
</ol>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/1269b144cbe2373403334c381af09189.png" class="" title="image-20240209234532530">
<ol>
<li>读地址8的字。这会发生缓存不命中。组0中的高速缓存行确实是有效的，但是标记不匹配。</li>
</ol>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/0eb308fef12600daa531ab4f8899f41c.png" class="" title="image-20240209234603152">
<ol>
<li>读地址0的字。又会发生缓存不命中，因为在前面引用地址 时，我们刚好替换了，这就是<code>冲突不命中</code>的一个例子。</li>
</ol>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/9d3c56bfb14f6fa98be06d1d389611c4.png" class="" title="image-20240209234609789">
<ol>
<li>直接映射高速缓存中的冲突不命中</li>
</ol>
<ul>
<li>抖动:即高速缓存反复地加载和驱逐相同的高速缓存块的组.</li>
</ul>
<blockquote>
<p>为什么用中间的位来做索引你也许会奇怪，为什么高速缓存用中间的位来作为组索引，而不是用高位 为什么用中间的位更好，是有很好的原因的.如果高位用做索引，那么 一些连续的内存块就会映射到相同的高速缓存块 例如，在图中，头四个块映射到第一个高速缓存组，笫二个四个块映射到笫二个组，依此类推 如果一个程序有良好的空间局部性，顺序扫描一个数组的元素，那么在任何时刻，高速缓存都只保存着一个块大小的数组内容 这样对高速缓存的使用效率很低 .相比较而言，以中间位作为索引，相邻的块总是映射到不同的高速缓存行. 在这里的情况中，高速缓存能够存放整个大小为c的数组片，这里 c是高速缓存的大小。</p>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/ccd4fc29c72abc5ec7158f7039393f2e.png" class="" title="image-20240209235246828">
</blockquote>
<h4 id="组相联高速缓存"><a href="#组相联高速缓存" class="headerlink" title="组相联高速缓存"></a>组相联高速缓存</h4><p><code>直接映射高速缓存</code>中冲突不命中造成的问题源于每个组只有一行。<code>组相联高速缓存 (set associative cache)</code>放松了这条限制，所以每个组都保存有多于一个 高速缓存行。</p>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/520fef9962781b9fe334c124c248cdb9.png" class="" title="image-20240209235409701">
<ol>
<li>组相联高速缓存中的组选择</li>
</ol>
<p>它的组选择与直接映射高速缓存的组选择一样，组索引位标识组。</p>
<ol>
<li>组相联高速缓存中的行匹配和字选择</li>
</ol>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/7c76e8952a9727cf0d2c750a0f58daed.png" class="" title="image-20240209235459271">
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/fc9afd74ec08476bcc98b083c911be56.png" class="" title="image-20240210000246241">
<h4 id="全相联高速缓存"><a href="#全相联高速缓存" class="headerlink" title="全相联高速缓存"></a>全相联高速缓存</h4><img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/f31f40e2147b74f89fb21a5e7a9ae786.png" class="" title="image-20240210001632400">
<ol>
<li>全相联高速缓存中的组选择。全相联高速缓存中的组选择非常简单，因为只有一个组。</li>
</ol>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/03ac526d95741dae5b46c7fc553964a9.png" class="" title="image-20240210002847266">
<ol>
<li>全相联高速缓存中的行匹配。和字选择全相联高速缓存中的行匹配和字选择与组相联高速缓存中的是一样的。</li>
</ol>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/27b4a4d520073980b333100853cafed9.png" class="" title="image-20240210002858669">
<p>因为高速缓存电路必须<code>并行地</code>搜索许多相匹配的标记，构造一个又大又快的相联高速缓存很困难，而且很昂贵。因此，全相联高速缓存只适合做小的高速缓存，例如虚拟内存系统中的翻译备用缓冲器 (TLB),</p>
<h4 id="有关写的问题"><a href="#有关写的问题" class="headerlink" title="有关写的问题"></a>有关写的问题</h4><ul>
<li>直写(write-through)：就是立即将w 的高速缓存块写回到紧接着的低一层中。是直写的缺点是每次写都会引起<code>总线流量</code>。</li>
<li>写回 (write-back)：尽可能地推迟更新，只有当替换算法要驱逐这个更新过的块时，才把它写到紧接着的低一层中。但是它的缺点是增<br>加了复杂性。高速缓存必须为每个高速缓存行维护一个额外的修改位 (dirty bit)。</li>
<li>写分配 (write-allocate), 加载相应的低一层中的块到高速缓存中，然后更新这个高速缓存块。</li>
<li>非写分配 (not-write-allocate) , 避开高速缓存，直接把这个字写到低一层中。</li>
<li>直写高速缓存通常是非写分配的。写回高速缓存通常是写分配的。</li>
</ul>
<h4 id="一个真实的高速缓存层次结构的解剖"><a href="#一个真实的高速缓存层次结构的解剖" class="headerlink" title="一个真实的高速缓存层次结构的解剖"></a>一个真实的高速缓存层次结构的解剖</h4><img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/236982486ebccc1b057bf2ec1d09c8cc.png" class="" title="image-20240210004022700">
<h4 id="高速缓存参数的性能影响"><a href="#高速缓存参数的性能影响" class="headerlink" title="高速缓存参数的性能影响"></a>高速缓存参数的性能影响</h4><p>有许多指标来衡量高速缓存的性能：</p>
<ul>
<li>不命中率 (miss rate) 。在一个程序执行或程序的一部分执行期间，内存引用不命中的比率。</li>
<li>命中率 (hit rate) 。命中的内存引用比率。它等于 1-不命中率。</li>
<li>命中时间 (hit time) 。从高速缓存传送一个字到 CPU 所需的时间，包括组选择、行确认和字选择的时间。</li>
<li>不命中处罚 (miss penalty) 。由于不命中所需要的额外的时间。</li>
</ul>
<ol>
<li>高速缓存大小的影响</li>
</ol>
<p>较大的高速缓存可能会提高命中率，使大存储器运行得更快总是要难一些的 。结果，较大的高速缓存可能会增加命中时间。</p>
<ol>
<li>块大小的影响</li>
</ol>
<p>大的块有利有弊。一方面，较大的块能利用程序中可能存在的空间局部性，帮助提高命中率。不过，对于给定的高速缓存大小，块越大就意味着高速缓存行数越少，这会损害时间局部性比空间局部性更好的程序中的命中率。较大的块对不命中处罚也有负面影响，因为块越大，传送时间就越长。</p>
<ol>
<li>相联度的影响</li>
</ol>
<p>较高的相联度（也就E的值较大）的优点是降低了高速缓存由于冲突不命中出现抖动的可能性。不过，较高的相联度会造成较高的成本和不命中处罚。相联度的选择最终变成了命中时间和不命中处罚之间的折中 。</p>
<ol>
<li>写策略的影响</li>
</ol>
<p>直写高速缓存比较容易实现，而且能使用独立于高速缓存的写缓冲区 (write buffer) , 用来更新内存。越往层次结构下面走，传送时间增加，减少传送的数量就变得更加重要。一般而言，高速缓存越往下层，越可能使用写回而不是直写。</p>
<h3 id="编写高速缓存友好的代码"><a href="#编写高速缓存友好的代码" class="headerlink" title="编写高速缓存友好的代码"></a>编写高速缓存友好的代码</h3><p>基本方法：</p>
<ol>
<li>让最常见的情况运行得更快。</li>
<li>尽量减小每个循环内部的缓存不命中数量。</li>
</ol>
<ul>
<li><p>一般而言，如果一个高速缓存的块大小为B字节，那么个步长为k的引用模式（这里以字为单位的）平均每次循环迭代 min(l, (wordsize * k)/ B) 次缓存不命中 。</p>
</li>
<li><p>对局部变量的反复引用是好的，因为编译器能够将它们缓存在寄存器文 件中（时间局部性）。</p>
</li>
<li>步长为1的引用模式是好的，因为存储器层次结构中所有层次上的缓存都是将数据存储为连续的块（空间局部性）。</li>
</ul>
<h3 id="综合：高速缓存对程序性能的影响"><a href="#综合：高速缓存对程序性能的影响" class="headerlink" title="综合：高速缓存对程序性能的影响"></a>综合：高速缓存对程序性能的影响</h3><h4 id="存储器山"><a href="#存储器山" class="headerlink" title="存储器山"></a>存储器山</h4><p>利用chatgpt生成数据处理程序：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">% 存储器山时钟频率和内存速率数据</span></span><br><span class="line"></span><br><span class="line">memory_data = [</span><br><span class="line">    <span class="number">19730</span>   <span class="number">10983</span>   <span class="number">7935</span>    <span class="number">6654</span>    <span class="number">5372</span>    <span class="number">4941</span>    <span class="number">4294</span>    <span class="number">3578</span>    <span class="number">3462</span>    <span class="number">3261</span>    <span class="number">3163</span>    <span class="number">3028</span>    <span class="number">2802</span>    <span class="number">2735</span>    <span class="number">2658</span>;</span><br><span class="line">    <span class="number">21719</span>   <span class="number">10571</span>   <span class="number">8817</span>    <span class="number">6407</span>    <span class="number">5938</span>    <span class="number">4806</span>    <span class="number">4457</span>    <span class="number">3937</span>    <span class="number">3711</span>    <span class="number">3450</span>    <span class="number">3357</span>    <span class="number">3169</span>    <span class="number">3037</span>    <span class="number">2969</span>    <span class="number">2840</span>;</span><br><span class="line">    <span class="number">22330</span>   <span class="number">13040</span>   <span class="number">9658</span>    <span class="number">7674</span>    <span class="number">6594</span>    <span class="number">5863</span>    <span class="number">5089</span>    <span class="number">4385</span>    <span class="number">4334</span>    <span class="number">4150</span>    <span class="number">3970</span>    <span class="number">3851</span>    <span class="number">3492</span>    <span class="number">3586</span>    <span class="number">3503</span>;</span><br><span class="line">    <span class="number">26509</span>   <span class="number">14470</span>   <span class="number">12846</span>   <span class="number">11190</span>   <span class="number">9870</span>    <span class="number">8719</span>    <span class="number">8048</span>    <span class="number">7460</span>    <span class="number">7315</span>    <span class="number">6607</span>    <span class="number">6321</span>    <span class="number">6682</span>    <span class="number">5972</span>    <span class="number">6231</span>    <span class="number">5980</span>;</span><br><span class="line">    <span class="number">46887</span>   <span class="number">31859</span>   <span class="number">24558</span>   <span class="number">19533</span>   <span class="number">16235</span>   <span class="number">14037</span>   <span class="number">10792</span>   <span class="number">9643</span>    <span class="number">8886</span>    <span class="number">8096</span>    <span class="number">7412</span>    <span class="number">7201</span>    <span class="number">6673</span>    <span class="number">6371</span>    <span class="number">6010</span>;</span><br><span class="line">    <span class="number">41056</span>   <span class="number">30640</span>   <span class="number">24099</span>   <span class="number">18308</span>   <span class="number">14804</span>   <span class="number">12374</span>   <span class="number">10634</span>   <span class="number">9290</span>    <span class="number">8610</span>    <span class="number">7927</span>    <span class="number">7179</span>    <span class="number">6956</span>    <span class="number">6426</span>    <span class="number">6104</span>    <span class="number">5684</span>;</span><br><span class="line">    <span class="number">41233</span>   <span class="number">32133</span>   <span class="number">26039</span>   <span class="number">20696</span>   <span class="number">16938</span>   <span class="number">14191</span>   <span class="number">12289</span>   <span class="number">10591</span>   <span class="number">9951</span>    <span class="number">9303</span>    <span class="number">8646</span>    <span class="number">8894</span>    <span class="number">9162</span>    <span class="number">11831</span>   <span class="number">8452</span>;</span><br><span class="line">    <span class="number">40066</span>   <span class="number">38844</span>   <span class="number">36982</span>   <span class="number">33604</span>   <span class="number">30782</span>   <span class="number">26891</span>   <span class="number">23560</span>   <span class="number">20803</span>   <span class="number">21350</span>   <span class="number">24882</span>   <span class="number">25374</span>   <span class="number">26375</span>   <span class="number">27904</span>   <span class="number">27803</span>   <span class="number">28154</span>;</span><br><span class="line">    <span class="number">40280</span>   <span class="number">40730</span>   <span class="number">41249</span>   <span class="number">40166</span>   <span class="number">39069</span>   <span class="number">36080</span>   <span class="number">31765</span>   <span class="number">28163</span>   <span class="number">27859</span>   <span class="number">27057</span>   <span class="number">26582</span>   <span class="number">27722</span>   <span class="number">27764</span>   <span class="number">27846</span>   <span class="number">27826</span>;</span><br><span class="line">    <span class="number">40542</span>   <span class="number">40647</span>   <span class="number">40895</span>   <span class="number">40526</span>   <span class="number">39342</span>   <span class="number">35989</span>   <span class="number">31904</span>   <span class="number">28085</span>   <span class="number">27587</span>   <span class="number">27026</span>   <span class="number">26644</span>   <span class="number">27756</span>   <span class="number">27727</span>   <span class="number">27892</span>   <span class="number">27537</span>;</span><br><span class="line">    <span class="number">40281</span>   <span class="number">40875</span>   <span class="number">40944</span>   <span class="number">40158</span>   <span class="number">38901</span>   <span class="number">35481</span>   <span class="number">31738</span>   <span class="number">27741</span>   <span class="number">27353</span>   <span class="number">26387</span>   <span class="number">25701</span>   <span class="number">27005</span>   <span class="number">27412</span>   <span class="number">27088</span>   <span class="number">26542</span>;</span><br><span class="line">    <span class="number">40009</span>   <span class="number">41533</span>   <span class="number">40809</span>   <span class="number">39201</span>   <span class="number">38497</span>   <span class="number">34454</span>   <span class="number">30365</span>   <span class="number">27021</span>   <span class="number">26643</span>   <span class="number">32405</span>   <span class="number">40993</span>   <span class="number">41530</span>   <span class="number">43676</span>   <span class="number">41363</span>   <span class="number">43004</span>;</span><br><span class="line">    <span class="number">46307</span>   <span class="number">46497</span>   <span class="number">44877</span>   <span class="number">42117</span>   <span class="number">44895</span>   <span class="number">41941</span>   <span class="number">41600</span>   <span class="number">39566</span>   <span class="number">40435</span>   <span class="number">40435</span>   <span class="number">38435</span>   <span class="number">37740</span>   <span class="number">38235</span>   <span class="number">39556</span>   <span class="number">37740</span>;</span><br><span class="line">    <span class="number">46370</span>   <span class="number">44624</span>   <span class="number">42149</span>   <span class="number">42326</span>   <span class="number">39191</span>   <span class="number">35529</span>   <span class="number">38510</span>   <span class="number">36194</span>   <span class="number">35829</span>   <span class="number">33741</span>   <span class="number">34563</span>   <span class="number">31923</span>   <span class="number">30618</span>   <span class="number">31104</span>   <span class="number">29031</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">% 内存大小标签</span></span><br><span class="line">memory_sizes = &#123;<span class="string">&#x27;128m&#x27;</span>, <span class="string">&#x27;64m&#x27;</span>, <span class="string">&#x27;32m&#x27;</span>, <span class="string">&#x27;16m&#x27;</span>, <span class="string">&#x27;8m&#x27;</span>, <span class="string">&#x27;4m&#x27;</span>, <span class="string">&#x27;2m&#x27;</span>, <span class="string">&#x27;1024k&#x27;</span>, <span class="string">&#x27;512k&#x27;</span>, <span class="string">&#x27;256k&#x27;</span>, <span class="string">&#x27;128k&#x27;</span>, <span class="string">&#x27;64k&#x27;</span>, <span class="string">&#x27;32k&#x27;</span>, <span class="string">&#x27;16k&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建 X 轴和 Y 轴</span></span><br><span class="line">x = <span class="number">1</span>:<span class="built_in">size</span>(memory_data, <span class="number">2</span>); <span class="comment">% 存储器编号</span></span><br><span class="line">y = <span class="number">1</span>:<span class="built_in">size</span>(memory_data, <span class="number">1</span>); <span class="comment">% 内存大小</span></span><br><span class="line"><span class="comment">%x 的取值范围是从 1 到 memory_data 的列数</span></span><br><span class="line"><span class="comment">%y 的取值范围是从 1 到 memory_data 的行数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建 X 轴和 Y 轴的网格</span></span><br><span class="line">[X, Y] = <span class="built_in">meshgrid</span>(x, y);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建存储器山图</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">surf(X, Y, memory_data);</span><br><span class="line"><span class="comment">% surf(X,Y,Z) 创建一个三维曲面图，它是一个具有实色边和实色面的三维曲面。</span></span><br><span class="line">xlabel(<span class="string">&#x27;Storage Number&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Memory Size&#x27;</span>);</span><br><span class="line">zlabel(<span class="string">&#x27;Memory Rate (MB/sec)&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Memory Mountain&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 设置 X 轴和 Y 轴的刻度及标签</span></span><br><span class="line">xticks(x);</span><br><span class="line">yticks(y);</span><br><span class="line">yticklabels(memory_sizes);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/21a3fe8c7c848c2ee506d1c5e3624d9d.png" class="" title="image-20240226161751942">
<ul>
<li><p>对于步长为1的引用模式，由于硬件预取机制，被识别并试图在一个块被加载前取到高速缓存中。</p>
</li>
<li><p>在L2，L3，和主存山脊上，随着步长的增加，有一个空间局部性的斜坡，空间局部性下降。</p>
</li>
<li><p>即使是当程序的时间局部性很差时，空间局部性仍然能补救，并且是非常重要的。</p>
</li>
</ul>
<h4 id="重新排列循环以提高空间局部性"><a href="#重新排列循环以提高空间局部性" class="headerlink" title="重新排列循环以提高空间局部性"></a>重新排列循环以提高空间局部性</h4><p>计算n<em>n矩阵相乘问题，时间复杂度O（n*</em>3）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ijk</span><span class="params">(<span class="built_in">array</span> A, <span class="built_in">array</span> B, <span class="built_in">array</span> C, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">double</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin mm-ijk */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            sum += A[i][k]*B[k][j];</span><br><span class="line">        C[i][j] += sum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* $end mm-ijk */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">jik</span><span class="params">(<span class="built_in">array</span> A, <span class="built_in">array</span> B, <span class="built_in">array</span> C, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">double</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin mm-jik */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            sum += A[i][k]*B[k][j];</span><br><span class="line">        C[i][j] += sum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* $end mm-jik */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikj</span><span class="params">(<span class="built_in">array</span> A, <span class="built_in">array</span> B, <span class="built_in">array</span> C, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* $begin mm-ikj */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        r = A[i][k];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            C[i][j] += r*B[k][j];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* $end mm-ikj */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kij</span><span class="params">(<span class="built_in">array</span> A, <span class="built_in">array</span> B, <span class="built_in">array</span> C, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* $begin mm-kij */</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        r = A[i][k];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            C[i][j] += r*B[k][j];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* $end mm-kij */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kji</span><span class="params">(<span class="built_in">array</span> A, <span class="built_in">array</span> B, <span class="built_in">array</span> C, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin mm-kji */</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        r = B[k][j];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            C[i][j] += A[i][k]*r;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* $end mm-kji */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">jki</span><span class="params">(<span class="built_in">array</span> A, <span class="built_in">array</span> B, <span class="built_in">array</span> C, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin mm-jki */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        r = B[k][j];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            C[i][j] += A[i][k]*r;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* $end mm-jki */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/320a9aa1978e98750c0e1a6c9f61f8df.png" class="" title="image-20240226163041901">
<h4 id="在程序中利用局部性"><a href="#在程序中利用局部性" class="headerlink" title="在程序中利用局部性"></a>在程序中利用局部性</h4><ul>
<li><p>将你的注意力集中在内循环上，大部分计算和内存访问都发生在这里。</p>
</li>
<li><p>通过按照数据对象存储在内存中的顺序、以步长为 1的来读数据，从而使得你程序中的空间局部性最大。</p>
</li>
<li><p>一旦从存储器中读入了一个数据对象，就尽可能多地使用它，从而使得程序中的时间局部性最大</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://randolfluo.github.io">Randolf luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://randolfluo.github.io/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/">http://randolfluo.github.io/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://randolfluo.github.io" target="_blank">Randolfluo's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/csapp/">csapp</a><a class="post-meta__tags" href="/tags/book/">book</a></div><div class="post-share"><div class="social-share" data-image="https://img.paulzzh.com/touhou/random" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/01/30/csapp/%E7%AC%AC7%E7%AB%A0%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/" title="csapp第七章——链接"><img class="cover" src="http://api.yujn.cn/api/ACG.php" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">csapp第七章——链接</div></div><div class="info-2"><div class="info-item-1">链接链接 (linking) 是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行 。  链接可以执行于编译时 (compile time), 也就是在源代码被翻译成机器代码时；  也可以执行与加载时 (load time), 也就是在程序被加载器 (loader) 加载到内存并执行时；  甚至执行于运行时 (run time), 也就是由应用程序来执行。   编译器驱动程序12345678910111213141516171819202122232425/* main.c *//* $begin main */int sum(int *a, int n);int array[2] = &#123;1, 2&#125;;int main()&#123;    int val = sum(array, 2);    return val;&#125;/* $end main *//* sum.c *//* $begin sum */int sum(int *a, int n)&#123;    int i, s = 0;    for (i...</div></div></div></a><a class="pagination-related" href="/2024/02/05/51%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA0x1/" title="51单片机学习0x1"><img class="cover" src="http://api.yujn.cn/api/ACG.php" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">51单片机学习0x1</div></div><div class="info-2"><div class="info-item-1">江科大51单片机学习笔记 单片机​    单片机不是完成某一个逻辑功能的芯片，而是把一个计算机系统集成到一个芯片上。相当于一个微型的计算机。  命名规则：  51单片机　51单片机是对所有兼容Intel8031指令系统的单片机的统称，这一系列的单片机的始祖是Intel的8031单片机，后来随着flash...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/02/26/csapp/%E7%AC%AC10%E7%AB%A0%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/" title="csapp第十章——系统级IO"><img class="cover" src="http://api.yujn.cn/api/ACG.php" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-26</div><div class="info-item-2">csapp第十章——系统级IO</div></div><div class="info-2"><div class="info-item-1">系统级I/O输入与输出 (I/O) 是在主存和外部设备（例如磁盘驱动器、终端和网络）之间复制数据的过程。 UNIX I/O 所有的设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。   打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。 Linux shell 创建的每个进程开始时都有三个打开的文件：  12345/*								 /usr/include/unisted.h 						 */#define STDIN_FILENO    0       /* Standard input.  */#define STDOUT_FILENO   1       /* Standard output.  */#define STDERR_FILENO   2       /* Standard error output. ...</div></div></div></a><a class="pagination-related" href="/2024/01/30/csapp/%E7%AC%AC7%E7%AB%A0%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/" title="csapp第七章——链接"><img class="cover" src="http://api.yujn.cn/api/ACG.php" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-30</div><div class="info-item-2">csapp第七章——链接</div></div><div class="info-2"><div class="info-item-1">链接链接 (linking) 是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行 。  链接可以执行于编译时 (compile time), 也就是在源代码被翻译成机器代码时；  也可以执行与加载时 (load time), 也就是在程序被加载器 (loader) 加载到内存并执行时；  甚至执行于运行时 (run time), 也就是由应用程序来执行。   编译器驱动程序12345678910111213141516171819202122232425/* main.c *//* $begin main */int sum(int *a, int n);int array[2] = &#123;1, 2&#125;;int main()&#123;    int val = sum(array, 2);    return val;&#125;/* $end main *//* sum.c *//* $begin sum */int sum(int *a, int n)&#123;    int i, s = 0;    for (i...</div></div></div></a><a class="pagination-related" href="/2024/01/28/csapp/%E7%AC%AC5%E7%AB%A0%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/" title="csapp第五章——优化程序性能"><img class="cover" src="https://www.dmoe.cc/random.php" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-28</div><div class="info-item-2">csapp第五章——优化程序性能</div></div><div class="info-2"><div class="info-item-1">优化程序性能 第一，我们必须选择一组适当的算法和数据结构。 第二，我们必须编写出编译器能够有效优化以转换成高效可执行代码的源代码。   为什么我们需要优化程序，现代编译器不是具有很强的优化能力吗？ ans:因为编译器只进行安全的优化，消除可能出现的异常的运行时行为。意味着我们需要写出适合编译器优化的代码，优化程序性能。  内存别名使用 两个指针可能指向同一个内存位置的情况称为内存别名使用 (memory aliasing)  12345678910void twiddlel(long *Xp, long *yp) &#123; *XP += *yp; *XP += *yp; &#125; void twiddle2(long *XP, long *yp) &#123; *XP += 2* *yp; &#125;  乍一看两个函数好像没有区别，但是当*XP与*YP指向同一内存时。twiddle1变为原来的四倍，twiddle2变为原来的三倍。改变了程序的行为。 ...</div></div></div></a><a class="pagination-related" href="/2024/02/13/csapp/%E7%AC%AC8%E7%AB%A0%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" title="csapp第八章——异常控制流"><img class="cover" src="https://img.paulzzh.com/touhou/random" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-13</div><div class="info-item-2">csapp第八章——异常控制流</div></div><div class="info-2"><div class="info-item-1">[TOC] 异常控制流现代系统通过使控制流发生突变来对系统状态的变化做出反应 。一般而言 ，我们把这些突变称为异常控制流 (Exceptional Control Flow, ECF) 。 异常异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。  异常 (exception) 就是控制流中的突变，用来响应处理器状态中的某些变化。 当处理器检测到有事件发生时，它就会通过一张叫做异常表 (exception table)的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序 (exception handler)) 。 异常处理 异常处理程序运行在内核模式下，这意味它们对所有的系统资源都有完全的访问权限。 异常的类别  同步异步表示的结果的获取方式是主动获取还是被动接收；阻塞非阻塞表示的是获取这个动作是否可以立即返回不用等待。  中断中断是异步发生的， 是来自处理器外部的 I/0 设备的信号的结果。例如定时器计时结束后会向处理器发送一个中断。  陷阱和系统调用陷阱是有意的异常，是执行一条指令的结果...</div></div></div></a><a class="pagination-related" href="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" title="csapp第九章——虚拟内存"><img class="cover" src="http://api.yujn.cn/api/ACG.php" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-18</div><div class="info-item-2">csapp第九章——虚拟内存</div></div><div class="info-2"><div class="info-item-1">虚拟内存虚拟内存提供了三个重要的能力：   它将主存看成是 个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存  它为每个进程提供了一致的地址空间，从而简化了内存管理。  它保护了每个进程的地址空间不被其他进程破坏  物理和虚拟内存将虚拟地址转换为物理地址的任务叫做地址翻译 (address translation)。 地址翻译需要 CPU 硬件和操作系统之间的紧密合作 CPU 芯片上叫做内存管理单元(Memory Management Unit, MMU) 的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。  地址空间地址空间 (address space) 个非负整数地址的有序集合： 一个地址空间的大小是由表示最大地址所需要的位数来描述的。  虚拟地址空间： 一个包含 N=2**n个地址的虚拟地址空间就叫做一个n位地址空间，现代系统通常支持 32 位或者 64 位虚拟地址空间。  物理地址空间：对应于系统中物理内存的M个字节。   虚拟内存作为缓存的工具VM...</div></div></div></a><a class="pagination-related" href="/2023/12/03/csapp/bomblab/" title="bomblab"><img class="cover" src="http://api.yujn.cn/api/ACG.php" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-03</div><div class="info-item-2">bomblab</div></div><div class="info-2"><div class="info-item-1">bomblab开始愉快的拆除炸弹吧，（bushi） 通过这次实验可以基本掌握gdb的使用，这次使用了pwndgb插件 可以使用objdump查看反汇编程序，也可以在gdb里使用disassemble反汇编 超详细的wpCSAPP | Lab2-Bomb Lab 深入解析 - 知乎 (zhihu.com)  pwndgb的基本指令    指令 效果     s 单步步入   n 单步步过   r 重新运行   c 继续运行   i b, i r 查看断点、寄存器   return 退出当前函数   search 114514 查找114514   b *0x114514  ， b fun_name 在0x114514处下断点、在函数fun_name处下断点   delete ，delete 114514 删除所有断点，删除114514号断点   disassemble main 反汇编main函数   vmmap 显示进程的内存映射   cyclic 50 生成50个用来溢出的字符   cyclic -l   字符串 定位字符串再溢出字符的位置   p...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avater.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Randolf luo</div><div class="author-info-description">今日事，今日毕</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Randolfluo" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:lrj3216610@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">存储器层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.0.1.</span> <span class="toc-text">随机访问存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81RAM"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">静态RAM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81RAM"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">动态RAM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84DRAM"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">传统的DRAM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9D%97"><span class="toc-number">1.0.1.4.</span> <span class="toc-text">内存模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA%E7%9A%84DRAM"><span class="toc-number">1.0.1.5.</span> <span class="toc-text">增强的DRAM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.0.1.6.</span> <span class="toc-text">非易失性存储器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%B8%BB%E5%AD%98"><span class="toc-number">1.0.1.7.</span> <span class="toc-text">访问主存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8"><span class="toc-number">1.0.2.</span> <span class="toc-text">磁盘存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E6%9E%84%E9%80%A0"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">磁盘构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%AE%B9%E9%87%8F"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">磁盘容量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E6%93%8D%E4%BD%9C"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">磁盘操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%A3%81%E7%9B%98%E5%9D%97"><span class="toc-number">1.0.2.4.</span> <span class="toc-text">逻辑磁盘块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5I-O%E8%AE%BE%E5%A4%87"><span class="toc-number">1.0.2.5.</span> <span class="toc-text">连接I&#x2F;O设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E7%A3%81%E7%9B%98"><span class="toc-number">1.0.2.6.</span> <span class="toc-text">访问磁盘</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98"><span class="toc-number">1.0.3.</span> <span class="toc-text">固态硬盘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E8%B6%8B%E5%8A%BF"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">存储技术趋势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7"><span class="toc-number">1.0.4.</span> <span class="toc-text">局部性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%A8%8B%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BC%95%E7%94%A8%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">对程序数据引用的局部性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E6%8C%87%E4%BB%A4%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7"><span class="toc-number">1.0.4.2.</span> <span class="toc-text">取指令的局部性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%B0%8F%E7%BB%93"><span class="toc-number">1.0.4.3.</span> <span class="toc-text">局部性小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84-1"><span class="toc-number">1.0.5.</span> <span class="toc-text">存储器层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E7%BC%93%E5%AD%98"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">存储器层次结构中的缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.0.6.</span> <span class="toc-text">高速缓存存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E7%9A%84%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">通用的高速缓存存储器组织结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">1.0.6.2.</span> <span class="toc-text">直接映射高速缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E7%9B%B8%E8%81%94%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">1.0.6.3.</span> <span class="toc-text">组相联高速缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E7%9B%B8%E8%81%94%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">1.0.6.4.</span> <span class="toc-text">全相联高速缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%85%B3%E5%86%99%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.6.5.</span> <span class="toc-text">有关写的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%9C%9F%E5%AE%9E%E7%9A%84%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E7%9A%84%E8%A7%A3%E5%89%96"><span class="toc-number">1.0.6.6.</span> <span class="toc-text">一个真实的高速缓存层次结构的解剖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%8F%82%E6%95%B0%E7%9A%84%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D"><span class="toc-number">1.0.6.7.</span> <span class="toc-text">高速缓存参数的性能影响</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%8F%8B%E5%A5%BD%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">1.0.7.</span> <span class="toc-text">编写高速缓存友好的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%EF%BC%9A%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%AF%B9%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.0.8.</span> <span class="toc-text">综合：高速缓存对程序性能的影响</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%B1"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">存储器山</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%BE%AA%E7%8E%AF%E4%BB%A5%E6%8F%90%E9%AB%98%E7%A9%BA%E9%97%B4%E5%B1%80%E9%83%A8%E6%80%A7"><span class="toc-number">1.0.8.2.</span> <span class="toc-text">重新排列循环以提高空间局部性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%88%A9%E7%94%A8%E5%B1%80%E9%83%A8%E6%80%A7"><span class="toc-number">1.0.8.3.</span> <span class="toc-text">在程序中利用局部性</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/18/%E9%A2%98%E8%A7%A3/The%2018th%20Zhejiang%20Provincial%20Collegiate%20Programming%20Contest/" title="The 18th Zhejiang Provincial Collegiate Programming Contest"><img src="http://api.yujn.cn/api/ACG.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="The 18th Zhejiang Provincial Collegiate Programming Contest"/></a><div class="content"><a class="title" href="/2025/04/18/%E9%A2%98%E8%A7%A3/The%2018th%20Zhejiang%20Provincial%20Collegiate%20Programming%20Contest/" title="The 18th Zhejiang Provincial Collegiate Programming Contest">The 18th Zhejiang Provincial Collegiate Programming Contest</a><time datetime="2025-04-17T16:00:00.000Z" title="发表于 2025-04-18 00:00:00">2025-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/14/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC7%E7%AB%A0-%E6%9F%A5%E6%89%BE/" title="无标题"><img src="http://api.yujn.cn/api/ACG.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2025/04/14/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC7%E7%AB%A0-%E6%9F%A5%E6%89%BE/" title="无标题">无标题</a><time datetime="2025-04-14T02:09:58.968Z" title="发表于 2025-04-14 10:09:58">2025-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/14/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC5%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构-第5章—树与二叉树"><img src="https://img.paulzzh.com/touhou/random" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构-第5章—树与二叉树"/></a><div class="content"><a class="title" href="/2025/04/14/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC5%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构-第5章—树与二叉树">数据结构-第5章—树与二叉树</a><time datetime="2025-04-13T16:00:00.000Z" title="发表于 2025-04-14 00:00:00">2025-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/13/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" title="线段树与树状数组"><img src="https://api.paugram.com/wallpaper/" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线段树与树状数组"/></a><div class="content"><a class="title" href="/2025/04/13/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" title="线段树与树状数组">线段树与树状数组</a><time datetime="2025-04-13T09:42:00.000Z" title="发表于 2025-04-13 17:42:00">2025-04-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/13/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC6%E7%AB%A0-%E5%9B%BE/" title="数据结构-第6章—图"><img src="https://img.paulzzh.com/touhou/random" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构-第6章—图"/></a><div class="content"><a class="title" href="/2025/04/13/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC6%E7%AB%A0-%E5%9B%BE/" title="数据结构-第6章—图">数据结构-第6章—图</a><time datetime="2025-04-12T16:00:00.000Z" title="发表于 2025-04-13 00:00:00">2025-04-13</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://img.paulzzh.com/touhou/random);"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By Randolf luo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>