<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>csapp第七章——链接 | Randolfluo's blog</title><meta name="author" content="Randolf luo"><meta name="copyright" content="Randolf luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="csapp">
<meta property="og:type" content="article">
<meta property="og:title" content="csapp第七章——链接">
<meta property="og:url" content="http://randolfluo.github.io/2024/01/30/csapp/%E7%AC%AC7%E7%AB%A0%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/index.html">
<meta property="og:site_name" content="Randolfluo&#39;s blog">
<meta property="og:description" content="csapp">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://randolfluo.github.io/img/cover1.jpg">
<meta property="article:published_time" content="2024-01-30T14:42:00.000Z">
<meta property="article:modified_time" content="2024-07-11T16:00:00.000Z">
<meta property="article:author" content="Randolf luo">
<meta property="article:tag" content="csapp">
<meta property="article:tag" content="book">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://randolfluo.github.io/img/cover1.jpg"><link rel="shortcut icon" href="/img/avater.jpg"><link rel="canonical" href="http://randolfluo.github.io/2024/01/30/csapp/%E7%AC%AC7%E7%AB%A0%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Randolf luo","link":"链接: ","source":"来源: Randolfluo's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'csapp第七章——链接',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avater.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">111</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">34</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover1.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Randolfluo's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">csapp第七章——链接</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">csapp第七章——链接</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-30T14:42:00.000Z" title="发表于 2024-01-30 22:42:00">2024-01-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-11T16:00:00.000Z" title="更新于 2024-07-12 00:00:00">2024-07-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/csapp/">csapp</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/csapp/book/">book</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>链接 (linking) 是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行 。<br/></p>
<ul>
<li><p>链接可以执行于编译时 (compile time), 也就是在源代码被翻译成机器代码时；</p>
</li>
<li><p>也可以执行与加载时 (load time), 也就是在程序被加载器 (loader) 加载到内存并执行时；</p>
</li>
<li><p>甚至执行于运行时 (run time), 也就是由应用程序来执行。</p>
</li>
</ul>
<h3 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="comment">/* $begin main */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val = sum(<span class="built_in">array</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end main */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* sum.c */</span></span><br><span class="line"><span class="comment">/* $begin sum */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        s += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end sum */</span></span><br></pre></td></tr></table></figure>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240131173001880.png" alt="image-20240131173001880"></p>
<ol>
<li><code>c预处理器(cpp)</code>将 的源程序 main.c译成一个 ASCII 码的中间文件 main.i</li>
<li><code>编译器 (cc1)</code>, 它将 main.i 翻译成一个 <code>ASCII 汇编语言文件</code>main.s</li>
<li><code>汇编器 (as)</code>, 它将 main.s 翻译成一个<code>可重定位目标文件</code>(relo-eatable object file) main. o:</li>
<li>运行<code>链接器程序 ld</code>, 将main.o,sum.o 以及一些必要的系统目标文件组合起来，创建一个可执行目标文件 (executable object file)prog</li>
<li>shell 调用操作系统中一个叫做<code>加载器 (loader)</code>的函数，它将 可执行文件 prog 中的代码和数据复制到内存，然后将控制转移到这个程序的开头。</li>
</ol>
<h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>为了构造可执行文件，链接器必须完成两个主要任务：</p>
<ul>
<li><code>符号解析 (symbol resolution)</code> 。目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量（即 中任何以 static 属性 声明的变量）。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。</li>
<li><code>重定位 (relocation)</code> 。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置 链接器使用汇编器产生的重定位条目(relocation entry) 的详细指令，不加甄别地执行这样的重定位。</li>
</ul>
<h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h3><ul>
<li><code>可重定位目标文件</code>。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件</li>
<li><code>可执行目标文件</code>。包含二进制代码和数据，其形式可以被直接复制到内存并执行</li>
<li><code>共享目标文件</code>。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。</li>
<li>编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>系统</th>
<th>格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一个Unix系统</td>
<td>a.out</td>
</tr>
<tr>
<td>Windows</td>
<td>可移植可执行格式(Portable Executable，PE)</td>
</tr>
<tr>
<td>MacOS-X</td>
<td>Mach-O</td>
</tr>
<tr>
<td>x86-64 Linux Unix</td>
<td>可执行可链接格式(Executable and Linkable Format, ELF)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h3><div class="table-container">
<table>
<thead>
<tr>
<th>节</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>.text</td>
<td>已编译程序的机器代码。</td>
</tr>
<tr>
<td>.rodata</td>
<td>只读数据段</td>
</tr>
<tr>
<td>.data</td>
<td>已初始化的全局和静态变量。</td>
</tr>
<tr>
<td>.bss</td>
<td>未初始化全局变量和静态变量</td>
</tr>
<tr>
<td>.symtab</td>
<td>符号表，它存放在程序中定义和引用的函数和全局变量的信息</td>
</tr>
<tr>
<td>.debug</td>
<td>一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 源文件。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">全局符号</td>
<td>模块定义并能被其他模块引用的全局符号</td>
<td>非静态的C函数和全局变量</td>
</tr>
<tr>
<td style="text-align:center">外部符号</td>
<td>其他模块定义并被模块引用的全局符号</td>
<td>其他模块定义的非静态的C函数和全局变量</td>
</tr>
<tr>
<td style="text-align:center">局部符号</td>
<td>只被模块定义和引用的局部符号</td>
<td>带 static 属性的C函数和全局变量。</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>局部C变量运行时存储在栈中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* $begin elfsymbol */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   name;      <span class="comment">/* String table offset */</span></span><br><span class="line">    <span class="type">char</span>  type:<span class="number">4</span>,    <span class="comment">/* Function or data (4 bits) */</span></span><br><span class="line">          binding:<span class="number">4</span>; <span class="comment">/* Local or global (4 bits) */</span></span><br><span class="line">    <span class="type">char</span>  reserved;  <span class="comment">/* Unused */</span></span><br><span class="line">    <span class="type">short</span> section;   <span class="comment">/* Section header index */</span></span><br><span class="line">    <span class="type">long</span>  value;     <span class="comment">/* Section offset or absolute address */</span></span><br><span class="line">    <span class="type">long</span>  size;      <span class="comment">/* Object size in bytes */</span></span><br><span class="line">&#125; Elf64_Symbol;</span><br><span class="line"><span class="comment">/* $end elfsymbol */</span></span><br></pre></td></tr></table></figure>
<p>通过<code>readelf -s</code> 可以查看目标文件符号表</p>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201100904804.png" alt="image-20240201100904804"></p>
<h3 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h3><ul>
<li>链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。</li>
<li>当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个<code>链接器符号表条目</code>，并把它交给链接器处理。</li>
</ul>
<h4 id="链接器如何解析多重定义的全局符号"><a href="#链接器如何解析多重定义的全局符号" class="headerlink" title="链接器如何解析多重定义的全局符号"></a>链接器如何解析多重定义的全局符号</h4><ul>
<li><p>函数和已初始化的全局变量是强符号</p>
</li>
<li><p>未初始化的全局变量是弱符号。</p>
</li>
</ul>
<p>根据强弱符号的定义， Linux 链接器使用下面的规则来处理多重定义的符号名：</p>
<ul>
<li>规则1：不允许有多个同名的强符号。</li>
<li>规则 2: 如果有一个强符号和多个弱符号同名，那么选择强符号。</li>
<li>规则 3: 如果有多个弱符号同名，那么从这些弱符号中任意选择一个。</li>
</ul>
<h4 id="与静态库链接"><a href="#与静态库链接" class="headerlink" title="与静态库链接"></a>与静态库链接</h4><p>链接器只复制被程序引用的目标模块</p>
<p><code>AR工具</code>可用于生成静态链接库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[] ~/Desktop/csapp/code/link gcc -c addvec.c multvec.c</span><br><span class="line">[] ~/Desktop/csapp/code/link ar rcs libvector.a addvec.o multvec.o</span><br><span class="line">[] ~/Desktop/csapp/code/link gcc -c main2.c</span><br><span class="line">[] ~/Desktop/csapp/code/link gcc -static -o prog2c main2.o ./libvector.a</span><br><span class="line">[] ~/Desktop/csapp/code/link ./prog2c</span><br><span class="line">z = [4 6]</span><br></pre></td></tr></table></figure>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201105530744.png" alt="image-20240201105530744"></p>
<h4 id="链接器如何使用静态库来解析引用"><a href="#链接器如何使用静态库来解析引用" class="headerlink" title="链接器如何使用静态库来解析引用"></a>链接器如何使用静态库来解析引用</h4><ul>
<li>在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。</li>
<li>如果静态库之间有依赖关系，我们要将调用函数的静态库放在定义函数静态库之前</li>
</ul>
<h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>合并输入模块，并为每个符号分配运行时地址。</p>
<p>重定位由两部分组成：</p>
<ul>
<li>重定位节和符号定义。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。</li>
<li>重定位节中的符号引用。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。依赖于重定位条目(relocation entry)。</li>
</ul>
<h4 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h4><p>代码的重定位条目放在 .rel.text巳初始化数据的重定位条目放在 .rel.data 中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* $begin elfrelo */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> offset;    <span class="comment">/* Offset of the reference to relocate */</span></span><br><span class="line">    <span class="type">long</span> type:<span class="number">32</span>,   <span class="comment">/* Relocation type */</span></span><br><span class="line">         symbol:<span class="number">32</span>; <span class="comment">/* Symbol table index */</span></span><br><span class="line">    <span class="type">long</span> addend;    <span class="comment">/* Constant part of relocation expression */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br><span class="line"><span class="comment">/* $end elfrelo */</span></span><br></pre></td></tr></table></figure></p>
<p>重定位类型：</p>
<ul>
<li>R_X86_64_PC32 。重定位一个使用 32 位PC相对地址的引用。</li>
<li>R_X86_64_32 。重定位一个使用 32 位绝对地址的引用。</li>
<li>…</li>
</ul>
<h4 id="重定位符号引用"><a href="#重定位符号引用" class="headerlink" title="重定位符号引用"></a>重定位符号引用</h4><p>重定位算法的伪代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">foreach sections &#123; </span><br><span class="line">foreach relocation entry r &#123; </span><br><span class="line">refptr = s + r.offset; I* ptr to reference to be relocated *I </span><br><span class="line">I* Relocate a PC-relative reference *I </span><br><span class="line"><span class="keyword">if</span> Cr.type== R_X86_64_PC32) &#123; </span><br><span class="line">refaddr = ADDR(s) + r.offset; I* ref<span class="number">&#x27;</span>s run-time address *I </span><br><span class="line">*refptr = (<span class="type">unsigned</span>) (ADDR(r.symbol) + r.addend - refaddr); </span><br><span class="line">&#125; </span><br><span class="line">I* Relocate an absolute reference *I </span><br><span class="line"><span class="title function_">if</span> <span class="params">(r.type == R_X86_64_32)</span> </span><br><span class="line">*refptr = (<span class="type">unsigned</span>) (ADDR(r.symbol) + r.addend); &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] ~/Desktop/csapp/code/link objdump -dx main.o</span><br></pre></td></tr></table></figure>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201113131489.png" alt="image-20240201113131489"></p>
<p>可能是gcc版本的问题，重定位类型不一致。都使用了相对寻址。最后也无法成功编译prog。</p>
<h3 id="可执行目标文件"><a href="#可执行目标文件" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h3><p>可执行文件是完全链接的（可重定位的）</p>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201115116040.png" alt="image-20240201115116040"></p>
<ul>
<li>ELF 可执行文件被设计得很容 加载到内存，可执行文件的连 的片 (chunk) 被映射到连续的内存段 程序头部表 (program h eader table) 描述了这种映射关系。</li>
<li>所谓内核就是操作系统驻留在内存的部分。</li>
</ul>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201115520305.png" alt="image-20240201115520305"></p>
<p>off: 目标文件中的偏移；     vaddr /paddr : 存地址 对齐要求；     filesz: 目标文件中的大小    memsz: 内存中的段大小     flags: 运行时访问权限。</p>
<h3 id="加载可执行目标文件"><a href="#加载可执行目标文件" class="headerlink" title="加载可执行目标文件"></a>加载可执行目标文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">/linux&gt; </span><span class="language-bash">./prog</span> </span><br></pre></td></tr></table></figure>
<blockquote>
<p>Linux 系统中的每个程序都运行在一个进程上下文中，有自己的虚拟地址空间。当 shell 运行一个程序时，父 shell 进程生成一个子进程，它是父进程的一个复制。子进程通过 execve统调用启动加载器。加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零 通过将虚拟地址空间中的页映射到可执行文件的页大小的片 (chunk), 新的代码和数据段袚初始化为可执行文件的内容。最后，加载器跳转到 _start地址，它最终会调用应用程序的 main 函数。除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制 。直到 CPU 引用一个被映射的虚拟页时才会进行复制，此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。</p>
</blockquote>
<h3 id="动态链接共享库"><a href="#动态链接共享库" class="headerlink" title="动态链接共享库"></a>动态链接共享库</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201134337320.png" alt="image-20240201134337320"></p>
<p>共享库也称为共享目标 (shared object), Linux 系统中通常用 .so 后缀来表示。微软的操作系统大最地使用了共享库，它们称为 DLL(动态链接库）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux &gt; cd lib64</span><br></pre></td></tr></table></figure>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201135409499.png" alt="image-20240201135409499"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windows &gt; C:\Windows\System32</span><br></pre></td></tr></table></figure>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201135344297.png" alt="image-20240201135344297"></p>
<p>生成动态链接库及动态链接的可执行程序</p>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201142210125.png" alt="image-20240201142210125"></p>
<p>-fpic 选项指示编译器生成与位置无关的代码。<br>-shared选项指示链接器创建一个共享的目标文件。</p>
<p>动态链接器本身就是一个共享目标（如在 Linux 系统上的 ld - linux. so), 加载器不会像它通常所做地那样将控制传递给应用，而是加载和运行这个动态链接器。</p>
<p>我们可以在节中查看到动态链接所需要的动态链接库</p>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201142848795.png" alt="image-20240201142848795"></p>
<h3 id="从应用程序中加载和链接共享库"><a href="#从应用程序中加载和链接共享库" class="headerlink" title="从应用程序中加载和链接共享库"></a>从应用程序中加载和链接共享库</h3><p>动态链接是强大有用的技术。</p>
<ul>
<li>分发软件。</li>
<li>构建高性能 Web 服务器。</li>
</ul>
<p>Linux 系统为动态链接器提供了一个简单的接口，允许应用程序在运行时加载和链接共享库。分别为dlopen 、dlsym 和 dlclose 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> z[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *handle;</span><br><span class="line">    <span class="type">void</span> (*addvec)(<span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Dynamically load the shared library that contains addvec() */</span></span><br><span class="line">    handle = dlopen(<span class="string">&quot;./libvector.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span> (!handle) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get a pointer to the addvec() function we just loaded */</span></span><br><span class="line">    addvec = dlsym(handle, <span class="string">&quot;addvec&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, error);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now we can call addvec() just like any other function */</span></span><br><span class="line">    addvec(x, y, z, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;z = [%d %d]\n&quot;</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Unload the shared library */</span></span><br><span class="line">    <span class="keyword">if</span> (dlclose(handle) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end dll */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -rdynamic -o prog2r dll.c -ldl</span><br></pre></td></tr></table></figure>
<p>调用函数后可以看到成功在运行中调用libvector.so库</p>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201144409139.png" alt="image-20240201144409139"></p>
<blockquote>
<p>Java 定义了一个标准调用规则，叫做<code>Java 本地接口 (Java Native Interface, JNI)</code> , 它允许Java 程序调用”本地的 “C 或C++ 函数。 JNI 的基本思想是将本地函数（如 foo) 编译到一个共享库中（如 foo.so) 当一个正在运行的 Java 程序试图调用函数 foo 时， Java解释器利用 <code>dlopen 接口</code>（或者与其类似的接口）<code>动态链接和加载</code> foo.so, 然后再调用 foo</p>
</blockquote>
<h3 id="位置无关代码"><a href="#位置无关代码" class="headerlink" title="位置无关代码"></a>位置无关代码</h3><p>可以加载而无需重定位的代码称为位置无关代码 (Position Independent Code, PIC)。用户对 GCC 使用 -fpic 选项指示 GNU 编译系统生成 PIC 代码。 共享库的编译必须总使用该选项。</p>
<h4 id="PIC数据引用"><a href="#PIC数据引用" class="headerlink" title="PIC数据引用"></a>PIC数据引用</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201145720373.png" alt="image-20240201145720373"></p>
<p>编译器可以利用代码段和数据段之间不变的距离，直接 <code>PC 相对引用</code>，并增加一个重定位，让链接器在构造这个共享模块时解析它。</p>
<h4 id="PIC函数调用"><a href="#PIC函数调用" class="headerlink" title="PIC函数调用"></a>PIC函数调用</h4><ul>
<li><code>过程链接表 (PLT)</code>PLT 是一个数组，其中每个条目是 16 字节代码。 PLT[O] 是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己PLT 条目。每个条目都负责调用一个具体的函数。 </li>
<li><code>全局偏移量表 (GOT)</code>。正如我们看到的， GOT 是一个数组，其中每个条目是8 字节地址。和 PLT 联合使用时,GOT [0]和 GOT[l] 包含动态链接器在解析函数地址时会使用的信息。 GOT[2] 是动态链接器在 ld-linux.so 模块中的入口点。</li>
</ul>
<h4 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h4><p>假设我们用调用<code>addvec</code>函数，首先进入PLT[2]。若为第<code>1</code>次调用，由于采用延迟绑定，我们需要进行动态链接，然后把控制传递给addvec。第<code>n（n&gt;1)</code>调用由于<code>addvec</code>函数已经被加载到内存中确定的位置，则会从直接从PLT表跳转到GOT表中，在GOT表中进行函数调用。<br/></p>
<ul>
<li><p><code>plt</code>在代码段，<code>got</code>在数据段</p>
</li>
<li><p><code>plt</code>是地址的填写者，<code>got</code>是地址的保存者</p>
</li>
</ul>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201145741391.png" alt="image-20240201145741391"></p>
<h3 id="库打桩机制"><a href="#库打桩机制" class="headerlink" title="库打桩机制"></a>库打桩机制</h3><p>Linux 链接器支持一个很强大的技术，称为库打桩 (library interpositioning), 它允许你截获对共享库函数的调用，取而代之执行自己的代码。</p>
<h3 id="编译时打桩"><a href="#编译时打桩" class="headerlink" title="编译时打桩"></a>编译时打桩</h3><p>int.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>malloc.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> malloc(size) mymalloc(size)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> free(ptr) myfree(ptr)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mymalloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myfree</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>
<p>mymalloc.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RUNTIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc wrapper function */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *(*mallocp)(<span class="type">size_t</span> size);</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">    mallocp = dlsym(RTLD_NEXT, <span class="string">&quot;malloc&quot;</span>); <span class="comment">/* Get address of libc malloc */</span></span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(error, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *ptr = mallocp(size); <span class="comment">/* Call libc malloc */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d) = %p\n&quot;</span>, (<span class="type">int</span>)size, ptr);</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free wrapper function */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> (*freep)(<span class="type">void</span> *) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    freep = dlsym(RTLD_NEXT, <span class="string">&quot;free&quot;</span>); <span class="comment">/* Get address of libc free */</span></span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(error, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    freep(ptr); <span class="comment">/* Call libc free */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                                                    </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c mymalloc.c -o mymalloc.o</span><br><span class="line">gcc -I -o intc <span class="type">int</span>.c mymalloc.o</span><br></pre></td></tr></table></figure>
<p>由于有 -I.参数，所以会进行打桩，它告诉预处理器在搜索通常的系统目录之前，先在当前目录中查找 malloc.h 。</p>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201153521256.png" alt="image-20240201153521256"></p>
<p>可一看到先调用了mymalloc函数后再调用malloc函数，由于再包装函数增加了<code>printf</code>函数，得到如下输出：</p>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201153641037.png" alt="image-20240201153641037"></p>
<h4 id="链接时打桩"><a href="#链接时打桩" class="headerlink" title="链接时打桩"></a>链接时打桩</h4><p>Linux 静态链接器支持用 —wrap 标志进行链接时打桩。</p>
<p>mymalloc.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LINKTIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *__real_malloc(<span class="type">size_t</span> size);</span><br><span class="line"><span class="type">void</span> __real_free(<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc wrapper function */</span></span><br><span class="line"><span class="type">void</span> *__wrap_malloc(<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr = __real_malloc(size); <span class="comment">/* Call libc malloc */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d) = %p\n&quot;</span>, (<span class="type">int</span>)size, ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free wrapper function */</span></span><br><span class="line"><span class="type">void</span> __wrap_free(<span class="type">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    __real_free(ptr); <span class="comment">/* Call libc free */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc  -Wl,--wrap,malloc -Wl,--wrap,free -o intc1 int.o mymalloc.o</span><br></pre></td></tr></table></figure>
<p><code>-Wl option</code> 标志把 option 传递给链接器。 option 中的每个逗号都要替换为一个空格。所以 -Wl,—wrap,malloc 就把- -wrap malloc 传递给链接器。</p>
<h4 id="运行时打桩"><a href="#运行时打桩" class="headerlink" title="运行时打桩"></a>运行时打桩</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* malloc wrapper function */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *(*mallocp)(<span class="type">size_t</span> size);</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">    mallocp = dlsym(RTLD_NEXT, <span class="string">&quot;malloc&quot;</span>); <span class="comment">/* Get address of libc malloc */</span></span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(error, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *ptr = mallocp(size); <span class="comment">/* Call libc malloc */</span></span><br><span class="line">    <span class="comment">//printf(&quot;malloc(%d) = %p\n&quot;, (int)size, ptr);</span></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free wrapper function */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> (*freep)(<span class="type">void</span> *) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    freep = dlsym(RTLD_NEXT, <span class="string">&quot;free&quot;</span>); <span class="comment">/* Get address of libc free */</span></span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(error, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    freep(ptr); <span class="comment">/* Call libc free */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end interposer */</span></span><br></pre></td></tr></table></figure>
<p>由于printf函数会调用malloc函数，malloc打桩调用printf会陷入死循环引发段错误。因此我们将其注释掉</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo $SEHLL    //打印当前shell</span><br><span class="line">chsh -s /bin/bash  //切换shell</span><br><span class="line">LD_PRELOAD=&quot;./mymalloc.so&quot; ./xxx 运行时打桩</span><br></pre></td></tr></table></figure>
<p>可以对任意程序进行运行时打桩</p>
<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201164115580.png" alt="image-20240201164115580"></p>
<h3 id="处理目标文件的工具"><a href="#处理目标文件的工具" class="headerlink" title="处理目标文件的工具"></a>处理目标文件的工具</h3><p>Linux 系统中有大量可用的工具 可以 帮助你理解和处理目 标文件 。特别地， GNU binutils 包尤其有帮助，而且可以运行在每个Linux平台上</p>
<ul>
<li>AR: 创建静态库，插入、删除、列出和提取成员</li>
<li>STRINGS: 列出 个目标文件中所有可打印的字符串。</li>
<li>STRIP: 目标文件中删除符号表信息</li>
<li>NM: 列出目标文件的符号表中定义的符号。</li>
<li>SIZE: 列出目标文件中节的名字和大小</li>
<li>READELF: 显示目标文件的完整结构，包括 E LF 头中编码的所有信息。包含SIZE和 NM 功能。</li>
<li><p>OBJDUMP: 所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编 .text 节中的二进制指令</p>
</li>
<li><p>LDD: 列出一个可执行文 件在运行时所需要的共享库</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://randolfluo.github.io">Randolf luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://randolfluo.github.io/2024/01/30/csapp/%E7%AC%AC7%E7%AB%A0%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/">http://randolfluo.github.io/2024/01/30/csapp/%E7%AC%AC7%E7%AB%A0%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://randolfluo.github.io" target="_blank">Randolfluo's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/csapp/">csapp</a><a class="post-meta__tags" href="/tags/book/">book</a></div><div class="post-share"><div class="social-share" data-image="/img/cover1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/01/28/csapp/%E7%AC%AC5%E7%AB%A0%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/" title="csapp第五章——优化程序性能"><img class="cover" src="/img/cover3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">csapp第五章——优化程序性能</div></div><div class="info-2"><div class="info-item-1">优化程序性能 第一，我们必须选择一组适当的算法和数据结构。 第二，我们必须编写出编译器能够有效优化以转换成高效可执行代码的源代码。   为什么我们需要优化程序，现代编译器不是具有很强的优化能力吗？ ans:因为编译器只进行安全的优化，消除可能出现的异常的运行时行为。意味着我们需要写出适合编译器优化的代码，优化程序性能。  内存别名使用 两个指针可能指向同一个内存位置的情况称为内存别名使用 (memory aliasing)  12345678910void twiddlel(long *Xp, long *yp) &#123; *XP += *yp; *XP += *yp; &#125; void twiddle2(long *XP, long *yp) &#123; *XP += 2* *yp; &#125;  乍一看两个函数好像没有区别，但是当*XP与*YP指向同一内存时。twiddle1变为原来的四倍，twiddle2变为原来的三倍。改变了程序的行为。 ...</div></div></div></a><a class="pagination-related" href="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/" title="csapp第六章——存储器层次结构"><img class="cover" src="/img/cover1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">csapp第六章——存储器层次结构</div></div><div class="info-2"><div class="info-item-1">存储器层次结构计算机技术的成功很大程度上源自于存储技术的巨大进步 。 随机访问存储器静态RAM 由于 SRAM 存储器单元的双稳态特性，只要有电，它就会永远地保持它的值。 动态RAMDRAM 将每个位存储为对每个电容的充电。与 SRAM 不同， DRAM 存储器单元对干扰非常敏感 。  传统的DRAMDRAM 芯片中的单元（位）被分成d 个超单元 (supercell) , 每个超单元都个DRAM单元组成。 d*w 的DRAM 总共存储了d w位信息。  图示为168 DRAM 芯片的组织，有 d=l6 个超单元，每个超单元有 w=8 位， r=4 行，c=4 。   将 DRAM 组织成二维阵列而不是线性数组的一个原因是降低芯片上地址引脚的数量。  二维阵列组织的缺点是必须分两步发送地址，这增加了访问时间。   内存模块DRAM 芯片封装在内存模块 (memory module) 中，它插到主板的扩展槽上 。 内存控制器将超单元地址 发送到内存模块，然后内存模块再广播到每个 DRAM 。作为响应，每个DRAM...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/02/26/csapp/%E7%AC%AC10%E7%AB%A0%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/" title="csapp第十章——系统级IO"><img class="cover" src="/img/cover1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-26</div><div class="info-item-2">csapp第十章——系统级IO</div></div><div class="info-2"><div class="info-item-1">系统级I/O输入与输出 (I/O) 是在主存和外部设备（例如磁盘驱动器、终端和网络）之间复制数据的过程。 UNIX I/O 所有的设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。   打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。 Linux shell 创建的每个进程开始时都有三个打开的文件：  12345/*								 /usr/include/unisted.h 						 */#define STDIN_FILENO    0       /* Standard input.  */#define STDOUT_FILENO   1       /* Standard output.  */#define STDERR_FILENO   2       /* Standard error output. ...</div></div></div></a><a class="pagination-related" href="/2024/01/28/csapp/%E7%AC%AC5%E7%AB%A0%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/" title="csapp第五章——优化程序性能"><img class="cover" src="/img/cover3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-28</div><div class="info-item-2">csapp第五章——优化程序性能</div></div><div class="info-2"><div class="info-item-1">优化程序性能 第一，我们必须选择一组适当的算法和数据结构。 第二，我们必须编写出编译器能够有效优化以转换成高效可执行代码的源代码。   为什么我们需要优化程序，现代编译器不是具有很强的优化能力吗？ ans:因为编译器只进行安全的优化，消除可能出现的异常的运行时行为。意味着我们需要写出适合编译器优化的代码，优化程序性能。  内存别名使用 两个指针可能指向同一个内存位置的情况称为内存别名使用 (memory aliasing)  12345678910void twiddlel(long *Xp, long *yp) &#123; *XP += *yp; *XP += *yp; &#125; void twiddle2(long *XP, long *yp) &#123; *XP += 2* *yp; &#125;  乍一看两个函数好像没有区别，但是当*XP与*YP指向同一内存时。twiddle1变为原来的四倍，twiddle2变为原来的三倍。改变了程序的行为。 ...</div></div></div></a><a class="pagination-related" href="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/" title="csapp第六章——存储器层次结构"><img class="cover" src="/img/cover1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-01</div><div class="info-item-2">csapp第六章——存储器层次结构</div></div><div class="info-2"><div class="info-item-1">存储器层次结构计算机技术的成功很大程度上源自于存储技术的巨大进步 。 随机访问存储器静态RAM 由于 SRAM 存储器单元的双稳态特性，只要有电，它就会永远地保持它的值。 动态RAMDRAM 将每个位存储为对每个电容的充电。与 SRAM 不同， DRAM 存储器单元对干扰非常敏感 。  传统的DRAMDRAM 芯片中的单元（位）被分成d 个超单元 (supercell) , 每个超单元都个DRAM单元组成。 d*w 的DRAM 总共存储了d w位信息。  图示为168 DRAM 芯片的组织，有 d=l6 个超单元，每个超单元有 w=8 位， r=4 行，c=4 。   将 DRAM 组织成二维阵列而不是线性数组的一个原因是降低芯片上地址引脚的数量。  二维阵列组织的缺点是必须分两步发送地址，这增加了访问时间。   内存模块DRAM 芯片封装在内存模块 (memory module) 中，它插到主板的扩展槽上 。 内存控制器将超单元地址 发送到内存模块，然后内存模块再广播到每个 DRAM 。作为响应，每个DRAM...</div></div></div></a><a class="pagination-related" href="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" title="csapp第九章——虚拟内存"><img class="cover" src="/img/cover1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-18</div><div class="info-item-2">csapp第九章——虚拟内存</div></div><div class="info-2"><div class="info-item-1">虚拟内存虚拟内存提供了三个重要的能力：   它将主存看成是 个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存  它为每个进程提供了一致的地址空间，从而简化了内存管理。  它保护了每个进程的地址空间不被其他进程破坏  物理和虚拟内存将虚拟地址转换为物理地址的任务叫做地址翻译 (address translation)。 地址翻译需要 CPU 硬件和操作系统之间的紧密合作 CPU 芯片上叫做内存管理单元(Memory Management Unit, MMU) 的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。  地址空间地址空间 (address space) 个非负整数地址的有序集合： 一个地址空间的大小是由表示最大地址所需要的位数来描述的。  虚拟地址空间： 一个包含 N=2**n个地址的虚拟地址空间就叫做一个n位地址空间，现代系统通常支持 32 位或者 64 位虚拟地址空间。  物理地址空间：对应于系统中物理内存的M个字节。   虚拟内存作为缓存的工具VM...</div></div></div></a><a class="pagination-related" href="/2024/02/13/csapp/%E7%AC%AC8%E7%AB%A0%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" title="csapp第八章——异常控制流"><img class="cover" src="/img/cover1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-13</div><div class="info-item-2">csapp第八章——异常控制流</div></div><div class="info-2"><div class="info-item-1">[TOC] 异常控制流现代系统通过使控制流发生突变来对系统状态的变化做出反应 。一般而言 ，我们把这些突变称为异常控制流 (Exceptional Control Flow, ECF) 。 异常异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。  异常 (exception) 就是控制流中的突变，用来响应处理器状态中的某些变化。 当处理器检测到有事件发生时，它就会通过一张叫做异常表 (exception table)的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序 (exception handler)) 。 异常处理 异常处理程序运行在内核模式下，这意味它们对所有的系统资源都有完全的访问权限。 异常的类别  同步异步表示的结果的获取方式是主动获取还是被动接收；阻塞非阻塞表示的是获取这个动作是否可以立即返回不用等待。  中断中断是异步发生的， 是来自处理器外部的 I/0 设备的信号的结果。例如定时器计时结束后会向处理器发送一个中断。  陷阱和系统调用陷阱是有意的异常，是执行一条指令的结果...</div></div></div></a><a class="pagination-related" href="/2023/12/07/csapp/attacklab/" title="attacklab"><img class="cover" src="/img/cover2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-07</div><div class="info-item-2">attacklab</div></div><div class="info-2"><div class="info-item-1">Part I: Code Injection Attacks开冲！！ level1 sub rsp,0x28说明缓冲区有0x28即40字节，我们只需在这之后加入touch1()函数的权限地址来提权。 gets()函数不会对输入大小进行检查，遇到\n0x0a结束字符串读取  touch1地址为0x4017c0  payload(注意不能填充0a)，同时小端序要倒序存储(低地址存放数据低位，高地址存放数据高位)  12345600 00 00 00 00 00 00 00 #低地址00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00c0 17 40 00 00 00 00 00...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avater.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Randolf luo</div><div class="author-info-description">今日事，今日毕</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">111</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">34</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Randolfluo" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:lrj3216610@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">1.</span> <span class="toc-text">链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.0.1.</span> <span class="toc-text">编译器驱动程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">1.0.2.</span> <span class="toc-text">静态链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="toc-number">1.0.3.</span> <span class="toc-text">目标文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="toc-number">1.0.4.</span> <span class="toc-text">可重定位目标文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%92%8C%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="toc-number">1.0.5.</span> <span class="toc-text">符号和符号表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90"><span class="toc-number">1.0.6.</span> <span class="toc-text">符号解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%99%A8%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E5%A4%9A%E9%87%8D%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%A8%E5%B1%80%E7%AC%A6%E5%8F%B7"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">链接器如何解析多重定义的全局符号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93%E9%93%BE%E6%8E%A5"><span class="toc-number">1.0.6.2.</span> <span class="toc-text">与静态库链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%99%A8%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%BA%93%E6%9D%A5%E8%A7%A3%E6%9E%90%E5%BC%95%E7%94%A8"><span class="toc-number">1.0.6.3.</span> <span class="toc-text">链接器如何使用静态库来解析引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">1.0.7.</span> <span class="toc-text">重定位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E6%9D%A1%E7%9B%AE"><span class="toc-number">1.0.7.1.</span> <span class="toc-text">重定位条目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8"><span class="toc-number">1.0.7.2.</span> <span class="toc-text">重定位符号引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="toc-number">1.0.8.</span> <span class="toc-text">可执行目标文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="toc-number">1.0.9.</span> <span class="toc-text">加载可执行目标文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="toc-number">1.0.10.</span> <span class="toc-text">动态链接共享库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="toc-number">1.0.11.</span> <span class="toc-text">从应用程序中加载和链接共享库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81"><span class="toc-number">1.0.12.</span> <span class="toc-text">位置无关代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PIC%E6%95%B0%E6%8D%AE%E5%BC%95%E7%94%A8"><span class="toc-number">1.0.12.1.</span> <span class="toc-text">PIC数据引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PIC%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">1.0.12.2.</span> <span class="toc-text">PIC函数调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A"><span class="toc-number">1.0.12.3.</span> <span class="toc-text">延迟绑定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E6%89%93%E6%A1%A9%E6%9C%BA%E5%88%B6"><span class="toc-number">1.0.13.</span> <span class="toc-text">库打桩机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E6%89%93%E6%A1%A9"><span class="toc-number">1.0.14.</span> <span class="toc-text">编译时打桩</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E6%97%B6%E6%89%93%E6%A1%A9"><span class="toc-number">1.0.14.1.</span> <span class="toc-text">链接时打桩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%93%E6%A1%A9"><span class="toc-number">1.0.14.2.</span> <span class="toc-text">运行时打桩</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">1.0.15.</span> <span class="toc-text">处理目标文件的工具</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/11/dailyrecord/2024_11_11/" title="记一次2024ICPC杭州站"><img src="/img/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="记一次2024ICPC杭州站"/></a><div class="content"><a class="title" href="/2024/11/11/dailyrecord/2024_11_11/" title="记一次2024ICPC杭州站">记一次2024ICPC杭州站</a><time datetime="2024-11-10T16:00:00.000Z" title="发表于 2024-11-11 00:00:00">2024-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/15/math/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" title="无标题"><img src="/img/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2024/10/15/math/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" title="无标题">无标题</a><time datetime="2024-10-15T06:44:44.734Z" title="发表于 2024-10-15 14:44:44">2024-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/29/potato_clock/v0.01/" title="无标题"><img src="/img/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2024/09/29/potato_clock/v0.01/" title="无标题">无标题</a><time datetime="2024-09-29T06:08:49.443Z" title="发表于 2024-09-29 14:08:49">2024-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/26/%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%840x2/" title="无标题"><img src="/img/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2024/09/26/%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%840x2/" title="无标题">无标题</a><time datetime="2024-09-26T12:40:48.042Z" title="发表于 2024-09-26 20:40:48">2024-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/26/pr/pr%E5%85%A5%E9%97%A8/" title="无标题"><img src="/img/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2024/09/26/pr/pr%E5%85%A5%E9%97%A8/" title="无标题">无标题</a><time datetime="2024-09-26T12:40:47.924Z" title="发表于 2024-09-26 20:40:47">2024-09-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover1.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By Randolf luo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>