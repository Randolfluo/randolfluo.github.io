<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>EffectiveCpp0x1 | Randolfluo's blog</title><meta name="author" content="Randolf luo"><meta name="copyright" content="Randolf luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="导读&amp;Accustoming youself to C++">
<meta property="og:type" content="article">
<meta property="og:title" content="EffectiveCpp0x1">
<meta property="og:url" content="http://randolfluo.github.io/2024/04/01/C&C++/Effective%20Cpp0x1/index.html">
<meta property="og:site_name" content="Randolfluo&#39;s blog">
<meta property="og:description" content="导读&amp;Accustoming youself to C++">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://randolfluo.github.io/img/cover3.jpg">
<meta property="article:published_time" content="2024-04-01T14:42:00.000Z">
<meta property="article:modified_time" content="2024-07-11T16:00:00.000Z">
<meta property="article:author" content="Randolf luo">
<meta property="article:tag" content="cpp">
<meta property="article:tag" content="effective cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://randolfluo.github.io/img/cover3.jpg"><link rel="shortcut icon" href="/img/avater.jpg"><link rel="canonical" href="http://randolfluo.github.io/2024/04/01/C&amp;C++/Effective%20Cpp0x1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Randolf luo","link":"链接: ","source":"来源: Randolfluo's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'EffectiveCpp0x1',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avater.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">111</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">34</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover3.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Randolfluo's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">EffectiveCpp0x1</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">EffectiveCpp0x1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-01T14:42:00.000Z" title="发表于 2024-04-01 22:42:00">2024-04-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-11T16:00:00.000Z" title="更新于 2024-07-12 00:00:00">2024-07-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/cpp/">cpp</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/cpp/effective-cpp/">effective cpp</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">1.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>5分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h1><p>[toc]</p>
<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li><strong>声明式</strong>：告诉编译器某个东西的<code>名称</code>和<code>类型</code>，但是略去细节。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">templete&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Randolfluo</span>;</span><br><span class="line"><span class="function">std::string <span class="title">Print</span><span class="params">(std::string string)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>定义式</strong>：提供编译器对象、函数和模板等的实际代码本体。</p>
</li>
<li><p><strong>初始化</strong>：给予对象值的过程。</p>
</li>
<li><p><strong>copy构造</strong>与<strong>copy赋值</strong>:通过是否有新对象被定义区分。</p>
</li>
</ul>
<h2 id="Accustoming-youself-to-C"><a href="#Accustoming-youself-to-C" class="headerlink" title="Accustoming youself to C++"></a>Accustoming youself to C++</h2><h3 id="01-View-C-as-a-federation-of-languages"><a href="#01-View-C-as-a-federation-of-languages" class="headerlink" title="01. View C++ as a federation of languages"></a>01. View C++ as a federation of languages</h3><p>C++是一个多重范式语言:</p>
<ul>
<li><strong>过程形式(procedural)</strong>：通过函数调用和控制流语句(如if语句和循环)来实现。</li>
<li><strong>面向对象形式(object-oriented)</strong>：支持封装、继承和多态等面向对象的特性。</li>
<li><strong>函数形式(functional)</strong>：</li>
<li><strong>泛型形式(generic)</strong>：C++通过模板支持泛型编程。模板允许你编写可以处理各种数据类型的通用代码。标准模板库（STL）中的容器和算法都是泛型的，可以与各种数据类型一起使用。</li>
<li><strong>元编程形式(metaprogramming)</strong>：C++提供了元编程的功能，其中最常见的是模板元编程。通过模板元编程，你可以在编译时生成代码，实现诸如计算、类型推导、代码生成等功能。</li>
</ul>
<h3 id="02-Prefer-consts-enums-and-inlines-to-define"><a href="#02-Prefer-consts-enums-and-inlines-to-define" class="headerlink" title="02. Prefer consts,enums,and inlines to #define"></a>02. Prefer consts,enums,and inlines to #define</h3><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><ul>
<li><p>由于<code>预处理符号#</code>会在函数编译前进行复制和替换，如果发生错误，我们得到的信息将是<code>1234</code>而不是<code>Randolfluo</code>，于是你将为追踪他而浪费时间。</p>
</li>
<li><p>正确的方法是以常量替换宏。</p>
</li>
<li><p><code>#define</code>不注重作用域，因此不具封装性。</p>
</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Randolfluo =1234		</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Randolfluo = <span class="number">1234</span>		</span><br></pre></td></tr></table></figure>
<ul>
<li>宏看起来像函数，但是不会招致函数调用(function call)带来的额外开销。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Macro_Print(a,b) std::cout &lt;&lt; (a) + (b) &lt;&lt; std::endl;		<span class="comment">//错误方式，相较于函数调用效率更高，但是调用时可能产生错误输出。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Inline_Print</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span>	<span class="comment">//正确方式，性能相同，但是具有类型安全，pass by reference-to-const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Macro_Print</span>(a, b);</span><br><span class="line">	<span class="built_in">Inline_Print</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类专属常量"><a href="#类专属常量" class="headerlink" title="类专属常量"></a>类专属常量</h4><ul>
<li>静态成员变量的定义通常需要在类外部进行，以便为其分配存储空间。这是因为在类声明中只是声明了静态成员变量的存在，而没有分配内存。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MY_CONSTANT = <span class="number">10</span>; <span class="comment">// 类专属常量声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类专属常量定义和初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MyClass::MY_CONSTANT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;My class constant: &quot;</span> &lt;&lt; MyClass::MY_CONSTANT &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
<h4 id="请记住"><a href="#请记住" class="headerlink" title="请记住"></a>请记住</h4><ul>
<li>对于单纯常量，最好以const对象或enums替换#define。</li>
<li>对于形似函数的宏（macros），最好改用inline函数替换#defines。</li>
</ul>
<h3 id="03-Use-const-whenever-possible"><a href="#03-Use-const-whenever-possible" class="headerlink" title="03. Use const whenever possible"></a>03. Use const whenever possible</h3><ul>
<li>令函数返回一个常量值，往往可以降低因错误而造成的意外。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Num</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> Num <span class="keyword">operator</span>+ (<span class="type">const</span> Num&amp; other) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Num result;</span><br><span class="line">        result.num = num + other.num;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Num a, b, c;</span><br><span class="line">    c = a + b;		</span><br><span class="line">    <span class="keyword">if</span>( a + b = c )	<span class="comment">//少写一个=号,如果不加入const，则此操作编译器将不报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h4><ul>
<li>将const实施于成员函数的目的，是为了确认该成员函数可作用于const对象。</li>
<li>通过pass by reference-to-const 传递对象，提高程序效率。</li>
</ul>
<h4 id="bitwise-constness-amp-logical-constness"><a href="#bitwise-constness-amp-logical-constness" class="headerlink" title="bitwise constness &amp; logical constness"></a>bitwise constness &amp; logical constness</h4><ul>
<li>请看书</li>
</ul>
<h4 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住"></a>请记住</h4><ul>
<li>将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</li>
<li>编译器强制实施bitwise constness,但你编写程序时应该使用“概念上的常量性”( conceptual constness)。</li>
<li>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。</li>
</ul>
<h3 id="04-Make-sure-that-objects-are-initialized-before-ther’re-used"><a href="#04-Make-sure-that-objects-are-initialized-before-ther’re-used" class="headerlink" title="04. Make sure that objects are initialized before ther’re used."></a>04. Make sure that objects are initialized before ther’re used.</h3><ul>
<li>永远在使用对象前先将它初始化。</li>
</ul>
<h4 id="member-intialization-list"><a href="#member-intialization-list" class="headerlink" title="member intialization list"></a>member intialization list</h4><ul>
<li>如果成员变量是<code>const</code>或<code>reference</code>，就要赋初值,使用<code>成员初始化列表</code>。</li>
<li>类成员的初始化顺序不是按照初始化列表的顺序来的，而是按照类成员的声明顺序。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>()</span><br><span class="line">        :<span class="built_in">x</span>(<span class="number">12</span>)			<span class="comment">//member intialization list</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;		<span class="comment">//default member intializer</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output 12</span></span><br></pre></td></tr></table></figure>
<h4 id="local-static-amp-non-local-static"><a href="#local-static-amp-non-local-static" class="headerlink" title="local static &amp;  non-local static"></a>local static &amp;  non-local static</h4><ul>
<li><code>local static</code>对象即函数内部的 static 变量，适用于需要在函数调用间保持状态的情况，可以防止变量的多次初始化，且仅在声明的函数内部可见。</li>
</ul>
<ul>
<li><p><code>non-local static</code>即函数外部的 static 变量，适用于在文件内部共享状态的情况，可以防止变量被其他文件访问，且仅在声明的文件内部可见。</p>
</li>
<li><p><code>Singleton</code>模式：将每个<code>non-local static</code>对象搬到自己的专属函数内(该对象在此函数内被声明为<code>static</code>[即<code>local static</code>对象])。这些函数返回一个reference 指向它所含的对象。然后用户调用这些函数，而不直接指涉这些对象。换句话说，non-local static 对象被local static 对象替换了。</p>
</li>
</ul>
<p>//TODO为什么默认构造函数比有初值的构造函数效率低</p>
<h4 id="请记住-2"><a href="#请记住-2" class="headerlink" title="请记住"></a>请记住</h4><ul>
<li>为内置型对象进行手工初始化，因为C++不保证初始化它们。</li>
<li>构造函数最好使用成员初值列( member initialization list)，而不要在构造函数本体内使用赋值操作(asignment)。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。</li>
<li>为免除“跨编译单元之初始化次序”问题，请以local static 对象替换non-local static对象。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://randolfluo.github.io">Randolf luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://randolfluo.github.io/2024/04/01/C&amp;C++/Effective%20Cpp0x1/">http://randolfluo.github.io/2024/04/01/C&amp;C++/Effective%20Cpp0x1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://randolfluo.github.io" target="_blank">Randolfluo's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/cpp/">cpp</a><a class="post-meta__tags" href="/tags/effective-cpp/">effective cpp</a></div><div class="post-share"><div class="social-share" data-image="/img/cover3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/03/28/C&amp;C++/Cpp%E6%96%B0%E7%89%B9%E6%80%A7/" title="Cpp新特性"><img class="cover" src="/img/cover1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Cpp新特性</div></div><div class="info-2"><div class="info-item-1">[toc] lvalue &amp;&amp; rvalue     （C++11）Understanding lvalues and rvalues in C and C++ - Eli Bendersky’s website (thegreenplace.net)  An lvalue (locator value) represents an object that occupies some identifiable location in memory (i.e. has an address). rvalues are defined by exclusion, by saying that every expression is either an lvalue or an rvalue. Therefore, from the above definition of lvalue, an rvalue is an expression that does not represent an object occupying some identifiable...</div></div></div></a><a class="pagination-related" href="/2024/04/02/C&amp;C++/templates/" title="template"><img class="cover" src="/img/cover2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">template</div></div><div class="info-2"><div class="info-item-1">templatetemplates的基本用法 编译器根据你提供的规则为你编写代码。  模板定义本身不参与编译，而是编译器根据模板的用户使用模板时提供的类型参数生成代码，再进行编译。   1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;string&gt;template &lt;typename T&gt;void Print(T value)		//函数模板&#123;	std::cout &lt;&lt; value &lt;&lt; std::endl;&#125;template &lt;typename T, int N&gt;class Array		//类模板&#123;private:	T m_Array[N];public:	int GetSize() const &#123;		return N;	&#125;&#125;;int main() &#123;	Array&lt;int, 5&gt;...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/04/03/C&C++/Effective%20Cpp0x2/" title="EffectiveCpp0x2"><img class="cover" src="/img/cover1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-03</div><div class="info-item-2">EffectiveCpp0x2</div></div><div class="info-2"><div class="info-item-1">Effective C+ [toc] Constructors,Destructors,and Assignment Operators05. Know what functions C++ silently writes and calls C++自动为类声明copy构造函数，copy assignment操作符和析构函数。如果没有声明构造函数，编译器会生成default构造函数。 这些函数都是public且inline的。   123456789101112131415#include&lt;iostream&gt;class Entity&#123;public:    Entity()    &#123;&#125; // Default constructor    ~Entity()   &#123;&#125; // Destructor    Entity(const Entity&amp; rhs)   &#123;&#125; // Copy constructor    Entity operator=(const Entity&amp; rhs) ...</div></div></div></a><a class="pagination-related" href="/2024/04/05/C&C++/Effective%20Cpp0x3/" title="EffectiveCpp0x3"><img class="cover" src="/img/cover1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="info-item-2">EffectiveCpp0x3</div></div><div class="info-2"><div class="info-item-1">[toc] Resource Management 如内存，互斥锁，数据库连接，网络sockets…… 重要的是，当你不再使用它了，应该将它还给系统。  13. Use objects to manage resources. 获得资源后立刻放进管理对象(managing object) 内。“资源取得时机便是初始化时机” (Resource Acquisition Is Initialization; RAII) 。  管理对象(managing object) 运用析构函数确保资源被释放。    为什么手动释放堆内存容易出错？ e.g: Investment * createlnvestment(); void f (){Investment* plnv = createlnvestment(); …… delete plnv; return; } //若……中有return导致提前返回，则会导致资源泄露，且不易察觉   std::auto_ptr:已被弃用。由于其拷贝时原先的指针会指向null，致潜在的资源泄漏和行为不确定性。auto_ptr 被 C++11 中引入的...</div></div></div></a><a class="pagination-related" href="/2024/04/19/C&C++/Effective%20Cpp0x5/" title="EffectiveCpp0x5"><img class="cover" src="/img/cover1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-19</div><div class="info-item-2">EffectiveCpp0x5</div></div><div class="info-2"><div class="info-item-1">Implementation[toc] 26. Postpone variable definitions as long as possible.只要你定义了一个变量而其类型带有一个构造函数或析构函数，那么当程序的控制流(control flow) 到达这个变量定义式时，你便得承受构造成本；当这个变量离开其作用域时，你便得承受析构成本。即使这个变量最终并未被使用，仍需耗费这些成本，所以你应该尽可能避免这种情形。 考虑一个加密函数当抛出一个异常时（如加密字符串长度过短），则该encrypted字符串将未被使用： 1234567891011121314// this function defines the variable &quot;encrypted&quot; too soonstd::string encryptPassword(const std::string&amp; password)&#123;  using namespace std;  string encrypted;  if (password.length() &lt;...</div></div></div></a><a class="pagination-related" href="/2024/04/21/C&C++/Effective%20Cpp0x6/" title="EffectiveCpp0x6"><img class="cover" src="/img/cover3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-21</div><div class="info-item-2">EffectiveCpp0x6</div></div><div class="info-2"><div class="info-item-1">Inheritance and Object-Oriented Design[toc]  我：请问什么是面向对象原则 ChatGPT：SOLID 是面向对象设计中的五个基本设计原则的首字母缩写，它们是：  单一职责原则（Single Responsibility Principle，SRP）： 每个类或模块应该只有一个改变的理由，即一个类应该只负责一个职责。这个原则指导我们将系统分解为小而独立的部分，每个部分都有自己的职责，使得代码更加清晰、可维护和可重用。 开放-封闭原则（Open/Closed Principle，OCP）： 软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。这意味着当需要改变系统的行为时，不应该修改已有的代码，而是应该通过扩展现有的代码来实现新的行为。这个原则鼓励使用抽象和多态性来实现系统的灵活性和可扩展性。 里氏替换原则（Liskov Substitution Principle，LSP）：...</div></div></div></a><a class="pagination-related" href="/2024/04/28/C&C++/Effective%20Cpp0x8/" title="EffectiveCpp0x6"><img class="cover" src="/img/cover3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-28</div><div class="info-item-2">EffectiveCpp0x6</div></div><div class="info-2"><div class="info-item-1">Customizing new and delete[toc] Understande the behavior of the new-handler.当operator new无法满足内存分配需求时，会抛出异常，用户可以通过调用set_new_handler来设置异常处理函数。 MSVC声明： 12_EXPORT_STD using new_handler = void(__CLRCALL_PURE_OR_CDECL*)();_EXPORT_STD extern &quot;C++&quot; _CRTIMP2 new_handler __cdecl set_new_handler(_In_opt_ new_handler) noexcept; 这段代码定义了new_handler类型为函数指针，并声明了set_new_handler函数，noexcept，表示不抛出异常 set_new_handler的参数是个指针，指向operator new无法分配足够内存时该被调用的函数。其返回值也是个指针，指向set_new_handler...</div></div></div></a><a class="pagination-related" href="/2024/04/24/C&C++/Effective%20Cpp0x7/" title="EffectiveCpp0x6"><img class="cover" src="/img/cover2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-24</div><div class="info-item-2">EffectiveCpp0x6</div></div><div class="info-2"><div class="info-item-1">Templates and Generic ProgrammingC++ template 机制自身是一部完整的图灵机C Turing-complete) ：它可以被用来计算任何可计算的值。于是导出了模板元编程(template metaprogramming) ，创造出“在C++编译器内执行并于编译完成时停止执行”的程序。 [toc] 41. Understand implicit interfaces and compile-time polymorphism.面向对象编程世界总是以显式接口(explicit interfaces) 和运行期多态(runtime polymorphism)解决问题。 模板反倒是反倒是隐式接口(implicit interfaces)和编译期多态(compile-time polymorphism)移到前头了。 来看以下例子： 12345678910class Widget &#123;public:  Widget();  virtual ~Widget();  virtual std::size_t size() const; ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avater.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Randolf luo</div><div class="author-info-description">今日事，今日毕</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">111</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">34</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Randolfluo" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:lrj3216610@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Effective-C"><span class="toc-number">1.</span> <span class="toc-text">Effective C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB"><span class="toc-number">1.1.</span> <span class="toc-text">导读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Accustoming-youself-to-C"><span class="toc-number">1.2.</span> <span class="toc-text">Accustoming youself to C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01-View-C-as-a-federation-of-languages"><span class="toc-number">1.2.1.</span> <span class="toc-text">01. View C++ as a federation of languages</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-Prefer-consts-enums-and-inlines-to-define"><span class="toc-number">1.2.2.</span> <span class="toc-text">02. Prefer consts,enums,and inlines to #define</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">预处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.3.</span> <span class="toc-text"> </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E4%B8%93%E5%B1%9E%E5%B8%B8%E9%87%8F"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">类专属常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AE%B0%E4%BD%8F"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">请记住</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-Use-const-whenever-possible"><span class="toc-number">1.2.4.</span> <span class="toc-text">03. Use const whenever possible</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">const成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bitwise-constness-amp-logical-constness"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">bitwise constness &amp; logical constness</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AE%B0%E4%BD%8F-1"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">请记住</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04-Make-sure-that-objects-are-initialized-before-ther%E2%80%99re-used"><span class="toc-number">1.2.5.</span> <span class="toc-text">04. Make sure that objects are initialized before ther’re used.</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#member-intialization-list"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">member intialization list</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#local-static-amp-non-local-static"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">local static &amp;  non-local static</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AE%B0%E4%BD%8F-2"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">请记住</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/11/dailyrecord/2024_11_11/" title="记一次2024ICPC杭州站"><img src="/img/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="记一次2024ICPC杭州站"/></a><div class="content"><a class="title" href="/2024/11/11/dailyrecord/2024_11_11/" title="记一次2024ICPC杭州站">记一次2024ICPC杭州站</a><time datetime="2024-11-10T16:00:00.000Z" title="发表于 2024-11-11 00:00:00">2024-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/15/math/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" title="无标题"><img src="/img/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2024/10/15/math/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" title="无标题">无标题</a><time datetime="2024-10-15T06:44:44.734Z" title="发表于 2024-10-15 14:44:44">2024-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/29/potato_clock/v0.01/" title="无标题"><img src="/img/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2024/09/29/potato_clock/v0.01/" title="无标题">无标题</a><time datetime="2024-09-29T06:08:49.443Z" title="发表于 2024-09-29 14:08:49">2024-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/26/%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%840x2/" title="无标题"><img src="/img/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2024/09/26/%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%840x2/" title="无标题">无标题</a><time datetime="2024-09-26T12:40:48.042Z" title="发表于 2024-09-26 20:40:48">2024-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/26/pr/pr%E5%85%A5%E9%97%A8/" title="无标题"><img src="/img/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2024/09/26/pr/pr%E5%85%A5%E9%97%A8/" title="无标题">无标题</a><time datetime="2024-09-26T12:40:47.924Z" title="发表于 2024-09-26 20:40:47">2024-09-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover3.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By Randolf luo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>