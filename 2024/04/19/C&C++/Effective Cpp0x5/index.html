<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>EffectiveCpp0x5 | Randolfluo's blog</title><meta name="author" content="Randolf luo"><meta name="copyright" content="Randolf luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Implementation">
<meta property="og:type" content="article">
<meta property="og:title" content="EffectiveCpp0x5">
<meta property="og:url" content="http://randolfluo.github.io/2024/04/19/C&C++/Effective%20Cpp0x5/index.html">
<meta property="og:site_name" content="Randolfluo&#39;s blog">
<meta property="og:description" content="Implementation">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.paulzzh.com/touhou/random">
<meta property="article:published_time" content="2024-04-19T14:42:00.000Z">
<meta property="article:modified_time" content="2024-04-18T16:00:00.000Z">
<meta property="article:author" content="Randolf luo">
<meta property="article:tag" content="cpp">
<meta property="article:tag" content="effective cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.paulzzh.com/touhou/random"><link rel="shortcut icon" href="/img/avater.jpg"><link rel="canonical" href="http://randolfluo.github.io/2024/04/19/C&amp;C++/Effective%20Cpp0x5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Randolf luo","link":"链接: ","source":"来源: Randolfluo's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'EffectiveCpp0x5',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avater.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/album/"><i class="fa-fw fas fa_images"></i><span> 图片</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://img.paulzzh.com/touhou/random);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Randolfluo's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">EffectiveCpp0x5</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/album/"><i class="fa-fw fas fa_images"></i><span> 图片</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">EffectiveCpp0x5</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-19T14:42:00.000Z" title="发表于 2024-04-19 22:42:00">2024-04-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-18T16:00:00.000Z" title="更新于 2024-04-19 00:00:00">2024-04-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/cpp/">cpp</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/cpp/effective-cpp/">effective cpp</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>[toc]</p>
<h3 id="26-Postpone-variable-definitions-as-long-as-possible"><a href="#26-Postpone-variable-definitions-as-long-as-possible" class="headerlink" title="26. Postpone variable definitions as long as possible."></a>26. Postpone variable definitions as long as possible.</h3><p>只要你定义了一个变量而其类型带有一个构造函数或析构函数，那么当程序的控制流(control flow) 到达这个变量定义式时，你便得承受构造成本；当这个变量离开其作用域时，你便得承受析构成本。即使这个变量最终并未被使用，仍需耗费这些成本，所以你应该尽可能避免这种情形。</p>
<h4 id="考虑一个加密函数"><a href="#考虑一个加密函数" class="headerlink" title="考虑一个加密函数"></a>考虑一个加密函数</h4><p>当抛出一个异常时（如加密字符串长度过短），则该encrypted字符串将未被使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this function defines the variable &quot;encrypted&quot; too soon</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">  string encrypted;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ...                        <span class="comment">// do whatever is necessary to place an</span></span><br><span class="line">                             <span class="comment">// encrypted version of password in encrypted</span></span><br><span class="line">  <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>延后了声明时间，但是是缺省的构造函数相较于使用含参构造函数效率较低。条款4 曾解释为什么“通过default 构造<br>函数构造出一个对象然后对它赋值”比“直接在构造时指定初值”效率差。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this function postpones encrypted&#x27;s definition until it&#x27;s truly necessary</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string encrypted;</span><br><span class="line"></span><br><span class="line">  ...                      <span class="comment">// do whatever is necessary to place an</span></span><br><span class="line">                           <span class="comment">// encrypted version of password in encrypted</span></span><br><span class="line">  <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们将构造和赋值连接起来</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this function postpones encrypted&#x27;s definition until</span></span><br><span class="line"><span class="comment">// it&#x27;s necessary, but it&#x27;s still needlessly inefficient</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...                                   <span class="comment">// check length as above</span></span><br><span class="line"></span><br><span class="line">  string encrypted;                     <span class="comment">// default-construct encrypted</span></span><br><span class="line">  encrypted = password;                 <span class="comment">// assign to encrypted</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">encrypt</span>(encrypted);</span><br><span class="line">  <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是推荐的方法：用 password 初始化 encrypted，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// finally, the best way to define and initialize encrypted</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...                                     <span class="comment">// check length</span></span><br><span class="line"></span><br><span class="line">  <span class="function">string <span class="title">encrypted</span><span class="params">(password)</span></span>;             <span class="comment">// define and initialize</span></span><br><span class="line">                                          <span class="comment">// via copy constructor</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">encrypt</span>(encrypted);</span><br><span class="line">  <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这让我们联想起本条款所谓“尽可能延后”的真正意义。你<code>不只应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初值实参为止</code>。如果这样，不仅能够避免构造（和析构）非必要对象，还可以避免无意义的default 构造行为。更深一层说，以“具明显意义之初值”将变量初始化，还可以附带说明变量的目的。</p>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Approach A: define outside loop   // Approach B: define inside loop</span></span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">  w = some value dependent on i;       <span class="function">Widget <span class="title">w</span><span class="params">(some value dependent on i)</span></span>;</span><br><span class="line">  ...                                  ...</span><br><span class="line">&#125;										&#125;</span><br></pre></td></tr></table></figure>
<p>方法 A：1 个构造函数 + 1 个析构函数 + n 个赋值。</p>
<p>方法 B：n 个构造函数 + n 个析构函数。</p>
<p>如果classes 的一个赋值成本低千一组构造＋析构成本，做法A 大体而言比较高效。尤其当n 值很大的时候。否则做法B 或许较好。此外做法A 造成名称w 的<code>作用域</code>（覆盖整个循环）比做法B 更大，有时那对程序的可理解性和易维护性造成冲突。因此除非</p>
<ol>
<li>你知道赋值成本比“构造＋析构”成本低。</li>
<li>你正在处理代码中效率高度敏感C performance-sensitive) 的部分，否则你应该使用做法B 。</li>
</ol>
<h4 id="请记住"><a href="#请记住" class="headerlink" title="请记住"></a>请记住</h4><ul>
<li>尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。</li>
</ul>
<h3 id="27-Minimize-casting"><a href="#27-Minimize-casting" class="headerlink" title="27. Minimize casting"></a>27. Minimize casting</h3><h4 id="三种不同形式的转型"><a href="#三种不同形式的转型" class="headerlink" title="三种不同形式的转型"></a>三种不同形式的转型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(T)expression	<span class="comment">//C风格</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">T</span>(expression)	<span class="comment">//函数风格</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//cpp的四大转型</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;T&gt; (expression)    	<span class="comment">//对象的常量性移除</span></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt; (expression)	<span class="comment">//执行安全的向下转型，这种转换要求至少有一个类含有虚函数，用于支持运行时类型识别（RTTI）。</span></span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt; (expression)	<span class="comment">//低级转型，允许几乎任何指针之间的转换，以及指针与足够大的整数类型之间的转换。</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt; (expression)		<span class="comment">//强迫隐式转换，基本数据类型之间的转换（如整数和浮点数）、将指针向上转换至继承层次中的基类（不进行运行时类型检查）、以及调用用户定义的转换函数。</span></span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>许多程序员相信，转型其实什么都没做，只是告诉编译器把某种类型视为另一种类型。这是错误的观念。</code>请看如下实现了多重继承：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123; <span class="keyword">public</span>: <span class="type">int</span> b1; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;&#125; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123; <span class="keyword">public</span>: <span class="type">int</span> b2; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;&#125;;</span><br><span class="line"></span><br><span class="line">					</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derived d;</span><br><span class="line">Base1* pb1 = &amp;d;  <span class="comment">// 指向 Derived 对象的开始</span></span><br><span class="line">Base2* pb2 = &amp;d;  <span class="comment">// 需要调整偏移量以正确指向 Derived 中的 Base2 部分</span></span><br><span class="line">cout &lt;&lt; &amp;d &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pb1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pb2 &lt;&lt; endl;		</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">00000022</span>C70FF730</span><br><span class="line"><span class="number">00000022</span>C70FF730</span><br><span class="line"><span class="number">00000022</span>C70FF740</span><br></pre></td></tr></table></figure>
<p>pb2的地址比pb1和&amp;d的地址多16，即一个<code>int加上虚函数指针</code>4+8=12（<code>内存对齐</code>使得其为16），但是普通函数并不占用此内存布局，多个虚函数只需要一个虚指针。</p>
<p>注意，对象的布局和地址的计算方式随编译器的不同而不同。</p>
<h4 id="不要对this指针进行转型"><a href="#不要对this指针进行转型" class="headerlink" title="不要对this指针进行转型"></a>不要对this指针进行转型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Window &#123;                                // base class</span><br><span class="line">public:</span><br><span class="line">  virtual void onResize() &#123; ... &#125;             // base onResize impl</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SpecialWindow: public Window &#123;          // derived class</span><br><span class="line">public:</span><br><span class="line">  virtual void onResize() &#123;                   // derived onResize impl;</span><br><span class="line">    static_cast&lt;Window&gt;(*this).onResize();    // cast *this to Window,</span><br><span class="line">                                              // then call its onResize;</span><br><span class="line">                                              // this doesn&#x27;t work!</span><br><span class="line">    ...                                       // do SpecialWindow-</span><br><span class="line">  &#125;                                           // specific stuff</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>强制转型创建了一个* this 的<code>基类部分的新的临时的拷贝</code>，然后调用这个拷贝的 onResize！</p>
<p>它是在“当前对象之base class 成分”的副本上调用window: :onResize, 然后在当前对象身上执行Special window 专属动作。导致的境况是那些代码使当前对象进入一种病态，没有做基类的变更，却做了派生类的变更。</p>
<p>正确做法，你应该调用当前对象的基类版本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class SpecialWindow: public Window &#123;</span><br><span class="line">public:</span><br><span class="line">  virtual void onResize() &#123;</span><br><span class="line">    Window::onResize();                    // call Window::onResize</span><br><span class="line">    ...                                    // on *this</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个例子也表明如果你发现自己要做强制转型，这就是你可能做错了某事的一个信号。在你想用 dynamic_cast 时尤其如此。</p>
<h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><ul>
<li><code>dynamic_cast</code> 的实现依赖于 RTTI 机制。RTTI 会在每个对象中存储有关对象类型的信息，包括虚函数表（vtable）等。在运行时，<code>dynamic_cast</code> 使用这些信息来进行类型检查。</li>
<li>我们为什么需要dynamic_cast：在我们只有基类指针的情况下，在我认定为的derived class对象上执行对应的操作。如：我们有一个指向基类人的指针，有两个派生类：敌人和人质。故我们需要判断，敌人就kiil掉，人质则保护他。我们可不能像<code>俄式救援</code>那样，不分敌我。</li>
</ul>
<p>同时，有两种方式可以避免使用dynamic_cast:</p>
<ol>
<li>使用存储着直接指向派生类对象的指针（通常是智能指针——参见 Item 13）的容器，从而消除通过基类接口操控这个对象的需要。如设计一个敌人容器和人质容器。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> <span class="type">int</span>&amp; x)</span><br><span class="line">        :<span class="built_in">m_name</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;看到了:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">Getname</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">enemy</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">kill</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;成功击杀敌人:&quot;</span> &lt;&lt; <span class="built_in">Getname</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hostage</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">protect</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;成功保护人质:&quot;</span> &lt;&lt; <span class="built_in">Getname</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::shared_ptr&lt;enemy&gt; &gt; Enemy_vector;</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::shared_ptr&lt;hostage&gt; &gt; Hostage_vector;</span><br><span class="line"><span class="comment">// see Item 13 for info on std::shared_ptr</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Enemy_vector e;</span><br><span class="line">    e.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;enemy&gt;(<span class="number">1</span>));</span><br><span class="line">    e.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;enemy&gt;(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    Hostage_vector h;</span><br><span class="line">    h.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;hostage&gt;(<span class="number">3</span>));</span><br><span class="line">    h.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;hostage&gt;(<span class="number">4</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = e.<span class="built_in">begin</span>(); it != e.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        (*it)-&gt;<span class="built_in">kill</span>(); <span class="comment">// 通过迭代器访问对象的成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = h.<span class="built_in">begin</span>(); it != h.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        (*it)-&gt;<span class="built_in">protect</span>(); <span class="comment">// 通过迭代器访问对象的成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在base class内提供virtual 函数做你想对各个派生类做的事，通过缺省实现。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> x) : <span class="built_in">m_name</span>(x) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;创建 Person：&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>() &#123;&#125;  <span class="comment">// 确保使用多态基类时有一个虚析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">action</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 统一接口为 action</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Enemy</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Enemy</span>(<span class="type">int</span> x) : <span class="built_in">Person</span>(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">action</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;成功击杀敌人：&quot;</span> &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hostage</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Hostage</span>(<span class="type">int</span> x) : <span class="built_in">Person</span>(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">action</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;成功保护人质：&quot;</span> &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::shared_ptr&lt;Person&gt;&gt; PersonVector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PersonVector p;</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">make_shared</span>&lt;Enemy&gt;(<span class="number">1</span>));</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">make_shared</span>&lt;Enemy&gt;(<span class="number">2</span>));</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">make_shared</span>&lt;Hostage&gt;(<span class="number">3</span>));</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">make_shared</span>&lt;Hostage&gt;(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; person : p) &#123;</span><br><span class="line">        person-&gt;<span class="built_in">action</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住"></a>请记住</h4><ul>
<li>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynarnic_cast 。</li>
<li>如果有个设计需要转型动作，试着发展无需转型的替代设计。</li>
<li>如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码内。</li>
<li>宁可使用C++-style （新式）转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的职掌。</li>
</ul>
<h3 id="28-Avoid-returning-“handles”-to-object-internals"><a href="#28-Avoid-returning-“handles”-to-object-internals" class="headerlink" title="28. Avoid returning “handles” to object internals"></a>28. Avoid returning “handles” to object internals</h3><p>//TODO</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;                      <span class="comment">// class for representing points</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> newVal)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> newVal)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RectData</span> &#123;                    <span class="comment">// Point data for a Rectangle</span></span><br><span class="line">  Point ulhc;                        <span class="comment">// ulhc = &quot; upper left-hand corner&quot;</span></span><br><span class="line">  Point lrhc;                        <span class="comment">// lrhc = &quot; lower right-hand corner&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">  <span class="function">Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::shared_ptr&lt;RectData&gt; pData;          <span class="comment">// see Item 13 for info on</span></span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">coord1</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">coord2</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Rectangle <span class="title">rec</span><span class="params">(coord1, coord2)</span></span>;     <span class="comment">// rec is a const rectangle from</span></span><br><span class="line">                                         <span class="comment">// (0, 0) to (100, 100)</span></span><br><span class="line"></span><br><span class="line">rec.<span class="built_in">upperLeft</span>().<span class="built_in">setX</span>(<span class="number">50</span>);                <span class="comment">// now rec goes from</span></span><br><span class="line">                                         <span class="comment">// (50, 0) to (100, 100)!</span></span><br></pre></td></tr></table></figure>
<ul>
<li>upperLeft 的调用者能够使用被返回的reference （指向rec 内部的Point 成员变量）来更改成员。</li>
<li>第一，成员变量的封装性最多只等于“返回其reference” 的函数的访问级别。本例之中虽然ulhc 和lrhc 都被声明为private,它们实际上却是public。</li>
<li>第二，如果const 成员函数传出一个reference, 后者所指数据与对象自身有关联，而它又被存储于对象之外，那么这个函数的调用者可以修改那笔数据。这正是<code>bitwise constness</code> 的一个附带结果，见条款3 。</li>
</ul>
<p>我们通过将返回值修改为const来防止修改对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc;&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种方法还是有问题的，若使用该引用时对象已经被销毁，会导致<code>悬垂引用（dangling references）</code>，产生未定义行为。<code>悬垂引用（dangling references）</code>指的是引用了已经被释放或无效的对象或变量的情况。还有<code>悬垂指针</code>指指向已经被释放或无效的内存地址的指针。</p>
<h4 id="请记住-2"><a href="#请记住-2" class="headerlink" title="请记住"></a>请记住</h4><ul>
<li>避免<code>返回handles （包括references 、指针、迭代器）</code>指向对象内部。遵守这个条款可增加封装性，const 成员函数的行为像个const。</li>
</ul>
<h3 id="29-Strive-for-exception-safe-code"><a href="#29-Strive-for-exception-safe-code" class="headerlink" title="29.Strive for exception-safe code."></a>29.Strive for exception-safe code.</h3><h4 id="异常安全的三种承诺"><a href="#异常安全的三种承诺" class="headerlink" title="异常安全的三种承诺"></a>异常安全的三种承诺</h4><ul>
<li><strong>基本异常安全性（Basic Exception Safety）</strong>：<ul>
<li>承诺：不会泄露资源，对象保持一致性。</li>
<li>简要描述：在发生异常时，对象的内部状态仍然保持一致，没有资源泄漏，但可能会存在部分修改未被回滚。</li>
</ul>
</li>
<li><strong>强异常安全性（Strong Exception Safety）</strong>：<ul>
<li>承诺：在发生异常时，程序状态不会改变，资源不会泄漏。</li>
<li>简要描述：无论异常发生与否，程序状态都会保持不变，对象的内部状态完全一致，没有资源泄漏。</li>
</ul>
</li>
<li><strong>无异常安全性（No-Throw or No-Except Safety）</strong>：<ul>
<li>承诺：永远不会抛出异常。</li>
<li>简要描述：在函数执行过程中不会抛出异常，即使是在异常发生的情况下也能够正常执行。这通常需要通过使用 <code>noexcept</code> 关键字来声明函数不会抛出异常。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span>;           <span class="comment">// change background</span></span><br><span class="line">  ...                                                    <span class="comment">// image</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  Mutex mutex;                    <span class="comment">// mutex for this object</span></span><br><span class="line"></span><br><span class="line">  Image *bgImage;                 <span class="comment">// current background image</span></span><br><span class="line">  <span class="type">int</span> imageChanges;               <span class="comment">// # of times image has been changed</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现一</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">lock</span>(&amp;mutex);                      <span class="comment">// acquire mutex (as in Item 14)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> bgImage;                    <span class="comment">// get rid of old background</span></span><br><span class="line">  ++imageChanges;                    <span class="comment">// update image change count</span></span><br><span class="line">  bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);       <span class="comment">// install new background</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">unlock</span>(&amp;mutex);                    <span class="comment">// release mutex</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当异常被抛出时，带有异常安全性的函数会：</p>
<ul>
<li>不泄漏任何资源。上述代码没有做到这一点，因为一旦”new Image (imgSrc)” 导致异常，对unlock 的调用就绝不会执行，于是互斥器就永远被把持住了。</li>
<li>不允许数据败坏。如果”new Image (imgSrc)” 抛出异常，gimage 就是指向一个已被删除的对象， imageChanges 也已被累加，而其实并没有新的图像被成功安装起来。</li>
</ul>
<p>由智能指针管理图像和锁，在reset成员函数旧图像被替换引用归零对象被删除，在作用域结束时，锁自动被释放。保证基本异常安全性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  std::shared_ptr&lt;Image&gt; bgImage;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">  bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc));  <span class="comment">// replace bgImage&#x27;s internal</span></span><br><span class="line">                                     <span class="comment">// pointer with the result of the</span></span><br><span class="line">                                     <span class="comment">// &quot;new Image&quot; expression</span></span><br><span class="line">  ++imageChanges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="copy-and-swap"><a href="#copy-and-swap" class="headerlink" title="copy and swap"></a>copy and swap</h4><p>通过pimpl idiom实现。实现了强异常安全性。</p>
<p><code>copy-and-swap</code> 的关键在千“修改对象数据的副本，然后在一个<code>不抛异常的函数</code>中将修改后的数据和原件置换”，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PMImpl</span> &#123;                               <span class="comment">//因为pretty的封装性使由pImpl是private得到了保证</span></span><br><span class="line">  std::shared_ptr&lt;Image&gt; bgImage;        </span><br><span class="line">  <span class="type">int</span> imageChanges;                          </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Mutex mutex;</span><br><span class="line">  std::tr1::shared_ptr&lt;PMImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> std::swap;                            <span class="comment">// see Item 25</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;                            <span class="comment">// acquire the mutex</span></span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;PMImpl&gt;                <span class="comment">// copy obj. data</span></span><br><span class="line">    <span class="built_in">pNew</span>(<span class="keyword">new</span> <span class="built_in">PMImpl</span>(*pImpl));</span><br><span class="line"></span><br><span class="line">  pNew-&gt;bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc));     <span class="comment">// modify the copy</span></span><br><span class="line">  ++pNew-&gt;imageChanges;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">swap</span>(pImpl, pNew);                          <span class="comment">// swap the new</span></span><br><span class="line">                                              <span class="comment">// data into place</span></span><br><span class="line"></span><br><span class="line">&#125;                                             <span class="comment">// release the mutex</span></span><br></pre></td></tr></table></figure>
<p>考虑如下函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void someFunc()</span><br><span class="line">&#123;</span><br><span class="line">  ...                                     // make copy of local state</span><br><span class="line">  f1();</span><br><span class="line">  f2();</span><br><span class="line">  ...                                     // swap modified state into place</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>很明显，如果 f1 或 f2 低于强力异常安全，someFunc 就很难成为强力异常安全的。例如，假设 f1 仅提供基本保证。为了让 someFunc 提供强力保证，它必须写代码在调用 f1 之前测定整个程序的状态，并捕捉来自 f1 的所有异常，然后恢复到最初的状态。</p>
</li>
<li><p>即使 f1 和 f2 都是强力异常安全的，事情也好不到哪去。如果 f1 运行完成，程序的状态已经发生了毫无疑问的变化，所以如果随后 f2 抛出一个异常，即使 f2 没有改变任何东西，程序的状态也已经和调用 someFunc 时不同。</p>
</li>
<li><p>当“强烈保证”不切实际时，你就必须提供“基本保证”。现实中你或许会发现，你可以为某些函数提供强烈保证，但效率和复杂度带来的成本会使它对许多人而言摇摇欲坠。</p>
</li>
<li><p>问题出在“连带影响”(side effects) ~如果函数只操作局部性状态(local state,例如someFunc 只影响其“调用者对象”的状态），便相对容易地提供强烈保证。但是当函数对“非局部性数据” (non-local data) 有连带影响时，提供强烈保证就困难得多。</p>
</li>
</ul>
<h4 id="请记住-3"><a href="#请记住-3" class="headerlink" title="请记住"></a>请记住</h4><ul>
<li>异常安全函数(Exception-safe functions) 即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：<code>基本型、强烈型、不抛异常型</code>。</li>
<li>“强烈保证”往往能够以copy-and-swap 实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。</li>
<li>函数提供的“异常安全保证“通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。</li>
</ul>
<h3 id="30-Understand-the-ins-and-outs-of-inlining"><a href="#30-Understand-the-ins-and-outs-of-inlining" class="headerlink" title="30. Understand the ins and outs of inlining."></a>30. Understand the ins and outs of inlining.</h3><ul>
<li>过度使用inline函数会膨胀你生成的二进制文件。</li>
<li>inline只是对编译器的一个申请，不是强制命令。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">  ...</span><br><span class="line">  int age() const &#123; return theAge; &#125;    // an implicit inline request: age is</span><br><span class="line">  ...                                   // defined in a class definition</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">  int theAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>这样的函数通常是成员函数，但是 Item 46 解释了友元函数也能被定义在类的内部，如果它们在那里，它们也被隐式地声明为 inline。</li>
</ul>
<p>例如，如果你的程序要持有一个 inline 函数的地址，编译器必须为它生成一个 outlined 函数本体。他们怎么能生成一个指向根本不存在的函数的指针呢？再加上，编译器一般不会对通过函数指针的调用进行 inline ，这就意味着，对一个 inline 函数的调用可能被也可能不被 inline 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline void f() &#123;...&#125;      // assume compilers are willing to inline calls to f</span><br><span class="line"></span><br><span class="line">void (*pf)() = f;          // pf points to f</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">f();                       // 将被inline</span><br><span class="line">pf();                      // 不被inline，因为它通过函数指针生成</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>Inline 函数通常－定被置于头文件内，因为大多数建置环境(build environments)在编译过程中进行inlining, 而为了将一个“函数调用“替换为”被调用函数的本体”，编译器必须知道那个函数长什么样子。</li>
<li>Templates 通常也被置千头文件内，因为它一旦被使用，编译器为了将它具现化，需要知道它长什么样子。</li>
<li>大部分编译器拒绝将<code>太过复杂（例如带有循环或递归</code>）的函数inlining, 而所有对<code>virtual 函数</code>的调用（除非是最平淡无奇的）也都会使inlining 落空。</li>
<li>virtual 意味”等待，直到运行期才确定调用哪个函数”，而inline 意味“执行前，先将调用动作替换为被调用函数的本体”。</li>
<li>构造函数和析构函数不适合inline，因为inline后必须处理异常，膨胀生成的二进制文件。</li>
<li>inline函数难以随程序库的升级而升级。如果你改变了内联函数的实现，必须重新编译引用了该内联函数的所有代码，以便更新这些代码中的内联函数定义。</li>
</ul>
<h4 id="请记住-4"><a href="#请记住-4" class="headerlink" title="请记住"></a>请记住</h4><ul>
<li>将大多数inlining 限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级(binary upgradability) 更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</li>
<li>不要只因为function templates 出现在头文件，就将它们声明为inline 。</li>
</ul>
<h3 id="31-Minimize-compilation-dependencies-between-files"><a href="#31-Minimize-compilation-dependencies-between-files" class="headerlink" title="31. Minimize compilation dependencies between files."></a>31. Minimize compilation dependencies between files.</h3><p>请看一个例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;date.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;address.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">         <span class="type">const</span> Address&amp; addr);</span><br><span class="line">  <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">      std::string theName;        <span class="comment">// implementation detail</span></span><br><span class="line">      Date theBirthDate;          <span class="comment">// implementation detail</span></span><br><span class="line">      Address theAddress;         <span class="comment">// implementation detail</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>当我们在<code>#include时，</code>就在Person定义文件和其含入文件之间形成了一种<code>编译依存关系(compilation dependency)</code>,如果被包含文件发生任何改动，那么包含它的源文件也需要重新编译。在大型项目中，这是致命的。</li>
<li>我们可以通过<code>预编译头文件</code>来防止重复编译相同的头文件。</li>
<li><code>cpp编译器</code>在编译期间要知道它的对象的大小。</li>
</ul>
<p>我们可以使用<code>前向声明</code>，<code>前向声明</code>是在编译时解析的，它告诉编译器某个实体的存在，但不提供其具体的实现细节。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">     <span class="keyword">class</span> <span class="title class_">string</span>;             <span class="comment">// forward declaration (an incorrect</span></span><br><span class="line">&#125;                              <span class="comment">// one — see below)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;                    <span class="comment">// forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;                 <span class="comment">// forward declaration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">                 <span class="type">const</span> Address&amp; addr);</span><br><span class="line">      <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">      <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">      <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="又是pimple-idiom"><a href="#又是pimple-idiom" class="headerlink" title="又是pimple idiom"></a>又是pimple idiom</h4><p>通过<code>pimple idiom</code>可以实现，<code>person</code>class只含有一个<code>PersonImpl</code>指针成员，指向其实现类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>                      <span class="comment">// standard library components</span></span></span><br><span class="line">                                       <span class="comment">// shouldn&#x27;t be forward-declared</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>;                      <span class="comment">// forward decl of Person impl. class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;                            <span class="comment">// forward decls of classes used in</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;                         <span class="comment">// Person interface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">        <span class="type">const</span> Address&amp; addr);</span><br><span class="line"> <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"> <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"> <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:                                   <span class="comment">// ptr to implementation;</span></span><br><span class="line">  std::shared_ptr&lt;PersonImpl&gt; pImpl;  <span class="comment">// see Item 13 </span></span><br><span class="line">&#125;;                                         </span><br></pre></td></tr></table></figure>
<ul>
<li><p>Person 的客户就完全与Dates, Addresses 以及Persons 的实现细目分离了。那些classes 的任何实现修改都不需要Person 客户端重新编译。此外由于客户无法看到Person 的实现细目，也就不可能写出什么“取决于那些细目”的代码。这真正是“接口与实现分离”!</p>
</li>
<li><p>关键在于以<code>“声明的依存性＂</code>替换<code>“定义的依存性”</code>，那正是<code>编译依存性最小化</code>的本质：现实中让头文件尽可能自我满足，万一做不到，则计它与其他文件内的声明式（而非定义式）相依。</p>
</li>
</ul>
<p>像 <code>Person</code> 这样使用 Pimpl Idiom 的类通常被称为<code>Handle classes（句柄类）</code>。Handle 类封装了指向实现类（Implementation classes）的指针，并将所有函数调用转发给实现类来完成实际的工作。Handle 类的主要作用是提供公共接口，并隐藏了实现细节，使得用户只需与 Handle 类交互而无需了解其背后的具体实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.h&quot;</span>          <span class="comment">// 我们正在实现 Person 类，所以我们必须 #include 它的类定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PersonImpl.h&quot;</span>      <span class="comment">// 我们还必须 #include PersonImpl 的类定义，否则我们无法调用其成员函数；注意，PersonImpl 与 Person 有完全相同的成员函数 — 它们的接口是相同的</span></span></span><br><span class="line"></span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">               <span class="type">const</span> Address&amp; addr)</span><br><span class="line">: <span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">PersonImpl</span>(name, birthday, addr))</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Person::name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pImpl-&gt;<span class="built_in">name</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在Handle classes 身上，成员函数必须通过implementation pointer 取得对象数据。那会为每一次访问增加一层间接性。而每一个对象消耗的内存数景必须增加implementation pointer 的大小。最后， implementation pointer 必须初始化（在Handleclass 构造函数内），指向一个动态分配得来的implementation object, 所以你将蒙受因动态内存分配（及其后的释放动作）而来的额外开销，以及遭遇bad—alloc 异常（内存不足）的可能性。</p>
<h4 id="interface-class"><a href="#interface-class" class="headerlink" title="interface class"></a>interface class</h4><p>令person称为特殊的abstract base class(抽象基类)</p>
<p>工厂函数或虚拟构造函数的概念，用于创建派生类对象并返回指向基类接口的指针。这样的设计模式允许客户端代码通过调用工厂函数来创建新对象，而无需直接使用派生类的构造函数。这种做法有助于实现<code>多态性和封装性</code>。</p>
<p>这种class 的目的是详细一一描述derived classes 的接口（见条款34) ，因此它通常不带成员变量，也没有构造函数，只有一个virtual 析构函数（见条款7) 以及一组pure virtual 函数，用来叙述整个接口。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个class 的客户必须以<code>Person 的pointers 和references</code>来撰写应用程序，因为它不可能针对“内含pure virtual 函数”的Person classes 具现出实体。（然而却有可能对派生自Person 的classes 具现出实体）就像Handle classes 的客户一样，除非Interface class 的接口被修改否则其客户不需重新编译。</p>
<p>我们可以定义<code>工厂函数</code>或<code>virtual构造函数</code>返回<code>智能指针</code>指向动态分配所得对象来为这种class创建新对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="type">static</span> std::shared_ptr&lt;Person&gt;    <span class="comment">// 返回一个 shared_ptr，指向一个用给定参数初始化的新 Person；请参阅 Item 18，了解为什么返回一个 shared_ptr</span></span><br><span class="line">   <span class="built_in">create</span>(<span class="type">const</span> std::string&amp; name,      <span class="comment">// 给定姓名的 Person 初始化</span></span><br><span class="line">          <span class="type">const</span> Date&amp; birthday,         <span class="comment">// 给定生日的 Person 初始化</span></span><br><span class="line">          <span class="type">const</span> Address&amp; addr);         <span class="comment">// 给定地址的 Person 初始化</span></span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span>: <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">             <span class="type">const</span> Address&amp; addr)</span><br><span class="line">  : <span class="built_in">theName</span>(name), <span class="built_in">theBirthDate</span>(birthday), <span class="built_in">theAddress</span>(addr)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// implementations of these </span></span><br><span class="line">  <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">// functions are not shown, but</span></span><br><span class="line">  <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;     <span class="comment">// they are easy to imagine</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string theName;</span><br><span class="line">  Date theBirthDate;</span><br><span class="line">  Address theAddress;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std::string name;</span><br><span class="line">Date dateOfBirth;</span><br><span class="line">Address address;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建支持 Person 接口的对象</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name, dateOfBirth, address))</span></span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; pp-&gt;<span class="built_in">name</span>()                 <span class="comment">// 通过 Person 接口使用对象</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot; was born on &quot;</span>            <span class="comment">// Person 接口</span></span><br><span class="line">          &lt;&lt; pp-&gt;<span class="built_in">birthDate</span>()</span><br><span class="line">          &lt;&lt; <span class="string">&quot; and now lives at &quot;</span></span><br><span class="line">          &lt;&lt; pp-&gt;<span class="built_in">address</span>();</span><br><span class="line">...                                     <span class="comment">// 当 pp 超出范围时，对象会自动被删除 — 请参见 Item 13 注释</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对这个特定的 RealPerson，写 Person::create 确实没什么价值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="type">const</span> std::string&amp; name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">const</span> Date&amp; birthday,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">const</span> Address&amp; addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> <span class="built_in">RealPerson</span>(name, birthday,addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person::create 的一个更现实的实现会创建不同派生类型的对象，依赖于诸如，其他函数的参数值，从文件或数据库读出的数据，环境变量等等。</p>
<p>至于Interface classes, 由千每个函数都是virtual, 所以你必须为每次函数调用付出一个间接跳跃(indirect jump) 成本（见条款7) 。此外Interface class 派生的对象必须内含一个vptr (virtual table pointer, 再次见条款7) ，这个指针可能会增加存放对象所需的内存数量一实际取决于这个对象除了Interface class 之外是否还有其他virtual 函数来源。</p>
<h4 id="others"><a href="#others" class="headerlink" title="others"></a>others</h4><ul>
<li><p>如果使用object references 或object pointers 可以完成任务，就不要使用objects 。你可以只靠一个类型声明式就定义出指向该类型的references 和pointers: 但如果定义某类型的objects, 就需要用到该类型的定义式。</p>
</li>
<li><p>如果能够，尽量以class 声明式替换class 定义式。注意，当你声明一个函数而它用到某个class 时，你并不需要该class 的定义；纵使函数以by value 方式传递该类型的参数（或返回值）亦然：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>; <span class="comment">// 类声明。</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>; <span class="comment">// 函数声明。此处不需要提供详细信息。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointrnents</span><span class="params">(Date d)</span></span>; <span class="comment">// 需要 Date 的定义。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>为声明式和定义式提供不同的头文件</li>
</ul>
<p>我们可以通过<code>#include</code>头文件来代替手工前置声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;datefwd.h&quot;</span>       </span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;                  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>C++提供export关键词，允许将template声明式和template 定义式分割</li>
</ul>
<h4 id="请记住-5"><a href="#请记住-5" class="headerlink" title="请记住"></a>请记住</h4><ul>
<li>支持“<code>编译依存性最小化</code>”的一般构想是：相依千声明式，不要相依于定义式。基于此构想的两个手段是Handle classes 和Interface classes 。</li>
<li>程序库头文件应该以“完全且仅有声明式”(full and declaration-only forms) 的形式存在。这种做法不论是否涉及templates 都适用。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/effective-cpp/content/0.html">Preface（前言） | Effective C++ (gitbooks.io)</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://randolfluo.github.io">Randolf luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://randolfluo.github.io/2024/04/19/C&amp;C++/Effective%20Cpp0x5/">http://randolfluo.github.io/2024/04/19/C&amp;C++/Effective%20Cpp0x5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://randolfluo.github.io" target="_blank">Randolfluo's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/cpp/">cpp</a><a class="post-meta__tags" href="/tags/effective-cpp/">effective cpp</a></div><div class="post-share"><div class="social-share" data-image="https://img.paulzzh.com/touhou/random" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/04/17/C&amp;C++/Effective%20Cpp0x4/" title="EffectiveCpp0x4"><img class="cover" src="https://api.gumengya.com/Api/DmImg?format=image" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">EffectiveCpp0x4</div></div><div class="info-2"><div class="info-item-1">[toc] Designs and Declarations18. Make  interfaces easy to use correctly and hard to use incorrectly 欲开发一个“容易被正确使用，不容易被误用”的接口，首先必须考虑客户可能做出什么样的错误。  类型系统是我们的同盟国 通过一下设计可以避免由于不同国家日期表示方式的区别而产生的错误。 1234567891011121314151617struct Day &#123;            struct Month &#123;                struct Year &#123;  explicit Day(int d)     explicit Month(int m)         explicit Year(int y)  :val(d) &#123;&#125;              :val(m) &#123;&#125;                    :val(y)&#123;&#125;  int val;               ...</div></div></div></a><a class="pagination-related" href="/2024/04/21/C&amp;C++/Effective%20Cpp0x6/" title="EffectiveCpp0x6"><img class="cover" src="http://api.yujn.cn/api/ACG.php" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">EffectiveCpp0x6</div></div><div class="info-2"><div class="info-item-1">Inheritance and Object-Oriented Design[toc]  我：请问什么是面向对象原则 ChatGPT：SOLID 是面向对象设计中的五个基本设计原则的首字母缩写，它们是：  单一职责原则（Single Responsibility Principle，SRP）： 每个类或模块应该只有一个改变的理由，即一个类应该只负责一个职责。这个原则指导我们将系统分解为小而独立的部分，每个部分都有自己的职责，使得代码更加清晰、可维护和可重用。 开放-封闭原则（Open/Closed Principle，OCP）： 软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。这意味着当需要改变系统的行为时，不应该修改已有的代码，而是应该通过扩展现有的代码来实现新的行为。这个原则鼓励使用抽象和多态性来实现系统的灵活性和可扩展性。 里氏替换原则（Liskov Substitution Principle，LSP）：...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/04/01/C&C++/Effective%20Cpp0x1/" title="EffectiveCpp0x1"><img class="cover" src="https://www.dmoe.cc/random.php" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-01</div><div class="info-item-2">EffectiveCpp0x1</div></div><div class="info-2"><div class="info-item-1">Effective C++[toc] 导读 声明式：告诉编译器某个东西的名称和类型，但是略去细节。  123templete&lt;typename T&gt;class Randolfluo;std::string Print(std::string string);  定义式：提供编译器对象、函数和模板等的实际代码本体。  初始化：给予对象值的过程。  copy构造与copy赋值:通过是否有新对象被定义区分。   Accustoming youself to C++01. View C++ as a federation of...</div></div></div></a><a class="pagination-related" href="/2024/04/03/C&C++/Effective%20Cpp0x2/" title="EffectiveCpp0x2"><img class="cover" src="https://www.dmoe.cc/random.php" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-03</div><div class="info-item-2">EffectiveCpp0x2</div></div><div class="info-2"><div class="info-item-1">Effective C+ [toc] Constructors,Destructors,and Assignment Operators05. Know what functions C++ silently writes and calls C++自动为类声明copy构造函数，copy assignment操作符和析构函数。如果没有声明构造函数，编译器会生成default构造函数。 这些函数都是public且inline的。   123456789101112131415#include&lt;iostream&gt;class Entity&#123;public:    Entity()    &#123;&#125; // Default constructor    ~Entity()   &#123;&#125; // Destructor    Entity(const Entity&amp; rhs)   &#123;&#125; // Copy constructor    Entity operator=(const Entity&amp; rhs) ...</div></div></div></a><a class="pagination-related" href="/2024/04/05/C&C++/Effective%20Cpp0x3/" title="EffectiveCpp0x3"><img class="cover" src="https://www.dmoe.cc/random.php" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="info-item-2">EffectiveCpp0x3</div></div><div class="info-2"><div class="info-item-1">[toc] Resource Management 如内存，互斥锁，数据库连接，网络sockets…… 重要的是，当你不再使用它了，应该将它还给系统。  13. Use objects to manage resources. 获得资源后立刻放进管理对象(managing object) 内。“资源取得时机便是初始化时机” (Resource Acquisition Is Initialization; RAII) 。  管理对象(managing object) 运用析构函数确保资源被释放。    为什么手动释放堆内存容易出错？ e.g: Investment * createlnvestment(); void f (){Investment* plnv = createlnvestment(); …… delete plnv; return; } //若……中有return导致提前返回，则会导致资源泄露，且不易察觉   std::auto_ptr:已被弃用。由于其拷贝时原先的指针会指向null，致潜在的资源泄漏和行为不确定性。auto_ptr 被 C++11 中引入的...</div></div></div></a><a class="pagination-related" href="/2024/04/17/C&C++/Effective%20Cpp0x4/" title="EffectiveCpp0x4"><img class="cover" src="https://api.gumengya.com/Api/DmImg?format=image" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-17</div><div class="info-item-2">EffectiveCpp0x4</div></div><div class="info-2"><div class="info-item-1">[toc] Designs and Declarations18. Make  interfaces easy to use correctly and hard to use incorrectly 欲开发一个“容易被正确使用，不容易被误用”的接口，首先必须考虑客户可能做出什么样的错误。  类型系统是我们的同盟国 通过一下设计可以避免由于不同国家日期表示方式的区别而产生的错误。 1234567891011121314151617struct Day &#123;            struct Month &#123;                struct Year &#123;  explicit Day(int d)     explicit Month(int m)         explicit Year(int y)  :val(d) &#123;&#125;              :val(m) &#123;&#125;                    :val(y)&#123;&#125;  int val;               ...</div></div></div></a><a class="pagination-related" href="/2024/04/24/C&C++/Effective%20Cpp0x7/" title="EffectiveCpp0x6"><img class="cover" src="https://www.dmoe.cc/random.php" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-24</div><div class="info-item-2">EffectiveCpp0x6</div></div><div class="info-2"><div class="info-item-1">Templates and Generic ProgrammingC++ template 机制自身是一部完整的图灵机C Turing-complete) ：它可以被用来计算任何可计算的值。于是导出了模板元编程(template metaprogramming) ，创造出“在C++编译器内执行并于编译完成时停止执行”的程序。 [toc] 41. Understand implicit interfaces and compile-time polymorphism.面向对象编程世界总是以显式接口(explicit interfaces) 和运行期多态(runtime polymorphism)解决问题。 模板反倒是反倒是隐式接口(implicit interfaces)和编译期多态(compile-time polymorphism)移到前头了。 来看以下例子： 12345678910class Widget &#123;public:  Widget();  virtual ~Widget();  virtual std::size_t size() const; ...</div></div></div></a><a class="pagination-related" href="/2024/04/28/C&C++/Effective%20Cpp0x8/" title="EffectiveCpp0x6"><img class="cover" src="https://www.dmoe.cc/random.php" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-28</div><div class="info-item-2">EffectiveCpp0x6</div></div><div class="info-2"><div class="info-item-1">Customizing new and delete[toc] Understande the behavior of the new-handler.当operator new无法满足内存分配需求时，会抛出异常，用户可以通过调用set_new_handler来设置异常处理函数。 MSVC声明： 12_EXPORT_STD using new_handler = void(__CLRCALL_PURE_OR_CDECL*)();_EXPORT_STD extern &quot;C++&quot; _CRTIMP2 new_handler __cdecl set_new_handler(_In_opt_ new_handler) noexcept; 这段代码定义了new_handler类型为函数指针，并声明了set_new_handler函数，noexcept，表示不抛出异常 set_new_handler的参数是个指针，指向operator new无法分配足够内存时该被调用的函数。其返回值也是个指针，指向set_new_handler...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avater.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Randolf luo</div><div class="author-info-description">今日事，今日毕</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Randolfluo" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:lrj3216610@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Implementation"><span class="toc-number">1.</span> <span class="toc-text">Implementation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#26-Postpone-variable-definitions-as-long-as-possible"><span class="toc-number">1.0.1.</span> <span class="toc-text">26. Postpone variable definitions as long as possible.</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E8%99%91%E4%B8%80%E4%B8%AA%E5%8A%A0%E5%AF%86%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">考虑一个加密函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AE%B0%E4%BD%8F"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">请记住</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-Minimize-casting"><span class="toc-number">1.0.2.</span> <span class="toc-text">27. Minimize casting</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E5%BD%A2%E5%BC%8F%E7%9A%84%E8%BD%AC%E5%9E%8B"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">三种不同形式的转型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E5%AF%B9this%E6%8C%87%E9%92%88%E8%BF%9B%E8%A1%8C%E8%BD%AC%E5%9E%8B"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">不要对this指针进行转型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dynamic-cast"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">dynamic_cast</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AE%B0%E4%BD%8F-1"><span class="toc-number">1.0.2.4.</span> <span class="toc-text">请记住</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-Avoid-returning-%E2%80%9Chandles%E2%80%9D-to-object-internals"><span class="toc-number">1.0.3.</span> <span class="toc-text">28. Avoid returning “handles” to object internals</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AE%B0%E4%BD%8F-2"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">请记住</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-Strive-for-exception-safe-code"><span class="toc-number">1.0.4.</span> <span class="toc-text">29.Strive for exception-safe code.</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%89%BF%E8%AF%BA"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">异常安全的三种承诺</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#copy-and-swap"><span class="toc-number">1.0.4.2.</span> <span class="toc-text">copy and swap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AE%B0%E4%BD%8F-3"><span class="toc-number">1.0.4.3.</span> <span class="toc-text">请记住</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-Understand-the-ins-and-outs-of-inlining"><span class="toc-number">1.0.5.</span> <span class="toc-text">30. Understand the ins and outs of inlining.</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AE%B0%E4%BD%8F-4"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">请记住</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-Minimize-compilation-dependencies-between-files"><span class="toc-number">1.0.6.</span> <span class="toc-text">31. Minimize compilation dependencies between files.</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%88%E6%98%AFpimple-idiom"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">又是pimple idiom</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#interface-class"><span class="toc-number">1.0.6.2.</span> <span class="toc-text">interface class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#others"><span class="toc-number">1.0.6.3.</span> <span class="toc-text">others</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AE%B0%E4%BD%8F-5"><span class="toc-number">1.0.6.4.</span> <span class="toc-text">请记住</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.0.7.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/18/%E9%A2%98%E8%A7%A3/The%2018th%20Zhejiang%20Provincial%20Collegiate%20Programming%20Contest/" title="The 18th Zhejiang Provincial Collegiate Programming Contest"><img src="https://www.dmoe.cc/random.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="The 18th Zhejiang Provincial Collegiate Programming Contest"/></a><div class="content"><a class="title" href="/2025/04/18/%E9%A2%98%E8%A7%A3/The%2018th%20Zhejiang%20Provincial%20Collegiate%20Programming%20Contest/" title="The 18th Zhejiang Provincial Collegiate Programming Contest">The 18th Zhejiang Provincial Collegiate Programming Contest</a><time datetime="2025-04-17T16:00:00.000Z" title="发表于 2025-04-18 00:00:00">2025-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/14/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC7%E7%AB%A0-%E6%9F%A5%E6%89%BE/" title="无标题"><img src="http://api.yujn.cn/api/ACG.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2025/04/14/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC7%E7%AB%A0-%E6%9F%A5%E6%89%BE/" title="无标题">无标题</a><time datetime="2025-04-14T02:09:58.968Z" title="发表于 2025-04-14 10:09:58">2025-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/14/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC5%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构-第5章—树与二叉树"><img src="https://www.dmoe.cc/random.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构-第5章—树与二叉树"/></a><div class="content"><a class="title" href="/2025/04/14/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC5%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构-第5章—树与二叉树">数据结构-第5章—树与二叉树</a><time datetime="2025-04-13T16:00:00.000Z" title="发表于 2025-04-14 00:00:00">2025-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/13/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" title="线段树与树状数组"><img src="https://api.mtyqx.cn/tapi/random.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线段树与树状数组"/></a><div class="content"><a class="title" href="/2025/04/13/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" title="线段树与树状数组">线段树与树状数组</a><time datetime="2025-04-13T09:42:00.000Z" title="发表于 2025-04-13 17:42:00">2025-04-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/13/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC6%E7%AB%A0-%E5%9B%BE/" title="数据结构-第6章—图"><img src="https://www.dmoe.cc/random.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构-第6章—图"/></a><div class="content"><a class="title" href="/2025/04/13/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC6%E7%AB%A0-%E5%9B%BE/" title="数据结构-第6章—图">数据结构-第6章—图</a><time datetime="2025-04-12T16:00:00.000Z" title="发表于 2025-04-13 00:00:00">2025-04-13</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://img.paulzzh.com/touhou/random);"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By Randolf luo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>