<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>malloclab | Randolfluo's blog</title><meta name="author" content="Randolf luo"><meta name="copyright" content="Randolf luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="csapp">
<meta property="og:type" content="article">
<meta property="og:title" content="malloclab">
<meta property="og:url" content="http://randolfluo.github.io/2024/06/25/csapp/malloclab/index.html">
<meta property="og:site_name" content="Randolfluo&#39;s blog">
<meta property="og:description" content="csapp">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://randolfluo.github.io/img/cover2.jpg">
<meta property="article:published_time" content="2024-06-25T14:42:00.000Z">
<meta property="article:modified_time" content="2024-06-24T16:00:00.000Z">
<meta property="article:author" content="Randolf luo">
<meta property="article:tag" content="csapp">
<meta property="article:tag" content="lab">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://randolfluo.github.io/img/cover2.jpg"><link rel="shortcut icon" href="/img/avater.jpg"><link rel="canonical" href="http://randolfluo.github.io/2024/06/25/csapp/malloclab/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Randolf luo","link":"链接: ","source":"来源: Randolfluo's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'malloclab',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avater.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">111</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">35</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Randolfluo's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">malloclab</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">malloclab</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-25T14:42:00.000Z" title="发表于 2024-06-25 22:42:00">2024-06-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-24T16:00:00.000Z" title="更新于 2024-06-25 00:00:00">2024-06-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/csapp/">csapp</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/csapp/lab/">lab</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="0x1-介绍"><a href="#0x1-介绍" class="headerlink" title="0x1 介绍"></a>0x1 介绍</h3><p>可以从手册得知，我们需要修改mm.c里面的三个函数<code>mm_malloc</code>、<code>mm_free</code>、<code>mm_realloc</code>来实现堆的相关功能。教师们为我们编写了如此庞大的测试环境，那么我们也要认真完成它。</p>
<p>由于lab自带的版本是每次请求时都执行sbrk系统调用。我们知道，系统调用会是陷入内核，花费大量时间，那么接下来我们要做的就是减少系统调用的次数。</p>
<p>下图为自带版本的测试，可以看到内存利用率并不高 ，并且有部分测试并未通过。</p>
<img src="/2024/06/25/csapp/malloclab/2381702efc279d861c60746cbe12ca7b.png" class="" title="80a87295cf1969b7c18f2a6d91758d9">
<h3 id="0x2-隐式空闲列表"><a href="#0x2-隐式空闲列表" class="headerlink" title="0x2 隐式空闲列表"></a>0x2 隐式空闲列表</h3><p>我们进行第一次修改，为其实现一个简单的分配器。</p>
<p>注意事项：</p>
<ul>
<li><p>这里的块指针bp指向第一个有效载荷</p>
</li>
<li><p>可以利用宏定义将复杂操作定义为类似函数操作的方法（PS：在预处理期间替换，而函数内联等操作则在编译期替换）</p>
</li>
<li><p>sbrk返回值</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>(void *)-1</td>
<td>调用失败，无法扩展数据段。通常伴随设置<code>errno</code>来描述具体错误。</td>
</tr>
<tr>
<td>非空指针</td>
<td>调用成功，返回指向数据段新分配空间的指针。</td>
</tr>
</tbody>
</table>
</div>
<p>首先是宏定义，宏定义可以简化操作，避免一些难以察觉的错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* single word (4) or double word (8) alignment */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* rounds up to the nearest multiple of ALIGNMENT */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT - 1)) &amp; ~0x7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p) (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val) (*(unsigned int *)(p) = (val))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp) ((char *)(bp)-WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE((char *)(bp)-WSIZE))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp) ((char *)(bp)-GET_SIZE((char *)(bp)-DSIZE))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size, alloc) ((size) | (alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *heap_listp = <span class="number">0</span>; <span class="comment">//初始堆地址</span></span><br></pre></td></tr></table></figure>
<p>手册提到，我们可以实现mm_check来检查内存分配器是否在工作。</p>
<p>这里我实现了两个日志函数，<code>log_message_function</code>用来记录函数执行顺序，<code>mm_check</code>用来打印空闲链表，这里的日志会严重影响运行速度，于是使用宏来控制日志的开关。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  #define DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_message(fmt, ...) log_message_function(fmt, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm_check() mm_check_function()</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_message(fmt, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm_check()</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">log_message_function</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">  FILE *file;</span><br><span class="line">  file = fopen(<span class="string">&quot;log.log&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">  va_list args;</span><br><span class="line">  va_start(args, fmt);</span><br><span class="line">  <span class="built_in">vfprintf</span>(file, fmt, args);</span><br><span class="line">  va_end(args);</span><br><span class="line">  fclose(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">mm_check_function</span><span class="params">()</span> &#123;</span><br><span class="line">  FILE *file;</span><br><span class="line">  file = fopen(<span class="string">&quot;log.log&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (file == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(file, <span class="string">&quot;---------------------链表----------------------&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(file, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="type">char</span> *p = heap_listp;</span><br><span class="line">  <span class="keyword">while</span> (GET_SIZE(HDRP(p)) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(p));</span><br><span class="line">    <span class="type">size_t</span> alloc = GET_ALLOC(HDRP(p));</span><br><span class="line">    <span class="built_in">fprintf</span>(file, <span class="string">&quot;pointer：%p   size:%d    alloc:%d\n&quot;</span>, p, size, alloc);</span><br><span class="line">    p = NEXT_BLKP(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">fprintf</span>(file, <span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(file, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (fclose(file) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化堆空间，主要是分配头部和脚部，使其符合空闲链表的组织方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((heap_listp = mem_sbrk(<span class="number">4</span> * WSIZE)) == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  PUT(heap_listp, <span class="number">0</span>);</span><br><span class="line">  PUT(heap_listp + (<span class="number">1</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">  PUT(heap_listp + (<span class="number">2</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">  PUT(heap_listp + (<span class="number">3</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">  heap_listp += (<span class="number">4</span> * WSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (extend_heap(CHUNKSIZE / WSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>mm_malloc</strong>：首先要将要分配的空间大小进行8字节对齐，调用<code>find_fit</code>函数：</p>
<ul>
<li>当有空闲空间时，调用<code>place()</code>函数，将此块标记为已分配。</li>
<li>当无空闲空间时，调用 <code>extend_heap</code>函数，增加并合并堆内存，然后调用<code>place()</code>函数。</li>
</ul>
<p><strong>mm_free:</strong></p>
<ul>
<li>将已分配的块标记为空闲块，然后调用<code>coalesce()</code>函数，按照下图四种情况进行合并。</li>
</ul>
<img src="/2024/06/25/csapp/malloclab/5ce1a25c8e2034b4be292d2126cc3fbf.png" class="" title="image-20240626234600066">
<p><strong>mm_realloc:</strong></p>
<ul>
<li>按照参数输入的不同执行不同的操作。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span> &#123;</span><br><span class="line"></span><br><span class="line">  log_message(<span class="string">&quot;malloc %d\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> asize = ALIGN(size + SIZE_T_SIZE); <span class="comment">//加入头部尾部并对齐</span></span><br><span class="line">  <span class="type">size_t</span> extendsize;</span><br><span class="line">  <span class="type">char</span> *bp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    log_message(<span class="string">&quot;malloc:success! pointer:%p   size:%d     alloc:%d  \n\n&quot;</span>, bp,</span><br><span class="line">                GET_SIZE(HDRP(bp)), GET_ALLOC(HDRP(bp)));</span><br><span class="line">    mm_check();</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    extendsize = MAX(CHUNKSIZE, asize);</span><br><span class="line">    log_message(<span class="string">&quot;We need %d!!!\n&quot;</span>, extendsize);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendsize / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      place(bp, asize);</span><br><span class="line">      log_message(<span class="string">&quot;malloc:success! pointer:%p   size:%d     alloc:%d  \n\n&quot;</span>, bp,</span><br><span class="line">                  GET_SIZE(HDRP(bp)), GET_ALLOC(HDRP(bp)));</span><br><span class="line">      mm_check();</span><br><span class="line">      <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line">  PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">  PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">  coalesce(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> oldsize;</span><br><span class="line">  <span class="type">void</span> *newptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">    mm_free(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> mm_malloc(size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  newptr = mm_malloc(size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!newptr) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  oldsize = GET_SIZE(HDRP(ptr));</span><br><span class="line">  <span class="keyword">if</span> (size &lt; oldsize)</span><br><span class="line">    oldsize = size;</span><br><span class="line">  <span class="built_in">memcpy</span>(newptr, ptr, oldsize);</span><br><span class="line"></span><br><span class="line">  mm_free(ptr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来的则是各种子函数，主要是注意堆操作的方式，仔细检查。在这里，log_message()可以帮助我们调试，快速确定合并方式，执行结果，函数执行顺序等重要方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> prev_alloc = GET_ALLOC(HDRP(PREV_BLKP(bp)));</span><br><span class="line">  <span class="type">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">  <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc) &#123; <span class="comment">/* case 1 */</span></span><br><span class="line">    log_message(<span class="string">&quot;coalesce: case 1   pointer:%p\n&quot;</span>, bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc) &#123; <span class="comment">/* case 2 */</span></span><br><span class="line">    size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    log_message(<span class="string">&quot;coalesce: case 2   pointer:%p\n&quot;</span>, bp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc) &#123; <span class="comment">/* case 3 */</span></span><br><span class="line">    size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    bp = PREV_BLKP(bp);</span><br><span class="line"></span><br><span class="line">    log_message(<span class="string">&quot;coalesce: case 3   pointer:%p\n&quot;</span>, bp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; !next_alloc) &#123; <span class="comment">/* case 4 */</span></span><br><span class="line">    size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">    PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    log_message(<span class="string">&quot;coalesce: case 4   pointer:%p\n&quot;</span>, bp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">char</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> asize)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *p = heap_listp;</span><br><span class="line">  <span class="keyword">while</span> (GET_SIZE(HDRP(p)) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(p));</span><br><span class="line">    <span class="type">size_t</span> alloc = GET_ALLOC(HDRP(p));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!alloc &amp;&amp; size &gt;= asize) &#123;</span><br><span class="line">      log_message(<span class="string">&quot;fit_block   poniter:%p size:%d   alloc:%d\n&quot;</span>, p, size,</span><br><span class="line">                  alloc);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = NEXT_BLKP(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">size_t</span> asize)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line">  <span class="keyword">if</span> ((size - asize) &gt;= (<span class="number">2</span> * DSIZE)) &#123;</span><br><span class="line">    PUT(HDRP(ptr), PACK(asize, <span class="number">1</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(asize, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    ptr = NEXT_BLKP(ptr);</span><br><span class="line">    PUT(HDRP(ptr), PACK(size - asize, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size - asize, <span class="number">0</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">1</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *bp;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  size = (words % <span class="number">2</span>) ? ((words + <span class="number">1</span>) * WSIZE) : (words * WSIZE); <span class="comment">//写反了</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">  PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">  PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">  log_message(<span class="string">&quot;extend_heap:   pointer:%p  size:%d \n&quot;</span>, bp, size);</span><br><span class="line">  <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们来测试一下，可以看到我们的分数成功来到了64分！</p>
<img src="/2024/06/25/csapp/malloclab/53e13495d7280199cf81ad5e4152d842.png" class="" title="image-20240626222745331">
<h3 id="0x3-显式空闲列表"><a href="#0x3-显式空闲列表" class="headerlink" title="0x3 显式空闲列表"></a>0x3 显式空闲列表</h3><p>接下来进行我们的改进！在<code>空闲块</code>内添加前驱后继指针，当需要空闲块时，直接通过指针直接访问下一节点，而不是需要先获取头部信息计算偏移。这种方法可以加快分配速度，但是在释放块时需要线性时间来搜索前驱。那么这样到底可以提升多少访问速度呢，我们使用后进先出的LIFO顺序维护链表。</p>
<img src="/2024/06/25/csapp/malloclab/ab6bf107873419f3905243660536576d.png" class="" title="image-20240626225807142">
<p>利用宏定义来快速获取和放置前驱和后继指针， 同时定义插入和删除函数，简化对链表的操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取指针 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_PRED(bp) (*(char **)(bp))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SUCC(bp) (*(char **)((char *)(bp) + WSIZE))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 放置指针 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT_PRED(bp, pred) (*(char **)(bp) = (pred))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT_SUCC(bp, succ) (*(char **)((char *)(bp) + WSIZE) = (succ))</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *free_listp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_free_block</span><span class="params">(<span class="type">char</span> *bp)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (free_listp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PUT_PRED(bp, <span class="literal">NULL</span>);</span><br><span class="line">        PUT_SUCC(bp, free_listp);</span><br><span class="line">        PUT_PRED(free_listp, bp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PUT_PRED(bp, <span class="literal">NULL</span>);</span><br><span class="line">        PUT_SUCC(bp, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    free_listp = bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">remove_free_block</span><span class="params">(<span class="type">char</span> *bp)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *pred = GET_PRED(bp);</span><br><span class="line">  <span class="type">char</span> *succ = GET_SUCC(bp);</span><br><span class="line">  <span class="comment">//当前块不为列表头部</span></span><br><span class="line">  <span class="keyword">if</span> (pred != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    PUT_SUCC(pred, succ);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    free_listp = succ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断是否有后继，将前驱添加到后继中</span></span><br><span class="line">  <span class="keyword">if</span> (succ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    PUT_PRED(succ, pred);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写<code>mm_check_function()</code>检测空闲链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span>  <span class="type">void</span> <span class="title function_">mm_check_function</span><span class="params">()</span> &#123;</span><br><span class="line">  FILE *file;</span><br><span class="line">  file = fopen(<span class="string">&quot;log.log&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *p = free_listp;</span><br><span class="line">  <span class="built_in">fprintf</span>(file, <span class="string">&quot;\n\n====================空闲链表======================\n&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(p));</span><br><span class="line">    <span class="type">size_t</span> alloc = GET_ALLOC(HDRP(p));</span><br><span class="line">    <span class="built_in">fprintf</span>(file, <span class="string">&quot;pointer：%p  pre:%p   succ:%p  size:%d    alloc:%d\n&quot;</span>, p,GET_PRED(p), GET_SUCC(p), size, alloc);</span><br><span class="line">    p = GET_SUCC(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">fprintf</span>(file, <span class="string">&quot;\n====================空闲链表======================\n\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fclose(file) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现的三大函数只需在free时将空闲块加入空闲链表即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_init - initialize the malloc package.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((heap_listp = mem_sbrk(<span class="number">4</span> * WSIZE)) == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  PUT(heap_listp, <span class="number">0</span>);</span><br><span class="line">  PUT(heap_listp + (<span class="number">1</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">  PUT(heap_listp + (<span class="number">2</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">  PUT(heap_listp + (<span class="number">3</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">  heap_listp += (<span class="number">4</span> * WSIZE);</span><br><span class="line">     free_listp = <span class="literal">NULL</span>;  <span class="comment">// 初始化 free_listp</span></span><br><span class="line">  <span class="keyword">if</span> (extend_heap(CHUNKSIZE / WSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span></span><br><span class="line"><span class="comment"> *     Always allocate a block whose size is a multiple of the alignment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span> &#123;</span><br><span class="line"></span><br><span class="line">  log_message(<span class="string">&quot;malloc %d\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> asize = ALIGN(size + SIZE_T_SIZE); <span class="comment">//加入头部尾部并对齐</span></span><br><span class="line">  <span class="type">size_t</span> extendsize;</span><br><span class="line">  <span class="type">char</span> *bp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    log_message(<span class="string">&quot;malloc:success! pointer:%p   size:%d     alloc:%d  \n\n&quot;</span>, bp,</span><br><span class="line">                GET_SIZE(HDRP(bp)), GET_ALLOC(HDRP(bp)));</span><br><span class="line">    mm_check();</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    extendsize = MAX(CHUNKSIZE, asize);</span><br><span class="line">    log_message(<span class="string">&quot;We need %d!!!\n&quot;</span>, extendsize);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendsize / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      place(bp, asize);</span><br><span class="line">      log_message(<span class="string">&quot;malloc:success! pointer:%p   size:%d     alloc:%d  \n\n&quot;</span>, bp,</span><br><span class="line">                  GET_SIZE(HDRP(bp)), GET_ALLOC(HDRP(bp)));</span><br><span class="line">      mm_check();</span><br><span class="line">      <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Freeing a block does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line">  PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">  PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">  insert_free_block(ptr);</span><br><span class="line">  coalesce(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> oldsize;</span><br><span class="line">  <span class="type">void</span> *newptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">    mm_free(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> mm_malloc(size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  newptr = mm_malloc(size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!newptr) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  oldsize = GET_SIZE(HDRP(ptr));</span><br><span class="line">  <span class="keyword">if</span> (size &lt; oldsize)</span><br><span class="line">    oldsize = size;</span><br><span class="line">  <span class="built_in">memcpy</span>(newptr, ptr, oldsize);</span><br><span class="line"></span><br><span class="line">  mm_free(ptr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意区分已分配的块和未分配的块，</p>
<p><strong>只有未分配的块才需要添加前驱和后继指针，已分配的块需要及时去除前驱和后继指针。</strong></p>
<p>coalesce函数不同情况的空闲块都需要先删除指针后重新分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span>  <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> prev_alloc = GET_ALLOC(HDRP(PREV_BLKP(bp)));</span><br><span class="line">  <span class="type">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">  <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc) &#123; <span class="comment">/* case 1 */</span></span><br><span class="line">    log_message(<span class="string">&quot;coalesce: case 1   pointer:%p\n&quot;</span>, bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc) &#123; <span class="comment">/* case 2 */</span></span><br><span class="line">    size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    remove_free_block(bp);</span><br><span class="line">    remove_free_block(NEXT_BLKP(bp));</span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    insert_free_block(bp);</span><br><span class="line">    log_message(<span class="string">&quot;coalesce: case 2   pointer:%p\n&quot;</span>, bp);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc) &#123; <span class="comment">/* case 3 */</span></span><br><span class="line">    remove_free_block(bp);</span><br><span class="line">    remove_free_block(PREV_BLKP(bp));</span><br><span class="line">    size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    insert_free_block(PREV_BLKP(bp));</span><br><span class="line">    bp = PREV_BLKP(bp);</span><br><span class="line">    log_message(<span class="string">&quot;coalesce: case 3   pointer:%p\n&quot;</span>, bp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; !next_alloc) &#123; <span class="comment">/* case 4 */</span></span><br><span class="line">    remove_free_block(PREV_BLKP(bp));</span><br><span class="line">    remove_free_block(bp);</span><br><span class="line">    remove_free_block(NEXT_BLKP(bp));</span><br><span class="line">    size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">    PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    bp = PREV_BLKP(bp);</span><br><span class="line">    insert_free_block(bp);</span><br><span class="line">    log_message(<span class="string">&quot;coalesce: case 4   pointer:%p\n&quot;</span>, bp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">char</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> asize)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *p = free_listp;</span><br><span class="line">  <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(p));</span><br><span class="line">    <span class="type">size_t</span> alloc = GET_ALLOC(HDRP(p));</span><br><span class="line">    <span class="keyword">if</span> (!alloc &amp;&amp; size &gt;= asize) &#123;</span><br><span class="line">      log_message(<span class="string">&quot;fit_block   poniter:%p size:%d   alloc:%d\n&quot;</span>, p, size, alloc);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    p = GET_SUCC(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">size_t</span> asize)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line">  <span class="keyword">if</span> ((size - asize) &gt;= (<span class="number">2</span> * DSIZE)) &#123;</span><br><span class="line">    PUT(HDRP(ptr), PACK(asize, <span class="number">1</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(asize, <span class="number">1</span>));</span><br><span class="line">    remove_free_block(ptr);   <span class="comment">// 将已分配的块从空闲块列表中移除</span></span><br><span class="line">    <span class="type">char</span> *next_ptr = NEXT_BLKP(ptr);</span><br><span class="line">    PUT(HDRP(next_ptr), PACK(size - asize, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(next_ptr), PACK(size - asize, <span class="number">0</span>));   </span><br><span class="line">    insert_free_block(next_ptr);    <span class="comment">// 将剩余的部分作为空闲块插入列表</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">1</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">1</span>));</span><br><span class="line">    remove_free_block(ptr);   <span class="comment">// 将已分配的块从空闲块列表中移除</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *bp;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  size = (words % <span class="number">2</span>) ? ((words + <span class="number">1</span>) * WSIZE) : (words * WSIZE); <span class="comment">//写反了</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">  PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">  PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">  log_message(<span class="string">&quot;extend_heap:   pointer:%p  size:%d \n&quot;</span>, bp, size);</span><br><span class="line">  insert_free_block(bp);</span><br><span class="line">  mm_check();</span><br><span class="line">  <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到虽然内存利用率有些许下降，但是我们分配速度得到了快速的提升！！！那么，82也算是优秀了吧(👉ﾟヮﾟ)👉。</p>
<img src="/2024/06/25/csapp/malloclab/d700b1d2a93e5f569f51b2dacf8a4e20.png" class="" title="image-20240627211854640">
<h3 id="0x4分离空闲列表"><a href="#0x4分离空闲列表" class="headerlink" title="0x4分离空闲列表"></a>0x4分离空闲列表</h3><p>将不同大小的空闲列表分割，将分配时查找空闲块的时间变为匹配不同大小链表的时间，当空闲块很多时，可以显著提高分配器的效率。</p>
<p>这里先标记为TODO，希望以后有时间会回来做。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://randolfluo.github.io">Randolf luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://randolfluo.github.io/2024/06/25/csapp/malloclab/">http://randolfluo.github.io/2024/06/25/csapp/malloclab/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://randolfluo.github.io" target="_blank">Randolfluo's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/csapp/">csapp</a><a class="post-meta__tags" href="/tags/lab/">lab</a></div><div class="post-share"><div class="social-share" data-image="/img/cover2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/05/24/js/javascript%20%E5%AF%B9%E8%B1%A1/" title="JavaScript学习记录0x2"><img class="cover" src="/img/cover3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">JavaScript学习记录0x2</div></div><div class="info-2"><div class="info-item-1">4.1 对象构造对象的方法 12let user = new Object(); // “构造函数” 的语法let user = &#123;&#125;;  // “字面量” 的语法 文本和属性123456789101112131415let user = &#123;    name: &quot;Randolfluo&quot;,    &quot;Nian lin&quot;: 20&#125;;alert(user.name);user.country = &quot;China&quot;  // 添加属性alert(user.country);delete user.country;        // 删除属性alert(user.country);      //undefineduser[&quot;Nian lin&quot;] = 18;   //有空格或者数字开头的属性，需要用中括号                        //这里的Nian lin可以由程序运行时计算得出 方括号12345678//因此我们实现返回用户需要的属性值let...</div></div></div></a><a class="pagination-related" href="/2024/06/28/OS/xv6_0x1/" title="XV6 0x1"><img class="cover" src="/img/cover1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">XV6 0x1</div></div><div class="info-2"><div class="info-item-1">lab1xv6地址：6.S081 / Fall 2020 (mit.edu) 环境配置：Mit6.s081环境配置踩坑之旅WSL2+VScode_mit6s081-CSDN博客 视频链接：MIT 6.S081 2020 操作系统 [中英文字幕]_哔哩哔哩_bilibili 译文：mit-public-courses-cn-translatio.gitbook.io 参考：课程介绍 · 6.S081 All-In-One (dgs.zone) xv6做的比较快，主要是较难lab参考了dalao得。（PS：主要是自己能力就这，能完成中低难度的lab已经是万幸了）   Design is sort of high level structure, and implementation is really about what the code looks like.  设计是一种高层次的结构，而实现则是关于代码真正的样子  OS Purpose：  ABSTRACT MULTIPLEX ISOLATION SHARING SECURITY PERFORMANCE RANGE OF...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/12/03/csapp/bomblab/" title="bomblab"><img class="cover" src="/img/cover3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-03</div><div class="info-item-2">bomblab</div></div><div class="info-2"><div class="info-item-1">bomblab开始愉快的拆除炸弹吧，（bushi） 通过这次实验可以基本掌握gdb的使用，这次使用了pwndgb插件 可以使用objdump查看反汇编程序，也可以在gdb里使用disassemble反汇编 超详细的wpCSAPP | Lab2-Bomb Lab 深入解析 - 知乎 (zhihu.com)  pwndgb的基本指令    指令 效果     s 单步步入   n 单步步过   r 重新运行   c 继续运行   i b, i r 查看断点、寄存器   return 退出当前函数   search 114514 查找114514   b *0x114514  ， b fun_name 在0x114514处下断点、在函数fun_name处下断点   delete ，delete 114514 删除所有断点，删除114514号断点   disassemble main 反汇编main函数   vmmap 显示进程的内存映射   cyclic 50 生成50个用来溢出的字符   cyclic -l   字符串 定位字符串再溢出字符的位置   p...</div></div></div></a><a class="pagination-related" href="/2024/04/06/csapp/shlab/" title="shlab"><img class="cover" src="/img/cover3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-06</div><div class="info-item-2">shlab</div></div><div class="info-2"><div class="info-item-1">shlab 这个lab主要是考察信号的使用，还有进程创建的知识。  首先回顾一下信号处理程序的终点：  处理程序要尽可能简单。 在处理程序中只调用异步信号安全的函数。(可重入的且不能被信号处理程序中断)。 在进入处理程序时把errno 保存在某个局部变最中，在处理程序返回前恢复它。 阻塞所有的信号，保护对共享全局数据结构的访问。  首先是参数解析执行，在子进程创建过程中，设置和解除阻塞的SIGCHLD信号来避免进程在添加进job组前终止导致把不存在的子进程添加到作业列表中，书上已经给我们例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void eval(char *cmdline) &#123;    char *argv[MAXARGS] = &#123;NULL&#125;;       //初始化指针地址    int fg_bg;    pid_t pid;        sigset_t mask_all, mask_one,...</div></div></div></a><a class="pagination-related" href="/2023/12/07/csapp/attacklab/" title="attacklab"><img class="cover" src="/img/cover1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-07</div><div class="info-item-2">attacklab</div></div><div class="info-2"><div class="info-item-1">Part I: Code Injection Attacks开冲！！ level1 sub rsp,0x28说明缓冲区有0x28即40字节，我们只需在这之后加入touch1()函数的权限地址来提权。 gets()函数不会对输入大小进行检查，遇到\n0x0a结束字符串读取  touch1地址为0x4017c0  payload(注意不能填充0a)，同时小端序要倒序存储(低地址存放数据低位，高地址存放数据高位)  12345600 00 00 00 00 00 00 00 #低地址00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00c0 17 40 00 00 00 00 00...</div></div></div></a><a class="pagination-related" href="/2024/01/28/csapp/%E7%AC%AC5%E7%AB%A0%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/" title="csapp第五章——优化程序性能"><img class="cover" src="/img/cover1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-28</div><div class="info-item-2">csapp第五章——优化程序性能</div></div><div class="info-2"><div class="info-item-1">优化程序性能 第一，我们必须选择一组适当的算法和数据结构。 第二，我们必须编写出编译器能够有效优化以转换成高效可执行代码的源代码。   为什么我们需要优化程序，现代编译器不是具有很强的优化能力吗？ ans:因为编译器只进行安全的优化，消除可能出现的异常的运行时行为。意味着我们需要写出适合编译器优化的代码，优化程序性能。  内存别名使用 两个指针可能指向同一个内存位置的情况称为内存别名使用 (memory aliasing)  12345678910void twiddlel(long *Xp, long *yp) &#123; *XP += *yp; *XP += *yp; &#125; void twiddle2(long *XP, long *yp) &#123; *XP += 2* *yp; &#125;  乍一看两个函数好像没有区别，但是当*XP与*YP指向同一内存时。twiddle1变为原来的四倍，twiddle2变为原来的三倍。改变了程序的行为。 ...</div></div></div></a><a class="pagination-related" href="/2024/02/26/csapp/%E7%AC%AC10%E7%AB%A0%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/" title="csapp第十章——系统级IO"><img class="cover" src="/img/cover3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-26</div><div class="info-item-2">csapp第十章——系统级IO</div></div><div class="info-2"><div class="info-item-1">系统级I/O输入与输出 (I/O) 是在主存和外部设备（例如磁盘驱动器、终端和网络）之间复制数据的过程。 UNIX I/O 所有的设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。   打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。 Linux shell 创建的每个进程开始时都有三个打开的文件：  12345/*								 /usr/include/unisted.h 						 */#define STDIN_FILENO    0       /* Standard input.  */#define STDOUT_FILENO   1       /* Standard output.  */#define STDERR_FILENO   2       /* Standard error output. ...</div></div></div></a><a class="pagination-related" href="/2024/01/30/csapp/%E7%AC%AC7%E7%AB%A0%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/" title="csapp第七章——链接"><img class="cover" src="/img/cover2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-30</div><div class="info-item-2">csapp第七章——链接</div></div><div class="info-2"><div class="info-item-1">链接链接 (linking) 是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行 。  链接可以执行于编译时 (compile time), 也就是在源代码被翻译成机器代码时；  也可以执行与加载时 (load time), 也就是在程序被加载器 (loader) 加载到内存并执行时；  甚至执行于运行时 (run time), 也就是由应用程序来执行。   编译器驱动程序12345678910111213141516171819202122232425/* main.c *//* $begin main */int sum(int *a, int n);int array[2] = &#123;1, 2&#125;;int main()&#123;    int val = sum(array, 2);    return val;&#125;/* $end main *//* sum.c *//* $begin sum */int sum(int *a, int n)&#123;    int i, s = 0;    for (i...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avater.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Randolf luo</div><div class="author-info-description">今日事，今日毕</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">111</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">35</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Randolfluo" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:lrj3216610@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">0x1 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x2-%E9%9A%90%E5%BC%8F%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">0x2 隐式空闲列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x3-%E6%98%BE%E5%BC%8F%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">0x3 显式空闲列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x4%E5%88%86%E7%A6%BB%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">0x4分离空闲列表</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/31/dailyrecord/%E8%AE%B0%EF%BC%9A2025-3/" title="记：2025-3"><img src="https://randolfluo.top/2025/03/31/dailyrecord/%E8%AE%B0%EF%BC%9A2025-3/image-20250331220834539.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="记：2025-3"/></a><div class="content"><a class="title" href="/2025/03/31/dailyrecord/%E8%AE%B0%EF%BC%9A2025-3/" title="记：2025-3">记：2025-3</a><time datetime="2025-03-30T16:00:00.000Z" title="发表于 2025-03-31 00:00:00">2025-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/31/codeforce/%E5%92%8B%E6%8F%90%E6%9D%82%E9%A2%98/" title="咋提杂题"><img src="/img/cover3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="咋提杂题"/></a><div class="content"><a class="title" href="/2025/03/31/codeforce/%E5%92%8B%E6%8F%90%E6%9D%82%E9%A2%98/" title="咋提杂题">咋提杂题</a><time datetime="2025-03-30T16:00:00.000Z" title="发表于 2025-03-31 00:00:00">2025-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/30/codeforce/2025_3_29/" title="Codeforces Round 1014 (Div. 2)"><img src="/img/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Codeforces Round 1014 (Div. 2)"/></a><div class="content"><a class="title" href="/2025/03/30/codeforce/2025_3_29/" title="Codeforces Round 1014 (Div. 2)">Codeforces Round 1014 (Div. 2)</a><time datetime="2025-03-29T16:00:00.000Z" title="发表于 2025-03-30 00:00:00">2025-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/29/BlueBridge/13%E5%B1%8A%E7%9C%81%E8%B5%9BB%E7%BB%84/" title="无标题"><img src="/img/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2025/03/29/BlueBridge/13%E5%B1%8A%E7%9C%81%E8%B5%9BB%E7%BB%84/" title="无标题">无标题</a><time datetime="2025-03-29T13:03:57.157Z" title="发表于 2025-03-29 21:03:57">2025-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/28/%E6%A0%A1%E8%B5%9B/2025_3_28/" title="2025_3_28 省赛集训1"><img src="/img/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025_3_28 省赛集训1"/></a><div class="content"><a class="title" href="/2025/03/28/%E6%A0%A1%E8%B5%9B/2025_3_28/" title="2025_3_28 省赛集训1">2025_3_28 省赛集训1</a><time datetime="2025-03-27T16:00:00.000Z" title="发表于 2025-03-28 00:00:00">2025-03-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover2.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By Randolf luo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>